!function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = "function" == typeof require && require;
                if (!u && a) {
                    return a(o, !0);
                }
                if (i) {
                    return i(o, !0);
                }
                var f = new Error("Cannot find module '" + o + "'");
                throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o] = {
                exports: {}
            };
            t[o][0].call(l.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = "function" == typeof require && require;
    for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }
    return s;
}({
    1: [ function(require, module, exports) {
        cc._LogInfos = {
            ActionManager: {
                addAction: "cc.ActionManager.addAction(): action must be non-null",
                removeAction: "cocos2d: removeAction: Target not found",
                removeActionByTag: "cc.ActionManager.removeActionByTag(): an invalid tag",
                removeActionByTag_2: "cc.ActionManager.removeActionByTag(): target must be non-null",
                getActionByTag: "cc.ActionManager.getActionByTag(): an invalid tag",
                getActionByTag_2: "cocos2d : getActionByTag(tag = %s): Action not found"
            },
            configuration: {
                dumpInfo: "cocos2d: **** WARNING **** CC_ENABLE_PROFILERS is defined. Disable it when you finish profiling (from ccConfig.js)",
                loadConfigFile: "Expected 'data' dict, but not found. Config file: %s",
                loadConfigFile_2: "Please load the resource first : %s"
            },
            Director: {
                resume: "cocos2d: Director: Error in gettimeofday",
                setProjection: "cocos2d: Director: unrecognized projection",
                popToSceneStackLevel: "cocos2d: Director: unrecognized projection",
                popToSceneStackLevel_2: "cocos2d: Director: Error in gettimeofday",
                popScene: "running scene should not null",
                pushScene: "the scene should not null"
            },
            Array: {
                verifyType: "element type is wrong!"
            },
            deprecated: '"%s" is deprecated, please use "%s" instead.',
            Scheduler: {
                scheduleCallbackForTarget: "CCSheduler#scheduleCallback. Callback already scheduled. Updating interval from:%s to %s",
                scheduleCallbackForTarget_2: "cc.scheduler.scheduleCallbackForTarget(): callback_fn should be non-null.",
                scheduleCallbackForTarget_3: "cc.scheduler.scheduleCallbackForTarget(): target should be non-null.",
                pauseTarget: "cc.Scheduler.pauseTarget():target should be non-null",
                resumeTarget: "cc.Scheduler.resumeTarget():target should be non-null",
                isTargetPaused: "cc.Scheduler.isTargetPaused():target should be non-null"
            },
            Node: {
                getZOrder: "getZOrder is deprecated. Please use getLocalZOrder instead.",
                setZOrder: "setZOrder is deprecated. Please use setLocalZOrder instead.",
                getRotation: "RotationX != RotationY. Don't know which one to return",
                getScale: "ScaleX != ScaleY. Don't know which one to return",
                addChild: "An Node can't be added as a child of itself.",
                addChild_2: "child already added. It can't be added again",
                addChild_3: "child must be non-null",
                removeFromParentAndCleanup: "removeFromParentAndCleanup is deprecated. Use removeFromParent instead",
                boundingBox: "boundingBox is deprecated. Use getBoundingBox instead",
                removeChildByTag: "argument tag is an invalid tag",
                removeChildByTag_2: "cocos2d: removeChildByTag(tag = %s): child not found!",
                removeAllChildrenWithCleanup: "removeAllChildrenWithCleanup is deprecated. Use removeAllChildren instead",
                stopActionByTag: "cc.Node.stopActionBy(): argument tag an invalid tag",
                getActionByTag: "cc.Node.getActionByTag(): argument tag is an invalid tag",
                reumeSchedulerAndActions: "resumeSchedulerAndActions is deprecated, please use resume instead.",
                pauseSchedulerAndActions: "pauseSchedulerAndActions is deprecated, please use pause instead.",
                _arrayMakeObjectsPerformSelector: "Unknown callback function",
                reorderChild: "child must be non-null",
                runAction: "cc.Node.runAction(): action must be non-null",
                schedule: "callback function must be non-null",
                schedule_2: "interval must be positive",
                initWithTexture: "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
                _requestDirtyFlag: "_ccsg.Node._requestDirtyFlag: failed to satisfy the request, key (%s) for flag have already been taken"
            },
            AtlasNode: {
                _updateAtlasValues: "cc.AtlasNode.updateAtlasValues(): Shall be overridden in subclasses",
                _initWithTileFile: "",
                _initWithTexture: "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture."
            },
            _checkEventListenerAvailable: {
                keyboard: "cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!",
                touchOneByOne: "cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!",
                touchAllAtOnce: "cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!",
                acceleration: "cc._EventListenerAcceleration.checkAvailable(): _onAccelerationEvent must be non-nil"
            },
            EventListener: {
                create: "Invalid parameter."
            },
            __getListenerID: "Don't call this method if the event is for touch.",
            LayerMultiplex: {
                initWithLayers: "parameters should not be ending with null in Javascript",
                switchTo: "Invalid index in MultiplexLayer switchTo message",
                switchToAndReleaseMe: "Invalid index in MultiplexLayer switchTo message",
                addLayer: "cc.Layer.addLayer(): layer should be non-null"
            },
            view: {
                setDesignResolutionSize: "Resolution not valid",
                setDesignResolutionSize_2: "should set resolutionPolicy"
            },
            inputManager: {
                handleTouchesBegin: "The touches is more than MAX_TOUCHES, nUnusedIndex = %s"
            },
            swap: "cc.swap is being modified from original macro, please check usage",
            checkGLErrorDebug: "WebGL error %s",
            spriteFrameAnimationCache: {
                _addAnimationsWithDictionary: "cocos2d: cc.SpriteFrameAnimationCache: No animations were found in provided dictionary.",
                _addAnimationsWithDictionary_2: "cc.SpriteFrameAnimationCache. Invalid animation format",
                addAnimations: "cc.SpriteFrameAnimationCache.addAnimations(): File could not be found",
                _parseVersion1: "cocos2d: cc.SpriteFrameAnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
                _parseVersion1_2: "cocos2d: cc.SpriteFrameAnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
                _parseVersion1_3: "cocos2d: cc.SpriteFrameAnimationCache: None of the frames for animation '%s' were found in the cc.SpriteFrameCache. Animation is not being added to the Animation Cache.",
                _parseVersion1_4: "cocos2d: cc.SpriteFrameAnimationCache: An animation in your dictionary refers to a frame which is not in the cc.SpriteFrameCache. Some or all of the frames for the animation '%s' may be missing.",
                _parseVersion2: "cocos2d: CCAnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
                _parseVersion2_2: "cocos2d: cc.SpriteFrameAnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
                addAnimations_2: "cc.SpriteFrameAnimationCache.addAnimations(): Invalid texture file name"
            },
            Sprite: {
                reorderChild: "cc.Sprite.reorderChild(): this child is not in children list",
                ignoreAnchorPointForPosition: "cc.Sprite.ignoreAnchorPointForPosition(): it is invalid in cc.Sprite when using SpriteBatchNode",
                setDisplayFrameWithAnimationName: "cc.Sprite.setDisplayFrameWithAnimationName(): Frame not found",
                setDisplayFrameWithAnimationName_2: "cc.Sprite.setDisplayFrameWithAnimationName(): Invalid frame index",
                setDisplayFrame: "setDisplayFrame is deprecated, please use setSpriteFrame instead.",
                _updateBlendFunc: "cc.Sprite._updateBlendFunc(): _updateBlendFunc doesn't work when the sprite is rendered using a cc.CCSpriteBatchNode",
                initWithSpriteFrame: "cc.Sprite.initWithSpriteFrame(): spriteFrame should be non-null",
                initWithSpriteFrameName: "cc.Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null",
                initWithSpriteFrameName1: " is null, please check.",
                initWithFile: "cc.Sprite.initWithFile(): filename should be non-null",
                setDisplayFrameWithAnimationName_3: "cc.Sprite.setDisplayFrameWithAnimationName(): animationName must be non-null",
                reorderChild_2: "cc.Sprite.reorderChild(): child should be non-null",
                addChild: "cc.Sprite.addChild(): cc.Sprite only supports cc.Sprites as children when using cc.SpriteBatchNode",
                addChild_2: "cc.Sprite.addChild(): cc.Sprite only supports a sprite using same texture as children when using cc.SpriteBatchNode",
                addChild_3: "cc.Sprite.addChild(): child should be non-null",
                setTexture: "cc.Sprite.texture setter: Batched sprites should use the same texture as the batchnode",
                updateQuadFromSprite: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
                insertQuadFromSprite: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
                addChild_4: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
                addChild_5: "cc.SpriteBatchNode.addChild(): cc.Sprite is not using the same texture",
                initWithTexture: "Sprite.initWithTexture(): Argument must be non-nil ",
                setSpriteFrame: "Invalid spriteFrameName",
                setTexture_2: "Invalid argument: cc.Sprite.texture setter expects a CCTexture2D.",
                updateQuadFromSprite_2: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
                insertQuadFromSprite_2: "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null"
            },
            SpriteBatchNode: {
                addSpriteWithoutQuad: "cc.SpriteBatchNode.addQuadFromSprite(): SpriteBatchNode only supports cc.Sprites as children",
                increaseAtlasCapacity: "cocos2d: CCSpriteBatchNode: resizing TextureAtlas capacity from %s to %s.",
                increaseAtlasCapacity_2: "cocos2d: WARNING: Not enough memory to resize the atlas",
                reorderChild: "cc.SpriteBatchNode.addChild(): Child doesn't belong to Sprite",
                removeChild: "cc.SpriteBatchNode.addChild(): sprite batch node should contain the child",
                addSpriteWithoutQuad_2: "cc.SpriteBatchNode.addQuadFromSprite(): child should be non-null",
                reorderChild_2: "cc.SpriteBatchNode.addChild(): child should be non-null",
                updateQuadFromSprite: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
                insertQuadFromSprite: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
                addChild: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
                initWithTexture: "Sprite.initWithTexture(): Argument must be non-nil ",
                addChild_2: "cc.Sprite.addChild(): child should be non-null",
                setSpriteFrame: "Invalid spriteFrameName",
                setTexture: "Invalid argument: cc.Sprite texture setter expects a CCTexture2D.",
                updateQuadFromSprite_2: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
                insertQuadFromSprite_2: "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
                addChild_3: "cc.SpriteBatchNode.addChild(): child should be non-null"
            },
            spriteFrameCache: {
                _getFrameConfig: "cocos2d: WARNING: originalWidth/Height not found on the cc.SpriteFrame. AnchorPoint won't work as expected. Regenrate the .plist",
                addSpriteFrames: "cocos2d: WARNING: an alias with name %s already exists",
                _checkConflict: "cocos2d: WARNING: Sprite frame: %s has already been added by another source, please fix name conflit",
                getSpriteFrame: "cocos2d: cc.SpriteFrameCahce: Frame %s not found",
                _getFrameConfig_2: "Please load the resource first : %s",
                addSpriteFrames_2: "cc.SpriteFrameCache.addSpriteFrames(): plist should be non-null",
                addSpriteFrames_3: "Argument must be non-nil"
            },
            TextureAtlas: {
                initWithFile: "cocos2d: Could not open file: %s",
                insertQuad: "cc.TextureAtlas.insertQuad(): invalid totalQuads",
                initWithTexture: "cc.TextureAtlas.initWithTexture():texture should be non-null",
                updateQuad: "cc.TextureAtlas.updateQuad(): quad should be non-null",
                updateQuad_2: "cc.TextureAtlas.updateQuad(): Invalid index",
                insertQuad_2: "cc.TextureAtlas.insertQuad(): Invalid index",
                insertQuads: "cc.TextureAtlas.insertQuad(): Invalid index + amount",
                insertQuadFromIndex: "cc.TextureAtlas.insertQuadFromIndex(): Invalid newIndex",
                insertQuadFromIndex_2: "cc.TextureAtlas.insertQuadFromIndex(): Invalid fromIndex",
                removeQuadAtIndex: "cc.TextureAtlas.removeQuadAtIndex(): Invalid index",
                removeQuadsAtIndex: "cc.TextureAtlas.removeQuadsAtIndex(): index + amount out of bounds",
                moveQuadsFromIndex: "cc.TextureAtlas.moveQuadsFromIndex(): move is out of bounds",
                moveQuadsFromIndex_2: "cc.TextureAtlas.moveQuadsFromIndex(): Invalid newIndex",
                moveQuadsFromIndex_3: "cc.TextureAtlas.moveQuadsFromIndex(): Invalid oldIndex"
            },
            textureCache: {
                addPVRTCImage: "TextureCache:addPVRTCImage does not support on HTML5",
                addETCImage: "TextureCache:addPVRTCImage does not support on HTML5",
                textureForKey: "textureForKey is deprecated. Please use getTextureForKey instead.",
                addPVRImage: "addPVRImage does not support on HTML5",
                addUIImage: "cocos2d: Couldn't add UIImage in TextureCache",
                dumpCachedTextureInfo: "cocos2d: '%s' id=%s %s x %s",
                dumpCachedTextureInfo_2: "cocos2d: '%s' id= HTMLCanvasElement %s x %s",
                dumpCachedTextureInfo_3: "cocos2d: TextureCache dumpDebugInfo: %s textures, HTMLCanvasElement for %s KB (%s MB)",
                addUIImage_2: "cc.Texture.addUIImage(): image should be non-null",
                invalidKey: "TextureCache: url should be non-null"
            },
            Texture2D: {
                initWithETCFile: "initWithETCFile does not support on HTML5",
                initWithPVRFile: "initWithPVRFile does not support on HTML5",
                initWithPVRTCData: "initWithPVRTCData does not support on HTML5",
                addImage: "cc.Texture.addImage(): path should be non-null",
                initWithImage: "cocos2d: cc.Texture2D. Can't create Texture. UIImage is nil",
                initWithImage_2: "cocos2d: WARNING: Image (%s x %s) is bigger than the supported %s x %s",
                initWithString: "initWithString isn't supported on cocos2d-html5",
                initWithETCFile_2: "initWithETCFile does not support on HTML5",
                initWithPVRFile_2: "initWithPVRFile does not support on HTML5",
                initWithPVRTCData_2: "initWithPVRTCData does not support on HTML5",
                bitsPerPixelForFormat: "bitsPerPixelForFormat: %s, cannot give useful result, it's a illegal pixel format",
                _initPremultipliedATextureWithImage: "cocos2d: cc.Texture2D: Using RGB565 texture since image has no alpha",
                addImage_2: "cc.Texture.addImage(): path should be non-null",
                initWithData: "NSInternalInconsistencyException"
            },
            MissingFile: "Missing file: %s",
            radiansToDegress: "cc.radiansToDegress() should be called cc.radiansToDegrees()",
            RectWidth: "Rect width exceeds maximum margin: %s",
            RectHeight: "Rect height exceeds maximum margin: %s",
            EventManager: {
                addListener: "0 priority is forbidden for fixed priority since it's used for scene graph based priority.",
                removeListeners: "Invalid listener type!",
                setPriority: "Can't set fixed priority with scene graph based listener.",
                addListener_2: "Invalid parameters.",
                addListener_3: "listener must be a cc.EventListener object when adding a fixed priority listener",
                addListener_4: "The listener has been registered, please don't register it again.",
                _forceAddEventListener: "Invalid scene graph priority!",
                _updateListeners: "If program goes here, there should be event in dispatch.",
                _updateListeners_2: "_inDispatch should be 1 here."
            }
        };
        if (false) {
            cc._LogInfos.Editor = {
                Class: {
                    callSuperCtor: "cc.Class will automatically call super constructor of %s, you should not call it manually."
                }
            };
        }
        cc._logToWebPage = function(msg) {
            if (!cc._canvas) {
                return;
            }
            var logList = cc._logList;
            var doc = document;
            if (!logList) {
                var logDiv = doc.createElement("Div");
                var logDivStyle = logDiv.style;
                logDiv.setAttribute("id", "logInfoDiv");
                cc._canvas.parentNode.appendChild(logDiv);
                logDiv.setAttribute("width", "200");
                logDiv.setAttribute("height", cc._canvas.height);
                logDivStyle.zIndex = "99999";
                logDivStyle.position = "absolute";
                logDivStyle.top = "0";
                logDivStyle.left = "0";
                logList = cc._logList = doc.createElement("textarea");
                var logListStyle = logList.style;
                logList.setAttribute("rows", "20");
                logList.setAttribute("cols", "30");
                logList.setAttribute("disabled", true);
                logDiv.appendChild(logList);
                logListStyle.backgroundColor = "transparent";
                logListStyle.borderBottom = "1px solid #cccccc";
                logListStyle.borderRightWidth = "0px";
                logListStyle.borderLeftWidth = "0px";
                logListStyle.borderTopWidth = "0px";
                logListStyle.borderTopStyle = "none";
                logListStyle.borderRightStyle = "none";
                logListStyle.borderLeftStyle = "none";
                logListStyle.padding = "0px";
                logListStyle.margin = 0;
            }
            logList.value = logList.value + msg + "\r\n";
            logList.scrollTop = logList.scrollHeight;
        };
        cc._formatString = function(arg) {
            if (cc.js.isObject(arg)) {
                try {
                    return JSON.stringify(arg);
                } catch (err) {
                    return "";
                }
            } else {
                return arg;
            }
        };
        cc.DebugMode = cc.Enum({
            NONE: 0,
            INFO: 1,
            WARN: 2,
            ERROR: 3,
            INFO_FOR_WEB_PAGE: 4,
            WARN_FOR_WEB_PAGE: 5,
            ERROR_FOR_WEB_PAGE: 6
        });
        cc._initDebugSetting = function(mode) {
            if (mode === cc.DebugMode.NONE) {
                return;
            }
            var locLog;
            if (mode > cc.DebugMode.ERROR) {
                locLog = cc._logToWebPage.bind(cc);
                cc.error = function() {
                    locLog("ERROR :  " + cc.formatStr.apply(cc, arguments));
                };
                cc.assert = function(cond, msg) {
                    "use strict";
                    if (!cond && msg) {
                        for (var i = 2; i < arguments.length; i++) {
                            msg = msg.replace(/(%s)|(%d)/, cc._formatString(arguments[i]));
                        }
                        locLog("Assert: " + msg);
                    }
                };
                if (mode !== cc.DebugMode.ERROR_FOR_WEB_PAGE) {
                    cc.warn = function() {
                        locLog("WARN :  " + cc.formatStr.apply(cc, arguments));
                    };
                }
                if (mode === cc.DebugMode.INFO_FOR_WEB_PAGE) {
                    cc.log = cc.info = function() {
                        locLog(cc.formatStr.apply(cc, arguments));
                    };
                }
            } else {
                if (console && console.log.apply) {
                    if (!console.error) {
                        console.error = console.log;
                    }
                    if (!console.warn) {
                        console.warn = console.log;
                    }
                    if (console.error.bind) {
                        cc.error = console.error.bind(console);
                    } else {
                        cc.error = function() {
                            return console.error.apply(console, arguments);
                        };
                    }
                    cc.assert = function(cond, msg) {
                        if (!cond && msg) {
                            for (var i = 2; i < arguments.length; i++) {
                                msg = msg.replace(/(%s)|(%d)/, cc._formatString(arguments[i]));
                            }
                            throw new Error(msg);
                        }
                    };
                    if (mode !== cc.DebugMode.ERROR) {
                        cc.warn = function() {
                            return console.warn.apply(console, arguments);
                        };
                    }
                    if (mode === cc.DebugMode.INFO) {
                        cc.log = function() {
                            return console.log.apply(console, arguments);
                        };
                        cc.info = function() {
                            (console.info || console.log).apply(console, arguments);
                        };
                    }
                }
            }
            cc._throw = function(error) {
                cc.error(error.stack || error);
            };
        };
    }, {} ],
    2: [ function(require, module, exports) {
        (function(cc, ccui, ccs, sp, cp) {
            var cc = cc || {};
            cc._loadingImage = "data:image/gif;base64,R0lGODlhEAAQALMNAD8/P7+/vyoqKlVVVX9/fxUVFUBAQGBgYMDAwC8vL5CQkP///wAAAP///wAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFAAANACwAAAAAEAAQAAAEO5DJSau9OOvNex0IMnDIsiCkiW6g6BmKYlBFkhSUEgQKlQCARG6nEBwOgl+QApMdCIRD7YZ5RjlGpCUCACH5BAUAAA0ALAAAAgAOAA4AAAQ6kLGB0JA4M7QW0hrngRllkYyhKAYqKUGguAws0ypLS8JxCLQDgXAIDg+FRKIA6v0SAECCBpXSkstMBAAh+QQFAAANACwAAAAACgAQAAAEOJDJORAac6K1kDSKYmydpASBUl0mqmRfaGTCcQgwcxDEke+9XO2WkxQSiUIuAQAkls0n7JgsWq8RACH5BAUAAA0ALAAAAAAOAA4AAAQ6kMlplDIzTxWC0oxwHALnDQgySAdBHNWFLAvCukc215JIZihVIZEogDIJACBxnCSXTcmwGK1ar1hrBAAh+QQFAAANACwAAAAAEAAKAAAEN5DJKc4RM+tDyNFTkSQF5xmKYmQJACTVpQSBwrpJNteZSGYoFWjIGCAQA2IGsVgglBOmEyoxIiMAIfkEBQAADQAsAgAAAA4ADgAABDmQSVZSKjPPBEDSGucJxyGA1XUQxAFma/tOpDlnhqIYN6MEAUXvF+zldrMBAjHoIRYLhBMqvSmZkggAIfkEBQAADQAsBgAAAAoAEAAABDeQyUmrnSWlYhMASfeFVbZdjHAcgnUQxOHCcqWylKEohqUEAYVkgEAMfkEJYrFA6HhKJsJCNFoiACH5BAUAAA0ALAIAAgAOAA4AAAQ3kMlJq704611SKloCAEk4lln3DQgyUMJxCBKyLAh1EMRR3wiDQmHY9SQslyIQUMRmlmVTIyRaIgA7";
            cc._fpsImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAAgCAYAAAD9qabkAAAKQ2lDQ1BJQ0MgcHJvZmlsZQAAeNqdU3dYk/cWPt/3ZQ9WQtjwsZdsgQAiI6wIyBBZohCSAGGEEBJAxYWIClYUFRGcSFXEgtUKSJ2I4qAouGdBiohai1VcOO4f3Ke1fXrv7e371/u855zn/M55zw+AERImkeaiagA5UoU8Otgfj09IxMm9gAIVSOAEIBDmy8JnBcUAAPADeXh+dLA//AGvbwACAHDVLiQSx+H/g7pQJlcAIJEA4CIS5wsBkFIAyC5UyBQAyBgAsFOzZAoAlAAAbHl8QiIAqg0A7PRJPgUA2KmT3BcA2KIcqQgAjQEAmShHJAJAuwBgVYFSLALAwgCgrEAiLgTArgGAWbYyRwKAvQUAdo5YkA9AYACAmUIszAAgOAIAQx4TzQMgTAOgMNK/4KlfcIW4SAEAwMuVzZdL0jMUuJXQGnfy8ODiIeLCbLFCYRcpEGYJ5CKcl5sjE0jnA0zODAAAGvnRwf44P5Dn5uTh5mbnbO/0xaL+a/BvIj4h8d/+vIwCBAAQTs/v2l/l5dYDcMcBsHW/a6lbANpWAGjf+V0z2wmgWgrQevmLeTj8QB6eoVDIPB0cCgsL7SViob0w44s+/zPhb+CLfvb8QB7+23rwAHGaQJmtwKOD/XFhbnauUo7nywRCMW735yP+x4V//Y4p0eI0sVwsFYrxWIm4UCJNx3m5UpFEIcmV4hLpfzLxH5b9CZN3DQCshk/ATrYHtctswH7uAQKLDljSdgBAfvMtjBoLkQAQZzQyefcAAJO/+Y9AKwEAzZek4wAAvOgYXKiUF0zGCAAARKCBKrBBBwzBFKzADpzBHbzAFwJhBkRADCTAPBBCBuSAHAqhGJZBGVTAOtgEtbADGqARmuEQtMExOA3n4BJcgetwFwZgGJ7CGLyGCQRByAgTYSE6iBFijtgizggXmY4EImFINJKApCDpiBRRIsXIcqQCqUJqkV1II/ItchQ5jVxA+pDbyCAyivyKvEcxlIGyUQPUAnVAuagfGorGoHPRdDQPXYCWomvRGrQePYC2oqfRS+h1dAB9io5jgNExDmaM2WFcjIdFYIlYGibHFmPlWDVWjzVjHVg3dhUbwJ5h7wgkAouAE+wIXoQQwmyCkJBHWExYQ6gl7CO0EroIVwmDhDHCJyKTqE+0JXoS+cR4YjqxkFhGrCbuIR4hniVeJw4TX5NIJA7JkuROCiElkDJJC0lrSNtILaRTpD7SEGmcTCbrkG3J3uQIsoCsIJeRt5APkE+S+8nD5LcUOsWI4kwJoiRSpJQSSjVlP+UEpZ8yQpmgqlHNqZ7UCKqIOp9aSW2gdlAvU4epEzR1miXNmxZDy6Qto9XQmmlnafdoL+l0ugndgx5Fl9CX0mvoB+nn6YP0dwwNhg2Dx0hiKBlrGXsZpxi3GS+ZTKYF05eZyFQw1zIbmWeYD5hvVVgq9ip8FZHKEpU6lVaVfpXnqlRVc1U/1XmqC1SrVQ+rXlZ9pkZVs1DjqQnUFqvVqR1Vu6k2rs5Sd1KPUM9RX6O+X/2C+mMNsoaFRqCGSKNUY7fGGY0hFsYyZfFYQtZyVgPrLGuYTWJbsvnsTHYF+xt2L3tMU0NzqmasZpFmneZxzQEOxrHg8DnZnErOIc4NznstAy0/LbHWaq1mrX6tN9p62r7aYu1y7Rbt69rvdXCdQJ0snfU6bTr3dQm6NrpRuoW623XP6j7TY+t56Qn1yvUO6d3RR/Vt9KP1F+rv1u/RHzcwNAg2kBlsMThj8MyQY+hrmGm40fCE4agRy2i6kcRoo9FJoye4Ju6HZ+M1eBc+ZqxvHGKsNN5l3Gs8YWJpMtukxKTF5L4pzZRrmma60bTTdMzMyCzcrNisyeyOOdWca55hvtm82/yNhaVFnMVKizaLx5balnzLBZZNlvesmFY+VnlW9VbXrEnWXOss623WV2xQG1ebDJs6m8u2qK2brcR2m23fFOIUjynSKfVTbtox7PzsCuya7AbtOfZh9iX2bfbPHcwcEh3WO3Q7fHJ0dcx2bHC866ThNMOpxKnD6VdnG2ehc53zNRemS5DLEpd2lxdTbaeKp26fesuV5RruutK10/Wjm7ub3K3ZbdTdzD3Ffav7TS6bG8ldwz3vQfTw91jicczjnaebp8LzkOcvXnZeWV77vR5Ps5wmntYwbcjbxFvgvct7YDo+PWX6zukDPsY+Ap96n4e+pr4i3z2+I37Wfpl+B/ye+zv6y/2P+L/hefIW8U4FYAHBAeUBvYEagbMDawMfBJkEpQc1BY0FuwYvDD4VQgwJDVkfcpNvwBfyG/ljM9xnLJrRFcoInRVaG/owzCZMHtYRjobPCN8Qfm+m+UzpzLYIiOBHbIi4H2kZmRf5fRQpKjKqLupRtFN0cXT3LNas5Fn7Z72O8Y+pjLk722q2cnZnrGpsUmxj7Ju4gLiquIF4h/hF8ZcSdBMkCe2J5MTYxD2J43MC52yaM5zkmlSWdGOu5dyiuRfm6c7Lnnc8WTVZkHw4hZgSl7I/5YMgQlAvGE/lp25NHRPyhJuFT0W+oo2iUbG3uEo8kuadVpX2ON07fUP6aIZPRnXGMwlPUit5kRmSuSPzTVZE1t6sz9lx2S05lJyUnKNSDWmWtCvXMLcot09mKyuTDeR55m3KG5OHyvfkI/lz89sVbIVM0aO0Uq5QDhZML6greFsYW3i4SL1IWtQz32b+6vkjC4IWfL2QsFC4sLPYuHhZ8eAiv0W7FiOLUxd3LjFdUrpkeGnw0n3LaMuylv1Q4lhSVfJqedzyjlKD0qWlQyuCVzSVqZTJy26u9Fq5YxVhlWRV72qX1VtWfyoXlV+scKyorviwRrjm4ldOX9V89Xlt2treSrfK7etI66Trbqz3Wb+vSr1qQdXQhvANrRvxjeUbX21K3nShemr1js20zcrNAzVhNe1bzLas2/KhNqP2ep1/XctW/a2rt77ZJtrWv913e/MOgx0VO97vlOy8tSt4V2u9RX31btLugt2PGmIbur/mft24R3dPxZ6Pe6V7B/ZF7+tqdG9s3K+/v7IJbVI2jR5IOnDlm4Bv2pvtmne1cFoqDsJB5cEn36Z8e+NQ6KHOw9zDzd+Zf7f1COtIeSvSOr91rC2jbaA9ob3v6IyjnR1eHUe+t/9+7zHjY3XHNY9XnqCdKD3x+eSCk+OnZKeenU4/PdSZ3Hn3TPyZa11RXb1nQ8+ePxd07ky3X/fJ897nj13wvHD0Ivdi2yW3S609rj1HfnD94UivW2/rZffL7Vc8rnT0Tes70e/Tf/pqwNVz1/jXLl2feb3vxuwbt24m3Ry4Jbr1+Hb27Rd3Cu5M3F16j3iv/L7a/eoH+g/qf7T+sWXAbeD4YMBgz8NZD+8OCYee/pT/04fh0kfMR9UjRiONj50fHxsNGr3yZM6T4aeypxPPyn5W/3nrc6vn3/3i+0vPWPzY8Av5i8+/rnmp83Lvq6mvOscjxx+8znk98ab8rc7bfe+477rfx70fmSj8QP5Q89H6Y8en0E/3Pud8/vwv94Tz+4A5JREAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfcAgcQLxxUBNp/AAAQZ0lEQVR42u2be3QVVZbGv1N17829eRLyIKAEOiISEtPhJTJAYuyBDmhWjAEx4iAGBhxA4wABbVAMWUAeykMCM+HRTcBRWkNH2l5moS0LCCrQTkYeQWBQSCAIgYRXEpKbW/XNH5zS4noR7faPEeu31l0h4dSpvc+t/Z199jkFWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhY/H9D/MR9qfKnLj/00U71aqfJn9+HCkCR/Wk36ddsgyJ/1wF4fkDfqqm9/gPsUeTnVr6a2xlQfnxdI7zs0W7irzD17Ytb2WT7EeNv/r4ox1O3Quf2QP2pgt9utwfout4FQE8AVBSlnaRmfvAURQkg2RlAbwB9AThlW5L0GaiKojhJhgOIBqDa7XaPrusdPtr5kQwF0BVAAoBIABRCKDd5aFUhRDAAw57eAOwAhKIoupft3zoqhB1AqLwuHIBut9uFt02qqvqRDJR2dAEQJj/BAOjn56dqmma+xiaECAEQAWAggLsB6A6HQ2iaZggBhBAqgEAAnQB0kzaEmT4hAITT6VQ8Ho/HJAKKECJQtr8LwD1y/A1/vcdfEUIEyfZ9AcQbYvZ942Px88L2UwlJR0dH0EMPPbRj5syZPUeNGrXR7Xb/641xIwJ1XY9NSUlZm52dfW+XLl1w8uRJzJ8//+OGhoYJqqqe1TSt1Wsm9NN1PSIqKmr12rVrR5WUlHy1bdu2AQCumWc3IYRD1/UwVVXnFRQUTIuNjUVzczN2797dWFJSkq8oymZd15sAGAEnFEUJ1nX9nzIzM1dnZmZGh4SE4OTJk5g5c+Zf29vbp9pstrMej6fVOyhIhgAYU1hY+B+hoaGoqKg4XVlZea+XTULTNFdCQsLGiRMnPuR2u3UhBOV9eeDAAWXTpk095DUe6WsoyRE5OTlr0tLSAux2O/bs2cO5c+e+pijKUpIXSHaQVAGkvPLKK++6XK4OksJLCFlXV2cvKSlJBFAjhU+x2WwhHo9nUHp6+urMzMy7wsLCUF9fjxdffPHjxsbGiTab7WuPx9NiEutOuq4PyMjI+M+srKyYqKgoHD58GDNmzNjq8XhyVFU9b/q+LH7hBAEYu3PnTlZVVRFAGgCX6f/tAHoOHDjwa0p27txp/JO9e/f+QM7cipw9nfL3kQBKt2zZQpJ87rnn6mQmoHilw2EACs+cOUOSrK+vZ1NTE0nyo48+IoBpxswoBcMJ4Ndjx471kOTFixe5d+9ekqTH42H//v13A4jyzpAURfEH0H/OnDnthu1z5sw558MmFUCPWbNmnaMP3nrrLZoyDmP8Hl68eDFJ8siRI9/Yc+zYMQKYKdtAztrTrl27xptRXV1NAKMAOAyBBBA/Y8aMdpLs6Ojgxx9//E37+++//29yvFXppwvAwMcee8xjtDHsuXLlCqOjo//ia3wsfpkoALqFhoZuIckJEyackimm3dQmEMDUmpoakmRISMhhAHOHDx/eQJIbN24kgKEyMAHAFRMTs2XXrl1saWkhSZ0kp0+ffhrAr3wEW/S8efOukORLL72kA1gKYMPWrVtJkk899dRJAHeYrgsEsIQkjx8/TgDvAPjd448/3kaSb7zxBmUa7vC6z53BwcFbSHL9+vU6Sc6aNes8gF5ewWAH0PfVV18lSQL4DMBGIcQ6AKtcLleBFC2jXtFt8ODBe0iyoqKCAJYByC8qKmJDQwOzsrK+MAmqo1OnTveHhoa+GRkZ+XZkZOSWiIiIvzgcjk9mzpypkWRmZuZpmbYbGV4AgPnNzc1sa2sjgN0A5iQmJtaSZHl5OQHcb/K3s81mW0uSTU1NBFAFYFbfvn1Pk+Tbb79NAA8IIVzW42/hByA+Pz/fLR/2ZXIda05NI/z9/TeR5J49ewhgqlxTrtI0jY2NjQQw3zTLuWJiYjaUlJToS5Ys6fjkk080kwDEeAmADcA9GzZsIElGRUW9CyAWwLApU6Y0kOSKFSsog9QICGdERMTGsrIyZmVlEcC9AB4IDw/fTpLbtm0jgN94CUAnAJmVlZVcs2aNZ/LkyRdJcvbs2b4EwAkgZfPmzTxw4AABFAN4BkC6vFeUSewcAO5duXIlSTIhIaEawGMAxgKYAmAGgCS73e5vrKVk/yGythANYEhCQsIhkly+fDkBpKqqGmL6DgIALDKN/3yZpVWQZGVlJQE8aPI3KiMjo5okV61aRQAjAPQBMPfIkSN0u90EUCBtsPiFEwpgbn19PdetW2fM5N4zQ9ekpKQqkty0aRMBpMjiWM6JEydIkoqirJUFJ6iq6pAPVy8A6cZMehMBUACEuVyuFwG8HBwcPEIWx367ZMkSjSQXLVrUJouTRorrkAHdA8BdQogsAOsKCwtJkmPGjDkvMw2bDDo/ADEjRoz4XylyFbm5uY0mAbjLyyZ/AOOrq6tZVlbWsWDBgo69e/eyoqKCgwcPPg4gSQaoIRbp27dvN7KF+tLSUr28vJwFBQXtMpvpYRIM7+wrAkDeqVOnePbsWQIoNKfzpiXPg8uXLydJJicnNwF4f+nSpW6STEtLq5fjYwhk1wkTJtSQ5Ouvv04AqTKj+N2xY8dIkgEBAW/Ie1v8wncRegwZMmQvSfbr12+3Ua33WqPfOWbMmP0kWVpaSgCDZAqcfejQIWNZsEGKgvnh9gfQb9myZd8nAEJVVZtMkUNk8CcNHTq0liR1XWdYWNhmH1mJIme80OnTp18x1rp5eXkEsNJms92Fb7e/IgEsvHz5Mp999tkmAI/l5uZeMC0B7vEqqAYAyL106RJJsra2lpWVld+sucePH38ZQG+5NncBeOrgwYMkqbe3t/Po0aOsra011wAWyl0H7x0JJ4DE+fPnu0kyPT29DsDdUrBuyNKEEAkAdpw/f/6GeoEM8GUmfwEgPCIiopwkGxsbabPZPgOw6L777vvm4p49e26VGYjFLxUhhD+ApLKyMp44ccIoVnXybgbgzkcfffRzklyzZg0BDJYCMMmoCwQFBXkLgLGWvvcWAgBToSsKwNPTp09vMR7UuLi4rwH0lgU8c/Db5ezbeeTIkRWzZ8++aMxu+fn5BPCADBwHgP4LFy701NXVEUAJgAnPP/98kyxMNgHo53A4zH77BQQETMvPz7+Um5vbBuAlAFMSExPPmdbVL0qh8Acw8fDhw5SCchVAEYAVb775JknyhRdeaJYztHfxMwLAaqNwCGC2FArv8x0hAHKNLGPKlCme5OTk/Zs3bzb7O0wKiiG8KXl5ed8IxenTp0mSR48e1UmyW7duWywBuD2xyQcgFECgoih+8H1gyJgZV5Lkyy+/3CbTRIePtl2HDBmyw1QBHyGDdXZdXR1JUghRKkXBjOMHCoBdpr0L3nvvPZLkF198wejo6O0A4lVVDTb74HQ6AwD8Wq7Jh8rgGgDgQ13XjVR8qaxJuADMbmlpYXl5uV5UVNRWUFDgfv/993Vj/ZydnU1c37eHXML4S3viAcQqitJD2l104cIFY8lTKsXSBWBMVVWVcd9yed2A1NTUQ6Zl00CvLMMOoHdubm6zFIlWOf5+PsY/Kj09vdrU11QAwwGsv3jxIk21m2DZr10I0RXAuAcffPBgaWkpV69eTYfDcdiwUxY0w6xw+flX8L1xApjevXv3lREREaW6rofB93aPDUDQpEmTMgHgtddeqwBwEd/utZvpqK6uPgEAcXFxkA94NwB9unfvjrNnz4LklwDcf08iIqv66Zs2bXrl4YcfxooVKxAbG7uqrq5uAYA2TdOEqqpGYIi2tjbl6aeffu/YsWPv5uTk7JaC1wHg4Pnz542MwoVvTx+21dbWYvjw4WLixIl+2dnZ9lGjRgmSTE1NRUpKCkwFTGiaxtTU1OXTpk3707Bhw/6g67pDipnT4biuj7qut+Lbk3Vf1tTUXI9qu91Pjq1QFEUBgJaWFgBo8yGOQ8eNGxcAAOvXr/8QwBUfYygAKL169eoCABcuXACAWtn2hOGv0+kMNO1KiPDw8F4A4rZv3/7R1KlTR0+bNu1ht9u9r1+/fqitrQXJgwDarRC6/QjPzs4+QJIffPCB9/aQmSAA43ft2mW0e1QGoi8CAPyLsZccExNTC2BlRkbGRdOyYJCP2csBIN6UAZzCd7cBbQCijYp/dXU1ExMTz6SmptaMHj36f9LS0vYlJCRsl6mxIWSdu3fv/g5J7t+/nwC2AShMTk6+SJKff/45AWRLYbD7+fndAeDf5BJnLoCCyZMnt5JkdnZ2C4B/F0KEm1Pu+Pj4rST55ZdfEsBWAK+mpaVdMo3raDn7KwDuSEpK+m+S3LBhAwG8DuCtHTt2UBbpjgC408vvcFVV15HkuXPnjMp+p5uMf0RcXNyHJNnQ0EBVVfcCWBQXF3fG+Jv0yxABPwB5LS0tRmFxN4BlTzzxxGWSXLx4sS5F3GGFy+1Hp5SUlJq6ujoWFxdTpsZ2H+0iIyMj/0iSWVlZX5mr5jfJFroPGzasxlhTnjp1iiTZ3NxMl8tlrCd9pfa9SkpKSJI5OTmnZOageLUZZqxvfVFWVkZcPwdgNwnSCKPqb17jkmR8fPzfZMDZ5CRsFBmNI7h95s2b1yhT7/MAYmStwCx4vy0uLqa3v5qmEcCfvSr1QQAeXb16NY3Cm3HQ55133iGAp+SxZTNhKSkpfzUddkrFjYevzAQCeGjp0qXfsYckY2NjTwD4leGDLCL2HTdunNtoY+zWSHFcIHdsFCtcfuZ1vO9Eqs3m7/F47sb1k2qX/f3997W2tl7BjWfpBYDOzzzzzIVJkyZh0KBBCwEsB3AJvl9AETabLcDj8dwRFRW1ctasWb8JCgpSzp07d62wsPC/Wltb8xRFadR1/ZqPXYbgAQMGbI2Pjw/+6quv9ldVVT0r01ezuPRJSUn5Y9euXXVd11WzDaqq6kePHm3+7LPPRgO4KlNuxWazhXo8nuTk5OSXMjIyEl0uFxoaGtqKior+dPXq1VdUVT0jj7r68ieoT58+vx8yZMjdx48fP1JVVTVF9m20VW02WyfZf97YsWPjXS4X6urqWvPy8jYCWCyEuEDS8FdVFKWzruv//OSTTy5OTk7uqWkaPv3007qysrJ8RVH+LI8ym8/rB3Tu3HnRI488knLo0KG2ffv2ZQI4C98vP6mqqoZqmpaclpa2cOTIkX39/f3R0NDQUVxc/G5TU9PLqqrWa5rWLH1QVFUN0TStX1JSUvH48eP7BwYG4uDBg1cKCgpeBbBe2u+2Qug2EwD5N5sMPuNtMe8XP4TT6Qxoa2sbIGeXvUKIK7d4IISiKC5d1wPljOfA9bPwzYqiXNV13dd6Uqiq6qdpml2mpe02m63d4/G4vcTF5fF47LJf71nJA6BZVVW3pmntuPHlmAD5wk6Q9NnbHp9vHaqq6tA0zU/64PZhk1FfCZB9G/23ALiqKEqzD39tpvbGUqoFwFUhRLP3yzpCCDtJpxyXDulfG27+pqRR3DXsUWVd4Yq0x/taVQjhIhksC8L+ABpM9ljBf5sKwI8pIBr75L5E4vvu+UNeG/a+hv+AL7yFH8qPtOfHjtOP6V/Bja8D6z/B2Nys/1u9Xv33tLf4GfF/LC4GCJwByWIAAAAASUVORK5CYII=";
            cc._loaderImage = "data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAAAlAAD/4QMpaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjAtYzA2MCA2MS4xMzQ3NzcsIDIwMTAvMDIvMTItMTc6MzI6MDAgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjM4MDBEMDY2QTU1MjExRTFBQTAzQjEzMUNFNzMxRkQwIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjM4MDBEMDY1QTU1MjExRTFBQTAzQjEzMUNFNzMxRkQwIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzUgV2luZG93cyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU2RTk0OEM4OERCNDExRTE5NEUyRkE3M0M3QkE1NTlEIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU2RTk0OEM5OERCNDExRTE5NEUyRkE3M0M3QkE1NTlEIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+/+4ADkFkb2JlAGTAAAAAAf/bAIQADQkJCQoJDQoKDRMMCwwTFhENDREWGhUVFhUVGhkUFhUVFhQZGR0fIB8dGScnKionJzk4ODg5QEBAQEBAQEBAQAEODAwOEA4RDw8RFA4RDhQVERISERUfFRUXFRUfKB0ZGRkZHSgjJiAgICYjLCwoKCwsNzc1NzdAQEBAQEBAQEBA/8AAEQgAyACgAwEiAAIRAQMRAf/EALAAAAEFAQEAAAAAAAAAAAAAAAQAAgMFBgcBAQEAAwEBAAAAAAAAAAAAAAAAAQMEAgUQAAIBAgIEBwoLBgQGAwAAAAECAwAEEQUhMRIGQVFxsTITFGGBwdEiQlKSMzWRoeFicqKyI1NzFYJjJDQWB9KjVCbxwkNkJWXik3QRAAIBAgMFBQcDBQEAAAAAAAABAhEDIRIEMUFRcTJhwVIUBZGhsSJyEzOB0ULhYpIjUxX/2gAMAwEAAhEDEQA/AMJSpUqAVKlXuFAeUq9wpUB5XuFe4V6ooDzZHDox0CnGMinzwl7Z8NajaHeoO3vmTBZBtp9YUIqTEV5ROxHKnWRnaU8VRMhFBUjpV7hSoSeUq9pUB5Sr2lhQHlKvcK8oBV7hSFSRrtaKAZs07YNPM1pG2xJIAw1jSeandry/8X4m8VCKkWwaWwam7Xl/4v1W8VLtmX/i/VbxUoKkWwakSM407tmX/i/VbxUmzGwjQsjdY41IARie/U0IbZO0kNtCXnOCkEBeFu4KI3Bs7DNb27ya+jDx3kJeEnpJJEcQVbWDsk17u5urd591ucZkWhym2Vnd9RkCDEpFxDRpbw0bunu5mlp2De2FMLYXOD2wB2xbOeraUcYGJ72mlSUiqzzdzMd3Z3mixltA2yzcK/NlHM1DQyRXce1HocdNOEfJXZ88y9ZojOqhiBszIRiHQ8Y4cK5TvHuzLljHNMqxNoDjLFraHHnjPxcNCGVbxEUzYNTx5jZSxhpW6qTzlwJ+DCvO2Zf+L9VvFSgqyHYNLYNTdssPxfibxUu15f8Ai/VPiqCakOwa82DU/a8v/F+JvFTDdWPBL8R8VKCvYRYV5UzoMAy6QdIIqI0B4KJtxiRQwou16QoGUkntH5Tz0RbZbmF2hktraSVBo2lUkY8tDye0flPPXTslVUyiyVRsjqUOA4yMT8dW2ram2m6UVTNq9S7EIyUVJydMTn/6DnP+im9Wl+g5z/opvVrpteEhQWY4AaSTwAVf5WPiZh/9S5/zj7zltzlmYWkfWXNvJDGTgGcYDHirR7i7mSbwXParsFMrgb7w6jKw/wCmnc9I14kF3vpvCljbMyWMOJL4aEiB8qU/ObUK7HYWVrl1pFZWiCOCBQqKOLjPGTrNZZqKbUXVHq2nNwTuJRk1VpbgXN8s7Rk5ym0UQQzhIG2NAjhxHWbI+gCBVjBBFbwxwQqEiiUJGg1BVGAFe7dV28WYLYZFmF2Th1UD7JGjymGyn1iK5OyzIBGB1HgrLZhamzumQAGJwSqnSCh1q3GOCodxt4cxurdcpzuN4cyhiWaF5Bg09udUmnWw1H/jV9nFuJ7Quo+8h8peThFA+047vduyMtk7fYqTl07YFdfUufMPzT5p71UdtlmYXaGS2t3mQHAsgxANdadYJopLe4QS2867EsZ4QfCNYrCFbjdDPmgkYyWFxgVf04ifJf6ScNdRUW1XBb6FU5TjF5EpSSrGu/s5lN+g5z/opvVpfoOc/wCim9WtdHnatvObJXDW7xLGhB8nrPaY9/HCr+tEdPCVaSeDoYLnqF63lzW4/PFSW3ecxbI84VSzWUwUaSdg0DXXK5nvAipnd6qgKvWnQO7pri9ZUEmm3Vl2j1kr8pRlFRyquBNZjGxQ/S56Y1S2fu9OVueon11Szahoou06QoQUXadIVCD2FJJ7R+U89dMydv8Axdn+TH9muZye0flPPXQstlK5Tbka1gUjlC1q0vVLkeb6r+O3Tx9xcY1nt8c0NrZCyiOE1108NYjGv1joo7Js1jzKyScYLIvkzL6LDwHXVJksH9Sb49dKNq0tj1jA6uriOCL+02FWX7iVtZX1/AzaHTyeoauKn2MX9W79zebiZCuR5MjSrhfXuEtwTrUeZH+yNfdrRNcxI6IzhXlJEak6WIGJ2Rw4ChWnChndtlVBLMdQA0k1gbXNMzzDfDLs6mjaPKppJbWwJ1bOwwxw43OnHh71YT3DpfWUJmFlb5jHHDdeXBHIsrRea5TSqvxqG04cNN62vetoCS4tre5mgnkGE9q+3DKOkuI2WX6LDQRRHWDh1UCtwj7QRg2wdl8Djgw1qe7XvW0BQ3kfZ7mSLgU+T9E6RVbnuVrnWVSWqj+Lt8ZbRuHEdKPkYVcZ2MJY5fSGyeVar45+rkWQHAqccalPE5km1htWK5nK4Wnt5FuUBUwOMG4nGkA/BXUrW4S6torlOjMgcd/xVn7rLo7zKs0uEjCNeSvdwoBhgsZxX1l2j36k3Lu+uyprdj5Vs5A+i/lD48a0aaVJOPi7jB6lbzWozpjB48pf1NDXNN4vfl7+Z4BXS65pvF78vfzPAK71XTHmZ/S/yT+jvJ7L3fHytz1E+upbL+Qj5W56jfXWRnsIYKLtekKEFGWvSFQgyjk9o/Keet3YthlMP/5x9msJJ7R+U89biyb/AMXEv7gD6tadL1T+kwepRrC39ZkLDMbiwMvUHRPG0bjlGg8ore/23sxBldxfMPLupNhT8yL/AORNZbdzJ484scytxgLqJY5LZj6Q2sV5G1Vud1mjjyG0ij0NEGSZToKyhjtqw4waztuiXA3qKTbSxltfGhbZlE95ZtZqxVbgiOZhrER9ph3Svk9+pJILZ4Y4DGBFCUMKjRsGPobPFhUfW0NJmljE2xJcIrcI2vFUEln1lRXd6lrazXT9GCNpD+yNqoI7mOVduNw6nzlOIoPOUa6yye1XXcbMR5GdQ3xY0BSbj31/FcTQZirJ+q431q7anbHCTZ72Bw7lbPrKBMcBWNNgbMBBh+bsjBdni0VJ1lARZs6yWiupxCuMDy6KpS2IwOo6DTr3Mre3e5tZZVUM4ZBjqOOJoWO4jkXajcOOMHGgDISvWIrdAkKR80+TzVl908bPPL3LzxOuHdifxVfiTAg92qI/w+/8gGgSyN/mR7XPVlp0lF/3L3mbVKtu5Hjbk/8AHE2Fc03i9+Xv5ngFdKNc13i9+Xv5ngFaNV0x5nn+l/kn9HeEWXu+PlbnqJ9dS2Xu9OVueon11kZ7CGCjLXpCgxRlr0hUIPYUcntH5Tz1s8vb+Bt1/dqPirGSe0flPPWusG/g4Py15q06XqlyMWvVYQ+ruI9xJOqzO9hOto/sP8tbGOFIrmWeM7IuMDMnAXXQJOUjQeOsJk0nY96ip0CYunrjaHx1t+srPJUbXBm2LrFPikwTOb+T+VhbZxGMrDXp83x1QSy2tucJpUjPETp+Cn5/ftaRvKvtp3Kx48HG3erHMzOxZiWZtLMdJNQSbbL71Vk6yynViOkqnEEfOWtPbXi3EQkGg6mXiNckjeSJxJGxR10qw0GtxuxmvbImD4CZMFlA4fRfv0BqesqqzTMZNMEDbIHtHH2QeCiZJSqMQdOGiue53mz3czQwsRbIcNHnkec3c4qAMuriz68gTIToxwOOnlp0MjxMJYW741Gs3RVldtbygE/dMcHX/moDaxTiWNZB53B3arb8/wC+4SOF4sf/AKxU9kcBsfOGHfoUHtG/RbzY5Die5HHhXdvavqiZ9Q8Jdlq4/gbKua7xe/L38zwCuhpf2Uk/Zo50kmwJKIdogDjw1VzzeL35e/meAVp1LTgqY4nn+mRauzqmqwrjzCLL3fHytz1E+upLL+Qj5W56jfXWRnroYKLtekKEFF2vSFQg9hSSe0flPPWosm/hIfoLzVl5PaPynnrRWb/w0X0F5q06XqlyM2sVYx5gmbFre/t71NY2T+0h8VbSO5SWNJUOKSAMp7jDGspmMPaLRlXS6eWve1/FRO7WYdbZm1Y/eW/R7qHxHRXGojlm3ulid6aVbaW+OALvgCLq2Hm9WxHKWqjhj6xsK1e8dm15l4niG1LZkswGsxtrPeOmsvayBJA1VItlWjptLuTdPMo7LtjRDq9naK4+WF9IrUW7BaHOljGqVHB7w2hzVoZt87d8vaNYSLl02CcRsDEbJbj71Uu7UBkvJ7/D7q2QoDxySaAO8MTXdxRVMpRp5XZOWdF/ms7R5XdyKfKWJsO/5PhrG5XlNxmEywW6bTnTxAAcJNbGSMXkM1pjgbiNo1PziPJ+Os7u7m/6ReM00ZOgxSpqYYHT3wRXMKN4ll9zUG4bQfNshu8sZVuEA2hirA4qe/VOwwrVbzbww5mI44UKRRYkbWG0S3JWctbd7u5WFfOOLHiUdJqmaipfLsIsObhWe001lMkMVvJNjhghIALMcBxCs7fxXQmkupx1bXDswGPlaTidVaEyKNXkoo4eBV+Sq7L7Vs9zcBgeyQ4GQ/MB1crmoim2orezqcowTuSeEY48jQ7oZX2PLzdyLhNd6RjrEY6I7+uspvH78vfzPAK6UAAAFGAGgAcArmu8Xvy9/M8ArTfio24RW5nnaG67uou3H/KPuqT2X8hHytz1G+upLL3enK3PUb66ys9RDBRdr0hQgou06QqEGUkntH5Tz1e238vF9BeaqKT2j8p56vbb+Xi+gvNWjTdUuRn1XTHmTh8KrJTJlt8t1CPIY44cGnpJVjTJYkmjaN9Ib4u7V923njTethRauZJV3PaW1rfLIiXEDYg6R4VYc9CXW7thfOZbKdbGZtLW8uPVY/u3GrkNUkM9zlcxUjbhfWOA90cRq4gv4LhdqN+VToNYWmnRm9NNVWNTyHc6VWBv8wt4YeHqm6xyPmroq1Z7WGFLSxTq7WLSuPSdjrkfumq5yHXDUeA92oO2SKpVumNAaoJLMXH3myp0rpJ4uKhc3tbDM5BMri1zAj79j7KTiY8TcdBpcsith0286o+sPCagEX9Pzg4zXUCp6QYse8oouCG3tk6m1BYv05W6T+IdyolxbHDAAa2OgDlNCz3ryN2WxBd5PJMg1t81eId2ukqnLlTBbfcuY+9uJLiRcvtPvHdsHK+cfRHcHDWsyawjyy0WBcDI3lTP6TeIcFV+S5OmXx9bJg1048o8Cj0V8Jq2DVu09nL80up7OxHi+oal3P8AXB/IsZS8T/YOV65zvCcc7vfzPAK3ivWCz445zeH954BXOr6I8yfSfyz+jvCLP3fHytz1G+upLP3fHytz1E+usbPaQ0UXadIUIKLtekKhB7Ckk9o/Keer22/l4/oLzVRSe0flPPV7b/y8X0F5q0abqlyM+q6Y8yQsBTDMor1o8aiaE1pbluMqS3sbLLHIhSRQyngqukhaJ9uBjo+H5aOa3ao2t34qouRlLajTalGP8v0IY8ylXQ+PKPFU/bYXOLPge6CKia0LaxTOxHu1Q7cuBd9yPEJ7TbjXKO8CajbMIF6CNIeNvJHjqIWJ7tSpYkalqVblwIdyG+RGXur0hXYJFxal+Dhq5y3slkv3Y2pD0pTr+QUClpJRUdo9XW4OLrTHtM16cZLLWkeC7y4jvlNEpcRtw1Ux27Ci448NZrTFy3nn3IQWxlgGrDZ3pza7/M8ArZo+ArF5171uvp+CqdV0R5l/psUrs2vB3hdl7vTlbnqJ9dS2Xu+PlbnqJ9dY2eshooq16QoQUXa9IVCD2FLJ7RuU89WNtmUSQqkgYMgw0accKrpPaPynnrZWG4Vi+VWmY5tnMWXG+XrIYnA0rhj0mdcTgdNdwnKDqjmduM1SRR/qlr8/4KX6pa8T/BVzDuLZXudRZblmbxXcPUNPc3KqCIwrbOzgrHEnHjoyD+3eSXkht7DeKG4umDGOJVUklfouThXfmbnZ7Cvy1vt9pmv1W1+d8FL9VteJvgq5yrcOGfLmzHN80iyyETPbptAEFo2ZG8pmUa1OFNn3Ky6W/sbDKM5hv5bx2WTZA+7RF2y52WOPJTzE+z2Dy1vt9pT/AKpacTerS/U7Tib1a04/t7kDXPY03jhN0W6sQ7K7W3q2dnrMccaDy/8At80kuZfqWYxWNtlcvUPPhiGYhWDeUy7IwYU8xPs9g8tb7faUn6pacTerTxm9oOBvVq3v9z927aynuId44LiWKNnjhAXF2UYhRg516qpsryjLr21665zFLSTaK9U2GOA87SwqY37knRU+BzOzags0s1Oyr+BKM6sxwP6tSDPLMen6vy0rvdm3Sxlu7K/S7WDDrFUDUTxgnTU826eXW7KlxmqQuwDBXUKcD+1Xee/wXuKX5XDGWLapSVcOyhEM/seJ/V+WnjeGx4pPV+Wkm6kKZlFay3Jlt7iFpYZY8ASVK6DjtDDA0f8A0Tl340/1f8Ndx8xJVWXB0KbktFFpNzdVXAC/qOwA0CQni2flrO3Vwbm5lnI2TKxbDirX/wBE5d+NcfV/wVR7xZPa5U9utvI8nWhmbbw0YEAYYAVxfhfy5rlKR4Fulu6X7mW1mzT8S4Yis/5CPlbnqJ9dSWfu9OVueon11mZvQ2i7XpChKKtekKhBlNJ7R+U89bDfGTb3a3ZX0Lcj6kdY+T2j8p560288m1kWQr6MJ+ylSAr+2cnV5renjs3H1loX+3j9XvbbtxLN9lqW4UnV5jdnjtXHxihtyZNjeSBu5J9k1BJe7xy7W5CJ/wCzuD/mTVTf2+fq97LJuLrPsNRueS7W6aJ/38x+vLVXuY+xvHaNxbf2GoCezf8A36j/APsSf8w1sLnqczTefJluYoLm5uo5F61sBshItP1cNFYe1f8A3ir/APfE/wCZUe9bB94r5jwuPsrQFhmG4l/Z2M17HdW90tuu3IkTHaCjWdIw0VVZdks9/C06yJFEp2dp+E1bbqybGTZ8vpQD7L1XRv8A7blT96Oda7tpNuuNE37Cq9KSisjyuUoxrStKllHbLlWTXsMs8chuSuwEPDqwoLe5y+YRE/gLzmqRekvKKtd4327yM/ulHxmrHJStySWVRyrjxKI2XC/CTlnlPPKTpTdFbP0L1bgrf5Lp0G3dPhQHwV0S1lzBsns3sESR8Crh9WAJGjSOKuU3E+zdZQ3oJh8IArdZXFDmOTpHa3i2+YrI2KtKy4ricBsBuHHgFXSo440+Wa2qqxjvM9uMoy+WvzWpLCWWWE28HxL6e43ojgkeSCBY1Ri5BGIUDT51cl3vm276BBqSEH4WbxV0tlkyXJcxTMb+OW6uY9mGHrCzDQwwAbTp2uKuTZ9N1uYsfRRR8WPhrm419mSSjRyiqxVK7y23B/ftuTm2oSdJyzNVw3BFn7vTlbnqF9dS2fu9OVueon11lZuQ2iLdsGFD05H2dNQGV0ntG5Tz1dWm9N1b2kVq8EVwsI2UaQaQOKhmitZGLOmk68DhSFvY+gfWNSAg7z3Qvo7yKCKIohiaNR5LKxx8qpxvjcqS0VpbxvwOAcRQPZ7D0G9Y0uz2HoH1jUCpLY7zXlpbm3eKO5QuzjrBqZji3x17PvNcyT288VvDBJbMWUovS2hslW7mFQ9nsPQPrGl2ew9A+saCod/WNxtbYsrfb17WBxx5ddD2281xC88klvDcSXEnWuzrqOGGC9zRUPZ7D0G9Y0uzWHoH1jQVCLreq6ntZbaO3it1mGy7RjTs1X2mYy20ZiCq8ZOODcdEdmsPQb1jS7PYegfWNdJuLqnQiSUlRqpFLmryxtH1Ma7Qw2gNNPOdSt0oI27p007s9h6B9Y0uz2HoH1jXX3Z+I4+1b8IJdX89xLHKQFMXQUahpxoiPN5P+onfU+A0/s9h6DesaXZ7D0D6xpG7OLbUtu0StW5JJx2bBsmbtiSiEk+cxoCWWSaVpZOk2vDVo0VYdnsPQb1jSNvZcCH1jSd2c+p1XAmFqEOmOPEfaH+BQd1ueo211IzrgFUYKNAAqI1WztCpUqVCRUqVKgFSpUqAVKlSoBUqVKgFSpUqAVKlSoBUqVKgFSpUqAVKlSoD/9k=";
            var cc = cc || {};
            cc._tmp = cc._tmp || {};
            cc._LogInfos = cc._LogInfos || {};
            var _p = window;
            _p.gl;
            _p.WebGLRenderingContext;
            _p.DeviceOrientationEvent;
            _p.DeviceMotionEvent;
            _p.AudioContext;
            if (!_p.AudioContext) {
                _p.webkitAudioContext;
            }
            _p.mozAudioContext;
            _p = Object.prototype;
            _p._super;
            _p.ctor;
            _p = null;
            cc.ORIENTATION_PORTRAIT = 0;
            cc.ORIENTATION_PORTRAIT_UPSIDE_DOWN = 1;
            cc.ORIENTATION_LANDSCAPE_LEFT = 2;
            cc.ORIENTATION_LANDSCAPE_RIGHT = 3;
            cc._drawingUtil = null;
            cc._renderContext = null;
            cc._supportRender = false;
            cc._canvas = null;
            cc.container = null;
            cc._gameDiv = null;
            cc.isEditor = "undefined" !== typeof Editor;
            cc.each = function(obj, iterator, context) {
                if (!obj) {
                    return;
                }
                if (obj instanceof Array) {
                    for (var i = 0, li = obj.length; i < li; i++) {
                        if (false === iterator.call(context, obj[i], i)) {
                            return;
                        }
                    }
                } else {
                    for (var key in obj) {
                        if (false === iterator.call(context, obj[key], key)) {
                            return;
                        }
                    }
                }
            };
            cc.isCrossOrigin = function(url) {
                if (!url) {
                    cc.log("invalid URL");
                    return false;
                }
                var startIndex = url.indexOf("://");
                if (-1 === startIndex) {
                    return false;
                }
                var endIndex = url.indexOf("/", startIndex + 3);
                var urlOrigin = -1 === endIndex ? url : url.substring(0, endIndex);
                return urlOrigin !== location.origin;
            };
            cc.formatStr = function() {
                var args = arguments;
                var l = args.length;
                if (l < 1) {
                    return "";
                }
                var str = args[0];
                var needToFormat = true;
                if ("object" === typeof str) {
                    needToFormat = false;
                }
                for (var i = 1; i < l; ++i) {
                    var arg = args[i];
                    if (needToFormat) {
                        while (true) {
                            var result = null;
                            if ("number" === typeof arg) {
                                result = str.match(/(%d)|(%s)/);
                                if (result) {
                                    str = str.replace(/(%d)|(%s)/, arg);
                                    break;
                                }
                            }
                            result = str.match(/%s/);
                            if (result) {
                                str = str.replace(/%s/, arg);
                            } else {
                                str += "    " + arg;
                            }
                            break;
                        }
                    } else {
                        str += "    " + arg;
                    }
                }
                return str;
            };
            require("../cocos2d/core/utils");
            require("../cocos2d/core/platform/CCLoader");
            require("../cocos2d/core/platform/CCSys");
            require("../cocos2d/core/CCGame");
            !function() {
                var _jsAddedCache = {}, _engineInitCalled = false, _engineLoadedCallback = null;
                cc._engineLoaded = false;
                function _determineRenderType(config) {
                    var CONFIG_KEY = cc.game.CONFIG_KEY, userRenderMode = parseInt(config[CONFIG_KEY.renderMode]) || 0;
                    if (isNaN(userRenderMode) || userRenderMode > 2 || userRenderMode < 0) {
                        config[CONFIG_KEY.renderMode] = 0;
                    }
                    cc._renderType = cc.game.RENDER_TYPE_CANVAS;
                    cc._supportRender = false;
                    if (0 === userRenderMode) {
                        if (cc.sys.capabilities["opengl"]) {
                            cc._renderType = cc.game.RENDER_TYPE_WEBGL;
                            cc._supportRender = true;
                        } else {
                            if (cc.sys.capabilities["canvas"]) {
                                cc._renderType = cc.game.RENDER_TYPE_CANVAS;
                                cc._supportRender = true;
                            }
                        }
                    } else {
                        if (1 === userRenderMode && cc.sys.capabilities["canvas"]) {
                            cc._renderType = cc.game.RENDER_TYPE_CANVAS;
                            cc._supportRender = true;
                        } else {
                            if (2 === userRenderMode && cc.sys.capabilities["opengl"]) {
                                cc._renderType = cc.game.RENDER_TYPE_WEBGL;
                                cc._supportRender = true;
                            }
                        }
                    }
                }
                function _getJsListOfModule(moduleMap, moduleName, dir) {
                    if (_jsAddedCache[moduleName]) {
                        return null;
                    }
                    dir = dir || "";
                    var jsList = [];
                    var tempList = moduleMap[moduleName];
                    if (!tempList) {
                        throw new Error("can not find module [" + moduleName + "]");
                    }
                    var ccPath = cc.path;
                    for (var i = 0, li = tempList.length; i < li; i++) {
                        var item = tempList[i];
                        if (_jsAddedCache[item]) {
                            continue;
                        }
                        var extname = ccPath.extname(item);
                        if (!extname) {
                            var arr = _getJsListOfModule(moduleMap, item, dir);
                            if (arr) {
                                jsList = jsList.concat(arr);
                            }
                        } else {
                            if (".js" === extname.toLowerCase()) {
                                jsList.push(ccPath.join(dir, item));
                            }
                        }
                        _jsAddedCache[item] = 1;
                    }
                    return jsList;
                }
                function _afterEngineLoaded(config) {
                    cc._initDebugSetting(config[cc.game.CONFIG_KEY.debugMode]);
                    cc._engineLoaded = true;
                    cc.log(cc.ENGINE_VERSION);
                    if (_engineLoadedCallback) {
                        _engineLoadedCallback();
                    }
                }
                function _load(config) {
                    var self = this;
                    var CONFIG_KEY = cc.game.CONFIG_KEY, engineDir = config[CONFIG_KEY.engineDir], loader = cc.loader;
                    if (cc._Class) {
                        _afterEngineLoaded(config);
                    } else {
                        var ccModulesPath = cc.path.join(engineDir, "moduleConfig.json");
                        loader.loadJson(ccModulesPath, function(err, modulesJson) {
                            if (err) {
                                throw new Error(err);
                            }
                            var modules = config["modules"] || [];
                            var moduleMap = modulesJson["module"];
                            var jsList = [];
                            if (cc.sys.capabilities["opengl"] && modules.indexOf("base4webgl") < 0) {
                                modules.splice(0, 0, "base4webgl");
                            } else {
                                if (modules.indexOf("core") < 0) {
                                    modules.splice(0, 0, "core");
                                }
                            }
                            for (var i = 0, li = modules.length; i < li; i++) {
                                var arr = _getJsListOfModule(moduleMap, modules[i], engineDir);
                                if (arr) {
                                    jsList = jsList.concat(arr);
                                }
                            }
                            cc.loader.loadJsWithImg(jsList, function(err) {
                                if (err) {
                                    throw err;
                                }
                                _afterEngineLoaded(config);
                            });
                        });
                    }
                }
                function _windowLoaded() {
                    window.removeEventListener("load", _windowLoaded, false);
                    _load(cc.game.config);
                }
                cc.initEngine = function(config, cb) {
                    if (_engineInitCalled) {
                        var previousCallback = _engineLoadedCallback;
                        _engineLoadedCallback = function() {
                            previousCallback && previousCallback();
                            cb && cb();
                        };
                        return;
                    }
                    _engineLoadedCallback = cb;
                    if (!cc.game.config && config) {
                        cc.game.config = config;
                    } else {
                        if (!cc.game.config) {
                            cc.game._loadConfig();
                        }
                    }
                    config = cc.game.config;
                    _determineRenderType(config);
                    document.body ? _load(config) : window.addEventListener("load", _windowLoaded, false);
                    _engineInitCalled = true;
                };
            }();
            var cc = cc || {};
            cc._tmp = cc._tmp || {};
            cc.associateWithNative = function(jsObj, superclass) {};
            cc.KEY = {
                none: 0,
                back: 6,
                menu: 18,
                backspace: 8,
                tab: 9,
                enter: 13,
                shift: 16,
                ctrl: 17,
                alt: 18,
                pause: 19,
                capslock: 20,
                escape: 27,
                space: 32,
                pageup: 33,
                pagedown: 34,
                end: 35,
                home: 36,
                left: 37,
                up: 38,
                right: 39,
                down: 40,
                select: 41,
                insert: 45,
                Delete: 46,
                0: 48,
                1: 49,
                2: 50,
                3: 51,
                4: 52,
                5: 53,
                6: 54,
                7: 55,
                8: 56,
                9: 57,
                a: 65,
                b: 66,
                c: 67,
                d: 68,
                e: 69,
                f: 70,
                g: 71,
                h: 72,
                i: 73,
                j: 74,
                k: 75,
                l: 76,
                m: 77,
                n: 78,
                o: 79,
                p: 80,
                q: 81,
                r: 82,
                s: 83,
                t: 84,
                u: 85,
                v: 86,
                w: 87,
                x: 88,
                y: 89,
                z: 90,
                num0: 96,
                num1: 97,
                num2: 98,
                num3: 99,
                num5: 101,
                num6: 102,
                num7: 103,
                num8: 104,
                num9: 105,
                "*": 106,
                "+": 107,
                "-": 109,
                numdel: 110,
                "/": 111,
                f1: 112,
                f2: 113,
                f3: 114,
                f4: 115,
                f5: 116,
                f6: 117,
                f7: 118,
                f8: 119,
                f9: 120,
                f10: 121,
                f11: 122,
                f12: 123,
                numlock: 144,
                scrolllock: 145,
                ";": 186,
                semicolon: 186,
                equal: 187,
                "=": 187,
                ",": 188,
                comma: 188,
                dash: 189,
                ".": 190,
                period: 190,
                forwardslash: 191,
                grave: 192,
                "[": 219,
                openbracket: 219,
                backslash: 220,
                "]": 221,
                closebracket: 221,
                quote: 222,
                dpadLeft: 1e3,
                dpadRight: 1001,
                dpadUp: 1003,
                dpadDown: 1004,
                dpadCenter: 1005
            };
            cc.FMT_JPG = 0;
            cc.FMT_PNG = 1;
            cc.FMT_TIFF = 2;
            cc.FMT_RAWDATA = 3;
            cc.FMT_WEBP = 4;
            cc.FMT_UNKNOWN = 5;
            cc.getImageFormatByData = function(imgData) {
                if (imgData.length > 8 && 137 === imgData[0] && 80 === imgData[1] && 78 === imgData[2] && 71 === imgData[3] && 13 === imgData[4] && 10 === imgData[5] && 26 === imgData[6] && 10 === imgData[7]) {
                    return cc.FMT_PNG;
                }
                if (imgData.length > 2 && (73 === imgData[0] && 73 === imgData[1] || 77 === imgData[0] && 77 === imgData[1] || 255 === imgData[0] && 216 === imgData[1])) {
                    return cc.FMT_TIFF;
                }
                return cc.FMT_UNKNOWN;
            };
            cc.inherits = function(childCtor, parentCtor) {
                function tempCtor() {}
                tempCtor.prototype = parentCtor.prototype;
                childCtor.superClass_ = parentCtor.prototype;
                childCtor.prototype = new tempCtor();
                childCtor.prototype.constructor = childCtor;
            };
            cc.base = function(me, opt_methodName, var_args) {
                var caller = arguments.callee.caller;
                if (caller.superClass_) {
                    ret = caller.superClass_.constructor.apply(me, Array.prototype.slice.call(arguments, 1));
                    return ret;
                }
                var args = Array.prototype.slice.call(arguments, 2);
                var foundCaller = false;
                for (var ctor = me.constructor; ctor; ctor = ctor.superClass_ && ctor.superClass_.constructor) {
                    if (ctor.prototype[opt_methodName] === caller) {
                        foundCaller = true;
                    } else {
                        if (foundCaller) {
                            return ctor.prototype[opt_methodName].apply(me, args);
                        }
                    }
                }
                if (me[opt_methodName] === caller) {
                    return me.constructor.prototype[opt_methodName].apply(me, args);
                } else {
                    throw Error("cc.base called from a method of one name to a method of a different name");
                }
            };
            cc.SAXParser = cc._Class.extend({
                _parser: null,
                _isSupportDOMParser: null,
                ctor: function() {
                    if (window.DOMParser) {
                        this._isSupportDOMParser = true;
                        this._parser = new DOMParser();
                    } else {
                        this._isSupportDOMParser = false;
                    }
                },
                parse: function(xmlTxt) {
                    return this._parseXML(xmlTxt);
                },
                _parseXML: function(textxml) {
                    var xmlDoc;
                    if (this._isSupportDOMParser) {
                        xmlDoc = this._parser.parseFromString(textxml, "text/xml");
                    } else {
                        xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
                        xmlDoc.async = "false";
                        xmlDoc.loadXML(textxml);
                    }
                    return xmlDoc;
                }
            });
            cc.PlistParser = cc.SAXParser.extend({
                parse: function(xmlTxt) {
                    var xmlDoc = this._parseXML(xmlTxt);
                    var plist = xmlDoc.documentElement;
                    if ("plist" !== plist.tagName) {
                        cc.warn("Not a plist file!");
                        return {};
                    }
                    var node = null;
                    for (var i = 0, len = plist.childNodes.length; i < len; i++) {
                        node = plist.childNodes[i];
                        if (1 === node.nodeType) {
                            break;
                        }
                    }
                    xmlDoc = null;
                    return this._parseNode(node);
                },
                _parseNode: function(node) {
                    var data = null, tagName = node.tagName;
                    if ("dict" === tagName) {
                        data = this._parseDict(node);
                    } else {
                        if ("array" === tagName) {
                            data = this._parseArray(node);
                        } else {
                            if ("string" === tagName) {
                                if (1 === node.childNodes.length) {
                                    data = node.firstChild.nodeValue;
                                } else {
                                    data = "";
                                    for (var i = 0; i < node.childNodes.length; i++) {
                                        data += node.childNodes[i].nodeValue;
                                    }
                                }
                            } else {
                                if ("false" === tagName) {
                                    data = false;
                                } else {
                                    if ("true" === tagName) {
                                        data = true;
                                    } else {
                                        if ("real" === tagName) {
                                            data = parseFloat(node.firstChild.nodeValue);
                                        } else {
                                            if ("integer" === tagName) {
                                                data = parseInt(node.firstChild.nodeValue, 10);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return data;
                },
                _parseArray: function(node) {
                    var data = [];
                    for (var i = 0, len = node.childNodes.length; i < len; i++) {
                        var child = node.childNodes[i];
                        if (1 !== child.nodeType) {
                            continue;
                        }
                        data.push(this._parseNode(child));
                    }
                    return data;
                },
                _parseDict: function(node) {
                    var data = {};
                    var key = null;
                    for (var i = 0, len = node.childNodes.length; i < len; i++) {
                        var child = node.childNodes[i];
                        if (1 !== child.nodeType) {
                            continue;
                        }
                        if ("key" === child.tagName) {
                            key = child.firstChild.nodeValue;
                        } else {
                            data[key] = this._parseNode(child);
                        }
                    }
                    return data;
                }
            });
            cc.saxParser = new cc.SAXParser();
            cc.plistParser = new cc.PlistParser();
            cc._txtLoader = {
                load: function(realUrl, url, res, cb) {
                    cc.loader.loadTxt(realUrl, cb);
                }
            };
            cc.loader.register([ "txt", "xml", "vsh", "fsh", "atlas" ], cc._txtLoader);
            cc._jsonLoader = {
                load: function(realUrl, url, res, cb) {
                    cc.loader.loadJson(realUrl, cb);
                }
            };
            cc.loader.register([ "json", "ExportJson" ], cc._jsonLoader);
            cc._jsLoader = {
                load: function(realUrl, url, res, cb) {
                    cc.loader.loadJs(realUrl, cb);
                }
            };
            cc.loader.register([ "js" ], cc._jsLoader);
            cc._imgLoader = {
                load: function(realUrl, url, res, cb) {
                    cc.loader.cache[url] = cc.loader.loadImg(realUrl, function(err, img) {
                        if (err) {
                            return cb(err);
                        }
                        cc.textureCache.handleLoadedTexture(url);
                        cb(null, img);
                    });
                }
            };
            cc.loader.register([ "png", "jpg", "bmp", "jpeg", "gif", "ico", "tiff", "webp" ], cc._imgLoader);
            cc._serverImgLoader = {
                load: function(realUrl, url, res, cb) {
                    cc.loader.cache[url] = cc.loader.loadImg(res.src, function(err, img) {
                        if (err) {
                            return cb(err);
                        }
                        cc.textureCache.handleLoadedTexture(url);
                        cb(null, img);
                    });
                }
            };
            cc.loader.register([ "serverImg" ], cc._serverImgLoader);
            cc._plistLoader = {
                load: function(realUrl, url, res, cb) {
                    cc.loader.loadTxt(realUrl, function(err, txt) {
                        if (err) {
                            return cb(err);
                        }
                        cb(null, cc.plistParser.parse(txt));
                    });
                }
            };
            cc.loader.register([ "plist" ], cc._plistLoader);
            cc._fontLoader = {
                TYPE: {
                    ".eot": "embedded-opentype",
                    ".ttf": "truetype",
                    ".ttc": "truetype",
                    ".woff": "woff",
                    ".svg": "svg"
                },
                _loadFont: function(name, srcs, type) {
                    var doc = document, path = cc.path, TYPE = this.TYPE, fontStyle = document.createElement("style");
                    fontStyle.type = "text/css";
                    doc.body.appendChild(fontStyle);
                    var fontStr = "";
                    if (isNaN(name - 0)) {
                        fontStr += "@font-face { font-family:" + name + "; src:";
                    } else {
                        fontStr += "@font-face { font-family:'" + name + "'; src:";
                    }
                    if (srcs instanceof Array) {
                        for (var i = 0, li = srcs.length; i < li; i++) {
                            var src = srcs[i];
                            type = path.extname(src).toLowerCase();
                            fontStr += "url('" + srcs[i] + "') format('" + TYPE[type] + "')";
                            fontStr += i === li - 1 ? ";" : ",";
                        }
                    } else {
                        type = type.toLowerCase();
                        fontStr += "url('" + srcs + "') format('" + TYPE[type] + "');";
                    }
                    fontStyle.textContent += fontStr + "}";
                    var preloadDiv = document.createElement("div");
                    var _divStyle = preloadDiv.style;
                    _divStyle.fontFamily = name;
                    preloadDiv.innerHTML = ".";
                    _divStyle.position = "absolute";
                    _divStyle.left = "-100px";
                    _divStyle.top = "-100px";
                    doc.body.appendChild(preloadDiv);
                },
                load: function(realUrl, url, res, cb) {
                    var self = this;
                    var type = res.type, name = res.name, srcs = res.srcs;
                    if (cc.js.isString(res)) {
                        type = cc.path.extname(res);
                        name = cc.path.basename(res, type);
                        self._loadFont(name, res, type);
                    } else {
                        self._loadFont(name, srcs);
                    }
                    if (document.fonts) {
                        document.fonts.load("1em " + name).then(function() {
                            cb(null, true);
                        }, function(err) {
                            cb(err);
                        });
                    } else {
                        cb(null, true);
                    }
                }
            };
            cc.loader.register([ "font", "eot", "ttf", "woff", "svg", "ttc" ], cc._fontLoader);
            cc._binaryLoader = {
                load: function(realUrl, url, res, cb) {
                    cc.loader.loadBinary(realUrl, cb);
                }
            };
            cc._csbLoader = {
                load: function(realUrl, url, res, cb) {
                    cc.loader.loadCsb(realUrl, cb);
                }
            };
            cc.loader.register([ "csb" ], cc._csbLoader);
            window["CocosEngine"] = cc.ENGINE_VERSION = "Cocos Creator v0.7";
            cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL = 0;
            cc.DIRECTOR_STATS_POSITION = cc.p(0, 0);
            cc.DIRECTOR_FPS_INTERVAL = .5;
            cc.COCOSNODE_RENDER_SUBPIXEL = 1;
            cc.SPRITEBATCHNODE_RENDER_SUBPIXEL = 1;
            cc.AUTO_PREMULTIPLIED_ALPHA_FOR_PNG = 0;
            cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA = 0;
            cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP = 0;
            cc.TEXTURE_ATLAS_USE_VAO = 0;
            cc.TEXTURE_NPOT_SUPPORT = 0;
            cc.RETINA_DISPLAY_SUPPORT = 1;
            cc.RETINA_DISPLAY_FILENAME_SUFFIX = "-hd";
            cc.USE_LA88_LABELS = 1;
            cc.SPRITE_DEBUG_DRAW = 0;
            cc.SPRITEBATCHNODE_DEBUG_DRAW = 0;
            cc.LABELBMFONT_DEBUG_DRAW = 0;
            cc.LABELATLAS_DEBUG_DRAW = 0;
            cc.IS_RETINA_DISPLAY_SUPPORTED = 1;
            cc.DEFAULT_ENGINE = cc.ENGINE_VERSION + "-canvas";
            cc.ENABLE_STACKABLE_ACTIONS = 1;
            cc.ENABLE_GL_STATE_CACHE = 1;
            cc.$ = function(x) {
                var parent = this === cc ? document : this;
                var el = x instanceof HTMLElement ? x : parent.querySelector(x);
                if (el) {
                    el.find = el.find || cc.$;
                    el.hasClass = el.hasClass || function(cls) {
                        return this.className.match(new RegExp("(\\s|^)" + cls + "(\\s|$)"));
                    };
                    el.addClass = el.addClass || function(cls) {
                        if (!this.hasClass(cls)) {
                            if (this.className) {
                                this.className += " ";
                            }
                            this.className += cls;
                        }
                        return this;
                    };
                    el.removeClass = el.removeClass || function(cls) {
                        if (this.hasClass(cls)) {
                            this.className = this.className.replace(cls, "");
                        }
                        return this;
                    };
                    el.remove = el.remove || function() {
                        if (this.parentNode) {
                            this.parentNode.removeChild(this);
                        }
                        return this;
                    };
                    el.appendTo = el.appendTo || function(x) {
                        x.appendChild(this);
                        return this;
                    };
                    el.prependTo = el.prependTo || function(x) {
                        x.childNodes[0] ? x.insertBefore(this, x.childNodes[0]) : x.appendChild(this);
                        return this;
                    };
                    el.transforms = el.transforms || function() {
                        this.style[cc.$.trans] = cc.$.translate(this.position) + cc.$.rotate(this.rotation) + cc.$.scale(this.scale) + cc.$.skew(this.skew);
                        return this;
                    };
                    el.position = el.position || {
                        x: 0,
                        y: 0
                    };
                    el.rotation = el.rotation || 0;
                    el.scale = el.scale || {
                        x: 1,
                        y: 1
                    };
                    el.skew = el.skew || {
                        x: 0,
                        y: 0
                    };
                    el.translates = function(x, y) {
                        this.position.x = x;
                        this.position.y = y;
                        this.transforms();
                        return this;
                    };
                    el.rotate = function(x) {
                        this.rotation = x;
                        this.transforms();
                        return this;
                    };
                    el.resize = function(x, y) {
                        this.scale.x = x;
                        this.scale.y = y;
                        this.transforms();
                        return this;
                    };
                    el.setSkew = function(x, y) {
                        this.skew.x = x;
                        this.skew.y = y;
                        this.transforms();
                        return this;
                    };
                }
                return el;
            };
            switch (cc.sys.browserType) {
              case cc.sys.BROWSER_TYPE_FIREFOX:
                cc.$.pfx = "Moz";
                cc.$.hd = true;
                break;

              case cc.sys.BROWSER_TYPE_CHROME:
              case cc.sys.BROWSER_TYPE_SAFARI:
                cc.$.pfx = "webkit";
                cc.$.hd = true;
                break;

              case cc.sys.BROWSER_TYPE_OPERA:
                cc.$.pfx = "O";
                cc.$.hd = false;
                break;

              case cc.sys.BROWSER_TYPE_IE:
                cc.$.pfx = "ms";
                cc.$.hd = false;
                break;

              default:
                cc.$.pfx = "webkit";
                cc.$.hd = true;
            }
            cc.$.trans = cc.$.pfx + "Transform";
            cc.$.translate = cc.$.hd ? function(a) {
                return "translate3d(" + a.x + "px, " + a.y + "px, 0) ";
            } : function(a) {
                return "translate(" + a.x + "px, " + a.y + "px) ";
            };
            cc.$.rotate = cc.$.hd ? function(a) {
                return "rotateZ(" + a + "deg) ";
            } : function(a) {
                return "rotate(" + a + "deg) ";
            };
            cc.$.scale = function(a) {
                return "scale(" + a.x + ", " + a.y + ") ";
            };
            cc.$.skew = function(a) {
                return "skewX(" + -a.x + "deg) skewY(" + a.y + "deg)";
            };
            cc.$new = function(x) {
                return cc.$(document.createElement(x));
            };
            cc.$.findpos = function(obj) {
                var curleft = 0;
                var curtop = 0;
                do {
                    curleft += obj.offsetLeft;
                    curtop += obj.offsetTop;
                } while (obj = obj.offsetParent);
                return {
                    x: curleft,
                    y: curtop
                };
            };
            cc.Touches = [];
            cc.TouchesIntergerDict = {};
            cc.DENSITYDPI_DEVICE = "device-dpi";
            cc.DENSITYDPI_HIGH = "high-dpi";
            cc.DENSITYDPI_MEDIUM = "medium-dpi";
            cc.DENSITYDPI_LOW = "low-dpi";
            cc.__BrowserGetter = {
                init: function() {
                    this.html = document.getElementsByTagName("html")[0];
                },
                availWidth: function(frame) {
                    if (!frame || frame === this.html) {
                        return window.innerWidth;
                    } else {
                        return frame.clientWidth;
                    }
                },
                availHeight: function(frame) {
                    if (!frame || frame === this.html) {
                        return window.innerHeight;
                    } else {
                        return frame.clientHeight;
                    }
                },
                meta: {
                    width: "device-width"
                },
                adaptationType: cc.sys.browserType
            };
            if (window.navigator.userAgent.indexOf("OS 8_1_") > -1) {
                cc.__BrowserGetter.adaptationType = cc.sys.BROWSER_TYPE_MIUI;
            }
            if (cc.sys.os === cc.sys.OS_IOS) {
                cc.__BrowserGetter.adaptationType = cc.sys.BROWSER_TYPE_SAFARI;
            }
            switch (cc.__BrowserGetter.adaptationType) {
              case cc.sys.BROWSER_TYPE_SAFARI:
                cc.__BrowserGetter.meta["minimal-ui"] = "true";
                cc.__BrowserGetter.availWidth = function(frame) {
                    return frame.clientWidth;
                };
                cc.__BrowserGetter.availHeight = function(frame) {
                    return frame.clientHeight;
                };
                break;

              case cc.sys.BROWSER_TYPE_CHROME:
                cc.__BrowserGetter.__defineGetter__("target-densitydpi", function() {
                    return cc.view._targetDensityDPI;
                });

              case cc.sys.BROWSER_TYPE_SOUGOU:
              case cc.sys.BROWSER_TYPE_UC:
                cc.__BrowserGetter.availWidth = function(frame) {
                    return frame.clientWidth;
                };
                cc.__BrowserGetter.availHeight = function(frame) {
                    return frame.clientHeight;
                };
                break;

              case cc.sys.BROWSER_TYPE_MIUI:
                cc.__BrowserGetter.init = function(view) {
                    if (view.__resizeWithBrowserSize) {
                        return;
                    }
                    var resize = function() {
                        view.setDesignResolutionSize(view._designResolutionSize.width, view._designResolutionSize.height, view._resolutionPolicy);
                        window.removeEventListener("resize", resize, false);
                    };
                    window.addEventListener("resize", resize, false);
                };
            }
            cc.EGLView = cc._Class.extend({
                _delegate: null,
                _frameSize: null,
                _designResolutionSize: null,
                _originalDesignResolutionSize: null,
                _viewPortRect: null,
                _visibleRect: null,
                _retinaEnabled: false,
                _autoFullScreen: true,
                _devicePixelRatio: 1,
                _viewName: "",
                _resizeCallback: null,
                _scaleX: 1,
                _originalScaleX: 1,
                _scaleY: 1,
                _originalScaleY: 1,
                _indexBitsUsed: 0,
                _maxTouches: 5,
                _resolutionPolicy: null,
                _rpExactFit: null,
                _rpShowAll: null,
                _rpNoBorder: null,
                _rpFixedHeight: null,
                _rpFixedWidth: null,
                _initialized: false,
                _captured: false,
                _wnd: null,
                _hDC: null,
                _hRC: null,
                _supportTouch: false,
                _contentTranslateLeftTop: null,
                _frameZoomFactor: 1,
                __resizeWithBrowserSize: false,
                _isAdjustViewPort: true,
                _targetDensityDPI: null,
                ctor: function() {
                    var _t = this, d = document, _strategyer = cc.ContainerStrategy, _strategy = cc.ContentStrategy;
                    cc.__BrowserGetter.init(this);
                    _t._frameSize = cc.size(0, 0);
                    _t._initFrameSize();
                    var w = cc.game.canvas.width, h = cc.game.canvas.height;
                    _t._designResolutionSize = cc.size(w, h);
                    _t._originalDesignResolutionSize = cc.size(w, h);
                    _t._viewPortRect = cc.rect(0, 0, w, h);
                    _t._visibleRect = cc.rect(0, 0, w, h);
                    _t._contentTranslateLeftTop = {
                        left: 0,
                        top: 0
                    };
                    _t._viewName = "Cocos2dHTML5";
                    var sys = cc.sys;
                    _t.enableRetina(sys.os === sys.OS_IOS || sys.os === sys.OS_OSX);
                    cc.visibleRect && cc.visibleRect.init(_t._visibleRect);
                    _t._rpExactFit = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.EXACT_FIT);
                    _t._rpShowAll = new cc.ResolutionPolicy(_strategyer.PROPORTION_TO_FRAME, _strategy.SHOW_ALL);
                    _t._rpNoBorder = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.NO_BORDER);
                    _t._rpFixedHeight = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_HEIGHT);
                    _t._rpFixedWidth = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_WIDTH);
                    _t._hDC = cc.game.canvas;
                    _t._hRC = cc._renderContext;
                    _t._targetDensityDPI = cc.DENSITYDPI_HIGH;
                },
                _resizeEvent: function() {
                    var view;
                    if (this.setDesignResolutionSize) {
                        view = this;
                    } else {
                        view = cc.view;
                    }
                    var prevFrameW = view._frameSize.width, prevFrameH = view._frameSize.height;
                    view._initFrameSize();
                    if (view._frameSize.width === prevFrameW && view._frameSize.height === prevFrameH) {
                        return;
                    }
                    var width = view._originalDesignResolutionSize.width;
                    var height = view._originalDesignResolutionSize.height;
                    if (width > 0) {
                        view.setDesignResolutionSize(width, height, view._resolutionPolicy);
                    }
                    cc.eventManager.dispatchCustomEvent("canvas-resize");
                    if (view._resizeCallback) {
                        view._resizeCallback.call();
                    }
                },
                setTargetDensityDPI: function(densityDPI) {
                    this._targetDensityDPI = densityDPI;
                    this._adjustViewportMeta();
                },
                getTargetDensityDPI: function() {
                    return this._targetDensityDPI;
                },
                resizeWithBrowserSize: function(enabled) {
                    if (enabled) {
                        if (!this.__resizeWithBrowserSize) {
                            this.__resizeWithBrowserSize = true;
                            window.addEventListener("resize", this._resizeEvent);
                            window.addEventListener("orientationchange", this._resizeEvent);
                        }
                    } else {
                        if (this.__resizeWithBrowserSize) {
                            this.__resizeWithBrowserSize = false;
                            window.removeEventListener("resize", this._resizeEvent);
                            window.removeEventListener("orientationchange", this._resizeEvent);
                        }
                    }
                },
                setResizeCallback: function(callback) {
                    if (cc.js.isFunction(callback) || null == callback) {
                        this._resizeCallback = callback;
                    }
                },
                _initFrameSize: function() {
                    var locFrameSize = this._frameSize;
                    locFrameSize.width = cc.__BrowserGetter.availWidth(cc.game.frame);
                    locFrameSize.height = cc.__BrowserGetter.availHeight(cc.game.frame);
                },
                _adjustSizeKeepCanvasSize: function() {
                    var designWidth = this._originalDesignResolutionSize.width;
                    var designHeight = this._originalDesignResolutionSize.height;
                    if (designWidth > 0) {
                        this.setDesignResolutionSize(designWidth, designHeight, this._resolutionPolicy);
                    }
                },
                _setViewportMeta: function(metas, overwrite) {
                    var vp = document.getElementById("cocosMetaElement");
                    if (vp && overwrite) {
                        document.head.removeChild(vp);
                    }
                    var elems = document.getElementsByName("viewport"), currentVP = elems ? elems[0] : null, content, key, pattern;
                    content = currentVP ? currentVP.content : "";
                    vp = vp || document.createElement("meta");
                    vp.id = "cocosMetaElement";
                    vp.name = "viewport";
                    vp.content = "";
                    for (key in metas) {
                        if (-1 == content.indexOf(key)) {
                            content += "," + key + "=" + metas[key];
                        } else {
                            if (overwrite) {
                                pattern = new RegExp(key + "s*=s*[^,]+");
                                content.replace(pattern, key + "=" + metas[key]);
                            }
                        }
                    }
                    if (/^,/.test(content)) {
                        content = content.substr(1);
                    }
                    vp.content = content;
                    if (currentVP) {
                        currentVP.content = content;
                    }
                    document.head.appendChild(vp);
                },
                _adjustViewportMeta: function() {
                    if (this._isAdjustViewPort) {
                        this._setViewportMeta(cc.__BrowserGetter.meta, false);
                    }
                },
                _setScaleXYForRenderTexture: function() {
                    var scaleFactor = cc.contentScaleFactor();
                    this._scaleX = scaleFactor;
                    this._scaleY = scaleFactor;
                },
                _resetScale: function() {
                    this._scaleX = this._originalScaleX;
                    this._scaleY = this._originalScaleY;
                },
                _adjustSizeToBrowser: function() {},
                initialize: function() {
                    this._initialized = true;
                },
                adjustViewPort: function(enabled) {
                    this._isAdjustViewPort = enabled;
                },
                enableRetina: function(enabled) {
                    this._retinaEnabled = enabled ? true : false;
                },
                isRetinaEnabled: function() {
                    return this._retinaEnabled;
                },
                enableAutoFullScreen: function(enabled) {
                    this._autoFullScreen = enabled ? true : false;
                },
                isAutoFullScreenEnabled: function() {
                    return this._autoFullScreen;
                },
                end: function() {},
                isOpenGLReady: function() {
                    return null !== this._hDC && null !== this._hRC;
                },
                setFrameZoomFactor: function(zoomFactor) {
                    this._frameZoomFactor = zoomFactor;
                    this.centerWindow();
                    cc.director.setProjection(cc.director.getProjection());
                },
                swapBuffers: function() {},
                setIMEKeyboardState: function(isOpen) {},
                setContentTranslateLeftTop: function(offsetLeft, offsetTop) {
                    this._contentTranslateLeftTop = {
                        left: offsetLeft,
                        top: offsetTop
                    };
                },
                getContentTranslateLeftTop: function() {
                    return this._contentTranslateLeftTop;
                },
                setCanvasSize: function(width, height) {
                    var canvas = cc.game.canvas;
                    var container = cc.game.container;
                    canvas.width = width * this._devicePixelRatio;
                    canvas.height = height * this._devicePixelRatio;
                    canvas.style.width = width + "px";
                    canvas.style.height = height + "px";
                    container.style.width = width + "px";
                    container.style.height = height + "px";
                    this._resizeEvent();
                },
                getCanvasSize: function() {
                    return cc.size(cc.game.canvas.width, cc.game.canvas.height);
                },
                getFrameSize: function() {
                    return cc.size(this._frameSize.width, this._frameSize.height);
                },
                setFrameSize: function(width, height) {
                    this._frameSize.width = width;
                    this._frameSize.height = height;
                    cc.game.frame.style.width = width + "px";
                    cc.game.frame.style.height = height + "px";
                    this._resizeEvent();
                    cc.director.setProjection(cc.director.getProjection());
                },
                centerWindow: function() {},
                getVisibleSize: function() {
                    return cc.size(this._visibleRect.width, this._visibleRect.height);
                },
                getVisibleSizeInPixel: function() {
                    return cc.size(this._visibleRect.width * this._scaleX, this._visibleRect.height * this._scaleY);
                },
                getVisibleOrigin: function() {
                    return cc.p(this._visibleRect.x, this._visibleRect.y);
                },
                getVisibleOriginInPixel: function() {
                    return cc.p(this._visibleRect.x * this._scaleX, this._visibleRect.y * this._scaleY);
                },
                canSetContentScaleFactor: function() {
                    return true;
                },
                getResolutionPolicy: function() {
                    return this._resolutionPolicy;
                },
                setResolutionPolicy: function(resolutionPolicy) {
                    var _t = this;
                    if (resolutionPolicy instanceof cc.ResolutionPolicy) {
                        _t._resolutionPolicy = resolutionPolicy;
                    } else {
                        var _locPolicy = cc.ResolutionPolicy;
                        if (resolutionPolicy === _locPolicy.EXACT_FIT) {
                            _t._resolutionPolicy = _t._rpExactFit;
                        }
                        if (resolutionPolicy === _locPolicy.SHOW_ALL) {
                            _t._resolutionPolicy = _t._rpShowAll;
                        }
                        if (resolutionPolicy === _locPolicy.NO_BORDER) {
                            _t._resolutionPolicy = _t._rpNoBorder;
                        }
                        if (resolutionPolicy === _locPolicy.FIXED_HEIGHT) {
                            _t._resolutionPolicy = _t._rpFixedHeight;
                        }
                        if (resolutionPolicy === _locPolicy.FIXED_WIDTH) {
                            _t._resolutionPolicy = _t._rpFixedWidth;
                        }
                    }
                },
                setDesignResolutionSize: function(width, height, resolutionPolicy) {
                    if (!(width > 0 || height > 0)) {
                        cc.log(cc._LogInfos.view.setDesignResolutionSize);
                        return;
                    }
                    this.setResolutionPolicy(resolutionPolicy);
                    var policy = this._resolutionPolicy;
                    if (!policy) {
                        cc.log(cc._LogInfos.view.setDesignResolutionSize_2);
                        return;
                    }
                    policy.preApply(this);
                    if (cc.sys.isMobile) {
                        this._adjustViewportMeta();
                    }
                    this._initFrameSize();
                    this._originalDesignResolutionSize.width = this._designResolutionSize.width = width;
                    this._originalDesignResolutionSize.height = this._designResolutionSize.height = height;
                    var result = policy.apply(this, this._designResolutionSize);
                    if (result.scale && 2 === result.scale.length) {
                        this._scaleX = result.scale[0];
                        this._scaleY = result.scale[1];
                    }
                    if (result.viewport) {
                        var vp = this._viewPortRect, vb = this._visibleRect, rv = result.viewport;
                        vp.x = rv.x;
                        vp.y = rv.y;
                        vp.width = rv.width;
                        vp.height = rv.height;
                        vb.x = -vp.x / this._scaleX;
                        vb.y = -vp.y / this._scaleY;
                        vb.width = cc.game.canvas.width / this._scaleX;
                        vb.height = cc.game.canvas.height / this._scaleY;
                        cc._renderContext.setOffset && cc._renderContext.setOffset(vp.x, -vp.y);
                    }
                    var director = cc.director;
                    director._winSizeInPoints.width = this._designResolutionSize.width;
                    director._winSizeInPoints.height = this._designResolutionSize.height;
                    policy.postApply(this);
                    cc.winSize.width = director._winSizeInPoints.width;
                    cc.winSize.height = director._winSizeInPoints.height;
                    if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
                        director.setGLDefaultValues();
                    }
                    this._originalScaleX = this._scaleX;
                    this._originalScaleY = this._scaleY;
                    if (cc.DOM) {
                        cc.DOM._resetEGLViewDiv();
                    }
                    cc.visibleRect && cc.visibleRect.init(this._visibleRect);
                },
                getDesignResolutionSize: function() {
                    return cc.size(this._designResolutionSize.width, this._designResolutionSize.height);
                },
                setRealPixelResolution: function(width, height, resolutionPolicy) {
                    this._setViewportMeta({
                        width: width
                    }, true);
                    document.body.style.width = width + "px";
                    document.body.style.left = "0px";
                    document.body.style.top = "0px";
                    this.setDesignResolutionSize(width, height, resolutionPolicy);
                },
                setViewPortInPoints: function(x, y, w, h) {
                    var locFrameZoomFactor = this._frameZoomFactor, locScaleX = this._scaleX, locScaleY = this._scaleY;
                    cc._renderContext.viewport(x * locScaleX * locFrameZoomFactor + this._viewPortRect.x * locFrameZoomFactor, y * locScaleY * locFrameZoomFactor + this._viewPortRect.y * locFrameZoomFactor, w * locScaleX * locFrameZoomFactor, h * locScaleY * locFrameZoomFactor);
                },
                setScissorInPoints: function(x, y, w, h) {
                    var locFrameZoomFactor = this._frameZoomFactor, locScaleX = this._scaleX, locScaleY = this._scaleY;
                    cc._renderContext.scissor(x * locScaleX * locFrameZoomFactor + this._viewPortRect.x * locFrameZoomFactor, y * locScaleY * locFrameZoomFactor + this._viewPortRect.y * locFrameZoomFactor, w * locScaleX * locFrameZoomFactor, h * locScaleY * locFrameZoomFactor);
                },
                isScissorEnabled: function() {
                    var gl = cc._renderContext;
                    return gl.isEnabled(gl.SCISSOR_TEST);
                },
                getScissorRect: function() {
                    var gl = cc._renderContext, scaleX = this._scaleX, scaleY = this._scaleY;
                    var boxArr = gl.getParameter(gl.SCISSOR_BOX);
                    return cc.rect((boxArr[0] - this._viewPortRect.x) / scaleX, (boxArr[1] - this._viewPortRect.y) / scaleY, boxArr[2] / scaleX, boxArr[3] / scaleY);
                },
                setViewName: function(viewName) {
                    if (null != viewName && viewName.length > 0) {
                        this._viewName = viewName;
                    }
                },
                getViewName: function() {
                    return this._viewName;
                },
                getViewPortRect: function() {
                    return this._viewPortRect;
                },
                getScaleX: function() {
                    return this._scaleX;
                },
                getScaleY: function() {
                    return this._scaleY;
                },
                getDevicePixelRatio: function() {
                    return this._devicePixelRatio;
                },
                convertToLocationInView: function(tx, ty, relatedPos) {
                    return {
                        x: this._devicePixelRatio * (tx - relatedPos.left),
                        y: this._devicePixelRatio * (relatedPos.top + relatedPos.height - ty)
                    };
                },
                _convertMouseToLocationInView: function(point, relatedPos) {
                    var locViewPortRect = this._viewPortRect, _t = this;
                    point.x = (_t._devicePixelRatio * (point.x - relatedPos.left) - locViewPortRect.x) / _t._scaleX;
                    point.y = (_t._devicePixelRatio * (relatedPos.top + relatedPos.height - point.y) - locViewPortRect.y) / _t._scaleY;
                },
                _convertTouchesWithScale: function(touches) {
                    var locViewPortRect = this._viewPortRect, locScaleX = this._scaleX, locScaleY = this._scaleY, selTouch, selPoint, selPrePoint;
                    for (var i = 0; i < touches.length; i++) {
                        selTouch = touches[i];
                        selPoint = selTouch._point;
                        selPrePoint = selTouch._prevPoint;
                        selTouch._setPoint((selPoint.x - locViewPortRect.x) / locScaleX, (selPoint.y - locViewPortRect.y) / locScaleY);
                        selTouch._setPrevPoint((selPrePoint.x - locViewPortRect.x) / locScaleX, (selPrePoint.y - locViewPortRect.y) / locScaleY);
                    }
                }
            });
            cc.EGLView._getInstance = function() {
                if (!this._instance) {
                    this._instance = this._instance || new cc.EGLView();
                    this._instance.initialize();
                }
                return this._instance;
            };
            cc.ContainerStrategy = cc._Class.extend({
                preApply: function(view) {},
                apply: function(view, designedResolution) {},
                postApply: function(view) {},
                _setupContainer: function(view, w, h) {
                    var frame = cc.game.frame;
                    if (cc.view._autoFullScreen && cc.sys.isMobile && frame === document.documentElement) {
                        cc.screen.autoFullScreen(frame);
                    }
                    var locCanvasElement = cc.game.canvas, locContainer = cc.game.container;
                    locContainer.style.width = locCanvasElement.style.width = w + "px";
                    locContainer.style.height = locCanvasElement.style.height = h + "px";
                    var devicePixelRatio = view._devicePixelRatio = 1;
                    if (view.isRetinaEnabled()) {
                        devicePixelRatio = view._devicePixelRatio = window.devicePixelRatio || 1;
                    }
                    locCanvasElement.width = w * devicePixelRatio;
                    locCanvasElement.height = h * devicePixelRatio;
                    cc._renderContext.resetCache && cc._renderContext.resetCache();
                    var body = document.body, style;
                    if (body && (style = body.style)) {
                        style.paddingTop = style.paddingTop || "0px";
                        style.paddingRight = style.paddingRight || "0px";
                        style.paddingBottom = style.paddingBottom || "0px";
                        style.paddingLeft = style.paddingLeft || "0px";
                        style.borderTop = style.borderTop || "0px";
                        style.borderRight = style.borderRight || "0px";
                        style.borderBottom = style.borderBottom || "0px";
                        style.borderLeft = style.borderLeft || "0px";
                        style.marginTop = style.marginTop || "0px";
                        style.marginRight = style.marginRight || "0px";
                        style.marginBottom = style.marginBottom || "0px";
                        style.marginLeft = style.marginLeft || "0px";
                    }
                },
                _fixContainer: function() {
                    document.body.insertBefore(cc.container, document.body.firstChild);
                    var bs = document.body.style;
                    bs.width = window.innerWidth + "px";
                    bs.height = window.innerHeight + "px";
                    bs.overflow = "hidden";
                    var contStyle = cc.container.style;
                    contStyle.position = "fixed";
                    contStyle.left = contStyle.top = "0px";
                    document.body.scrollTop = 0;
                }
            });
            cc.ContentStrategy = cc._Class.extend({
                _result: {
                    scale: [ 1, 1 ],
                    viewport: null
                },
                _buildResult: function(containerW, containerH, contentW, contentH, scaleX, scaleY) {
                    Math.abs(containerW - contentW) < 2 && (contentW = containerW);
                    Math.abs(containerH - contentH) < 2 && (contentH = containerH);
                    var viewport = cc.rect(Math.round((containerW - contentW) / 2), Math.round((containerH - contentH) / 2), contentW, contentH);
                    if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {}
                    this._result.scale = [ scaleX, scaleY ];
                    this._result.viewport = viewport;
                    return this._result;
                },
                preApply: function(view) {},
                apply: function(view, designedResolution) {
                    return {
                        scale: [ 1, 1 ]
                    };
                },
                postApply: function(view) {}
            });
            !function() {
                var EqualToFrame = cc.ContainerStrategy.extend({
                    apply: function(view) {
                        this._setupContainer(view, view._frameSize.width, view._frameSize.height);
                    }
                });
                var ProportionalToFrame = cc.ContainerStrategy.extend({
                    apply: function(view, designedResolution) {
                        var frameW = view._frameSize.width, frameH = view._frameSize.height, containerStyle = cc.container.style, designW = designedResolution.width, designH = designedResolution.height, scaleX = frameW / designW, scaleY = frameH / designH, containerW, containerH;
                        scaleX < scaleY ? (containerW = frameW, containerH = designH * scaleX) : (containerW = designW * scaleY, 
                        containerH = frameH);
                        var offx = Math.round((frameW - containerW) / 2);
                        var offy = Math.round((frameH - containerH) / 2);
                        containerW = frameW - 2 * offx;
                        containerH = frameH - 2 * offy;
                        this._setupContainer(view, containerW, containerH);
                        containerStyle.marginLeft = offx + "px";
                        containerStyle.marginRight = offx + "px";
                        containerStyle.marginTop = offy + "px";
                        containerStyle.marginBottom = offy + "px";
                    }
                });
                var EqualToWindow = EqualToFrame.extend({
                    preApply: function(view) {
                        this._super(view);
                        cc.game.frame = document.documentElement;
                    },
                    apply: function(view) {
                        this._super(view);
                        this._fixContainer();
                    }
                });
                var ProportionalToWindow = ProportionalToFrame.extend({
                    preApply: function(view) {
                        this._super(view);
                        cc.game.frame = document.documentElement;
                    },
                    apply: function(view, designedResolution) {
                        this._super(view, designedResolution);
                        this._fixContainer();
                    }
                });
                var OriginalContainer = cc.ContainerStrategy.extend({
                    apply: function(view) {
                        this._setupContainer(view, cc.game.canvas.width, cc.game.canvas.height);
                    }
                });
                cc.ContainerStrategy.EQUAL_TO_FRAME = new EqualToFrame();
                cc.ContainerStrategy.PROPORTION_TO_FRAME = new ProportionalToFrame();
                cc.ContainerStrategy.ORIGINAL_CONTAINER = new OriginalContainer();
                var ExactFit = cc.ContentStrategy.extend({
                    apply: function(view, designedResolution) {
                        var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, scaleX = containerW / designedResolution.width, scaleY = containerH / designedResolution.height;
                        return this._buildResult(containerW, containerH, containerW, containerH, scaleX, scaleY);
                    }
                });
                var ShowAll = cc.ContentStrategy.extend({
                    apply: function(view, designedResolution) {
                        var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designW = designedResolution.width, designH = designedResolution.height, scaleX = containerW / designW, scaleY = containerH / designH, scale = 0, contentW, contentH;
                        scaleX < scaleY ? (scale = scaleX, contentW = containerW, contentH = designH * scale) : (scale = scaleY, 
                        contentW = designW * scale, contentH = containerH);
                        return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
                    }
                });
                var NoBorder = cc.ContentStrategy.extend({
                    apply: function(view, designedResolution) {
                        var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designW = designedResolution.width, designH = designedResolution.height, scaleX = containerW / designW, scaleY = containerH / designH, scale, contentW, contentH;
                        scaleX < scaleY ? (scale = scaleY, contentW = designW * scale, contentH = containerH) : (scale = scaleX, 
                        contentW = containerW, contentH = designH * scale);
                        return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
                    }
                });
                var FixedHeight = cc.ContentStrategy.extend({
                    apply: function(view, designedResolution) {
                        var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designH = designedResolution.height, scale = containerH / designH, contentW = containerW, contentH = containerH;
                        return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
                    },
                    postApply: function(view) {
                        cc.director._winSizeInPoints = view.getVisibleSize();
                    }
                });
                var FixedWidth = cc.ContentStrategy.extend({
                    apply: function(view, designedResolution) {
                        var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designW = designedResolution.width, scale = containerW / designW, contentW = containerW, contentH = containerH;
                        return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
                    },
                    postApply: function(view) {
                        cc.director._winSizeInPoints = view.getVisibleSize();
                    }
                });
                cc.ContentStrategy.EXACT_FIT = new ExactFit();
                cc.ContentStrategy.SHOW_ALL = new ShowAll();
                cc.ContentStrategy.NO_BORDER = new NoBorder();
                cc.ContentStrategy.FIXED_HEIGHT = new FixedHeight();
                cc.ContentStrategy.FIXED_WIDTH = new FixedWidth();
            }();
            cc.ResolutionPolicy = cc._Class.extend({
                _containerStrategy: null,
                _contentStrategy: null,
                ctor: function(containerStg, contentStg) {
                    this.setContainerStrategy(containerStg);
                    this.setContentStrategy(contentStg);
                },
                preApply: function(view) {
                    this._containerStrategy.preApply(view);
                    this._contentStrategy.preApply(view);
                },
                apply: function(view, designedResolution) {
                    this._containerStrategy.apply(view, designedResolution);
                    return this._contentStrategy.apply(view, designedResolution);
                },
                postApply: function(view) {
                    this._containerStrategy.postApply(view);
                    this._contentStrategy.postApply(view);
                },
                setContainerStrategy: function(containerStg) {
                    if (containerStg instanceof cc.ContainerStrategy) {
                        this._containerStrategy = containerStg;
                    }
                },
                setContentStrategy: function(contentStg) {
                    if (contentStg instanceof cc.ContentStrategy) {
                        this._contentStrategy = contentStg;
                    }
                }
            });
            cc.js.get(cc.ResolutionPolicy.prototype, "canvasSize", function() {
                return cc.v2(cc.game.canvas.width, cc.game.canvas.height);
            });
            cc.ResolutionPolicy.EXACT_FIT = 0;
            cc.ResolutionPolicy.NO_BORDER = 1;
            cc.ResolutionPolicy.SHOW_ALL = 2;
            cc.ResolutionPolicy.FIXED_HEIGHT = 3;
            cc.ResolutionPolicy.FIXED_WIDTH = 4;
            cc.ResolutionPolicy.UNKNOWN = 5;
            cc.screen = {
                _supportsFullScreen: false,
                _preOnFullScreenChange: null,
                _touchEvent: "",
                _fn: null,
                _fnMap: [ [ "requestFullscreen", "exitFullscreen", "fullscreenchange", "fullscreenEnabled", "fullscreenElement" ], [ "requestFullScreen", "exitFullScreen", "fullScreenchange", "fullScreenEnabled", "fullScreenElement" ], [ "webkitRequestFullScreen", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitIsFullScreen", "webkitCurrentFullScreenElement" ], [ "mozRequestFullScreen", "mozCancelFullScreen", "mozfullscreenchange", "mozFullScreen", "mozFullScreenElement" ], [ "msRequestFullscreen", "msExitFullscreen", "MSFullscreenChange", "msFullscreenEnabled", "msFullscreenElement" ] ],
                init: function() {
                    this._fn = {};
                    var i, val, map = this._fnMap, valL;
                    for (i = 0, l = map.length; i < l; i++) {
                        val = map[i];
                        if (val && val[1] in document) {
                            for (i = 0, valL = val.length; i < valL; i++) {
                                this._fn[map[0][i]] = val[i];
                            }
                            break;
                        }
                    }
                    this._supportsFullScreen = "undefined" !== typeof this._fn.requestFullscreen;
                    this._touchEvent = "ontouchstart" in window ? "touchstart" : "mousedown";
                },
                fullScreen: function() {
                    if (!this._supportsFullScreen) {
                        return false;
                    } else {
                        if (void 0 === document[this._fn.fullscreenElement] || null === document[this._fn.fullscreenElement]) {
                            return false;
                        } else {
                            return true;
                        }
                    }
                },
                requestFullScreen: function(element, onFullScreenChange) {
                    if (!this._supportsFullScreen) {
                        return;
                    }
                    element = element || document.documentElement;
                    if (onFullScreenChange) {
                        var eventName = this._fn.fullscreenchange;
                        if (this._preOnFullScreenChange) {
                            document.removeEventListener(eventName, this._preOnFullScreenChange);
                        }
                        this._preOnFullScreenChange = onFullScreenChange;
                        document.addEventListener(eventName, onFullScreenChange, false);
                    }
                    return element[this._fn.requestFullscreen]();
                },
                exitFullScreen: function() {
                    return this._supportsFullScreen ? document[this._fn.exitFullscreen]() : true;
                },
                autoFullScreen: function(element, onFullScreenChange) {
                    element = element || document.body;
                    var touchTarget = cc._canvas || element;
                    var theScreen = this;
                    function callback() {
                        theScreen.requestFullScreen(element, onFullScreenChange);
                        touchTarget.removeEventListener(theScreen._touchEvent, callback);
                    }
                    this.requestFullScreen(element, onFullScreenChange);
                    touchTarget.addEventListener(this._touchEvent, callback);
                }
            };
            cc.screen.init();
            cc.visibleRect = {
                topLeft: cc.p(0, 0),
                topRight: cc.p(0, 0),
                top: cc.p(0, 0),
                bottomLeft: cc.p(0, 0),
                bottomRight: cc.p(0, 0),
                bottom: cc.p(0, 0),
                center: cc.p(0, 0),
                left: cc.p(0, 0),
                right: cc.p(0, 0),
                width: 0,
                height: 0,
                init: function(visibleRect) {
                    var w = this.width = visibleRect.width;
                    var h = this.height = visibleRect.height;
                    var l = visibleRect.x, b = visibleRect.y, t = b + h, r = l + w;
                    this.topLeft.x = l;
                    this.topLeft.y = t;
                    this.topRight.x = r;
                    this.topRight.y = t;
                    this.top.x = l + w / 2;
                    this.top.y = t;
                    this.bottomLeft.x = l;
                    this.bottomLeft.y = b;
                    this.bottomRight.x = r;
                    this.bottomRight.y = b;
                    this.bottom.x = l + w / 2;
                    this.bottom.y = b;
                    this.center.x = l + w / 2;
                    this.center.y = b + h / 2;
                    this.left.x = l;
                    this.left.y = b + h / 2;
                    this.right.x = r;
                    this.right.y = b + h / 2;
                }
            };
            cc.vertexLineToPolygon = function(points, stroke, vertices, offset, nuPoints) {
                nuPoints += offset;
                if (nuPoints <= 1) {
                    return;
                }
                stroke *= .5;
                var idx;
                var nuPointsMinus = nuPoints - 1;
                for (var i = offset; i < nuPoints; i++) {
                    idx = 2 * i;
                    var p1 = cc.p(points[2 * i], points[2 * i + 1]);
                    var perpVector;
                    if (0 === i) {
                        perpVector = cc.pPerp(cc.pNormalize(cc.pSub(p1, cc.p(points[2 * (i + 1)], points[2 * (i + 1) + 1]))));
                    } else {
                        if (i === nuPointsMinus) {
                            perpVector = cc.pPerp(cc.pNormalize(cc.pSub(cc.p(points[2 * (i - 1)], points[2 * (i - 1) + 1]), p1)));
                        } else {
                            var p0 = cc.p(points[2 * (i - 1)], points[2 * (i - 1) + 1]);
                            var p2 = cc.p(points[2 * (i + 1)], points[2 * (i + 1) + 1]);
                            var p2p1 = cc.pNormalize(cc.pSub(p2, p1));
                            var p0p1 = cc.pNormalize(cc.pSub(p0, p1));
                            var angle = Math.acos(cc.pDot(p2p1, p0p1));
                            if (angle < cc.degreesToRadians(70)) {
                                perpVector = cc.pPerp(cc.pNormalize(cc.pMidpoint(p2p1, p0p1)));
                            } else {
                                if (angle < cc.degreesToRadians(170)) {
                                    perpVector = cc.pNormalize(cc.pMidpoint(p2p1, p0p1));
                                } else {
                                    perpVector = cc.pPerp(cc.pNormalize(cc.pSub(p2, p0)));
                                }
                            }
                        }
                    }
                    perpVector = cc.pMult(perpVector, stroke);
                    vertices[2 * idx] = p1.x + perpVector.x;
                    vertices[2 * idx + 1] = p1.y + perpVector.y;
                    vertices[2 * (idx + 1)] = p1.x - perpVector.x;
                    vertices[2 * (idx + 1) + 1] = p1.y - perpVector.y;
                }
                offset = 0 === offset ? 0 : offset - 1;
                for (i = offset; i < nuPointsMinus; i++) {
                    idx = 2 * i;
                    var idx1 = idx + 2;
                    var v1 = cc.vertex2(vertices[2 * idx], vertices[2 * idx + 1]);
                    var v2 = cc.vertex2(vertices[2 * (idx + 1)], vertices[2 * (idx + 1) + 1]);
                    var v3 = cc.vertex2(vertices[2 * idx1], vertices[2 * idx1]);
                    var v4 = cc.vertex2(vertices[2 * (idx1 + 1)], vertices[2 * (idx1 + 1) + 1]);
                    var fixVertexResult = !cc.vertexLineIntersect(v1.x, v1.y, v4.x, v4.y, v2.x, v2.y, v3.x, v3.y);
                    if (!fixVertexResult.isSuccess) {
                        if (fixVertexResult.value < 0 || fixVertexResult.value > 1) {
                            fixVertexResult.isSuccess = true;
                        }
                    }
                    if (fixVertexResult.isSuccess) {
                        vertices[2 * idx1] = v4.x;
                        vertices[2 * idx1 + 1] = v4.y;
                        vertices[2 * (idx1 + 1)] = v3.x;
                        vertices[2 * (idx1 + 1) + 1] = v3.y;
                    }
                }
            };
            cc.vertexLineIntersect = function(Ax, Ay, Bx, By, Cx, Cy, Dx, Dy) {
                var distAB, theCos, theSin, newX;
                if (Ax === Bx && Ay === By || Cx === Dx && Cy === Dy) {
                    return {
                        isSuccess: false,
                        value: 0
                    };
                }
                Bx -= Ax;
                By -= Ay;
                Cx -= Ax;
                Cy -= Ay;
                Dx -= Ax;
                Dy -= Ay;
                distAB = Math.sqrt(Bx * Bx + By * By);
                theCos = Bx / distAB;
                theSin = By / distAB;
                newX = Cx * theCos + Cy * theSin;
                Cy = Cy * theCos - Cx * theSin;
                Cx = newX;
                newX = Dx * theCos + Dy * theSin;
                Dy = Dy * theCos - Dx * theSin;
                Dx = newX;
                if (Cy === Dy) {
                    return {
                        isSuccess: false,
                        value: 0
                    };
                }
                var t = (Dx + (Cx - Dx) * Dy / (Dy - Cy)) / distAB;
                return {
                    isSuccess: true,
                    value: t
                };
            };
            cc.vertexListIsClockwise = function(verts) {
                for (var i = 0, len = verts.length; i < len; i++) {
                    var a = verts[i];
                    var b = verts[(i + 1) % len];
                    var c = verts[(i + 2) % len];
                    if (cc.pCross(cc.pSub(b, a), cc.pSub(c, b)) > 0) {
                        return false;
                    }
                }
                return true;
            };
            cc.CGAffineToGL = function(trans, mat) {
                mat[2] = mat[3] = mat[6] = mat[7] = mat[8] = mat[9] = mat[11] = mat[14] = 0;
                mat[10] = mat[15] = 1;
                mat[0] = trans.a;
                mat[4] = trans.c;
                mat[12] = trans.tx;
                mat[1] = trans.b;
                mat[5] = trans.d;
                mat[13] = trans.ty;
            };
            cc.GLToCGAffine = function(mat, trans) {
                trans.a = mat[0];
                trans.c = mat[4];
                trans.tx = mat[12];
                trans.b = mat[1];
                trans.d = mat[5];
                trans.ty = mat[13];
            };
            cc.Touch = cc._Class.extend({
                _point: null,
                _prevPoint: null,
                _id: 0,
                _startPointCaptured: false,
                _startPoint: null,
                ctor: function(x, y, id) {
                    this.setTouchInfo(id, x, y);
                },
                getLocation: function() {
                    return {
                        x: this._point.x,
                        y: this._point.y
                    };
                },
                getLocationX: function() {
                    return this._point.x;
                },
                getLocationY: function() {
                    return this._point.y;
                },
                getPreviousLocation: function() {
                    return {
                        x: this._prevPoint.x,
                        y: this._prevPoint.y
                    };
                },
                getStartLocation: function() {
                    return {
                        x: this._startPoint.x,
                        y: this._startPoint.y
                    };
                },
                getDelta: function() {
                    return cc.pSub(this._point, this._prevPoint);
                },
                getLocationInView: function() {
                    return {
                        x: this._point.x,
                        y: this._point.y
                    };
                },
                getPreviousLocationInView: function() {
                    return {
                        x: this._prevPoint.x,
                        y: this._prevPoint.y
                    };
                },
                getStartLocationInView: function() {
                    return {
                        x: this._startPoint.x,
                        y: this._startPoint.y
                    };
                },
                getID: function() {
                    return this._id;
                },
                getId: function() {
                    cc.log("getId is deprecated. Please use getID instead.");
                    return this._id;
                },
                setTouchInfo: function(id, x, y) {
                    this._prevPoint = this._point;
                    this._point = cc.p(x || 0, y || 0);
                    this._id = id;
                    if (!this._startPointCaptured) {
                        this._startPoint = cc.p(this._point);
                        this._startPointCaptured = true;
                    }
                },
                _setPoint: function(x, y) {
                    if (void 0 === y) {
                        this._point.x = x.x;
                        this._point.y = x.y;
                    } else {
                        this._point.x = x;
                        this._point.y = y;
                    }
                },
                _setPrevPoint: function(x, y) {
                    if (void 0 === y) {
                        this._prevPoint = cc.p(x.x, x.y);
                    } else {
                        this._prevPoint = cc.p(x || 0, y || 0);
                    }
                }
            });
            var JS = cc.js;
            var Event = cc.Event;
            cc.Event.TOUCH = "touch";
            cc.Event.MOUSE = "mouse";
            cc.Event.FOCUS = "focus";
            cc.Event.KEYBOARD = "keyboard";
            cc.Event.ACCELERATION = "acceleration";
            var EventMouse = function(eventType, bubbles) {
                cc.Event.call(this, cc.Event.MOUSE, bubbles);
                this._eventType = eventType;
                this._button = 0;
                this._x = 0;
                this._y = 0;
                this._prevX = 0;
                this._prevY = 0;
                this._scrollX = 0;
                this._scrollY = 0;
            };
            JS.extend(EventMouse, cc.Event);
            JS.mixin(EventMouse.prototype, {
                setScrollData: function(scrollX, scrollY) {
                    this._scrollX = scrollX;
                    this._scrollY = scrollY;
                },
                getScrollX: function() {
                    return this._scrollX;
                },
                getScrollY: function() {
                    return this._scrollY;
                },
                setLocation: function(x, y) {
                    this._x = x;
                    this._y = y;
                },
                getLocation: function() {
                    return {
                        x: this._x,
                        y: this._y
                    };
                },
                getLocationInView: function() {
                    return {
                        x: this._x,
                        y: cc.view._designResolutionSize.height - this._y
                    };
                },
                _setPrevCursor: function(x, y) {
                    this._prevX = x;
                    this._prevY = y;
                },
                getDelta: function() {
                    return {
                        x: this._x - this._prevX,
                        y: this._y - this._prevY
                    };
                },
                getDeltaX: function() {
                    return this._x - this._prevX;
                },
                getDeltaY: function() {
                    return this._y - this._prevY;
                },
                setButton: function(button) {
                    this._button = button;
                },
                getButton: function() {
                    return this._button;
                },
                getLocationX: function() {
                    return this._x;
                },
                getLocationY: function() {
                    return this._y;
                }
            });
            EventMouse.NONE = 0;
            EventMouse.DOWN = 1;
            EventMouse.UP = 2;
            EventMouse.MOVE = 3;
            EventMouse.SCROLL = 4;
            EventMouse.BUTTON_LEFT = 0;
            EventMouse.BUTTON_RIGHT = 2;
            EventMouse.BUTTON_MIDDLE = 1;
            EventMouse.BUTTON_4 = 3;
            EventMouse.BUTTON_5 = 4;
            EventMouse.BUTTON_6 = 5;
            EventMouse.BUTTON_7 = 6;
            EventMouse.BUTTON_8 = 7;
            EventTouch = function(touchArr, bubbles) {
                cc.Event.call(this, cc.Event.TOUCH, bubbles);
                this._eventCode = 0;
                this._touches = touchArr || [];
                this.currentTouch = null;
            };
            JS.extend(EventTouch, cc.Event);
            JS.mixin(EventTouch.prototype, {
                getEventCode: function() {
                    return this._eventCode;
                },
                getTouches: function() {
                    return this._touches;
                },
                _setEventCode: function(eventCode) {
                    this._eventCode = eventCode;
                },
                _setTouches: function(touches) {
                    this._touches = touches;
                }
            });
            EventTouch.MAX_TOUCHES = 5;
            EventTouch.BEGAN = 0;
            EventTouch.MOVED = 1;
            EventTouch.ENDED = 2;
            EventTouch.CANCELED = 3;
            EventFocus = function(widgetGetFocus, widgetLoseFocus, bubbles) {
                cc.Event.call(this, cc.Event.FOCUS, bubbles);
                this._widgetGetFocus = widgetGetFocus;
                this._widgetLoseFocus = widgetLoseFocus;
            };
            JS.extend(EventFocus, cc.Event);
            EventAcceleration = function(acc, bubbles) {
                cc.Event.call(this, Event.ACCELERATION, bubbles);
                this._acc = acc;
            };
            JS.extend(EventAcceleration, cc.Event);
            EventKeyboard = function(keyCode, isPressed, bubbles) {
                cc.Event.call(this, Event.KEYBOARD, bubbles);
                this._keyCode = keyCode;
                this._isPressed = isPressed;
            };
            JS.extend(EventKeyboard, cc.Event);
            cc.Event.EventMouse = EventMouse;
            cc.Event.EventTouch = EventTouch;
            cc.Event.EventFocus = EventFocus;
            cc.Event.EventAcceleration = EventAcceleration;
            cc.Event.EventKeyboard = EventKeyboard;
            module.exports = Event;
            cc.EventListener = cc._Class.extend({
                _onEvent: null,
                _type: 0,
                _listenerID: null,
                _registered: false,
                _fixedPriority: 0,
                _node: null,
                _target: null,
                _paused: true,
                _isEnabled: true,
                ctor: function(type, listenerID, callback) {
                    this._onEvent = callback;
                    this._type = type || 0;
                    this._listenerID = listenerID || "";
                },
                _setPaused: function(paused) {
                    this._paused = paused;
                },
                _isPaused: function() {
                    return this._paused;
                },
                _setRegistered: function(registered) {
                    this._registered = registered;
                },
                _isRegistered: function() {
                    return this._registered;
                },
                _getType: function() {
                    return this._type;
                },
                _getListenerID: function() {
                    return this._listenerID;
                },
                _setFixedPriority: function(fixedPriority) {
                    this._fixedPriority = fixedPriority;
                },
                _getFixedPriority: function() {
                    return this._fixedPriority;
                },
                _setSceneGraphPriority: function(node) {
                    this._target = node;
                    this._node = node;
                },
                _getSceneGraphPriority: function() {
                    return this._node;
                },
                checkAvailable: function() {
                    return null !== this._onEvent;
                },
                clone: function() {
                    return null;
                },
                setEnabled: function(enabled) {
                    this._isEnabled = enabled;
                },
                isEnabled: function() {
                    return this._isEnabled;
                },
                retain: function() {},
                release: function() {}
            });
            cc.EventListener.UNKNOWN = 0;
            cc.EventListener.TOUCH_ONE_BY_ONE = 1;
            cc.EventListener.TOUCH_ALL_AT_ONCE = 2;
            cc.EventListener.KEYBOARD = 3;
            cc.EventListener.MOUSE = 4;
            cc.EventListener.ACCELERATION = 6;
            cc.EventListener.FOCUS = 7;
            cc.EventListener.CUSTOM = 8;
            cc._EventListenerCustom = cc.EventListener.extend({
                _onCustomEvent: null,
                ctor: function(listenerId, callback) {
                    this._onCustomEvent = callback;
                    var selfPointer = this;
                    var listener = function(event) {
                        if (null !== selfPointer._onCustomEvent) {
                            selfPointer._onCustomEvent(event);
                        }
                    };
                    cc.EventListener.prototype.ctor.call(this, cc.EventListener.CUSTOM, listenerId, listener);
                },
                checkAvailable: function() {
                    return cc.EventListener.prototype.checkAvailable.call(this) && null !== this._onCustomEvent;
                },
                clone: function() {
                    return new cc._EventListenerCustom(this._listenerID, this._onCustomEvent);
                }
            });
            cc._EventListenerCustom.create = function(eventName, callback) {
                return new cc._EventListenerCustom(eventName, callback);
            };
            cc._EventListenerMouse = cc.EventListener.extend({
                onMouseDown: null,
                onMouseUp: null,
                onMouseMove: null,
                onMouseScroll: null,
                ctor: function() {
                    var selfPointer = this;
                    var listener = function(event) {
                        var eventType = cc.Event.EventMouse;
                        switch (event._eventType) {
                          case eventType.DOWN:
                            if (selfPointer.onMouseDown) {
                                selfPointer.onMouseDown(event);
                            }
                            break;

                          case eventType.UP:
                            if (selfPointer.onMouseUp) {
                                selfPointer.onMouseUp(event);
                            }
                            break;

                          case eventType.MOVE:
                            if (selfPointer.onMouseMove) {
                                selfPointer.onMouseMove(event);
                            }
                            break;

                          case eventType.SCROLL:
                            if (selfPointer.onMouseScroll) {
                                selfPointer.onMouseScroll(event);
                            }
                        }
                    };
                    cc.EventListener.prototype.ctor.call(this, cc.EventListener.MOUSE, cc._EventListenerMouse.LISTENER_ID, listener);
                },
                clone: function() {
                    var eventListener = new cc._EventListenerMouse();
                    eventListener.onMouseDown = this.onMouseDown;
                    eventListener.onMouseUp = this.onMouseUp;
                    eventListener.onMouseMove = this.onMouseMove;
                    eventListener.onMouseScroll = this.onMouseScroll;
                    return eventListener;
                },
                checkAvailable: function() {
                    return true;
                }
            });
            cc._EventListenerMouse.LISTENER_ID = "__cc_mouse";
            cc._EventListenerMouse.create = function() {
                return new cc._EventListenerMouse();
            };
            cc._EventListenerTouchOneByOne = cc.EventListener.extend({
                _claimedTouches: null,
                swallowTouches: false,
                onTouchBegan: null,
                onTouchMoved: null,
                onTouchEnded: null,
                onTouchCancelled: null,
                ctor: function() {
                    cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ONE_BY_ONE, cc._EventListenerTouchOneByOne.LISTENER_ID, null);
                    this._claimedTouches = [];
                },
                setSwallowTouches: function(needSwallow) {
                    this.swallowTouches = needSwallow;
                },
                isSwallowTouches: function() {
                    return this.swallowTouches;
                },
                clone: function() {
                    var eventListener = new cc._EventListenerTouchOneByOne();
                    eventListener.onTouchBegan = this.onTouchBegan;
                    eventListener.onTouchMoved = this.onTouchMoved;
                    eventListener.onTouchEnded = this.onTouchEnded;
                    eventListener.onTouchCancelled = this.onTouchCancelled;
                    eventListener.swallowTouches = this.swallowTouches;
                    return eventListener;
                },
                checkAvailable: function() {
                    if (!this.onTouchBegan) {
                        cc.log(cc._LogInfos._checkEventListenerAvailable.touchOneByOne);
                        return false;
                    }
                    return true;
                }
            });
            cc._EventListenerTouchOneByOne.LISTENER_ID = "__cc_touch_one_by_one";
            cc._EventListenerTouchOneByOne.create = function() {
                return new cc._EventListenerTouchOneByOne();
            };
            cc._EventListenerTouchAllAtOnce = cc.EventListener.extend({
                onTouchesBegan: null,
                onTouchesMoved: null,
                onTouchesEnded: null,
                onTouchesCancelled: null,
                ctor: function() {
                    cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ALL_AT_ONCE, cc._EventListenerTouchAllAtOnce.LISTENER_ID, null);
                },
                clone: function() {
                    var eventListener = new cc._EventListenerTouchAllAtOnce();
                    eventListener.onTouchesBegan = this.onTouchesBegan;
                    eventListener.onTouchesMoved = this.onTouchesMoved;
                    eventListener.onTouchesEnded = this.onTouchesEnded;
                    eventListener.onTouchesCancelled = this.onTouchesCancelled;
                    return eventListener;
                },
                checkAvailable: function() {
                    if (null === this.onTouchesBegan && null === this.onTouchesMoved && null === this.onTouchesEnded && null === this.onTouchesCancelled) {
                        cc.log(cc._LogInfos._checkEventListenerAvailable.touchAllAtOnce);
                        return false;
                    }
                    return true;
                }
            });
            cc._EventListenerTouchAllAtOnce.LISTENER_ID = "__cc_touch_all_at_once";
            cc._EventListenerTouchAllAtOnce.create = function() {
                return new cc._EventListenerTouchAllAtOnce();
            };
            cc.EventListener.create = function(argObj) {
                cc.assert(argObj && argObj.event, cc._LogInfos.EventListener.create);
                var listenerType = argObj.event;
                delete argObj.event;
                var listener = null;
                if (listenerType === cc.EventListener.TOUCH_ONE_BY_ONE) {
                    listener = new cc._EventListenerTouchOneByOne();
                } else {
                    if (listenerType === cc.EventListener.TOUCH_ALL_AT_ONCE) {
                        listener = new cc._EventListenerTouchAllAtOnce();
                    } else {
                        if (listenerType === cc.EventListener.MOUSE) {
                            listener = new cc._EventListenerMouse();
                        } else {
                            if (listenerType === cc.EventListener.CUSTOM) {
                                listener = new cc._EventListenerCustom(argObj.eventName, argObj.callback);
                                delete argObj.eventName;
                                delete argObj.callback;
                            } else {
                                if (listenerType === cc.EventListener.KEYBOARD) {
                                    listener = new cc._EventListenerKeyboard();
                                } else {
                                    if (listenerType === cc.EventListener.ACCELERATION) {
                                        listener = new cc._EventListenerAcceleration(argObj.callback);
                                        delete argObj.callback;
                                    } else {
                                        if (listenerType === cc.EventListener.FOCUS) {
                                            listener = new cc._EventListenerFocus();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                for (var key in argObj) {
                    listener[key] = argObj[key];
                }
                return listener;
            };
            cc._EventListenerFocus = cc.EventListener.extend({
                clone: function() {
                    var listener = new cc._EventListenerFocus();
                    listener.onFocusChanged = this.onFocusChanged;
                    return listener;
                },
                checkAvailable: function() {
                    if (!this.onFocusChanged) {
                        cc.log("Invalid EventListenerFocus!");
                        return false;
                    }
                    return true;
                },
                onFocusChanged: null,
                ctor: function() {
                    var listener = function(event) {
                        if (this.onFocusChanged) {
                            this.onFocusChanged(event._widgetLoseFocus, event._widgetGetFocus);
                        }
                    };
                    cc.EventListener.prototype.ctor.call(this, cc.EventListener.FOCUS, cc._EventListenerFocus.LISTENER_ID, listener);
                }
            });
            cc._EventListenerFocus.LISTENER_ID = "__cc_focus_event";
            cc._EventListenerAcceleration = cc.EventListener.extend({
                _onAccelerationEvent: null,
                ctor: function(callback) {
                    this._onAccelerationEvent = callback;
                    var selfPointer = this;
                    var listener = function(event) {
                        selfPointer._onAccelerationEvent(event._acc, event);
                    };
                    cc.EventListener.prototype.ctor.call(this, cc.EventListener.ACCELERATION, cc._EventListenerAcceleration.LISTENER_ID, listener);
                },
                checkAvailable: function() {
                    cc.assert(this._onAccelerationEvent, cc._LogInfos._checkEventListenerAvailable.acceleration);
                    return true;
                },
                clone: function() {
                    return new cc._EventListenerAcceleration(this._onAccelerationEvent);
                }
            });
            cc._EventListenerAcceleration.LISTENER_ID = "__cc_acceleration";
            cc._EventListenerAcceleration.create = function(callback) {
                return new cc._EventListenerAcceleration(callback);
            };
            cc._EventListenerKeyboard = cc.EventListener.extend({
                onKeyPressed: null,
                onKeyReleased: null,
                ctor: function() {
                    var selfPointer = this;
                    var listener = function(event) {
                        if (event._isPressed) {
                            if (selfPointer.onKeyPressed) {
                                selfPointer.onKeyPressed(event._keyCode, event);
                            }
                        } else {
                            if (selfPointer.onKeyReleased) {
                                selfPointer.onKeyReleased(event._keyCode, event);
                            }
                        }
                    };
                    cc.EventListener.prototype.ctor.call(this, cc.EventListener.KEYBOARD, cc._EventListenerKeyboard.LISTENER_ID, listener);
                },
                clone: function() {
                    var eventListener = new cc._EventListenerKeyboard();
                    eventListener.onKeyPressed = this.onKeyPressed;
                    eventListener.onKeyReleased = this.onKeyReleased;
                    return eventListener;
                },
                checkAvailable: function() {
                    if (null === this.onKeyPressed && null === this.onKeyReleased) {
                        cc.log(cc._LogInfos._checkEventListenerAvailable.keyboard);
                        return false;
                    }
                    return true;
                }
            });
            cc._EventListenerKeyboard.LISTENER_ID = "__cc_keyboard";
            cc._EventListenerKeyboard.create = function() {
                return new cc._EventListenerKeyboard();
            };
            cc._EventListenerVector = cc._Class.extend({
                _fixedListeners: null,
                _sceneGraphListeners: null,
                gt0Index: 0,
                ctor: function() {
                    this._fixedListeners = [];
                    this._sceneGraphListeners = [];
                },
                size: function() {
                    return this._fixedListeners.length + this._sceneGraphListeners.length;
                },
                empty: function() {
                    return 0 === this._fixedListeners.length && 0 === this._sceneGraphListeners.length;
                },
                push: function(listener) {
                    if (0 === listener._getFixedPriority()) {
                        this._sceneGraphListeners.push(listener);
                    } else {
                        this._fixedListeners.push(listener);
                    }
                },
                clearSceneGraphListeners: function() {
                    this._sceneGraphListeners.length = 0;
                },
                clearFixedListeners: function() {
                    this._fixedListeners.length = 0;
                },
                clear: function() {
                    this._sceneGraphListeners.length = 0;
                    this._fixedListeners.length = 0;
                },
                getFixedPriorityListeners: function() {
                    return this._fixedListeners;
                },
                getSceneGraphPriorityListeners: function() {
                    return this._sceneGraphListeners;
                }
            });
            cc.__getListenerID = function(event) {
                var eventType = cc.Event, type = event.getType();
                if (type === eventType.ACCELERATION) {
                    return cc._EventListenerAcceleration.LISTENER_ID;
                }
                if (type === eventType.KEYBOARD) {
                    return cc._EventListenerKeyboard.LISTENER_ID;
                }
                if (type === eventType.MOUSE) {
                    return cc._EventListenerMouse.LISTENER_ID;
                }
                if (type === eventType.FOCUS) {
                    return cc._EventListenerFocus.LISTENER_ID;
                }
                if (type === eventType.TOUCH) {
                    cc.log(cc._LogInfos._getListenerID);
                }
                return type;
            };
            cc.eventManager = {
                DIRTY_NONE: 0,
                DIRTY_FIXED_PRIORITY: 1,
                DIRTY_SCENE_GRAPH_PRIORITY: 2,
                DIRTY_ALL: 3,
                _listenersMap: {},
                _priorityDirtyFlagMap: {},
                _nodeListenersMap: {},
                _nodePriorityMap: {},
                _globalZOrderNodeMap: {},
                _toAddedListeners: [],
                _dirtyNodes: [],
                _inDispatch: 0,
                _isEnabled: false,
                _nodePriorityIndex: 0,
                _internalCustomListenerIDs: [ cc.game.EVENT_HIDE, cc.game.EVENT_SHOW ],
                _setDirtyForNode: function(node) {
                    if (void 0 !== this._nodeListenersMap[node.__instanceId]) {
                        this._dirtyNodes.push(node);
                    }
                    if (node.getChildren) {
                        var _children = node.getChildren();
                        for (var i = 0, len = _children.length; i < len; i++) {
                            this._setDirtyForNode(_children[i]);
                        }
                    }
                },
                pauseTarget: function(node, recursive) {
                    var listeners = this._nodeListenersMap[node.__instanceId], i, len;
                    if (listeners) {
                        for (i = 0, len = listeners.length; i < len; i++) {
                            listeners[i]._setPaused(true);
                        }
                    }
                    if (true === recursive) {
                        var locChildren = node.getChildren();
                        for (i = 0, len = locChildren.length; i < len; i++) {
                            this.pauseTarget(locChildren[i], true);
                        }
                    }
                },
                resumeTarget: function(node, recursive) {
                    var listeners = this._nodeListenersMap[node.__instanceId], i, len;
                    if (listeners) {
                        for (i = 0, len = listeners.length; i < len; i++) {
                            listeners[i]._setPaused(false);
                        }
                    }
                    this._setDirtyForNode(node);
                    if (true === recursive && node.getChildren) {
                        var locChildren = node.getChildren();
                        for (i = 0, len = locChildren.length; i < len; i++) {
                            this.resumeTarget(locChildren[i], true);
                        }
                    }
                },
                _addListener: function(listener) {
                    if (0 === this._inDispatch) {
                        this._forceAddEventListener(listener);
                    } else {
                        this._toAddedListeners.push(listener);
                    }
                },
                _forceAddEventListener: function(listener) {
                    var listenerID = listener._getListenerID();
                    var listeners = this._listenersMap[listenerID];
                    if (!listeners) {
                        listeners = new cc._EventListenerVector();
                        this._listenersMap[listenerID] = listeners;
                    }
                    listeners.push(listener);
                    if (0 === listener._getFixedPriority()) {
                        this._setDirty(listenerID, this.DIRTY_SCENE_GRAPH_PRIORITY);
                        var node = listener._getSceneGraphPriority();
                        if (null === node) {
                            cc.log(cc._LogInfos.EventManager._forceAddEventListener);
                        }
                        this._associateNodeAndEventListener(node, listener);
                        if (node.isRunning()) {
                            this.resumeTarget(node);
                        }
                    } else {
                        this._setDirty(listenerID, this.DIRTY_FIXED_PRIORITY);
                    }
                },
                _getListeners: function(listenerID) {
                    return this._listenersMap[listenerID];
                },
                _updateDirtyFlagForSceneGraph: function() {
                    if (0 === this._dirtyNodes.length) {
                        return;
                    }
                    var locDirtyNodes = this._dirtyNodes, selListeners, selListener, locNodeListenersMap = this._nodeListenersMap;
                    for (var i = 0, len = locDirtyNodes.length; i < len; i++) {
                        selListeners = locNodeListenersMap[locDirtyNodes[i].__instanceId];
                        if (selListeners) {
                            for (var j = 0, listenersLen = selListeners.length; j < listenersLen; j++) {
                                selListener = selListeners[j];
                                if (selListener) {
                                    this._setDirty(selListener._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY);
                                }
                            }
                        }
                    }
                    this._dirtyNodes.length = 0;
                },
                _removeAllListenersInVector: function(listenerVector) {
                    if (!listenerVector) {
                        return;
                    }
                    var selListener;
                    for (var i = 0; i < listenerVector.length; ) {
                        selListener = listenerVector[i];
                        selListener._setRegistered(false);
                        if (null != selListener._getSceneGraphPriority()) {
                            this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener);
                            selListener._setSceneGraphPriority(null);
                        }
                        if (0 === this._inDispatch) {
                            cc.js.array.remove(listenerVector, selListener);
                        } else {
                            ++i;
                        }
                    }
                },
                _removeListenersForListenerID: function(listenerID) {
                    var listeners = this._listenersMap[listenerID], i;
                    if (listeners) {
                        var fixedPriorityListeners = listeners.getFixedPriorityListeners();
                        var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
                        this._removeAllListenersInVector(sceneGraphPriorityListeners);
                        this._removeAllListenersInVector(fixedPriorityListeners);
                        delete this._priorityDirtyFlagMap[listenerID];
                        if (!this._inDispatch) {
                            listeners.clear();
                            delete this._listenersMap[listenerID];
                        }
                    }
                    var locToAddedListeners = this._toAddedListeners, listener;
                    for (i = 0; i < locToAddedListeners.length; ) {
                        listener = locToAddedListeners[i];
                        if (listener && listener._getListenerID() === listenerID) {
                            cc.js.array.remove(locToAddedListeners, listener);
                        } else {
                            ++i;
                        }
                    }
                },
                _sortEventListeners: function(listenerID) {
                    var dirtyFlag = this.DIRTY_NONE, locFlagMap = this._priorityDirtyFlagMap;
                    if (locFlagMap[listenerID]) {
                        dirtyFlag = locFlagMap[listenerID];
                    }
                    if (dirtyFlag !== this.DIRTY_NONE) {
                        locFlagMap[listenerID] = this.DIRTY_NONE;
                        if (dirtyFlag & this.DIRTY_FIXED_PRIORITY) {
                            this._sortListenersOfFixedPriority(listenerID);
                        }
                        if (dirtyFlag & this.DIRTY_SCENE_GRAPH_PRIORITY) {
                            var rootEntity = cc.director.getScene();
                            if (rootEntity) {
                                this._sortListenersOfSceneGraphPriority(listenerID, rootEntity);
                            }
                        }
                    }
                },
                _sortListenersOfSceneGraphPriority: function(listenerID, rootNode) {
                    var listeners = this._getListeners(listenerID);
                    if (!listeners) {
                        return;
                    }
                    var sceneGraphListener = listeners.getSceneGraphPriorityListeners();
                    if (!sceneGraphListener || 0 === sceneGraphListener.length) {
                        return;
                    }
                    this._nodePriorityIndex = 0;
                    this._nodePriorityMap = {};
                    this._visitTarget(rootNode, true);
                    listeners.getSceneGraphPriorityListeners().sort(this._sortEventListenersOfSceneGraphPriorityDes);
                },
                _sortEventListenersOfSceneGraphPriorityDes: function(l1, l2) {
                    var locNodePriorityMap = cc.eventManager._nodePriorityMap, node1 = l1._getSceneGraphPriority(), node2 = l2._getSceneGraphPriority();
                    if (!l2 || !node2 || !locNodePriorityMap[node2.__instanceId]) {
                        return -1;
                    } else {
                        if (!l1 || !node1 || !locNodePriorityMap[node1.__instanceId]) {
                            return 1;
                        }
                    }
                    return locNodePriorityMap[l2._getSceneGraphPriority().__instanceId] - locNodePriorityMap[l1._getSceneGraphPriority().__instanceId];
                },
                _sortListenersOfFixedPriority: function(listenerID) {
                    var listeners = this._listenersMap[listenerID];
                    if (!listeners) {
                        return;
                    }
                    var fixedListeners = listeners.getFixedPriorityListeners();
                    if (!fixedListeners || 0 === fixedListeners.length) {
                        return;
                    }
                    fixedListeners.sort(this._sortListenersOfFixedPriorityAsc);
                    var index = 0;
                    for (var len = fixedListeners.length; index < len; ) {
                        if (fixedListeners[index]._getFixedPriority() >= 0) {
                            break;
                        }
                        ++index;
                    }
                    listeners.gt0Index = index;
                },
                _sortListenersOfFixedPriorityAsc: function(l1, l2) {
                    return l1._getFixedPriority() - l2._getFixedPriority();
                },
                _onUpdateListeners: function(listenerID) {
                    var listeners = this._listenersMap[listenerID];
                    if (!listeners) {
                        return;
                    }
                    var fixedPriorityListeners = listeners.getFixedPriorityListeners();
                    var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
                    var i, selListener;
                    if (sceneGraphPriorityListeners) {
                        for (i = 0; i < sceneGraphPriorityListeners.length; ) {
                            selListener = sceneGraphPriorityListeners[i];
                            if (!selListener._isRegistered()) {
                                cc.js.array.remove(sceneGraphPriorityListeners, selListener);
                            } else {
                                ++i;
                            }
                        }
                    }
                    if (fixedPriorityListeners) {
                        for (i = 0; i < fixedPriorityListeners.length; ) {
                            selListener = fixedPriorityListeners[i];
                            if (!selListener._isRegistered()) {
                                cc.js.array.remove(fixedPriorityListeners, selListener);
                            } else {
                                ++i;
                            }
                        }
                    }
                    if (sceneGraphPriorityListeners && 0 === sceneGraphPriorityListeners.length) {
                        listeners.clearSceneGraphListeners();
                    }
                    if (fixedPriorityListeners && 0 === fixedPriorityListeners.length) {
                        listeners.clearFixedListeners();
                    }
                },
                _updateListeners: function(event) {
                    var locInDispatch = this._inDispatch;
                    cc.assert(locInDispatch > 0, cc._LogInfos.EventManager._updateListeners);
                    if (locInDispatch > 1) {
                        return;
                    }
                    if (event.getType() === cc.Event.TOUCH) {
                        this._onUpdateListeners(cc._EventListenerTouchOneByOne.LISTENER_ID);
                        this._onUpdateListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
                    } else {
                        this._onUpdateListeners(cc.__getListenerID(event));
                    }
                    cc.assert(1 === locInDispatch, cc._LogInfos.EventManager._updateListeners_2);
                    var locListenersMap = this._listenersMap, locPriorityDirtyFlagMap = this._priorityDirtyFlagMap;
                    for (var selKey in locListenersMap) {
                        if (locListenersMap[selKey].empty()) {
                            delete locPriorityDirtyFlagMap[selKey];
                            delete locListenersMap[selKey];
                        }
                    }
                    var locToAddedListeners = this._toAddedListeners;
                    if (0 !== locToAddedListeners.length) {
                        for (var i = 0, len = locToAddedListeners.length; i < len; i++) {
                            this._forceAddEventListener(locToAddedListeners[i]);
                        }
                        this._toAddedListeners.length = 0;
                    }
                },
                _onTouchEventCallback: function(listener, argsObj) {
                    if (!listener._isRegistered) {
                        return false;
                    }
                    var event = argsObj.event, selTouch = event.currentTouch;
                    event.currentTarget = listener._node;
                    var isClaimed = false, removedIdx;
                    var getCode = event.getEventCode(), EventTouch = cc.Event.EventTouch;
                    if (getCode === EventTouch.BEGAN) {
                        if (listener.onTouchBegan) {
                            isClaimed = listener.onTouchBegan(selTouch, event);
                            if (isClaimed && listener._registered) {
                                listener._claimedTouches.push(selTouch);
                            }
                        }
                    } else {
                        if (listener._claimedTouches.length > 0 && -1 !== (removedIdx = listener._claimedTouches.indexOf(selTouch))) {
                            isClaimed = true;
                            if (getCode === EventTouch.MOVED && listener.onTouchMoved) {
                                listener.onTouchMoved(selTouch, event);
                            } else {
                                if (getCode === EventTouch.ENDED) {
                                    if (listener.onTouchEnded) {
                                        listener.onTouchEnded(selTouch, event);
                                    }
                                    if (listener._registered) {
                                        listener._claimedTouches.splice(removedIdx, 1);
                                    }
                                } else {
                                    if (getCode === EventTouch.CANCELLED) {
                                        if (listener.onTouchCancelled) {
                                            listener.onTouchCancelled(selTouch, event);
                                        }
                                        if (listener._registered) {
                                            listener._claimedTouches.splice(removedIdx, 1);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (event.isStopped()) {
                        cc.eventManager._updateListeners(event);
                        return true;
                    }
                    if (isClaimed && listener._registered && listener.swallowTouches) {
                        if (argsObj.needsMutableSet) {
                            argsObj.touches.splice(selTouch, 1);
                        }
                        return true;
                    }
                    return false;
                },
                _dispatchTouchEvent: function(event) {
                    this._sortEventListeners(cc._EventListenerTouchOneByOne.LISTENER_ID);
                    this._sortEventListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
                    var oneByOneListeners = this._getListeners(cc._EventListenerTouchOneByOne.LISTENER_ID);
                    var allAtOnceListeners = this._getListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
                    if (null === oneByOneListeners && null === allAtOnceListeners) {
                        return;
                    }
                    var originalTouches = event.getTouches(), mutableTouches = cc.js.array.copy(originalTouches);
                    var oneByOneArgsObj = {
                        event: event,
                        needsMutableSet: oneByOneListeners && allAtOnceListeners,
                        touches: mutableTouches,
                        selTouch: null
                    };
                    if (oneByOneListeners) {
                        for (var i = 0; i < originalTouches.length; i++) {
                            event.currentTouch = originalTouches[i];
                            this._dispatchEventToListeners(oneByOneListeners, this._onTouchEventCallback, oneByOneArgsObj);
                            if (event.isStopped()) {
                                return;
                            }
                        }
                    }
                    if (allAtOnceListeners && mutableTouches.length > 0) {
                        this._dispatchEventToListeners(allAtOnceListeners, this._onTouchesEventCallback, {
                            event: event,
                            touches: mutableTouches
                        });
                        if (event.isStopped()) {
                            return;
                        }
                    }
                    this._updateListeners(event);
                },
                _onTouchesEventCallback: function(listener, callbackParams) {
                    if (!listener._registered) {
                        return false;
                    }
                    var EventTouch = cc.Event.EventTouch, event = callbackParams.event, touches = callbackParams.touches, getCode = event.getEventCode();
                    event.currentTarget = listener._node;
                    if (getCode === EventTouch.BEGAN && listener.onTouchesBegan) {
                        listener.onTouchesBegan(touches, event);
                    } else {
                        if (getCode === EventTouch.MOVED && listener.onTouchesMoved) {
                            listener.onTouchesMoved(touches, event);
                        } else {
                            if (getCode === EventTouch.ENDED && listener.onTouchesEnded) {
                                listener.onTouchesEnded(touches, event);
                            } else {
                                if (getCode === EventTouch.CANCELLED && listener.onTouchesCancelled) {
                                    listener.onTouchesCancelled(touches, event);
                                }
                            }
                        }
                    }
                    if (event.isStopped()) {
                        cc.eventManager._updateListeners(event);
                        return true;
                    }
                    return false;
                },
                _associateNodeAndEventListener: function(node, listener) {
                    var listeners = this._nodeListenersMap[node.__instanceId];
                    if (!listeners) {
                        listeners = [];
                        this._nodeListenersMap[node.__instanceId] = listeners;
                    }
                    listeners.push(listener);
                },
                _dissociateNodeAndEventListener: function(node, listener) {
                    var listeners = this._nodeListenersMap[node.__instanceId];
                    if (listeners) {
                        cc.js.array.remove(listeners, listener);
                        if (0 === listeners.length) {
                            delete this._nodeListenersMap[node.__instanceId];
                        }
                    }
                },
                _dispatchEventToListeners: function(listeners, onEvent, eventOrArgs) {
                    var shouldStopPropagation = false;
                    var fixedPriorityListeners = listeners.getFixedPriorityListeners();
                    var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
                    var i = 0, j, selListener;
                    if (fixedPriorityListeners) {
                        if (0 !== fixedPriorityListeners.length) {
                            for (;i < listeners.gt0Index; ++i) {
                                selListener = fixedPriorityListeners[i];
                                if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
                                    shouldStopPropagation = true;
                                    break;
                                }
                            }
                        }
                    }
                    if (sceneGraphPriorityListeners && !shouldStopPropagation) {
                        for (j = 0; j < sceneGraphPriorityListeners.length; j++) {
                            selListener = sceneGraphPriorityListeners[j];
                            if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
                                shouldStopPropagation = true;
                                break;
                            }
                        }
                    }
                    if (fixedPriorityListeners && !shouldStopPropagation) {
                        for (;i < fixedPriorityListeners.length; ++i) {
                            selListener = fixedPriorityListeners[i];
                            if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
                                shouldStopPropagation = true;
                                break;
                            }
                        }
                    }
                },
                _setDirty: function(listenerID, flag) {
                    var locDirtyFlagMap = this._priorityDirtyFlagMap;
                    if (null == locDirtyFlagMap[listenerID]) {
                        locDirtyFlagMap[listenerID] = flag;
                    } else {
                        locDirtyFlagMap[listenerID] = flag | locDirtyFlagMap[listenerID];
                    }
                },
                _visitTarget: function(node, isRootNode) {
                    var children = node.getChildren(), i = 0;
                    var childrenCount = children.length, locGlobalZOrderNodeMap = this._globalZOrderNodeMap, locNodeListenersMap = this._nodeListenersMap;
                    if (childrenCount > 0) {
                        var child;
                        for (;i < childrenCount; i++) {
                            child = children[i];
                            if (child && child.getLocalZOrder() < 0) {
                                this._visitTarget(child, false);
                            } else {
                                break;
                            }
                        }
                        if (void 0 !== locNodeListenersMap[node.__instanceId]) {
                            if (!locGlobalZOrderNodeMap[node.getGlobalZOrder()]) {
                                locGlobalZOrderNodeMap[node.getGlobalZOrder()] = [];
                            }
                            locGlobalZOrderNodeMap[node.getGlobalZOrder()].push(node.__instanceId);
                        }
                        for (;i < childrenCount; i++) {
                            child = children[i];
                            if (child) {
                                this._visitTarget(child, false);
                            }
                        }
                    } else {
                        if (void 0 !== locNodeListenersMap[node.__instanceId]) {
                            if (!locGlobalZOrderNodeMap[node.getGlobalZOrder()]) {
                                locGlobalZOrderNodeMap[node.getGlobalZOrder()] = [];
                            }
                            locGlobalZOrderNodeMap[node.getGlobalZOrder()].push(node.__instanceId);
                        }
                    }
                    if (isRootNode) {
                        var globalZOrders = [];
                        for (var selKey in locGlobalZOrderNodeMap) {
                            globalZOrders.push(selKey);
                        }
                        globalZOrders.sort(this._sortNumberAsc);
                        var zOrdersLen = globalZOrders.length, selZOrders, j, locNodePriorityMap = this._nodePriorityMap;
                        for (i = 0; i < zOrdersLen; i++) {
                            selZOrders = locGlobalZOrderNodeMap[globalZOrders[i]];
                            for (j = 0; j < selZOrders.length; j++) {
                                locNodePriorityMap[selZOrders[j]] = ++this._nodePriorityIndex;
                            }
                        }
                        this._globalZOrderNodeMap = {};
                    }
                },
                _sortNumberAsc: function(a, b) {
                    return a - b;
                },
                addListener: function(listener, nodeOrPriority) {
                    cc.assert(listener && nodeOrPriority, cc._LogInfos.EventManager.addListener_2);
                    if (!(listener instanceof cc.EventListener)) {
                        cc.assert(!cc.js.isNumber(nodeOrPriority), cc._LogInfos.EventManager.addListener_3);
                        listener = cc.EventListener.create(listener);
                    } else {
                        if (listener._isRegistered()) {
                            cc.log(cc._LogInfos.EventManager.addListener_4);
                            return;
                        }
                    }
                    if (!listener.checkAvailable()) {
                        return;
                    }
                    if (cc.js.isNumber(nodeOrPriority)) {
                        if (0 === nodeOrPriority) {
                            cc.log(cc._LogInfos.EventManager.addListener);
                            return;
                        }
                        listener._setSceneGraphPriority(null);
                        listener._setFixedPriority(nodeOrPriority);
                        listener._setRegistered(true);
                        listener._setPaused(false);
                        this._addListener(listener);
                    } else {
                        listener._setSceneGraphPriority(nodeOrPriority);
                        listener._setFixedPriority(0);
                        listener._setRegistered(true);
                        this._addListener(listener);
                    }
                    return listener;
                },
                addCustomListener: function(eventName, callback) {
                    var listener = new cc._EventListenerCustom(eventName, callback);
                    this.addListener(listener, 1);
                    return listener;
                },
                removeListener: function(listener) {
                    if (null == listener) {
                        return;
                    }
                    var isFound, locListener = this._listenersMap;
                    for (var selKey in locListener) {
                        var listeners = locListener[selKey];
                        var fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
                        isFound = this._removeListenerInVector(sceneGraphPriorityListeners, listener);
                        if (isFound) {
                            this._setDirty(listener._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY);
                        } else {
                            isFound = this._removeListenerInVector(fixedPriorityListeners, listener);
                            if (isFound) {
                                this._setDirty(listener._getListenerID(), this.DIRTY_FIXED_PRIORITY);
                            }
                        }
                        if (listeners.empty()) {
                            delete this._priorityDirtyFlagMap[listener._getListenerID()];
                            delete locListener[selKey];
                        }
                        if (isFound) {
                            break;
                        }
                    }
                    if (!isFound) {
                        var locToAddedListeners = this._toAddedListeners;
                        for (var i = 0, len = locToAddedListeners.length; i < len; i++) {
                            var selListener = locToAddedListeners[i];
                            if (selListener === listener) {
                                cc.js.array.remove(locToAddedListeners, selListener);
                                selListener._setRegistered(false);
                                break;
                            }
                        }
                    }
                },
                _removeListenerInCallback: function(listeners, callback) {
                    if (null == listeners) {
                        return false;
                    }
                    for (var i = 0, len = listeners.length; i < len; i++) {
                        var selListener = listeners[i];
                        if (selListener._onCustomEvent === callback || selListener._onEvent === callback) {
                            selListener._setRegistered(false);
                            if (null != selListener._getSceneGraphPriority()) {
                                this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener);
                                selListener._setSceneGraphPriority(null);
                            }
                            if (0 === this._inDispatch) {
                                cc.js.array.remove(listeners, selListener);
                            }
                            return true;
                        }
                    }
                    return false;
                },
                _removeListenerInVector: function(listeners, listener) {
                    if (null == listeners) {
                        return false;
                    }
                    for (var i = 0, len = listeners.length; i < len; i++) {
                        var selListener = listeners[i];
                        if (selListener === listener) {
                            selListener._setRegistered(false);
                            if (null != selListener._getSceneGraphPriority()) {
                                this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener);
                                selListener._setSceneGraphPriority(null);
                            }
                            if (0 === this._inDispatch) {
                                cc.js.array.remove(listeners, selListener);
                            }
                            return true;
                        }
                    }
                    return false;
                },
                removeListeners: function(listenerType, recursive) {
                    var i, _t = this;
                    if (void 0 !== listenerType.__instanceId) {
                        delete _t._nodePriorityMap[listenerType.__instanceId];
                        cc.js.array.remove(_t._dirtyNodes, listenerType);
                        var listeners = _t._nodeListenersMap[listenerType.__instanceId], i;
                        if (listeners) {
                            var listenersCopy = cc.js.array.copy(listeners);
                            for (i = 0; i < listenersCopy.length; i++) {
                                _t.removeListener(listenersCopy[i]);
                            }
                            delete _t._nodeListenersMap[listenerType.__instanceId];
                        }
                        var locToAddedListeners = _t._toAddedListeners;
                        for (i = 0; i < locToAddedListeners.length; ) {
                            var listener = locToAddedListeners[i];
                            if (listener._getSceneGraphPriority() === listenerType) {
                                listener._setSceneGraphPriority(null);
                                listener._setRegistered(false);
                                locToAddedListeners.splice(i, 1);
                            } else {
                                ++i;
                            }
                        }
                        if (true === recursive) {
                            var locChildren = listenerType.getChildren(), len;
                            for (i = 0, len = locChildren.length; i < len; i++) {
                                _t.removeListeners(locChildren[i], true);
                            }
                        }
                    } else {
                        if (listenerType === cc.EventListener.TOUCH_ONE_BY_ONE) {
                            _t._removeListenersForListenerID(cc._EventListenerTouchOneByOne.LISTENER_ID);
                        } else {
                            if (listenerType === cc.EventListener.TOUCH_ALL_AT_ONCE) {
                                _t._removeListenersForListenerID(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
                            } else {
                                if (listenerType === cc.EventListener.MOUSE) {
                                    _t._removeListenersForListenerID(cc._EventListenerMouse.LISTENER_ID);
                                } else {
                                    if (listenerType === cc.EventListener.ACCELERATION) {
                                        _t._removeListenersForListenerID(cc._EventListenerAcceleration.LISTENER_ID);
                                    } else {
                                        if (listenerType === cc.EventListener.KEYBOARD) {
                                            _t._removeListenersForListenerID(cc._EventListenerKeyboard.LISTENER_ID);
                                        } else {
                                            cc.log(cc._LogInfos.EventManager.removeListeners);
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                removeCustomListeners: function(customEventName) {
                    this._removeListenersForListenerID(customEventName);
                },
                removeAllListeners: function() {
                    var locListeners = this._listenersMap, locInternalCustomEventIDs = this._internalCustomListenerIDs;
                    for (var selKey in locListeners) {
                        if (-1 === locInternalCustomEventIDs.indexOf(selKey)) {
                            this._removeListenersForListenerID(selKey);
                        }
                    }
                },
                setPriority: function(listener, fixedPriority) {
                    if (null == listener) {
                        return;
                    }
                    var locListeners = this._listenersMap;
                    for (var selKey in locListeners) {
                        var selListeners = locListeners[selKey];
                        var fixedPriorityListeners = selListeners.getFixedPriorityListeners();
                        if (fixedPriorityListeners) {
                            var found = fixedPriorityListeners.indexOf(listener);
                            if (-1 !== found) {
                                if (null != listener._getSceneGraphPriority()) {
                                    cc.log(cc._LogInfos.EventManager.setPriority);
                                }
                                if (listener._getFixedPriority() !== fixedPriority) {
                                    listener._setFixedPriority(fixedPriority);
                                    this._setDirty(listener._getListenerID(), this.DIRTY_FIXED_PRIORITY);
                                }
                                return;
                            }
                        }
                    }
                },
                setEnabled: function(enabled) {
                    this._isEnabled = enabled;
                },
                isEnabled: function() {
                    return this._isEnabled;
                },
                dispatchEvent: function(event) {
                    if (!this._isEnabled) {
                        return;
                    }
                    this._updateDirtyFlagForSceneGraph();
                    this._inDispatch++;
                    if (!event || !event.getType) {
                        throw new Error("event is undefined");
                    }
                    if (event.getType() === cc.Event.TOUCH) {
                        this._dispatchTouchEvent(event);
                        this._inDispatch--;
                        return;
                    }
                    var listenerID = cc.__getListenerID(event);
                    this._sortEventListeners(listenerID);
                    var selListeners = this._listenersMap[listenerID];
                    if (null != selListeners) {
                        this._dispatchEventToListeners(selListeners, this._onListenerCallback, event);
                    }
                    this._updateListeners(event);
                    this._inDispatch--;
                },
                _onListenerCallback: function(listener, event) {
                    event.currentTarget = listener._target;
                    listener._onEvent(event);
                    return event.isStopped();
                },
                dispatchCustomEvent: function(eventName, optionalUserData) {
                    var ev = new cc.Event.EventCustom(eventName);
                    ev.setUserData(optionalUserData);
                    this.dispatchEvent(ev);
                }
            };
            cc.rendererCanvas = {
                childrenOrderDirty: true,
                _transformNodePool: [],
                _renderCmds: [],
                _isCacheToCanvasOn: false,
                _cacheToCanvasCmds: {},
                _cacheInstanceIds: [],
                _currentID: 0,
                _clearColor: cc.color(),
                _clearFillStyle: "rgb(0, 0, 0)",
                getRenderCmd: function(renderableObject) {
                    return renderableObject._createRenderCmd();
                },
                rendering: function(ctx) {
                    var locCmds = this._renderCmds, i, len, scaleX = cc.view.getScaleX(), scaleY = cc.view.getScaleY();
                    var context = ctx || cc._renderContext;
                    context.computeRealOffsetY();
                    for (i = 0, len = locCmds.length; i < len; i++) {
                        locCmds[i].rendering(context, scaleX, scaleY);
                    }
                },
                _renderingToCacheCanvas: function(ctx, instanceID, scaleX, scaleY) {
                    if (!ctx) {
                        cc.log("The context of RenderTexture is invalid.");
                    }
                    scaleX = cc.js.isUndefined(scaleX) ? 1 : scaleX;
                    scaleY = cc.js.isUndefined(scaleY) ? 1 : scaleY;
                    instanceID = instanceID || this._currentID;
                    var locCmds = this._cacheToCanvasCmds[instanceID], i, len;
                    ctx.computeRealOffsetY();
                    for (i = 0, len = locCmds.length; i < len; i++) {
                        locCmds[i].rendering(ctx, scaleX, scaleY);
                    }
                    locCmds.length = 0;
                    var locIDs = this._cacheInstanceIds;
                    delete this._cacheToCanvasCmds[instanceID];
                    cc.js.array.remove(locIDs, instanceID);
                    if (0 === locIDs.length) {
                        this._isCacheToCanvasOn = false;
                    } else {
                        this._currentID = locIDs[locIDs.length - 1];
                    }
                },
                _turnToCacheMode: function(renderTextureID) {
                    this._isCacheToCanvasOn = true;
                    renderTextureID = renderTextureID || 0;
                    this._cacheToCanvasCmds[renderTextureID] = [];
                    if (-1 === this._cacheInstanceIds.indexOf(renderTextureID)) {
                        this._cacheInstanceIds.push(renderTextureID);
                    }
                    this._currentID = renderTextureID;
                },
                _turnToNormalMode: function() {
                    this._isCacheToCanvasOn = false;
                },
                resetFlag: function() {
                    this.childrenOrderDirty = false;
                    this._transformNodePool.length = 0;
                },
                transform: function() {
                    var locPool = this._transformNodePool;
                    locPool.sort(this._sortNodeByLevelAsc);
                    for (var i = 0, len = locPool.length; i < len; i++) {
                        if (0 !== locPool[i]._dirtyFlag) {
                            locPool[i].updateStatus();
                        }
                    }
                    locPool.length = 0;
                },
                transformDirty: function() {
                    return this._transformNodePool.length > 0;
                },
                _sortNodeByLevelAsc: function(n1, n2) {
                    return n1._curLevel - n2._curLevel;
                },
                pushDirtyNode: function(node) {
                    this._transformNodePool.push(node);
                },
                clear: function() {
                    var viewport = cc._canvas;
                    var wrapper = cc._renderContext;
                    var ctx = wrapper.getContext();
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.clearRect(0, 0, viewport.width, viewport.height);
                    if (0 !== this._clearColor.r || 0 !== this._clearColor.g || 0 !== this._clearColor.b) {
                        wrapper.setFillStyle(this._clearFillStyle);
                        wrapper.setGlobalAlpha(this._clearColor.a);
                        ctx.fillRect(0, 0, viewport.width, viewport.height);
                    }
                },
                clearRenderCommands: function() {
                    this._renderCmds.length = 0;
                    this._cacheInstanceIds.length = 0;
                    this._isCacheToCanvasOn = false;
                },
                pushRenderCommand: function(cmd) {
                    if (!cmd._needDraw) {
                        return;
                    }
                    if (this._isCacheToCanvasOn) {
                        var currentId = this._currentID, locCmdBuffer = this._cacheToCanvasCmds;
                        var cmdList = locCmdBuffer[currentId];
                        if (-1 === cmdList.indexOf(cmd)) {
                            cmdList.push(cmd);
                        }
                    } else {
                        if (-1 === this._renderCmds.indexOf(cmd)) {
                            this._renderCmds.push(cmd);
                        }
                    }
                }
            };
            !function() {
                cc.CanvasContextWrapper = function(context) {
                    this._context = context;
                    this._saveCount = 0;
                    this._currentAlpha = context.globalAlpha;
                    this._currentCompositeOperation = context.globalCompositeOperation;
                    this._currentFillStyle = context.fillStyle;
                    this._currentStrokeStyle = context.strokeStyle;
                    this._offsetX = 0;
                    this._offsetY = 0;
                    this._realOffsetY = this.height;
                    this._armatureMode = 0;
                };
                var proto = cc.CanvasContextWrapper.prototype;
                proto.resetCache = function() {
                    var context = this._context;
                    this._currentAlpha = context.globalAlpha;
                    this._currentCompositeOperation = context.globalCompositeOperation;
                    this._currentFillStyle = context.fillStyle;
                    this._currentStrokeStyle = context.strokeStyle;
                    this._realOffsetY = this._context.canvas.height + this._offsetY;
                };
                proto.setOffset = function(x, y) {
                    this._offsetX = x;
                    this._offsetY = y;
                    this._realOffsetY = this._context.canvas.height + this._offsetY;
                };
                proto.computeRealOffsetY = function() {
                    this._realOffsetY = this._context.canvas.height + this._offsetY;
                };
                proto.setViewScale = function(scaleX, scaleY) {
                    this._scaleX = scaleX;
                    this._scaleY = scaleY;
                };
                proto.getContext = function() {
                    return this._context;
                };
                proto.save = function() {
                    this._context.save();
                    this._saveCount++;
                };
                proto.restore = function() {
                    this._context.restore();
                    this._saveCount--;
                };
                proto.setGlobalAlpha = function(alpha) {
                    if (this._saveCount > 0) {
                        this._context.globalAlpha = alpha;
                    } else {
                        if (this._currentAlpha !== alpha) {
                            this._currentAlpha = alpha;
                            this._context.globalAlpha = alpha;
                        }
                    }
                };
                proto.setCompositeOperation = function(compositionOperation) {
                    if (this._saveCount > 0) {
                        this._context.globalCompositeOperation = compositionOperation;
                    } else {
                        if (this._currentCompositeOperation !== compositionOperation) {
                            this._currentCompositeOperation = compositionOperation;
                            this._context.globalCompositeOperation = compositionOperation;
                        }
                    }
                };
                proto.setFillStyle = function(fillStyle) {
                    if (this._saveCount > 0) {
                        this._context.fillStyle = fillStyle;
                    } else {
                        if (this._currentFillStyle !== fillStyle) {
                            this._currentFillStyle = fillStyle;
                            this._context.fillStyle = fillStyle;
                        }
                    }
                };
                proto.setStrokeStyle = function(strokeStyle) {
                    if (this._saveCount > 0) {
                        this._context.strokeStyle = strokeStyle;
                    } else {
                        if (this._currentStrokeStyle !== strokeStyle) {
                            this._currentStrokeStyle = strokeStyle;
                            this._context.strokeStyle = strokeStyle;
                        }
                    }
                };
                proto.setTransform = function(t, scaleX, scaleY) {
                    if (this._armatureMode > 0) {
                        this.restore();
                        this.save();
                        this._context.transform(t.a, -t.b, -t.c, t.d, t.tx * scaleX, -(t.ty * scaleY));
                    } else {
                        this._context.setTransform(t.a, -t.b, -t.c, t.d, this._offsetX + t.tx * scaleX, this._realOffsetY - t.ty * scaleY);
                    }
                };
                proto._switchToArmatureMode = function(enable, t, scaleX, scaleY) {
                    if (enable) {
                        this._armatureMode++;
                        this._context.setTransform(t.a, t.c, t.b, t.d, this._offsetX + t.tx * scaleX, this._realOffsetY - t.ty * scaleY);
                        this.save();
                    } else {
                        this._armatureMode--;
                        this.restore();
                    }
                };
            }();
            cc.rendererWebGL = {
                childrenOrderDirty: true,
                _transformNodePool: [],
                _renderCmds: [],
                _isCacheToBufferOn: false,
                _cacheToBufferCmds: {},
                _cacheInstanceIds: [],
                _currentID: 0,
                _clearColor: cc.color(),
                getRenderCmd: function(renderableObject) {
                    return renderableObject._createRenderCmd();
                },
                rendering: function(ctx) {
                    var locCmds = this._renderCmds, i, len;
                    var context = ctx || cc._renderContext;
                    for (i = 0, len = locCmds.length; i < len; i++) {
                        locCmds[i].rendering(context);
                    }
                },
                _turnToCacheMode: function(renderTextureID) {
                    this._isCacheToBufferOn = true;
                    renderTextureID = renderTextureID || 0;
                    this._cacheToBufferCmds[renderTextureID] = [];
                    this._cacheInstanceIds.push(renderTextureID);
                    this._currentID = renderTextureID;
                },
                _turnToNormalMode: function() {
                    this._isCacheToBufferOn = false;
                },
                _renderingToBuffer: function(renderTextureId) {
                    renderTextureId = renderTextureId || this._currentID;
                    var locCmds = this._cacheToBufferCmds[renderTextureId], i, len;
                    var ctx = cc._renderContext, locIDs = this._cacheInstanceIds;
                    for (i = 0, len = locCmds.length; i < len; i++) {
                        locCmds[i].rendering(ctx);
                    }
                    locCmds.length = 0;
                    delete this._cacheToBufferCmds[renderTextureId];
                    cc.js.array.remove(locIDs, renderTextureId);
                    if (0 === locIDs.length) {
                        this._isCacheToBufferOn = false;
                    } else {
                        this._currentID = locIDs[locIDs.length - 1];
                    }
                },
                resetFlag: function() {
                    this.childrenOrderDirty = false;
                    this._transformNodePool.length = 0;
                },
                transform: function() {
                    var locPool = this._transformNodePool;
                    locPool.sort(this._sortNodeByLevelAsc);
                    for (var i = 0, len = locPool.length; i < len; i++) {
                        locPool[i].updateStatus();
                    }
                    locPool.length = 0;
                },
                transformDirty: function() {
                    return this._transformNodePool.length > 0;
                },
                _sortNodeByLevelAsc: function(n1, n2) {
                    return n1._curLevel - n2._curLevel;
                },
                pushDirtyNode: function(node) {
                    this._transformNodePool.push(node);
                },
                clearRenderCommands: function() {
                    this._renderCmds.length = 0;
                },
                clear: function() {
                    var gl = cc._renderContext;
                    gl.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearColor.a);
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                },
                setDepthTest: function(enable) {
                    var gl = cc._renderContext;
                    if (enable) {
                        gl.clearDepth(1);
                        gl.enable(gl.DEPTH_TEST);
                        gl.depthFunc(gl.LEQUAL);
                    } else {
                        gl.disable(gl.DEPTH_TEST);
                    }
                },
                pushRenderCommand: function(cmd) {
                    if (!cmd._needDraw) {
                        return;
                    }
                    if (this._isCacheToBufferOn) {
                        var currentId = this._currentID, locCmdBuffer = this._cacheToBufferCmds;
                        var cmdList = locCmdBuffer[currentId];
                        if (-1 === cmdList.indexOf(cmd)) {
                            cmdList.push(cmd);
                        }
                    } else {
                        if (-1 === this._renderCmds.indexOf(cmd)) {
                            this._renderCmds.push(cmd);
                        }
                    }
                }
            };
            cc._tmp.PrototypeCCNode = function() {
                var _p = _ccsg.Node.prototype;
                cc.defineGetterSetter(_p, "x", _p.getPositionX, _p.setPositionX);
                cc.defineGetterSetter(_p, "y", _p.getPositionY, _p.setPositionY);
                _p.width;
                cc.defineGetterSetter(_p, "width", _p._getWidth, _p._setWidth);
                _p.height;
                cc.defineGetterSetter(_p, "height", _p._getHeight, _p._setHeight);
                _p.anchorX;
                cc.defineGetterSetter(_p, "anchorX", _p._getAnchorX, _p._setAnchorX);
                _p.anchorY;
                cc.defineGetterSetter(_p, "anchorY", _p._getAnchorY, _p._setAnchorY);
                _p.skewX;
                cc.defineGetterSetter(_p, "skewX", _p.getSkewX, _p.setSkewX);
                _p.skewY;
                cc.defineGetterSetter(_p, "skewY", _p.getSkewY, _p.setSkewY);
                _p.zIndex;
                cc.defineGetterSetter(_p, "zIndex", _p.getLocalZOrder, _p.setLocalZOrder);
                _p.vertexZ;
                cc.defineGetterSetter(_p, "vertexZ", _p.getVertexZ, _p.setVertexZ);
                _p.rotation;
                cc.defineGetterSetter(_p, "rotation", _p.getRotation, _p.setRotation);
                _p.rotationX;
                cc.defineGetterSetter(_p, "rotationX", _p.getRotationX, _p.setRotationX);
                _p.rotationY;
                cc.defineGetterSetter(_p, "rotationY", _p.getRotationY, _p.setRotationY);
                _p.scale;
                cc.defineGetterSetter(_p, "scale", _p.getScale, _p.setScale);
                _p.scaleX;
                cc.defineGetterSetter(_p, "scaleX", _p.getScaleX, _p.setScaleX);
                _p.scaleY;
                cc.defineGetterSetter(_p, "scaleY", _p.getScaleY, _p.setScaleY);
                _p.children;
                cc.defineGetterSetter(_p, "children", _p.getChildren);
                _p.childrenCount;
                cc.defineGetterSetter(_p, "childrenCount", _p.getChildrenCount);
                _p.parent;
                cc.defineGetterSetter(_p, "parent", _p.getParent, _p.setParent);
                _p.visible;
                cc.defineGetterSetter(_p, "visible", _p.isVisible, _p.setVisible);
                _p.running;
                cc.defineGetterSetter(_p, "running", _p.isRunning);
                _p.ignoreAnchor;
                cc.defineGetterSetter(_p, "ignoreAnchor", _p.isIgnoreAnchorPointForPosition, _p.ignoreAnchorPointForPosition);
                _p.tag;
                _p.userData;
                _p.userObject;
                _p.arrivalOrder;
                _p.actionManager;
                cc.defineGetterSetter(_p, "actionManager", _p.getActionManager, _p.setActionManager);
                _p.scheduler;
                cc.defineGetterSetter(_p, "scheduler", _p.getScheduler, _p.setScheduler);
                _p.shaderProgram;
                cc.defineGetterSetter(_p, "shaderProgram", _p.getShaderProgram, _p.setShaderProgram);
                _p.opacity;
                cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
                _p.opacityModifyRGB;
                cc.defineGetterSetter(_p, "opacityModifyRGB", _p.isOpacityModifyRGB);
                _p.cascadeOpacity;
                cc.defineGetterSetter(_p, "cascadeOpacity", _p.isCascadeOpacityEnabled, _p.setCascadeOpacityEnabled);
                _p.color;
                cc.defineGetterSetter(_p, "color", _p.getColor, _p.setColor);
                _p.cascadeColor;
                cc.defineGetterSetter(_p, "cascadeColor", _p.isCascadeColorEnabled, _p.setCascadeColorEnabled);
            };
            cc.NODE_TAG_INVALID = -1;
            cc.s_globalOrderOfArrival = 1;
            _ccsg.Node = cc.Class({
                name: "ccsg.Node",
                properties: {
                    _localZOrder: 0,
                    _globalZOrder: 0,
                    _vertexZ: 0,
                    _rotationX: 0,
                    _rotationY: 0,
                    _scaleX: 1,
                    _scaleY: 1,
                    _position: cc.p(0, 0),
                    _skewX: 0,
                    _skewY: 0,
                    _children: [],
                    _visible: true,
                    _anchorPoint: cc.p(0, 0),
                    _contentSize: cc.size(0, 0),
                    _parent: null,
                    _ignoreAnchorPointForPosition: false,
                    tag: cc.NODE_TAG_INVALID,
                    _showNode: false,
                    _name: "",
                    _realOpacity: 255,
                    _realColor: cc.Color.WHITE,
                    _cascadeColorEnabled: false,
                    _cascadeOpacityEnabled: false
                },
                ctor: function() {
                    var name = arguments[0];
                    this.__instanceId = cc.ClassManager.getNewInstanceId();
                    this._running = false;
                    this._reorderChildDirty = false;
                    this._shaderProgram = null;
                    this.arrivalOrder = 0;
                    this._additionalTransformDirty = false;
                    this._isTransitionFinished = false;
                    var director = cc.director;
                    this._actionManager = director.getActionManager();
                    this._scheduler = director.getScheduler();
                    this._additionalTransform = cc.affineTransformMakeIdentity();
                    this._initRendererCmd();
                },
                init: function() {
                    return true;
                },
                _arrayMakeObjectsPerformSelector: function(array, callbackType) {
                    if (!array || 0 === array.length) {
                        return;
                    }
                    var i, len = array.length, node;
                    var nodeCallbackType = _ccsg.Node._stateCallbackType;
                    switch (callbackType) {
                      case nodeCallbackType.onEnter:
                        for (i = 0; i < len; i++) {
                            node = array[i];
                            if (node) {
                                node.onEnter();
                            }
                        }
                        break;

                      case nodeCallbackType.onExit:
                        for (i = 0; i < len; i++) {
                            node = array[i];
                            if (node) {
                                node.onExit();
                            }
                        }
                        break;

                      case nodeCallbackType.onEnterTransitionDidFinish:
                        for (i = 0; i < len; i++) {
                            node = array[i];
                            if (node) {
                                node.onEnterTransitionDidFinish();
                            }
                        }
                        break;

                      case nodeCallbackType.cleanup:
                        for (i = 0; i < len; i++) {
                            node = array[i];
                            if (node) {
                                node.cleanup();
                            }
                        }
                        break;

                      case nodeCallbackType.updateTransform:
                        for (i = 0; i < len; i++) {
                            node = array[i];
                            if (node) {
                                node.updateTransform();
                            }
                        }
                        break;

                      case nodeCallbackType.onExitTransitionDidStart:
                        for (i = 0; i < len; i++) {
                            node = array[i];
                            if (node) {
                                node.onExitTransitionDidStart();
                            }
                        }
                        break;

                      case nodeCallbackType.sortAllChildren:
                        for (i = 0; i < len; i++) {
                            node = array[i];
                            if (node) {
                                node.sortAllChildren();
                            }
                        }
                        break;

                      default:
                        cc.assert(0, cc._LogInfos.Node._arrayMakeObjectsPerformSelector);
                    }
                },
                attr: function(attrs) {
                    for (var key in attrs) {
                        this[key] = attrs[key];
                    }
                },
                getSkewX: function() {
                    return this._skewX;
                },
                setSkewX: function(newSkewX) {
                    this._skewX = newSkewX;
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
                },
                getSkewY: function() {
                    return this._skewY;
                },
                setSkewY: function(newSkewY) {
                    this._skewY = newSkewY;
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
                },
                setLocalZOrder: function(localZOrder) {
                    this._localZOrder = localZOrder;
                    if (this._parent) {
                        this._parent.reorderChild(this, localZOrder);
                    }
                    cc.eventManager._setDirtyForNode(this);
                },
                _setLocalZOrder: function(localZOrder) {
                    this._localZOrder = localZOrder;
                },
                getLocalZOrder: function() {
                    return this._localZOrder;
                },
                getZOrder: function() {
                    cc.log(cc._LogInfos.Node.getZOrder);
                    return this.getLocalZOrder();
                },
                setZOrder: function(z) {
                    cc.log(cc._LogInfos.Node.setZOrder);
                    this.setLocalZOrder(z);
                },
                setGlobalZOrder: function(globalZOrder) {
                    if (this._globalZOrder !== globalZOrder) {
                        this._globalZOrder = globalZOrder;
                        cc.eventManager._setDirtyForNode(this);
                    }
                },
                getGlobalZOrder: function() {
                    return this._globalZOrder;
                },
                getVertexZ: function() {
                    return this._vertexZ;
                },
                setVertexZ: function(Var) {
                    this._vertexZ = Var;
                },
                getRotation: function() {
                    if (this._rotationX !== this._rotationY) {
                        cc.log(cc._LogInfos.Node.getRotation);
                    }
                    return this._rotationX;
                },
                setRotation: function(newRotation) {
                    this._rotationX = this._rotationY = newRotation;
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
                },
                getRotationX: function() {
                    return this._rotationX;
                },
                setRotationX: function(rotationX) {
                    this._rotationX = rotationX;
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
                },
                getRotationY: function() {
                    return this._rotationY;
                },
                setRotationY: function(rotationY) {
                    this._rotationY = rotationY;
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
                },
                getScale: function() {
                    if (this._scaleX !== this._scaleY) {
                        cc.log(cc._LogInfos.Node.getScale);
                    }
                    return this._scaleX;
                },
                setScale: function(scale, scaleY) {
                    this._scaleX = scale;
                    this._scaleY = scaleY || 0 === scaleY ? scaleY : scale;
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
                },
                getScaleX: function() {
                    return this._scaleX;
                },
                setScaleX: function(newScaleX) {
                    this._scaleX = newScaleX;
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
                },
                getScaleY: function() {
                    return this._scaleY;
                },
                setScaleY: function(newScaleY) {
                    this._scaleY = newScaleY;
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
                },
                setPosition: function(newPosOrxValue, yValue) {
                    var locPosition = this._position;
                    if (void 0 === yValue) {
                        if (locPosition.x === newPosOrxValue.x && locPosition.y === newPosOrxValue.y) {
                            return;
                        }
                        locPosition.x = newPosOrxValue.x;
                        locPosition.y = newPosOrxValue.y;
                    } else {
                        if (locPosition.x === newPosOrxValue && locPosition.y === yValue) {
                            return;
                        }
                        locPosition.x = newPosOrxValue;
                        locPosition.y = yValue;
                    }
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
                },
                getPosition: function() {
                    return cc.p(this._position);
                },
                getPositionX: function() {
                    return this._position.x;
                },
                setPositionX: function(x) {
                    this._position.x = x;
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
                },
                getPositionY: function() {
                    return this._position.y;
                },
                setPositionY: function(y) {
                    this._position.y = y;
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
                },
                getChildrenCount: function() {
                    return this._children.length;
                },
                getChildren: function() {
                    return this._children;
                },
                isVisible: function() {
                    return this._visible;
                },
                setVisible: function(visible) {
                    if (this._visible !== visible) {
                        this._visible = visible;
                        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
                        cc.renderer.childrenOrderDirty = true;
                    }
                },
                getAnchorPoint: function() {
                    return cc.p(this._anchorPoint);
                },
                setAnchorPoint: function(point, y) {
                    var locAnchorPoint = this._anchorPoint;
                    if (void 0 === y) {
                        if (point.x === locAnchorPoint.x && point.y === locAnchorPoint.y) {
                            return;
                        }
                        locAnchorPoint.x = point.x;
                        locAnchorPoint.y = point.y;
                    } else {
                        if (point === locAnchorPoint.x && y === locAnchorPoint.y) {
                            return;
                        }
                        locAnchorPoint.x = point;
                        locAnchorPoint.y = y;
                    }
                    this._renderCmd._updateAnchorPointInPoint();
                },
                _getAnchorX: function() {
                    return this._anchorPoint.x;
                },
                _setAnchorX: function(x) {
                    if (this._anchorPoint.x === x) {
                        return;
                    }
                    this._anchorPoint.x = x;
                    this._renderCmd._updateAnchorPointInPoint();
                },
                _getAnchorY: function() {
                    return this._anchorPoint.y;
                },
                _setAnchorY: function(y) {
                    if (this._anchorPoint.y === y) {
                        return;
                    }
                    this._anchorPoint.y = y;
                    this._renderCmd._updateAnchorPointInPoint();
                },
                getAnchorPointInPoints: function() {
                    return this._renderCmd.getAnchorPointInPoints();
                },
                _getWidth: function() {
                    return this._contentSize.width;
                },
                _setWidth: function(width) {
                    this._contentSize.width = width;
                    this._renderCmd._updateAnchorPointInPoint();
                },
                _getHeight: function() {
                    return this._contentSize.height;
                },
                _setHeight: function(height) {
                    this._contentSize.height = height;
                    this._renderCmd._updateAnchorPointInPoint();
                },
                getContentSize: function() {
                    return cc.size(this._contentSize);
                },
                setContentSize: function(size, height) {
                    var locContentSize = this._contentSize;
                    if (void 0 === height) {
                        if (size.width === locContentSize.width && size.height === locContentSize.height) {
                            return;
                        }
                        locContentSize.width = size.width;
                        locContentSize.height = size.height;
                    } else {
                        if (size === locContentSize.width && height === locContentSize.height) {
                            return;
                        }
                        locContentSize.width = size;
                        locContentSize.height = height;
                    }
                    this._renderCmd._updateAnchorPointInPoint();
                },
                isRunning: function() {
                    return this._running;
                },
                getParent: function() {
                    return this._parent;
                },
                setParent: function(parent) {
                    this._parent = parent;
                },
                isIgnoreAnchorPointForPosition: function() {
                    return this._ignoreAnchorPointForPosition;
                },
                ignoreAnchorPointForPosition: function(newValue) {
                    if (newValue !== this._ignoreAnchorPointForPosition) {
                        this._ignoreAnchorPointForPosition = newValue;
                        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
                    }
                },
                getTag: function() {
                    return this.tag;
                },
                setTag: function(tag) {
                    this.tag = tag;
                },
                setName: function(name) {
                    this._name = name;
                },
                getName: function() {
                    return this._name;
                },
                getOrderOfArrival: function() {
                    return this.arrivalOrder;
                },
                setOrderOfArrival: function(Var) {
                    this.arrivalOrder = Var;
                },
                getActionManager: function() {
                    if (!this._actionManager) {
                        this._actionManager = cc.director.getActionManager();
                    }
                    return this._actionManager;
                },
                setActionManager: function(actionManager) {
                    if (this._actionManager !== actionManager) {
                        this.stopAllActions();
                        this._actionManager = actionManager;
                    }
                },
                getScheduler: function() {
                    if (!this._scheduler) {
                        this._scheduler = cc.director.getScheduler();
                    }
                    return this._scheduler;
                },
                setScheduler: function(scheduler) {
                    if (this._scheduler !== scheduler) {
                        this.unscheduleAllCallbacks();
                        this._scheduler = scheduler;
                    }
                },
                boundingBox: function() {
                    cc.log(cc._LogInfos.Node.boundingBox);
                    return this.getBoundingBox();
                },
                getBoundingBox: function() {
                    var rect = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
                    return cc._rectApplyAffineTransformIn(rect, this.getNodeToParentTransform());
                },
                cleanup: function() {
                    this.stopAllActions();
                    this.unscheduleAllCallbacks();
                    cc.eventManager.removeListeners(this);
                    this._arrayMakeObjectsPerformSelector(this._children, _ccsg.Node._stateCallbackType.cleanup);
                },
                getChildByTag: function(aTag) {
                    var __children = this._children;
                    if (null !== __children) {
                        for (var i = 0; i < __children.length; i++) {
                            var node = __children[i];
                            if (node && node.tag === aTag) {
                                return node;
                            }
                        }
                    }
                    return null;
                },
                getChildByName: function(name) {
                    if (!name) {
                        cc.log("Invalid name");
                        return null;
                    }
                    var locChildren = this._children;
                    for (var i = 0, len = locChildren.length; i < len; i++) {
                        if (locChildren[i]._name === name) {
                            return locChildren[i];
                        }
                    }
                    return null;
                },
                addChild: function(child, localZOrder, tag) {
                    localZOrder = void 0 === localZOrder ? child._localZOrder : localZOrder;
                    var name, setTag = false;
                    if (cc.js.isUndefined(tag)) {
                        tag = void 0;
                        name = child._name;
                    } else {
                        if (cc.js.isString(tag)) {
                            name = tag;
                            tag = void 0;
                        } else {
                            if (cc.js.isNumber(tag)) {
                                setTag = true;
                                name = "";
                            }
                        }
                    }
                    cc.assert(child, cc._LogInfos.Node.addChild_3);
                    cc.assert(null === child._parent, "child already added. It can't be added again");
                    this._addChildHelper(child, localZOrder, tag, name, setTag);
                },
                _addChildHelper: function(child, localZOrder, tag, name, setTag) {
                    if (!this._children) {
                        this._children = [];
                    }
                    this._insertChild(child, localZOrder);
                    if (setTag) {
                        child.setTag(tag);
                    } else {
                        child.setName(name);
                    }
                    child.setParent(this);
                    child.setOrderOfArrival(cc.s_globalOrderOfArrival++);
                    if (this._running) {
                        child.onEnter();
                        if (this._isTransitionFinished) {
                            child.onEnterTransitionDidFinish();
                        }
                    }
                    if (this._cascadeColorEnabled) {
                        child._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.colorDirty);
                    }
                    if (this._cascadeOpacityEnabled) {
                        child._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.opacityDirty);
                    }
                },
                removeFromParent: function(cleanup) {
                    if (this._parent) {
                        if (void 0 === cleanup) {
                            cleanup = true;
                        }
                        this._parent.removeChild(this, cleanup);
                    }
                },
                removeFromParentAndCleanup: function(cleanup) {
                    cc.log(cc._LogInfos.Node.removeFromParentAndCleanup);
                    this.removeFromParent(cleanup);
                },
                removeChild: function(child, cleanup) {
                    if (0 === this._children.length) {
                        return;
                    }
                    if (void 0 === cleanup) {
                        cleanup = true;
                    }
                    if (this._children.indexOf(child) > -1) {
                        this._detachChild(child, cleanup);
                    }
                    cc.renderer.childrenOrderDirty = true;
                },
                removeChildByTag: function(tag, cleanup) {
                    if (tag === cc.NODE_TAG_INVALID) {
                        cc.log(cc._LogInfos.Node.removeChildByTag);
                    }
                    var child = this.getChildByTag(tag);
                    if (!child) {
                        cc.log(cc._LogInfos.Node.removeChildByTag_2, tag);
                    } else {
                        this.removeChild(child, cleanup);
                    }
                },
                removeAllChildrenWithCleanup: function(cleanup) {
                    this.removeAllChildren(cleanup);
                },
                removeAllChildren: function(cleanup) {
                    var __children = this._children;
                    if (null !== __children) {
                        if (void 0 === cleanup) {
                            cleanup = true;
                        }
                        for (var i = 0; i < __children.length; i++) {
                            var node = __children[i];
                            if (node) {
                                if (this._running) {
                                    node.onExitTransitionDidStart();
                                    node.onExit();
                                }
                                if (cleanup) {
                                    node.cleanup();
                                }
                                node.parent = null;
                                node._renderCmd.detachFromParent();
                            }
                        }
                        this._children.length = 0;
                        cc.renderer.childrenOrderDirty = true;
                    }
                },
                _detachChild: function(child, doCleanup) {
                    if (this._running) {
                        child.onExitTransitionDidStart();
                        child.onExit();
                    }
                    if (doCleanup) {
                        child.cleanup();
                    }
                    child.parent = null;
                    child._renderCmd.detachFromParent();
                    cc.js.array.remove(this._children, child);
                },
                _insertChild: function(child, z) {
                    cc.renderer.childrenOrderDirty = this._reorderChildDirty = true;
                    this._children.push(child);
                    child._setLocalZOrder(z);
                },
                setNodeDirty: function() {
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
                },
                reorderChild: function(child, zOrder) {
                    cc.assert(child, cc._LogInfos.Node.reorderChild);
                    cc.renderer.childrenOrderDirty = this._reorderChildDirty = true;
                    child.arrivalOrder = cc.s_globalOrderOfArrival;
                    cc.s_globalOrderOfArrival++;
                    child._setLocalZOrder(zOrder);
                },
                sortAllChildren: function() {
                    if (this._reorderChildDirty) {
                        var _children = this._children;
                        var len = _children.length, i, j, tmp;
                        for (i = 1; i < len; i++) {
                            tmp = _children[i];
                            j = i - 1;
                            while (j >= 0) {
                                if (tmp._localZOrder < _children[j]._localZOrder) {
                                    _children[j + 1] = _children[j];
                                } else {
                                    if (tmp._localZOrder === _children[j]._localZOrder && tmp.arrivalOrder < _children[j].arrivalOrder) {
                                        _children[j + 1] = _children[j];
                                    } else {
                                        break;
                                    }
                                }
                                j--;
                            }
                            _children[j + 1] = tmp;
                        }
                        this._reorderChildDirty = false;
                    }
                },
                draw: function(ctx) {},
                transformAncestors: function() {
                    if (null !== this._parent) {
                        this._parent.transformAncestors();
                        this._parent.transform();
                    }
                },
                onEnter: function() {
                    this._isTransitionFinished = false;
                    this._running = true;
                    this._arrayMakeObjectsPerformSelector(this._children, _ccsg.Node._stateCallbackType.onEnter);
                    this.resume();
                },
                onEnterTransitionDidFinish: function() {
                    this._isTransitionFinished = true;
                    this._arrayMakeObjectsPerformSelector(this._children, _ccsg.Node._stateCallbackType.onEnterTransitionDidFinish);
                },
                onExitTransitionDidStart: function() {
                    this._arrayMakeObjectsPerformSelector(this._children, _ccsg.Node._stateCallbackType.onExitTransitionDidStart);
                },
                onExit: function() {
                    this._running = false;
                    this.pause();
                    this._arrayMakeObjectsPerformSelector(this._children, _ccsg.Node._stateCallbackType.onExit);
                },
                runAction: function(action) {
                    cc.assert(action, cc._LogInfos.Node.runAction);
                    this.actionManager.addAction(action, this, !this._running);
                    return action;
                },
                stopAllActions: function() {
                    this.actionManager && this.actionManager.removeAllActionsFromTarget(this);
                },
                stopAction: function(action) {
                    this.actionManager.removeAction(action);
                },
                stopActionByTag: function(tag) {
                    if (tag === cc.ACTION_TAG_INVALID) {
                        cc.log(cc._LogInfos.Node.stopActionByTag);
                        return;
                    }
                    this.actionManager.removeActionByTag(tag, this);
                },
                getActionByTag: function(tag) {
                    if (tag === cc.ACTION_TAG_INVALID) {
                        cc.log(cc._LogInfos.Node.getActionByTag);
                        return null;
                    }
                    return this.actionManager.getActionByTag(tag, this);
                },
                getNumberOfRunningActions: function() {
                    return this.actionManager.numberOfRunningActionsInTarget(this);
                },
                scheduleUpdate: function() {
                    this.scheduleUpdateWithPriority(0);
                },
                scheduleUpdateWithPriority: function(priority) {
                    this.scheduler.scheduleUpdate(this, priority, !this._running);
                },
                unscheduleUpdate: function() {
                    this.scheduler.unscheduleUpdate(this);
                },
                schedule: function(callback, interval, repeat, delay, key) {
                    var len = arguments.length;
                    if ("function" === typeof callback) {
                        if (1 === len) {
                            interval = 0;
                            repeat = cc.REPEAT_FOREVER;
                            delay = 0;
                            key = this.__instanceId;
                        } else {
                            if (2 === len) {
                                if ("number" === typeof interval) {
                                    repeat = cc.REPEAT_FOREVER;
                                    delay = 0;
                                    key = this.__instanceId;
                                } else {
                                    key = interval;
                                    interval = 0;
                                    repeat = cc.REPEAT_FOREVER;
                                    delay = 0;
                                }
                            } else {
                                if (3 === len) {
                                    if ("string" === typeof repeat) {
                                        key = repeat;
                                        repeat = cc.REPEAT_FOREVER;
                                    } else {
                                        key = this.__instanceId;
                                    }
                                    delay = 0;
                                } else {
                                    if (4 === len) {
                                        key = this.__instanceId;
                                    }
                                }
                            }
                        }
                    } else {
                        if (1 === len) {
                            interval = 0;
                            repeat = cc.REPEAT_FOREVER;
                            delay = 0;
                        } else {
                            if (2 === len) {
                                repeat = cc.REPEAT_FOREVER;
                                delay = 0;
                            }
                        }
                    }
                    cc.assert(callback, cc._LogInfos.Node.schedule);
                    cc.assert(interval >= 0, cc._LogInfos.Node.schedule_2);
                    interval = interval || 0;
                    repeat = null == repeat ? cc.REPEAT_FOREVER : repeat;
                    delay = delay || 0;
                    this.scheduler.schedule(callback, this, interval, repeat, delay, !this._running, key);
                },
                scheduleOnce: function(callback, delay, key) {
                    if (void 0 === key) {
                        key = this.__instanceId;
                    }
                    this.schedule(callback, 0, 0, delay, key);
                },
                unschedule: function(callback_fn) {
                    if (!callback_fn) {
                        return;
                    }
                    this.scheduler.unschedule(callback_fn, this);
                },
                unscheduleAllCallbacks: function() {
                    this.scheduler.unscheduleAllForTarget(this);
                },
                resumeSchedulerAndActions: function() {
                    cc.log(cc._LogInfos.Node.resumeSchedulerAndActions);
                    this.resume();
                },
                resume: function() {
                    this.scheduler.resumeTarget(this);
                    this.actionManager && this.actionManager.resumeTarget(this);
                    cc.eventManager.resumeTarget(this);
                },
                pauseSchedulerAndActions: function() {
                    cc.log(cc._LogInfos.Node.pauseSchedulerAndActions);
                    this.pause();
                },
                pause: function() {
                    this.scheduler.pauseTarget(this);
                    this.actionManager && this.actionManager.pauseTarget(this);
                    cc.eventManager.pauseTarget(this);
                },
                setAdditionalTransform: function(additionalTransform) {
                    if (void 0 === additionalTransform) {
                        return this._additionalTransformDirty = false;
                    }
                    this._additionalTransform = additionalTransform;
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
                    this._additionalTransformDirty = true;
                },
                getParentToNodeTransform: function() {
                    return this._renderCmd.getParentToNodeTransform();
                },
                parentToNodeTransform: function() {
                    return this.getParentToNodeTransform();
                },
                getNodeToWorldTransform: function() {
                    var t;
                    if (this._renderCmd && cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                        t = this._renderCmd._worldTransform;
                    } else {
                        t = this.getNodeToParentTransform();
                        for (var p = this._parent; null !== p; p = p.parent) {
                            t = cc.affineTransformConcat(t, p.getNodeToParentTransform());
                        }
                    }
                    return t;
                },
                nodeToWorldTransform: function() {
                    return this.getNodeToWorldTransform();
                },
                getWorldToNodeTransform: function() {
                    return cc.affineTransformInvert(this.getNodeToWorldTransform());
                },
                worldToNodeTransform: function() {
                    return this.getWorldToNodeTransform();
                },
                convertToNodeSpace: function(worldPoint) {
                    return cc.pointApplyAffineTransform(worldPoint, this.getWorldToNodeTransform());
                },
                convertToWorldSpace: function(nodePoint) {
                    nodePoint = nodePoint || cc.p(0, 0);
                    return cc.pointApplyAffineTransform(nodePoint, this.getNodeToWorldTransform());
                },
                convertToNodeSpaceAR: function(worldPoint) {
                    return cc.pSub(this.convertToNodeSpace(worldPoint), this._renderCmd.getAnchorPointInPoints());
                },
                convertToWorldSpaceAR: function(nodePoint) {
                    nodePoint = nodePoint || cc.p(0, 0);
                    var pt = cc.pAdd(nodePoint, this._renderCmd.getAnchorPointInPoints());
                    return this.convertToWorldSpace(pt);
                },
                _convertToWindowSpace: function(nodePoint) {
                    var worldPoint = this.convertToWorldSpace(nodePoint);
                    return cc.director.convertToUI(worldPoint);
                },
                convertTouchToNodeSpace: function(touch) {
                    var point = touch.getLocation();
                    return this.convertToNodeSpace(point);
                },
                convertTouchToNodeSpaceAR: function(touch) {
                    var point = cc.director.convertToGL(touch.getLocation());
                    return this.convertToNodeSpaceAR(point);
                },
                updateTransform: function() {
                    this._arrayMakeObjectsPerformSelector(this._children, _ccsg.Node._stateCallbackType.updateTransform);
                },
                retain: function() {},
                release: function() {},
                visit: function(parentCmd) {
                    this._renderCmd.visit(parentCmd);
                },
                transform: function(parentCmd, recursive) {
                    this._renderCmd.transform(parentCmd, recursive);
                },
                nodeToParentTransform: function() {
                    return this.getNodeToParentTransform();
                },
                getNodeToParentTransform: function(ancestor) {
                    var t = this._renderCmd.getNodeToParentTransform();
                    if (ancestor) {
                        var T = {
                            a: t.a,
                            b: t.b,
                            c: t.c,
                            d: t.d,
                            tx: t.tx,
                            ty: t.ty
                        };
                        for (var p = this._parent; null != p && p != ancestor; p = p.getParent()) {
                            cc.affineTransformConcatIn(T, p.getNodeToParentTransform());
                        }
                        return T;
                    } else {
                        return t;
                    }
                },
                getNodeToParentAffineTransform: function(ancestor) {
                    return this.getNodeToParentTransform(ancestor);
                },
                getShaderProgram: function() {
                    return this._renderCmd.getShaderProgram();
                },
                setShaderProgram: function(newShaderProgram) {
                    this._renderCmd.setShaderProgram(newShaderProgram);
                },
                getGLServerState: function() {
                    return 0;
                },
                setGLServerState: function(state) {},
                getBoundingBoxToWorld: function() {
                    var rect = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
                    var trans = this.getNodeToWorldTransform();
                    cc._rectApplyAffineTransformIn(rect, trans);
                    if (!this._children) {
                        return rect;
                    }
                    var locChildren = this._children;
                    for (var i = 0; i < locChildren.length; i++) {
                        var child = locChildren[i];
                        if (child && child._visible) {
                            var childRect = child._getBoundingBoxToCurrentNode(trans);
                            if (childRect) {
                                rect = cc.rectUnion(rect, childRect);
                            }
                        }
                    }
                    return rect;
                },
                _getBoundingBoxToCurrentNode: function(parentTransform) {
                    var rect = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
                    var trans = void 0 === parentTransform ? this.getNodeToParentTransform() : cc.affineTransformConcat(this.getNodeToParentTransform(), parentTransform);
                    cc._rectApplyAffineTransformIn(rect, trans);
                    if (!this._children) {
                        return rect;
                    }
                    var locChildren = this._children;
                    for (var i = 0; i < locChildren.length; i++) {
                        var child = locChildren[i];
                        if (child && child._visible) {
                            var childRect = child._getBoundingBoxToCurrentNode(trans);
                            if (childRect) {
                                rect = cc.rectUnion(rect, childRect);
                            }
                        }
                    }
                    return rect;
                },
                getOpacity: function() {
                    return this._realOpacity;
                },
                getDisplayedOpacity: function() {
                    return this._renderCmd.getDisplayedOpacity();
                },
                setOpacity: function(opacity) {
                    this._realOpacity = opacity;
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.opacityDirty);
                },
                updateDisplayedOpacity: function(parentOpacity) {
                    this._renderCmd._updateDisplayOpacity(parentOpacity);
                },
                isCascadeOpacityEnabled: function() {
                    return this._cascadeOpacityEnabled;
                },
                setCascadeOpacityEnabled: function(cascadeOpacityEnabled) {
                    if (this._cascadeOpacityEnabled === cascadeOpacityEnabled) {
                        return;
                    }
                    this._cascadeOpacityEnabled = cascadeOpacityEnabled;
                    this._renderCmd.setCascadeOpacityEnabledDirty();
                },
                getColor: function() {
                    var locRealColor = this._realColor;
                    return cc.color(locRealColor.r, locRealColor.g, locRealColor.b, locRealColor.a);
                },
                getDisplayedColor: function() {
                    return this._renderCmd.getDisplayedColor();
                },
                setColor: function(color) {
                    var locRealColor = this._realColor;
                    locRealColor.r = color.r;
                    locRealColor.g = color.g;
                    locRealColor.b = color.b;
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.colorDirty);
                },
                updateDisplayedColor: function(parentColor) {
                    this._renderCmd._updateDisplayColor(parentColor);
                },
                isCascadeColorEnabled: function() {
                    return this._cascadeColorEnabled;
                },
                setCascadeColorEnabled: function(cascadeColorEnabled) {
                    if (this._cascadeColorEnabled === cascadeColorEnabled) {
                        return;
                    }
                    this._cascadeColorEnabled = cascadeColorEnabled;
                    this._renderCmd.setCascadeColorEnabledDirty();
                },
                setOpacityModifyRGB: function(opacityValue) {},
                isOpacityModifyRGB: function() {
                    return false;
                },
                _initRendererCmd: function() {
                    this._renderCmd = cc.renderer.getRenderCmd(this);
                },
                _createRenderCmd: function() {
                    if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                        return new _ccsg.Node.CanvasRenderCmd(this);
                    } else {
                        return new _ccsg.Node.WebGLRenderCmd(this);
                    }
                }
            });
            _ccsg.Node.extend = function(options) {
                return cc._Class.extend.call(_ccsg.Node, options);
            };
            _ccsg.Node.prototype.ctor = _ccsg.Node;
            _ccsg.Node.create = function() {
                return new _ccsg.Node();
            };
            _ccsg.Node._stateCallbackType = {
                onEnter: 1,
                onExit: 2,
                cleanup: 3,
                onEnterTransitionDidFinish: 4,
                updateTransform: 5,
                onExitTransitionDidStart: 6,
                sortAllChildren: 7
            };
            cc.assert(cc.js.isFunction(cc._tmp.PrototypeCCNode), cc._LogInfos.MissingFile, "BaseNodesPropertyDefine.js");
            cc._tmp.PrototypeCCNode();
            delete cc._tmp.PrototypeCCNode;
            cc.CustomRenderCmd = function(target, func) {
                this._needDraw = true;
                this._target = target;
                this._callback = func;
                this.rendering = function(ctx, scaleX, scaleY) {
                    if (!this._callback) {
                        return;
                    }
                    this._callback.call(this._target, ctx, scaleX, scaleY);
                };
            };
            _ccsg.Node._dirtyFlags = {
                transformDirty: 1,
                visibleDirty: 2,
                colorDirty: 4,
                opacityDirty: 8,
                cacheDirty: 16,
                orderDirty: 32,
                textDirty: 64,
                gradientDirty: 128,
                COUNT: 8
            };
            cc.js.get(_ccsg.Node._dirtyFlags, "all", function() {
                var count = _ccsg.Node._dirtyFlags.COUNT;
                return (1 << count) - 1;
            }, false);
            _ccsg.Node._requestDirtyFlag = function(key) {
                cc.assert(!_ccsg.Node._dirtyFlags[key], cc._LogInfos.Node._requestDirtyFlag, key);
                var count = _ccsg.Node._dirtyFlags.COUNT;
                var value = 1 << count;
                _ccsg.Node._dirtyFlags[key] = value;
                _ccsg.Node._dirtyFlags.COUNT++;
                return value;
            };
            _ccsg.Node.RenderCmd = function(renderable) {
                this._dirtyFlag = 1;
                cc.renderer.pushDirtyNode(this);
                this._node = renderable;
                this._needDraw = false;
                this._anchorPointInPoints = new cc.Vec2(0, 0);
                this._transform = {
                    a: 1,
                    b: 0,
                    c: 0,
                    d: 1,
                    tx: 0,
                    ty: 0
                };
                this._worldTransform = {
                    a: 1,
                    b: 0,
                    c: 0,
                    d: 1,
                    tx: 0,
                    ty: 0
                };
                this._inverse = {
                    a: 1,
                    b: 0,
                    c: 0,
                    d: 1,
                    tx: 0,
                    ty: 0
                };
                this._displayedOpacity = 255;
                this._displayedColor = cc.color(255, 255, 255, 255);
                this._cascadeColorEnabledDirty = false;
                this._cascadeOpacityEnabledDirty = false;
                this._curLevel = -1;
            };
            _ccsg.Node.RenderCmd.prototype = {
                constructor: _ccsg.Node.RenderCmd,
                getAnchorPointInPoints: function() {
                    return cc.p(this._anchorPointInPoints);
                },
                getDisplayedColor: function() {
                    var tmpColor = this._displayedColor;
                    return cc.color(tmpColor.r, tmpColor.g, tmpColor.b, tmpColor.a);
                },
                getDisplayedOpacity: function() {
                    return this._displayedOpacity;
                },
                setCascadeColorEnabledDirty: function() {
                    this._cascadeColorEnabledDirty = true;
                    this.setDirtyFlag(_ccsg.Node._dirtyFlags.colorDirty);
                },
                setCascadeOpacityEnabledDirty: function() {
                    this._cascadeOpacityEnabledDirty = true;
                    this.setDirtyFlag(_ccsg.Node._dirtyFlags.opacityDirty);
                },
                getParentToNodeTransform: function() {
                    if (this._dirtyFlag & _ccsg.Node._dirtyFlags.transformDirty) {
                        this._inverse = cc.affineTransformInvert(this.getNodeToParentTransform());
                    }
                    return this._inverse;
                },
                detachFromParent: function() {},
                _updateAnchorPointInPoint: function() {
                    var locAPP = this._anchorPointInPoints, locSize = this._node._contentSize, locAnchorPoint = this._node._anchorPoint;
                    locAPP.x = locSize.width * locAnchorPoint.x;
                    locAPP.y = locSize.height * locAnchorPoint.y;
                    this.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
                },
                setDirtyFlag: function(dirtyFlag) {
                    if (0 === this._dirtyFlag && 0 !== dirtyFlag) {
                        cc.renderer.pushDirtyNode(this);
                    }
                    this._dirtyFlag |= dirtyFlag;
                },
                getParentRenderCmd: function() {
                    if (this._node && this._node._parent && this._node._parent._renderCmd) {
                        return this._node._parent._renderCmd;
                    }
                    return null;
                },
                _updateDisplayColor: function(parentColor) {
                    var node = this._node;
                    var locDispColor = this._displayedColor, locRealColor = node._realColor;
                    var i, len, selChildren, item;
                    if (this._cascadeColorEnabledDirty && !node._cascadeColorEnabled) {
                        locDispColor.r = locRealColor.r;
                        locDispColor.g = locRealColor.g;
                        locDispColor.b = locRealColor.b;
                        var whiteColor = new cc.Color(255, 255, 255, 255);
                        selChildren = node._children;
                        for (i = 0, len = selChildren.length; i < len; i++) {
                            item = selChildren[i];
                            if (item && item._renderCmd) {
                                item._renderCmd._updateDisplayColor(whiteColor);
                            }
                        }
                        this._cascadeColorEnabledDirty = false;
                    } else {
                        if (void 0 === parentColor) {
                            var locParent = node._parent;
                            if (locParent && locParent._cascadeColorEnabled) {
                                parentColor = locParent.getDisplayedColor();
                            } else {
                                parentColor = cc.Color.WHITE;
                            }
                        }
                        locDispColor.r = 0 | locRealColor.r * parentColor.r / 255;
                        locDispColor.g = 0 | locRealColor.g * parentColor.g / 255;
                        locDispColor.b = 0 | locRealColor.b * parentColor.b / 255;
                        if (node._cascadeColorEnabled) {
                            selChildren = node._children;
                            for (i = 0, len = selChildren.length; i < len; i++) {
                                item = selChildren[i];
                                if (item && item._renderCmd) {
                                    item._renderCmd._updateDisplayColor(locDispColor);
                                    item._renderCmd._updateColor();
                                }
                            }
                        }
                    }
                    this._dirtyFlag = this._dirtyFlag & _ccsg.Node._dirtyFlags.colorDirty ^ this._dirtyFlag;
                },
                _updateDisplayOpacity: function(parentOpacity) {
                    var node = this._node;
                    var i, len, selChildren, item;
                    if (this._cascadeOpacityEnabledDirty && !node._cascadeOpacityEnabled) {
                        this._displayedOpacity = node._realOpacity;
                        selChildren = node._children;
                        for (i = 0, len = selChildren.length; i < len; i++) {
                            item = selChildren[i];
                            if (item && item._renderCmd) {
                                item._renderCmd._updateDisplayOpacity(255);
                            }
                        }
                        this._cascadeOpacityEnabledDirty = false;
                    } else {
                        if (void 0 === parentOpacity) {
                            var locParent = node._parent;
                            parentOpacity = 255;
                            if (locParent && locParent._cascadeOpacityEnabled) {
                                parentOpacity = locParent.getDisplayedOpacity();
                            }
                        }
                        this._displayedOpacity = node._realOpacity * parentOpacity / 255;
                        if (node._cascadeOpacityEnabled) {
                            selChildren = node._children;
                            for (i = 0, len = selChildren.length; i < len; i++) {
                                item = selChildren[i];
                                if (item && item._renderCmd) {
                                    item._renderCmd._updateDisplayOpacity(this._displayedOpacity);
                                    item._renderCmd._updateColor();
                                }
                            }
                        }
                    }
                    this._dirtyFlag = this._dirtyFlag & _ccsg.Node._dirtyFlags.opacityDirty ^ this._dirtyFlag;
                },
                _syncDisplayColor: function(parentColor) {
                    var node = this._node, locDispColor = this._displayedColor, locRealColor = node._realColor;
                    if (void 0 === parentColor) {
                        var locParent = node._parent;
                        if (locParent && locParent._cascadeColorEnabled) {
                            parentColor = locParent.getDisplayedColor();
                        } else {
                            parentColor = cc.Color.WHITE;
                        }
                    }
                    locDispColor.r = 0 | locRealColor.r * parentColor.r / 255;
                    locDispColor.g = 0 | locRealColor.g * parentColor.g / 255;
                    locDispColor.b = 0 | locRealColor.b * parentColor.b / 255;
                },
                _syncDisplayOpacity: function(parentOpacity) {
                    var node = this._node;
                    if (void 0 === parentOpacity) {
                        var locParent = node._parent;
                        parentOpacity = 255;
                        if (locParent && locParent._cascadeOpacityEnabled) {
                            parentOpacity = locParent.getDisplayedOpacity();
                        }
                    }
                    this._displayedOpacity = node._realOpacity * parentOpacity / 255;
                },
                _updateColor: function() {},
                updateStatus: function() {
                    var flags = _ccsg.Node._dirtyFlags, locFlag = this._dirtyFlag;
                    var colorDirty = locFlag & flags.colorDirty, opacityDirty = locFlag & flags.opacityDirty;
                    if (colorDirty) {
                        this._updateDisplayColor();
                    }
                    if (opacityDirty) {
                        this._updateDisplayOpacity();
                    }
                    if (colorDirty || opacityDirty) {
                        this._updateColor();
                    }
                    if (locFlag & flags.transformDirty) {
                        this.transform(this.getParentRenderCmd(), true);
                        this._dirtyFlag = this._dirtyFlag & _ccsg.Node._dirtyFlags.transformDirty ^ this._dirtyFlag;
                    }
                },
                getNodeToParentTransform: function() {
                    var node = this._node;
                    if (this._dirtyFlag & _ccsg.Node._dirtyFlags.transformDirty) {
                        var t = this._transform;
                        t.tx = node._position.x;
                        t.ty = node._position.y;
                        var a = 1, b = 0, c = 0, d = 1;
                        if (node._rotationX) {
                            var rotationRadiansX = .017453292519943295 * node._rotationX;
                            c = Math.sin(rotationRadiansX);
                            d = Math.cos(rotationRadiansX);
                        }
                        if (node._rotationY) {
                            var rotationRadiansY = .017453292519943295 * node._rotationY;
                            a = Math.cos(rotationRadiansY);
                            b = -Math.sin(rotationRadiansY);
                        }
                        t.a = a;
                        t.b = b;
                        t.c = c;
                        t.d = d;
                        var lScaleX = node._scaleX, lScaleY = node._scaleY;
                        var appX = this._anchorPointInPoints.x, appY = this._anchorPointInPoints.y;
                        var sx = lScaleX < 1e-6 && lScaleX > -1e-6 ? 1e-6 : lScaleX, sy = lScaleY < 1e-6 && lScaleY > -1e-6 ? 1e-6 : lScaleY;
                        if (1 !== lScaleX || 1 !== lScaleY) {
                            a = t.a *= sx;
                            b = t.b *= sx;
                            c = t.c *= sy;
                            d = t.d *= sy;
                        }
                        if (node._skewX || node._skewY) {
                            var skx = Math.tan(-node._skewX * Math.PI / 180);
                            var sky = Math.tan(-node._skewY * Math.PI / 180);
                            if (skx === 1 / 0) {
                                skx = 99999999;
                            }
                            if (sky === 1 / 0) {
                                sky = 99999999;
                            }
                            var xx = appY * skx;
                            var yy = appX * sky;
                            t.a = a - c * sky;
                            t.b = b - d * sky;
                            t.c = c - a * skx;
                            t.d = d - b * skx;
                            t.tx += a * xx + c * yy;
                            t.ty += b * xx + d * yy;
                        }
                        t.tx -= a * appX + c * appY;
                        t.ty -= b * appX + d * appY;
                        if (node._ignoreAnchorPointForPosition) {
                            t.tx += appX;
                            t.ty += appY;
                        }
                        if (node._additionalTransformDirty) {
                            this._transform = cc.affineTransformConcat(t, node._additionalTransform);
                        }
                    }
                    return this._transform;
                },
                _syncStatus: function(parentCmd) {
                    var flags = _ccsg.Node._dirtyFlags, locFlag = this._dirtyFlag;
                    var parentNode = parentCmd ? parentCmd._node : null;
                    if (parentNode && parentNode._cascadeColorEnabled && parentCmd._dirtyFlag & flags.colorDirty) {
                        locFlag |= flags.colorDirty;
                    }
                    if (parentNode && parentNode._cascadeOpacityEnabled && parentCmd._dirtyFlag & flags.opacityDirty) {
                        locFlag |= flags.opacityDirty;
                    }
                    if (parentCmd && parentCmd._dirtyFlag & flags.transformDirty) {
                        locFlag |= flags.transformDirty;
                    }
                    var colorDirty = locFlag & flags.colorDirty, opacityDirty = locFlag & flags.opacityDirty, transformDirty = locFlag & flags.transformDirty;
                    this._dirtyFlag = locFlag;
                    if (colorDirty) {
                        this._syncDisplayColor();
                    }
                    if (opacityDirty) {
                        this._syncDisplayOpacity();
                    }
                    if (colorDirty) {
                        this._updateColor();
                    }
                    if (transformDirty) {
                        this.transform(parentCmd, true);
                    }
                },
                visitChildren: function() {
                    var node = this._node;
                    var i, children = node._children, child;
                    var len = children.length;
                    if (len > 0) {
                        node.sortAllChildren();
                        for (i = 0; i < len; i++) {
                            child = children[i];
                            if (child._localZOrder < 0) {
                                child._renderCmd.visit(this);
                            } else {
                                break;
                            }
                        }
                        cc.renderer.pushRenderCommand(this);
                        for (;i < len; i++) {
                            children[i]._renderCmd.visit(this);
                        }
                    } else {
                        cc.renderer.pushRenderCommand(this);
                    }
                    this._dirtyFlag = 0;
                }
            };
            !function() {
                _ccsg.Node.CanvasRenderCmd = function(renderable) {
                    _ccsg.Node.RenderCmd.call(this, renderable);
                    this._cachedParent = null;
                    this._cacheDirty = false;
                };
                var proto = _ccsg.Node.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.RenderCmd.prototype);
                proto.constructor = _ccsg.Node.CanvasRenderCmd;
                proto.transform = function(parentCmd, recursive) {
                    var t = this.getNodeToParentTransform(), worldT = this._worldTransform;
                    this._cacheDirty = true;
                    if (parentCmd) {
                        var pt = parentCmd._worldTransform;
                        worldT.a = t.a * pt.a + t.b * pt.c;
                        worldT.b = t.a * pt.b + t.b * pt.d;
                        worldT.c = t.c * pt.a + t.d * pt.c;
                        worldT.d = t.c * pt.b + t.d * pt.d;
                        worldT.tx = pt.a * t.tx + pt.c * t.ty + pt.tx;
                        worldT.ty = pt.d * t.ty + pt.ty + pt.b * t.tx;
                    } else {
                        worldT.a = t.a;
                        worldT.b = t.b;
                        worldT.c = t.c;
                        worldT.d = t.d;
                        worldT.tx = t.tx;
                        worldT.ty = t.ty;
                    }
                    if (recursive) {
                        var locChildren = this._node._children;
                        if (!locChildren || 0 === locChildren.length) {
                            return;
                        }
                        var i, len;
                        for (i = 0, len = locChildren.length; i < len; i++) {
                            locChildren[i]._renderCmd.transform(this, recursive);
                        }
                    }
                };
                proto.visit = function(parentCmd) {
                    var node = this._node;
                    if (!node._visible) {
                        return;
                    }
                    parentCmd = parentCmd || this.getParentRenderCmd();
                    if (parentCmd) {
                        this._curLevel = parentCmd._curLevel + 1;
                    }
                    this._syncStatus(parentCmd);
                    this.visitChildren();
                };
                proto.setDirtyFlag = function(dirtyFlag, child) {
                    _ccsg.Node.RenderCmd.prototype.setDirtyFlag.call(this, dirtyFlag, child);
                    this._setCacheDirty(child);
                    if (this._cachedParent) {
                        this._cachedParent.setDirtyFlag(dirtyFlag, true);
                    }
                };
                proto._setCacheDirty = function() {
                    if (false === this._cacheDirty) {
                        this._cacheDirty = true;
                        var cachedP = this._cachedParent;
                        cachedP && cachedP !== this && cachedP._setNodeDirtyForCache && cachedP._setNodeDirtyForCache();
                    }
                };
                proto._setCachedParent = function(cachedParent) {
                    if (this._cachedParent === cachedParent) {
                        return;
                    }
                    this._cachedParent = cachedParent;
                    var children = this._node._children;
                    for (var i = 0, len = children.length; i < len; i++) {
                        children[i]._renderCmd._setCachedParent(cachedParent);
                    }
                };
                proto.detachFromParent = function() {
                    this._cachedParent = null;
                    var selChildren = this._node._children, item;
                    for (var i = 0, len = selChildren.length; i < len; i++) {
                        item = selChildren[i];
                        if (item && item._renderCmd) {
                            item._renderCmd.detachFromParent();
                        }
                    }
                };
                proto.setShaderProgram = function(shaderProgram) {};
                proto.getShaderProgram = function() {
                    return null;
                };
                _ccsg.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc = function(blendFunc) {
                    if (!blendFunc) {
                        return "source-over";
                    } else {
                        if (blendFunc.src === cc.SRC_ALPHA && blendFunc.dst === cc.ONE || blendFunc.src === cc.ONE && blendFunc.dst === cc.ONE) {
                            return "lighter";
                        } else {
                            if (blendFunc.src === cc.ZERO && blendFunc.dst === cc.SRC_ALPHA) {
                                return "destination-in";
                            } else {
                                if (blendFunc.src === cc.ZERO && blendFunc.dst === cc.ONE_MINUS_SRC_ALPHA) {
                                    return "destination-out";
                                } else {
                                    return "source-over";
                                }
                            }
                        }
                    }
                };
            }();
            !function() {
                _ccsg.Node.WebGLRenderCmd = function(renderable) {
                    _ccsg.Node.RenderCmd.call(this, renderable);
                    var mat4 = new cc.math.Matrix4(), mat = mat4.mat;
                    mat[2] = mat[3] = mat[6] = mat[7] = mat[8] = mat[9] = mat[11] = mat[14] = 0;
                    mat[10] = mat[15] = 1;
                    this._transform4x4 = mat4;
                    this._stackMatrix = new cc.math.Matrix4();
                    this._shaderProgram = null;
                    this._camera = null;
                };
                var proto = _ccsg.Node.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.RenderCmd.prototype);
                proto.constructor = _ccsg.Node.WebGLRenderCmd;
                proto._updateColor = function() {};
                proto.visit = function(parentCmd) {
                    var node = this._node;
                    if (!node._visible) {
                        return;
                    }
                    parentCmd = parentCmd || this.getParentRenderCmd();
                    if (node._parent && node._parent._renderCmd) {
                        this._curLevel = node._parent._renderCmd._curLevel + 1;
                    }
                    var currentStack = cc.current_stack;
                    currentStack.stack.push(currentStack.top);
                    this._syncStatus(parentCmd);
                    currentStack.top = this._stackMatrix;
                    this.visitChildren();
                    currentStack.top = currentStack.stack.pop();
                };
                proto.transform = function(parentCmd, recursive) {
                    var t4x4 = this._transform4x4, stackMatrix = this._stackMatrix, node = this._node;
                    parentCmd = parentCmd || this.getParentRenderCmd();
                    var parentMatrix = parentCmd ? parentCmd._stackMatrix : cc.current_stack.top;
                    var trans = this.getNodeToParentTransform();
                    this._dirtyFlag = this._dirtyFlag & _ccsg.Node._dirtyFlags.transformDirty ^ this._dirtyFlag;
                    var t4x4Mat = t4x4.mat;
                    t4x4Mat[0] = trans.a;
                    t4x4Mat[4] = trans.c;
                    t4x4Mat[12] = trans.tx;
                    t4x4Mat[1] = trans.b;
                    t4x4Mat[5] = trans.d;
                    t4x4Mat[13] = trans.ty;
                    t4x4Mat[14] = node._vertexZ;
                    cc.kmMat4Multiply(stackMatrix, parentMatrix, t4x4);
                    if (!recursive || !node._children || 0 === node._children.length) {
                        return;
                    }
                    var i, len, locChildren = node._children;
                    for (i = 0, len = locChildren.length; i < len; i++) {
                        locChildren[i]._renderCmd.transform(this, recursive);
                    }
                };
                proto.setShaderProgram = function(shaderProgram) {
                    this._shaderProgram = shaderProgram;
                };
                proto.getShaderProgram = function() {
                    return this._shaderProgram;
                };
            }();
            _ccsg.Scene = _ccsg.Node.extend({
                _className: "Scene",
                ctor: function() {
                    _ccsg.Node.prototype.ctor.call(this);
                    this._ignoreAnchorPointForPosition = true;
                    this.setAnchorPoint(.5, .5);
                    this.setContentSize(cc.director.getWinSize());
                }
            });
            _ccsg.Scene.create = function() {
                return new _ccsg.Scene();
            };
            cc.LoaderScene = _ccsg.Scene.extend({
                _interval: null,
                _label: null,
                _className: "LoaderScene",
                _onProjectionChange: null,
                cb: null,
                target: null,
                init: function() {
                    var self = this;
                    var logoWidth = 160;
                    var logoHeight = 200;
                    var bgLayer = self._bgLayer = new cc.LayerColor(cc.color(32, 32, 32, 255));
                    self.addChild(bgLayer, 0);
                    var fontSize = 24, lblHeight = -logoHeight / 2 + 100;
                    if (cc._loaderImage) {
                        cc.loader.loadImg(cc._loaderImage, {
                            isCrossOrigin: false
                        }, function(err, img) {
                            logoWidth = img.width;
                            logoHeight = img.height;
                            self._initStage(img, cc.visibleRect.center);
                        });
                        fontSize = 14;
                        lblHeight = -logoHeight / 2 - 10;
                    }
                    var label = self._label = new cc.LabelTTF("Loading... 0%", "Arial", fontSize);
                    label.setPosition(cc.pAdd(cc.visibleRect.center, cc.p(0, lblHeight)));
                    label.setColor(cc.color(180, 180, 180));
                    bgLayer.addChild(this._label, 10);
                    return true;
                },
                _initStage: function(img, centerPos) {
                    var self = this;
                    var texture2d = self._texture2d = new cc.Texture2D();
                    texture2d.initWithElement(img);
                    texture2d.handleLoadedTexture();
                    var logo = self._logo = new _ccsg.Sprite(texture2d);
                    logo.setScale(cc.contentScaleFactor());
                    logo.x = centerPos.x;
                    logo.y = centerPos.y;
                    self._bgLayer.addChild(logo, 10);
                },
                onEnter: function() {
                    var self = this;
                    _ccsg.Node.prototype.onEnter.call(self);
                    self.schedule(self._startLoading, .3);
                    this._onProjectionChange = function() {
                        self._updateTransform();
                    };
                    cc.director.on(cc.Director.EVENT_PROJECTION_CHANGED, this._onProjectionChange);
                },
                onExit: function() {
                    cc.director.off(cc.Director.EVENT_PROJECTION_CHANGED, this._onProjectionChange);
                    _ccsg.Node.prototype.onExit.call(this);
                    var tmpStr = "Loading... 0%";
                    this._label.setString(tmpStr);
                },
                initWithResources: function(resources, cb, target) {
                    if (cc.js.isString(resources)) {
                        resources = [ resources ];
                    }
                    this.resources = resources || [];
                    this.cb = cb;
                    this.target = target;
                },
                _startLoading: function() {
                    var self = this;
                    self.unschedule(self._startLoading);
                    var res = self.resources;
                    cc.loader.load(res, function(result, count, loadedCount) {
                        var percent = loadedCount / count * 100 | 0;
                        percent = Math.min(percent, 100);
                        self._label.setString("Loading... " + percent + "%");
                    }, function() {
                        if (self.cb) {
                            self.cb.call(self.target);
                        }
                    });
                },
                _updateTransform: function() {
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
                    this._bgLayer._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
                    this._label._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
                    this._logo._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
                }
            });
            cc.LoaderScene.preload = function(resources, cb, target) {
                var _cc = cc;
                if (!_cc.loaderScene) {
                    _cc.loaderScene = new cc.LoaderScene();
                    _cc.loaderScene.init();
                }
                _cc.loaderScene.initWithResources(resources, cb, target);
                cc.director.runScene(_cc.loaderScene);
                return _cc.loaderScene;
            };
            cc.Layer = _ccsg.Node.extend({
                _className: "Layer",
                ctor: function() {
                    var nodep = _ccsg.Node.prototype;
                    nodep.ctor.call(this);
                    this._ignoreAnchorPointForPosition = true;
                    nodep.setAnchorPoint.call(this, .5, .5);
                    nodep.setContentSize.call(this, cc.winSize);
                },
                init: function() {
                    var _t = this;
                    _t._ignoreAnchorPointForPosition = true;
                    _t.setAnchorPoint(.5, .5);
                    _t.setContentSize(cc.winSize);
                    _t._cascadeColorEnabled = false;
                    _t._cascadeOpacityEnabled = false;
                    return true;
                },
                bake: function() {
                    this._renderCmd.bake();
                },
                unbake: function() {
                    this._renderCmd.unbake();
                },
                isBaked: function() {
                    return this._renderCmd._isBaked;
                },
                addChild: function(child, localZOrder, tag) {
                    _ccsg.Node.prototype.addChild.call(this, child, localZOrder, tag);
                    this._renderCmd._bakeForAddChild(child);
                },
                _createRenderCmd: function() {
                    if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                        return new cc.Layer.CanvasRenderCmd(this);
                    } else {
                        return new cc.Layer.WebGLRenderCmd(this);
                    }
                }
            });
            cc.Layer.create = function() {
                return new cc.Layer();
            };
            cc.LayerColor = cc.Layer.extend({
                _blendFunc: null,
                _className: "LayerColor",
                getBlendFunc: function() {
                    return this._blendFunc;
                },
                changeWidthAndHeight: function(w, h) {
                    this.width = w;
                    this.height = h;
                },
                changeWidth: function(w) {
                    this.width = w;
                },
                changeHeight: function(h) {
                    this.height = h;
                },
                setOpacityModifyRGB: function(value) {},
                isOpacityModifyRGB: function() {
                    return false;
                },
                ctor: function(color, width, height) {
                    cc.Layer.prototype.ctor.call(this);
                    this._blendFunc = new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
                    cc.LayerColor.prototype.init.call(this, color, width, height);
                },
                init: function(color, width, height) {
                    if (cc._renderType !== cc.game.RENDER_TYPE_CANVAS) {
                        this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_COLOR);
                    }
                    var winSize = cc.director.getWinSize();
                    color = color || cc.color(0, 0, 0, 255);
                    width = void 0 === width ? winSize.width : width;
                    height = void 0 === height ? winSize.height : height;
                    var locRealColor = this._realColor;
                    locRealColor.r = color.r;
                    locRealColor.g = color.g;
                    locRealColor.b = color.b;
                    this._realOpacity = color.a;
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.colorDirty | _ccsg.Node._dirtyFlags.opacityDirty);
                    cc.LayerColor.prototype.setContentSize.call(this, width, height);
                    return true;
                },
                setBlendFunc: function(src, dst) {
                    var locBlendFunc = this._blendFunc;
                    if (void 0 === dst) {
                        locBlendFunc.src = src.src;
                        locBlendFunc.dst = src.dst;
                    } else {
                        locBlendFunc.src = src;
                        locBlendFunc.dst = dst;
                    }
                    this._renderCmd.updateBlendFunc(locBlendFunc);
                },
                _setWidth: function(width) {
                    _ccsg.Node.prototype._setWidth.call(this, width);
                    this._renderCmd._updateSquareVerticesWidth(width);
                },
                _setHeight: function(height) {
                    _ccsg.Node.prototype._setHeight.call(this, height);
                    this._renderCmd._updateSquareVerticesHeight(height);
                },
                setContentSize: function(size, height) {
                    cc.Layer.prototype.setContentSize.call(this, size, height);
                    this._renderCmd._updateSquareVertices(size, height);
                },
                _createRenderCmd: function() {
                    if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                        return new cc.LayerColor.CanvasRenderCmd(this);
                    } else {
                        return new cc.LayerColor.WebGLRenderCmd(this);
                    }
                }
            });
            cc.LayerColor.create = function(color, width, height) {
                return new cc.LayerColor(color, width, height);
            };
            !function() {
                var proto = cc.LayerColor.prototype;
                cc.defineGetterSetter(proto, "width", proto._getWidth, proto._setWidth);
                cc.defineGetterSetter(proto, "height", proto._getHeight, proto._setHeight);
            }();
            cc.LayerGradient = cc.LayerColor.extend({
                _endColor: null,
                _startOpacity: 255,
                _endOpacity: 255,
                _alongVector: null,
                _compressedInterpolation: false,
                _className: "LayerGradient",
                _colorStops: [],
                ctor: function(start, end, v, stops) {
                    cc.LayerColor.prototype.ctor.call(this);
                    this._endColor = cc.color(0, 0, 0, 255);
                    this._alongVector = cc.p(0, -1);
                    this._startOpacity = 255;
                    this._endOpacity = 255;
                    if (stops && stops instanceof Array) {
                        this._colorStops = stops;
                        stops.splice(0, 0, {
                            p: 0,
                            color: start || cc.Color.BLACK
                        });
                        stops.push({
                            p: 1,
                            color: end || cc.Color.BLACK
                        });
                    } else {
                        this._colorStops = [ {
                            p: 0,
                            color: start || cc.Color.BLACK
                        }, {
                            p: 1,
                            color: end || cc.Color.BLACK
                        } ];
                    }
                    cc.LayerGradient.prototype.init.call(this, start, end, v, stops);
                },
                init: function(start, end, v, stops) {
                    start = start || cc.color(0, 0, 0, 255);
                    end = end || cc.color(0, 0, 0, 255);
                    v = v || cc.p(0, -1);
                    var _t = this;
                    var locEndColor = _t._endColor;
                    _t._startOpacity = start.a;
                    locEndColor.r = end.r;
                    locEndColor.g = end.g;
                    locEndColor.b = end.b;
                    _t._endOpacity = end.a;
                    _t._alongVector = v;
                    _t._compressedInterpolation = true;
                    cc.LayerColor.prototype.init.call(_t, cc.color(start.r, start.g, start.b, 255));
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.colorDirty | _ccsg.Node._dirtyFlags.opacityDirty | _ccsg.Node._dirtyFlags.gradientDirty);
                    return true;
                },
                setContentSize: function(size, height) {
                    cc.LayerColor.prototype.setContentSize.call(this, size, height);
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.gradientDirty);
                },
                _setWidth: function(width) {
                    cc.LayerColor.prototype._setWidth.call(this, width);
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.gradientDirty);
                },
                _setHeight: function(height) {
                    cc.LayerColor.prototype._setHeight.call(this, height);
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.gradientDirty);
                },
                getStartColor: function() {
                    return cc.color(this._realColor);
                },
                setStartColor: function(color) {
                    this.color = color;
                    var stops = this._colorStops;
                    if (stops && stops.length > 0) {
                        var selColor = stops[0].color;
                        selColor.r = color.r;
                        selColor.g = color.g;
                        selColor.b = color.b;
                    }
                },
                setEndColor: function(color) {
                    var locColor = this._endColor;
                    locColor.r = color.r;
                    locColor.g = color.g;
                    locColor.b = color.b;
                    var stops = this._colorStops;
                    if (stops && stops.length > 0) {
                        var selColor = stops[stops.length - 1].color;
                        selColor.r = color.r;
                        selColor.g = color.g;
                        selColor.b = color.b;
                    }
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.colorDirty);
                },
                getEndColor: function() {
                    return cc.color(this._endColor);
                },
                setStartOpacity: function(o) {
                    this._startOpacity = o;
                    var stops = this._colorStops;
                    if (stops && stops.length > 0) {
                        stops[0].color.a = o;
                    }
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.opacityDirty);
                },
                getStartOpacity: function() {
                    return this._startOpacity;
                },
                setEndOpacity: function(o) {
                    this._endOpacity = o;
                    var stops = this._colorStops;
                    if (stops && stops.length > 0) {
                        stops[stops.length - 1].color.a = o;
                    }
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.opacityDirty);
                },
                getEndOpacity: function() {
                    return this._endOpacity;
                },
                setVector: function(Var) {
                    this._alongVector.x = Var.x;
                    this._alongVector.y = Var.y;
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.gradientDirty);
                },
                getVector: function() {
                    return cc.p(this._alongVector.x, this._alongVector.y);
                },
                isCompressedInterpolation: function() {
                    return this._compressedInterpolation;
                },
                setCompressedInterpolation: function(compress) {
                    this._compressedInterpolation = compress;
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.gradientDirty);
                },
                getColorStops: function() {
                    return this._colorStops;
                },
                setColorStops: function(colorStops) {
                    this._colorStops = colorStops;
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.colorDirty | _ccsg.Node._dirtyFlags.opacityDirty | _ccsg.Node._dirtyFlags.gradientDirty);
                },
                _createRenderCmd: function() {
                    if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                        return new cc.LayerGradient.CanvasRenderCmd(this);
                    } else {
                        return new cc.LayerGradient.WebGLRenderCmd(this);
                    }
                }
            });
            cc.LayerGradient.create = function(start, end, v, stops) {
                return new cc.LayerGradient(start, end, v, stops);
            };
            !function() {
                var proto = cc.LayerGradient.prototype;
                proto.startColor;
                cc.defineGetterSetter(proto, "startColor", proto.getStartColor, proto.setStartColor);
                proto.endColor;
                cc.defineGetterSetter(proto, "endColor", proto.getEndColor, proto.setEndColor);
                proto.startOpacity;
                cc.defineGetterSetter(proto, "startOpacity", proto.getStartOpacity, proto.setStartOpacity);
                proto.endOpacity;
                cc.defineGetterSetter(proto, "endOpacity", proto.getEndOpacity, proto.setEndOpacity);
                proto.vector;
                cc.defineGetterSetter(proto, "vector", proto.getVector, proto.setVector);
                proto.colorStops;
                cc.defineGetterSetter(proto, "colorStops", proto.getColorStops, proto.setColorStops);
            }();
            cc.LayerMultiplex = cc.Layer.extend({
                _enabledLayer: 0,
                _layers: null,
                _className: "LayerMultiplex",
                ctor: function(layers) {
                    cc.Layer.prototype.ctor.call(this);
                    if (layers instanceof Array) {
                        cc.LayerMultiplex.prototype.initWithLayers.call(this, layers);
                    } else {
                        cc.LayerMultiplex.prototype.initWithLayers.call(this, Array.prototype.slice.call(arguments));
                    }
                },
                initWithLayers: function(layers) {
                    if (layers.length > 0 && null == layers[layers.length - 1]) {
                        cc.log(cc._LogInfos.LayerMultiplex.initWithLayers);
                    }
                    this._layers = layers;
                    this._enabledLayer = 0;
                    this.addChild(this._layers[this._enabledLayer]);
                    return true;
                },
                switchTo: function(n) {
                    if (n >= this._layers.length) {
                        cc.log(cc._LogInfos.LayerMultiplex.switchTo);
                        return;
                    }
                    this.removeChild(this._layers[this._enabledLayer], true);
                    this._enabledLayer = n;
                    this.addChild(this._layers[n]);
                },
                switchToAndReleaseMe: function(n) {
                    if (n >= this._layers.length) {
                        cc.log(cc._LogInfos.LayerMultiplex.switchToAndReleaseMe);
                        return;
                    }
                    this.removeChild(this._layers[this._enabledLayer], true);
                    this._layers[this._enabledLayer] = null;
                    this._enabledLayer = n;
                    this.addChild(this._layers[n]);
                },
                addLayer: function(layer) {
                    if (!layer) {
                        cc.log(cc._LogInfos.LayerMultiplex.addLayer);
                        return;
                    }
                    this._layers.push(layer);
                }
            });
            cc.LayerMultiplex.create = function() {
                return new cc.LayerMultiplex(Array.prototype.slice.call(arguments));
            };
            !function() {
                cc.Layer.CanvasRenderCmd = function(renderable) {
                    _ccsg.Node.CanvasRenderCmd.call(this, renderable);
                    this._isBaked = false;
                    this._bakeSprite = null;
                    this._updateCache = 2;
                };
                var proto = cc.Layer.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
                proto.constructor = cc.Layer.CanvasRenderCmd;
                proto._setCacheDirty = function(child) {
                    if (child && 0 === this._updateCache) {
                        this._updateCache = 2;
                    }
                    if (false === this._cacheDirty) {
                        this._cacheDirty = true;
                        var cachedP = this._cachedParent;
                        cachedP && cachedP !== this && cachedP._setNodeDirtyForCache && cachedP._setNodeDirtyForCache();
                    }
                };
                proto.transform = function(parentCmd, recursive) {
                    var wt = this._worldTransform;
                    var a = wt.a, b = wt.b, c = wt.c, d = wt.d, tx = wt.tx, ty = wt.ty;
                    _ccsg.Node.CanvasRenderCmd.prototype.transform.call(this, parentCmd, recursive);
                    if ((wt.a !== a || wt.b !== b || wt.c !== c || wt.d !== d) && 0 === this._updateCache) {
                        this._updateCache = 2;
                    }
                };
                proto.bake = function() {
                    if (!this._isBaked) {
                        this._needDraw = true;
                        cc.renderer.childrenOrderDirty = true;
                        this._isBaked = this._cacheDirty = true;
                        if (0 === this._updateCache) {
                            this._updateCache = 2;
                        }
                        var children = this._node._children;
                        for (var i = 0, len = children.length; i < len; i++) {
                            children[i]._renderCmd._setCachedParent(this);
                        }
                        if (!this._bakeSprite) {
                            this._bakeSprite = new cc.BakeSprite();
                            this._bakeSprite.setAnchorPoint(0, 0);
                        }
                    }
                };
                proto.unbake = function() {
                    if (this._isBaked) {
                        cc.renderer.childrenOrderDirty = true;
                        this._needDraw = false;
                        this._isBaked = false;
                        this._cacheDirty = true;
                        if (0 === this._updateCache) {
                            this._updateCache = 2;
                        }
                        var children = this._node._children;
                        for (var i = 0, len = children.length; i < len; i++) {
                            children[i]._renderCmd._setCachedParent(null);
                        }
                    }
                };
                proto.isBaked = function() {
                    return this._isBaked;
                };
                proto.rendering = function() {
                    if (this._cacheDirty) {
                        var node = this._node;
                        var children = node._children, locBakeSprite = this._bakeSprite;
                        this.transform(this.getParentRenderCmd(), true);
                        var boundingBox = this._getBoundingBoxForBake();
                        boundingBox.width = 0 | boundingBox.width + .5;
                        boundingBox.height = 0 | boundingBox.height + .5;
                        var bakeContext = locBakeSprite.getCacheContext();
                        var ctx = bakeContext.getContext();
                        locBakeSprite.setPosition(boundingBox.x, boundingBox.y);
                        if (this._updateCache > 0) {
                            locBakeSprite.resetCanvasSize(boundingBox.width, boundingBox.height);
                            bakeContext.setOffset(0 - boundingBox.x, ctx.canvas.height - boundingBox.height + boundingBox.y);
                            node.sortAllChildren();
                            cc.renderer._turnToCacheMode(this.__instanceId);
                            for (var i = 0, len = children.length; i < len; i++) {
                                children[i].visit(this);
                            }
                            cc.renderer._renderingToCacheCanvas(bakeContext, this.__instanceId);
                            locBakeSprite.transform();
                            this._updateCache--;
                        }
                        this._cacheDirty = false;
                    }
                };
                proto.visit = function(parentCmd) {
                    if (!this._isBaked) {
                        _ccsg.Node.CanvasRenderCmd.prototype.visit.call(this, parentCmd);
                        return;
                    }
                    var node = this._node, children = node._children;
                    var len = children.length;
                    if (!node._visible || 0 === len) {
                        return;
                    }
                    this._syncStatus(parentCmd);
                    cc.renderer.pushRenderCommand(this);
                    this._cacheDirty = true;
                    if (0 === this._updateCache) {
                        this._updateCache = 2;
                    }
                    this._bakeSprite.visit(this);
                    this._dirtyFlag = 0;
                };
                proto._bakeForAddChild = function(child) {
                    if (child._parent === this._node && this._isBaked) {
                        child._renderCmd._setCachedParent(this);
                    }
                };
                proto._getBoundingBoxForBake = function() {
                    var rect = null, node = this._node;
                    if (!node._children || 0 === node._children.length) {
                        return cc.rect(0, 0, 10, 10);
                    }
                    var trans = node.getNodeToWorldTransform();
                    var locChildren = node._children;
                    for (var i = 0, len = locChildren.length; i < len; i++) {
                        var child = locChildren[i];
                        if (child && child._visible) {
                            if (rect) {
                                var childRect = child._getBoundingBoxToCurrentNode(trans);
                                if (childRect) {
                                    rect = cc.rectUnion(rect, childRect);
                                }
                            } else {
                                rect = child._getBoundingBoxToCurrentNode(trans);
                            }
                        }
                    }
                    return rect;
                };
            }();
            !function() {
                cc.LayerColor.CanvasRenderCmd = function(renderable) {
                    cc.Layer.CanvasRenderCmd.call(this, renderable);
                    this._needDraw = true;
                    this._blendFuncStr = "source-over";
                    this._bakeRenderCmd = new cc.CustomRenderCmd(this, this._bakeRendering);
                };
                var proto = cc.LayerColor.CanvasRenderCmd.prototype = Object.create(cc.Layer.CanvasRenderCmd.prototype);
                proto.constructor = cc.LayerColor.CanvasRenderCmd;
                proto.unbake = function() {
                    cc.Layer.CanvasRenderCmd.prototype.unbake.call(this);
                    this._needDraw = true;
                };
                proto.rendering = function(ctx, scaleX, scaleY) {
                    var wrapper = ctx || cc._renderContext, context = wrapper.getContext(), node = this._node, curColor = this._displayedColor, opacity = this._displayedOpacity / 255, locWidth = node._contentSize.width, locHeight = node._contentSize.height;
                    if (0 === opacity) {
                        return;
                    }
                    wrapper.setCompositeOperation(this._blendFuncStr);
                    wrapper.setGlobalAlpha(opacity);
                    wrapper.setFillStyle("rgba(" + (0 | curColor.r) + "," + (0 | curColor.g) + "," + (0 | curColor.b) + ", 1)");
                    wrapper.setTransform(this._worldTransform, scaleX, scaleY);
                    context.fillRect(0, 0, locWidth * scaleX, -locHeight * scaleY);
                    cc.g_NumberOfDraws++;
                };
                proto.updateBlendFunc = function(blendFunc) {
                    this._blendFuncStr = _ccsg.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc(blendFunc);
                };
                proto._updateSquareVertices = proto._updateSquareVerticesWidth = proto._updateSquareVerticesHeight = function() {};
                proto._bakeRendering = function() {
                    if (this._cacheDirty) {
                        var node = this._node;
                        var locBakeSprite = this._bakeSprite, children = node._children;
                        var len = children.length, i;
                        this.transform(this.getParentRenderCmd(), true);
                        var boundingBox = this._getBoundingBoxForBake();
                        boundingBox.width = 0 | boundingBox.width + .5;
                        boundingBox.height = 0 | boundingBox.height + .5;
                        var bakeContext = locBakeSprite.getCacheContext();
                        var ctx = bakeContext.getContext();
                        locBakeSprite.setPosition(boundingBox.x, boundingBox.y);
                        if (this._updateCache > 0) {
                            ctx.fillStyle = bakeContext._currentFillStyle;
                            locBakeSprite.resetCanvasSize(boundingBox.width, boundingBox.height);
                            bakeContext.setOffset(0 - boundingBox.x, ctx.canvas.height - boundingBox.height + boundingBox.y);
                            var child;
                            cc.renderer._turnToCacheMode(this.__instanceId);
                            if (len > 0) {
                                node.sortAllChildren();
                                for (i = 0; i < len; i++) {
                                    child = children[i];
                                    if (child._localZOrder < 0) {
                                        child._renderCmd.visit(this);
                                    } else {
                                        break;
                                    }
                                }
                                cc.renderer.pushRenderCommand(this);
                                for (;i < len; i++) {
                                    children[i]._renderCmd.visit(this);
                                }
                            } else {
                                cc.renderer.pushRenderCommand(this);
                            }
                            cc.renderer._renderingToCacheCanvas(bakeContext, this.__instanceId);
                            locBakeSprite.transform();
                            this._updateCache--;
                        }
                        this._cacheDirty = false;
                    }
                };
                proto.visit = function(parentCmd) {
                    if (!this._isBaked) {
                        _ccsg.Node.CanvasRenderCmd.prototype.visit.call(this, parentCmd);
                        return;
                    }
                    var node = this._node;
                    if (!node._visible) {
                        return;
                    }
                    this._syncStatus(parentCmd);
                    cc.renderer.pushRenderCommand(this._bakeRenderCmd);
                    this._bakeSprite._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
                    this._bakeSprite.visit(this);
                    this._dirtyFlag = 0;
                };
                proto._getBoundingBoxForBake = function() {
                    var node = this._node;
                    var rect = cc.rect(0, 0, node._contentSize.width, node._contentSize.height);
                    var trans = node.getNodeToWorldTransform();
                    rect = cc.rectApplyAffineTransform(rect, node.getNodeToWorldTransform());
                    if (!node._children || 0 === node._children.length) {
                        return rect;
                    }
                    var locChildren = node._children;
                    for (var i = 0; i < locChildren.length; i++) {
                        var child = locChildren[i];
                        if (child && child._visible) {
                            var childRect = child._getBoundingBoxToCurrentNode(trans);
                            rect = cc.rectUnion(rect, childRect);
                        }
                    }
                    return rect;
                };
            }();
            !function() {
                cc.LayerGradient.RenderCmd = {
                    updateStatus: function() {
                        var flags = _ccsg.Node._dirtyFlags, locFlag = this._dirtyFlag;
                        var colorDirty = locFlag & flags.colorDirty, opacityDirty = locFlag & flags.opacityDirty;
                        if (colorDirty) {
                            this._updateDisplayColor();
                        }
                        if (opacityDirty) {
                            this._updateDisplayOpacity();
                        }
                        if (colorDirty || opacityDirty || locFlag & flags.gradientDirty) {
                            this._updateColor();
                        }
                        if (locFlag & flags.transformDirty) {
                            this.transform(this.getParentRenderCmd(), true);
                        }
                        this._dirtyFlag = 0;
                    }
                };
            }();
            !function() {
                cc.LayerGradient.CanvasRenderCmd = function(renderable) {
                    cc.LayerColor.CanvasRenderCmd.call(this, renderable);
                    this._needDraw = true;
                    this._startPoint = cc.p(0, 0);
                    this._endPoint = cc.p(0, 0);
                    this._startStopStr = null;
                    this._endStopStr = null;
                };
                var proto = cc.LayerGradient.CanvasRenderCmd.prototype = Object.create(cc.LayerColor.CanvasRenderCmd.prototype);
                cc.js.mixin(proto, cc.LayerGradient.RenderCmd);
                proto.constructor = cc.LayerGradient.CanvasRenderCmd;
                proto.rendering = function(ctx, scaleX, scaleY) {
                    var wrapper = ctx || cc._renderContext, context = wrapper.getContext(), node = this._node, opacity = this._displayedOpacity / 255;
                    if (0 === opacity) {
                        return;
                    }
                    var locWidth = node._contentSize.width, locHeight = node._contentSize.height;
                    wrapper.setCompositeOperation(this._blendFuncStr);
                    wrapper.setGlobalAlpha(opacity);
                    var gradient = context.createLinearGradient(this._startPoint.x * scaleX, this._startPoint.y * scaleY, this._endPoint.x * scaleX, this._endPoint.y * scaleY);
                    if (node._colorStops) {
                        for (var i = 0; i < node._colorStops.length; i++) {
                            var stop = node._colorStops[i];
                            gradient.addColorStop(stop.p, this._colorStopsStr[i]);
                        }
                    } else {
                        gradient.addColorStop(0, this._startStopStr);
                        gradient.addColorStop(1, this._endStopStr);
                    }
                    wrapper.setFillStyle(gradient);
                    wrapper.setTransform(this._worldTransform, scaleX, scaleY);
                    context.fillRect(0, 0, locWidth * scaleX, -locHeight * scaleY);
                    cc.g_NumberOfDraws++;
                };
                proto._syncStatus = function(parentCmd) {
                    var flags = _ccsg.Node._dirtyFlags, locFlag = this._dirtyFlag;
                    var parentNode = parentCmd ? parentCmd._node : null;
                    if (parentNode && parentNode._cascadeColorEnabled && parentCmd._dirtyFlag & flags.colorDirty) {
                        locFlag |= flags.colorDirty;
                    }
                    if (parentNode && parentNode._cascadeOpacityEnabled && parentCmd._dirtyFlag & flags.opacityDirty) {
                        locFlag |= flags.opacityDirty;
                    }
                    if (parentCmd && parentCmd._dirtyFlag & flags.transformDirty) {
                        locFlag |= flags.transformDirty;
                    }
                    var colorDirty = locFlag & flags.colorDirty, opacityDirty = locFlag & flags.opacityDirty;
                    this._dirtyFlag = locFlag;
                    if (colorDirty) {
                        this._syncDisplayColor();
                    }
                    if (opacityDirty) {
                        this._syncDisplayOpacity();
                    }
                    if (locFlag & flags.transformDirty) {
                        this.transform(parentCmd);
                    }
                    if (colorDirty || opacityDirty || locFlag & flags.gradientDirty) {
                        this._updateColor();
                    }
                };
                proto._updateColor = function() {
                    var node = this._node;
                    var contentSize = node._contentSize;
                    var tWidth = .5 * contentSize.width, tHeight = .5 * contentSize.height;
                    this._dirtyFlag = this._dirtyFlag & _ccsg.Node._dirtyFlags.gradientDirty ^ this._dirtyFlag;
                    var angle = cc.pAngleSigned(cc.p(0, -1), node._alongVector);
                    var p1 = cc.pRotateByAngle(cc.p(0, -1), cc.p(0, 0), angle);
                    var factor = Math.min(Math.abs(1 / p1.x), Math.abs(1 / p1.y));
                    this._startPoint.x = tWidth * -p1.x * factor + tWidth;
                    this._startPoint.y = tHeight * p1.y * factor - tHeight;
                    this._endPoint.x = tWidth * p1.x * factor + tWidth;
                    this._endPoint.y = tHeight * -p1.y * factor - tHeight;
                    var locStartColor = this._displayedColor, locEndColor = node._endColor;
                    var startOpacity = node._startOpacity / 255, endOpacity = node._endOpacity / 255;
                    this._startStopStr = "rgba(" + Math.round(locStartColor.r) + "," + Math.round(locStartColor.g) + "," + Math.round(locStartColor.b) + "," + startOpacity.toFixed(4) + ")";
                    this._endStopStr = "rgba(" + Math.round(locEndColor.r) + "," + Math.round(locEndColor.g) + "," + Math.round(locEndColor.b) + "," + endOpacity.toFixed(4) + ")";
                    if (node._colorStops) {
                        this._startOpacity = 0;
                        this._endOpacity = 0;
                        this._colorStopsStr = [];
                        for (var i = 0; i < node._colorStops.length; i++) {
                            var stopColor = node._colorStops[i].color;
                            var stopOpacity = null == stopColor.a ? 1 : stopColor.a / 255;
                            this._colorStopsStr.push("rgba(" + Math.round(stopColor.r) + "," + Math.round(stopColor.g) + "," + Math.round(stopColor.b) + "," + stopOpacity.toFixed(4) + ")");
                        }
                    }
                };
            }();
            !function() {
                cc.Layer.WebGLRenderCmd = function(renderable) {
                    _ccsg.Node.WebGLRenderCmd.call(this, renderable);
                };
                var proto = cc.Layer.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
                proto.constructor = cc.Layer.WebGLRenderCmd;
                proto.bake = function() {};
                proto.unbake = function() {};
                proto._bakeForAddChild = function() {};
            }();
            !function() {
                cc.LayerColor.WebGLRenderCmd = function(renderable) {
                    cc.Layer.WebGLRenderCmd.call(this, renderable);
                    this._needDraw = true;
                    var _t = this;
                    _t._squareVerticesAB = new ArrayBuffer(32);
                    _t._squareColorsAB = new ArrayBuffer(16);
                    var locSquareVerticesAB = _t._squareVerticesAB, locSquareColorsAB = _t._squareColorsAB;
                    var locVertex2FLen = cc.Vertex2F.BYTES_PER_ELEMENT, locColorLen = cc.WebGLColor.BYTES_PER_ELEMENT;
                    _t._squareVertices = [ new cc.Vertex2F(0, 0, locSquareVerticesAB, 0), new cc.Vertex2F(0, 0, locSquareVerticesAB, locVertex2FLen), new cc.Vertex2F(0, 0, locSquareVerticesAB, 2 * locVertex2FLen), new cc.Vertex2F(0, 0, locSquareVerticesAB, 3 * locVertex2FLen) ];
                    _t._squareColors = [ new cc.WebGLColor(0, 0, 0, 255, locSquareColorsAB, 0), new cc.WebGLColor(0, 0, 0, 255, locSquareColorsAB, locColorLen), new cc.WebGLColor(0, 0, 0, 255, locSquareColorsAB, 2 * locColorLen), new cc.WebGLColor(0, 0, 0, 255, locSquareColorsAB, 3 * locColorLen) ];
                    _t._verticesFloat32Buffer = cc._renderContext.createBuffer();
                    _t._colorsUint8Buffer = cc._renderContext.createBuffer();
                };
                var proto = cc.LayerColor.WebGLRenderCmd.prototype = Object.create(cc.Layer.WebGLRenderCmd.prototype);
                proto.constructor = cc.LayerColor.WebGLRenderCmd;
                proto.rendering = function(ctx) {
                    var context = ctx || cc._renderContext;
                    var node = this._node;
                    this._shaderProgram.use();
                    this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
                    cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR);
                    cc.glBlendFunc(node._blendFunc.src, node._blendFunc.dst);
                    context.bindBuffer(context.ARRAY_BUFFER, this._verticesFloat32Buffer);
                    context.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, context.FLOAT, false, 0, 0);
                    context.bindBuffer(context.ARRAY_BUFFER, this._colorsUint8Buffer);
                    context.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, context.UNSIGNED_BYTE, true, 0, 0);
                    context.drawArrays(context.TRIANGLE_STRIP, 0, this._squareVertices.length);
                };
                proto._updateSquareVertices = function(size, height) {
                    var locSquareVertices = this._squareVertices;
                    if (void 0 === height) {
                        locSquareVertices[1].x = size.width;
                        locSquareVertices[2].y = size.height;
                        locSquareVertices[3].x = size.width;
                        locSquareVertices[3].y = size.height;
                    } else {
                        locSquareVertices[1].x = size;
                        locSquareVertices[2].y = height;
                        locSquareVertices[3].x = size;
                        locSquareVertices[3].y = height;
                    }
                    this._bindLayerVerticesBufferData();
                };
                proto._updateSquareVerticesWidth = function(width) {
                    var locSquareVertices = this._squareVertices;
                    locSquareVertices[1].x = width;
                    locSquareVertices[3].x = width;
                    this._bindLayerVerticesBufferData();
                };
                proto._updateSquareVerticesHeight = function(height) {
                    var locSquareVertices = this._squareVertices;
                    locSquareVertices[2].y = height;
                    locSquareVertices[3].y = height;
                    this._bindLayerVerticesBufferData();
                };
                proto._updateColor = function() {
                    var locDisplayedColor = this._displayedColor, locDisplayedOpacity = this._displayedOpacity, locSquareColors = this._squareColors;
                    for (var i = 0; i < 4; i++) {
                        locSquareColors[i].r = locDisplayedColor.r;
                        locSquareColors[i].g = locDisplayedColor.g;
                        locSquareColors[i].b = locDisplayedColor.b;
                        locSquareColors[i].a = locDisplayedOpacity;
                    }
                    this._bindLayerColorsBufferData();
                };
                proto._bindLayerVerticesBufferData = function() {
                    var glContext = cc._renderContext;
                    glContext.bindBuffer(glContext.ARRAY_BUFFER, this._verticesFloat32Buffer);
                    glContext.bufferData(glContext.ARRAY_BUFFER, this._squareVerticesAB, glContext.STATIC_DRAW);
                };
                proto._bindLayerColorsBufferData = function() {
                    var glContext = cc._renderContext;
                    glContext.bindBuffer(glContext.ARRAY_BUFFER, this._colorsUint8Buffer);
                    glContext.bufferData(glContext.ARRAY_BUFFER, this._squareColorsAB, glContext.STATIC_DRAW);
                };
                proto.updateBlendFunc = function(blendFunc) {};
            }();
            !function() {
                cc.LayerGradient.WebGLRenderCmd = function(renderable) {
                    cc.LayerColor.WebGLRenderCmd.call(this, renderable);
                    this._needDraw = true;
                    this._clipRect = new cc.Rect();
                    this._clippingRectDirty = false;
                };
                var proto = cc.LayerGradient.WebGLRenderCmd.prototype = Object.create(cc.LayerColor.WebGLRenderCmd.prototype);
                cc.js.mixin(proto, cc.LayerGradient.RenderCmd);
                proto.constructor = cc.LayerGradient.WebGLRenderCmd;
                proto._syncStatus = function(parentCmd) {
                    var flags = _ccsg.Node._dirtyFlags, locFlag = this._dirtyFlag;
                    var parentNode = parentCmd ? parentCmd._node : null;
                    if (parentNode && parentNode._cascadeColorEnabled && parentCmd._dirtyFlag & flags.colorDirty) {
                        locFlag |= flags.colorDirty;
                    }
                    if (parentNode && parentNode._cascadeOpacityEnabled && parentCmd._dirtyFlag & flags.opacityDirty) {
                        locFlag |= flags.opacityDirty;
                    }
                    if (parentCmd && parentCmd._dirtyFlag & flags.transformDirty) {
                        locFlag |= flags.transformDirty;
                    }
                    var colorDirty = locFlag & flags.colorDirty, opacityDirty = locFlag & flags.opacityDirty;
                    this._dirtyFlag = locFlag;
                    if (colorDirty) {
                        this._syncDisplayColor();
                    }
                    if (opacityDirty) {
                        this._syncDisplayOpacity();
                    }
                    this.transform(parentCmd);
                    if (colorDirty || opacityDirty || locFlag & flags.gradientDirty) {
                        this._updateColor();
                    }
                };
                proto._updateColor = function() {
                    this._dirtyFlag = this._dirtyFlag & _ccsg.Node._dirtyFlags.gradientDirty ^ this._dirtyFlag;
                    var node = this._node, stops = node._colorStops;
                    if (!stops || stops.length < 2) {
                        return;
                    }
                    this._clippingRectDirty = true;
                    var stopsLen = stops.length, verticesLen = 2 * stopsLen, i, contentSize = node._contentSize;
                    this._squareVerticesAB = new ArrayBuffer(8 * verticesLen);
                    this._squareColorsAB = new ArrayBuffer(4 * verticesLen);
                    var locVertices = this._squareVertices, locColors = this._squareColors;
                    locVertices.length = 0;
                    locColors.length = 0;
                    var locSquareVerticesAB = this._squareVerticesAB, locSquareColorsAB = this._squareColorsAB;
                    var locVertex2FLen = cc.Vertex2F.BYTES_PER_ELEMENT, locColorLen = cc.WebGLColor.BYTES_PER_ELEMENT;
                    for (i = 0; i < verticesLen; i++) {
                        locVertices.push(new cc.Vertex2F(0, 0, locSquareVerticesAB, locVertex2FLen * i));
                        locColors.push(new cc.WebGLColor(0, 0, 0, 255, locSquareColorsAB, locColorLen * i));
                    }
                    var angle = Math.PI + cc.pAngleSigned(cc.p(0, -1), node._alongVector), locAnchor = cc.p(contentSize.width / 2, contentSize.height / 2);
                    var degrees = Math.round(cc.radiansToDegrees(angle));
                    var transMat = cc.affineTransformMake(1, 0, 0, 1, locAnchor.x, locAnchor.y);
                    transMat = cc.affineTransformRotate(transMat, angle);
                    var a, b;
                    if (degrees < 90) {
                        a = cc.p(-locAnchor.x, locAnchor.y);
                        b = cc.p(locAnchor.x, locAnchor.y);
                    } else {
                        if (degrees < 180) {
                            a = cc.p(locAnchor.x, locAnchor.y);
                            b = cc.p(locAnchor.x, -locAnchor.y);
                        } else {
                            if (degrees < 270) {
                                a = cc.p(locAnchor.x, -locAnchor.y);
                                b = cc.p(-locAnchor.x, -locAnchor.y);
                            } else {
                                a = cc.p(-locAnchor.x, -locAnchor.y);
                                b = cc.p(-locAnchor.x, locAnchor.y);
                            }
                        }
                    }
                    var sin = Math.sin(angle), cos = Math.cos(angle);
                    var tx = Math.abs((a.x * cos - a.y * sin) / locAnchor.x), ty = Math.abs((b.x * sin + b.y * cos) / locAnchor.y);
                    transMat = cc.affineTransformScale(transMat, tx, ty);
                    for (i = 0; i < stopsLen; i++) {
                        var stop = stops[i], y = stop.p * contentSize.height;
                        var p0 = cc.pointApplyAffineTransform(-locAnchor.x, y - locAnchor.y, transMat);
                        locVertices[2 * i].x = p0.x;
                        locVertices[2 * i].y = p0.y;
                        var p1 = cc.pointApplyAffineTransform(contentSize.width - locAnchor.x, y - locAnchor.y, transMat);
                        locVertices[2 * i + 1].x = p1.x;
                        locVertices[2 * i + 1].y = p1.y;
                    }
                    var opacityf = this._displayedOpacity / 255;
                    for (i = 0; i < stopsLen; i++) {
                        var stopColor = stops[i].color, locSquareColor0 = locColors[2 * i], locSquareColor1 = locColors[2 * i + 1];
                        locSquareColor0.r = stopColor.r;
                        locSquareColor0.g = stopColor.g;
                        locSquareColor0.b = stopColor.b;
                        locSquareColor0.a = stopColor.a * opacityf;
                        locSquareColor1.r = stopColor.r;
                        locSquareColor1.g = stopColor.g;
                        locSquareColor1.b = stopColor.b;
                        locSquareColor1.a = stopColor.a * opacityf;
                    }
                    this._bindLayerVerticesBufferData();
                    this._bindLayerColorsBufferData();
                };
                proto.rendering = function(ctx) {
                    var context = ctx || cc._renderContext, node = this._node;
                    var clippingRect = this._getClippingRect();
                    context.enable(context.SCISSOR_TEST);
                    cc.view.setScissorInPoints(clippingRect.x, clippingRect.y, clippingRect.width, clippingRect.height);
                    this._shaderProgram.use();
                    this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
                    cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR);
                    cc.glBlendFunc(node._blendFunc.src, node._blendFunc.dst);
                    context.bindBuffer(context.ARRAY_BUFFER, this._verticesFloat32Buffer);
                    context.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, context.FLOAT, false, 0, 0);
                    context.bindBuffer(context.ARRAY_BUFFER, this._colorsUint8Buffer);
                    context.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, context.UNSIGNED_BYTE, true, 0, 0);
                    context.drawArrays(context.TRIANGLE_STRIP, 0, this._squareVertices.length);
                    context.disable(context.SCISSOR_TEST);
                };
                proto._getClippingRect = function() {
                    if (this._clippingRectDirty) {
                        var node = this._node;
                        var rect = cc.rect(0, 0, node._contentSize.width, node._contentSize.height);
                        var trans = node.getNodeToWorldTransform();
                        this._clipRect = cc._rectApplyAffineTransformIn(rect, trans);
                    }
                    return this._clipRect;
                };
            }();
            cc._tmp.PrototypeSprite = function() {
                var _p = _ccsg.Sprite.prototype;
                cc.defineGetterSetter(_p, "opacityModifyRGB", _p.isOpacityModifyRGB, _p.setOpacityModifyRGB);
                cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
                cc.defineGetterSetter(_p, "color", _p.getColor, _p.setColor);
                _p.dirty;
                _p.flippedX;
                cc.defineGetterSetter(_p, "flippedX", _p.isFlippedX, _p.setFlippedX);
                _p.flippedY;
                cc.defineGetterSetter(_p, "flippedY", _p.isFlippedY, _p.setFlippedY);
                _p.offsetX;
                cc.defineGetterSetter(_p, "offsetX", _p._getOffsetX);
                _p.offsetY;
                cc.defineGetterSetter(_p, "offsetY", _p._getOffsetY);
                _p.atlasIndex;
                _p.texture;
                cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
                _p.textureRectRotated;
                cc.defineGetterSetter(_p, "textureRectRotated", _p.isTextureRectRotated);
                _p.textureAtlas;
                _p.batchNode;
                cc.defineGetterSetter(_p, "batchNode", _p.getBatchNode, _p.setBatchNode);
                _p.quad;
                cc.defineGetterSetter(_p, "quad", _p.getQuad);
            };
            var EventTarget = require("../cocos2d/core/event/event-target");
            _ccsg.Sprite = _ccsg.Node.extend({
                dirty: false,
                atlasIndex: 0,
                textureAtlas: null,
                _batchNode: null,
                _recursiveDirty: null,
                _hasChildren: null,
                _shouldBeHidden: false,
                _transformToBatch: null,
                _blendFunc: null,
                _texture: null,
                _rect: null,
                _rectRotated: false,
                _offsetPosition: null,
                _unflippedOffsetPositionFromCenter: null,
                _opacityModifyRGB: false,
                _flippedX: false,
                _flippedY: false,
                _textureLoaded: false,
                _className: "Sprite",
                ctor: function(fileName, rect, rotated) {
                    var self = this;
                    _ccsg.Node.prototype.ctor.call(self);
                    EventTarget.call(self);
                    self._shouldBeHidden = false;
                    self._offsetPosition = cc.p(0, 0);
                    self._unflippedOffsetPositionFromCenter = cc.p(0, 0);
                    self._blendFunc = {
                        src: cc.BLEND_SRC,
                        dst: cc.BLEND_DST
                    };
                    self._rect = cc.rect(0, 0, 0, 0);
                    self._softInit(fileName, rect, rotated);
                },
                textureLoaded: function() {
                    return this._textureLoaded;
                },
                addLoadedEventListener: function(callback, target) {
                    this.once("load", callback, target);
                },
                isDirty: function() {
                    return this.dirty;
                },
                setDirty: function(bDirty) {
                    this.dirty = bDirty;
                },
                isTextureRectRotated: function() {
                    return this._rectRotated;
                },
                getAtlasIndex: function() {
                    return this.atlasIndex;
                },
                setAtlasIndex: function(atlasIndex) {
                    this.atlasIndex = atlasIndex;
                },
                getTextureRect: function() {
                    return cc.rect(this._rect);
                },
                getTextureAtlas: function() {
                    return this.textureAtlas;
                },
                setTextureAtlas: function(textureAtlas) {
                    this.textureAtlas = textureAtlas;
                },
                getOffsetPosition: function() {
                    return cc.p(this._offsetPosition);
                },
                _getOffsetX: function() {
                    return this._offsetPosition.x;
                },
                _getOffsetY: function() {
                    return this._offsetPosition.y;
                },
                getBlendFunc: function() {
                    return this._blendFunc;
                },
                initWithSpriteFrame: function(spriteFrame) {
                    cc.assert(spriteFrame, cc._LogInfos.Sprite.initWithSpriteFrame);
                    if (!spriteFrame.textureLoaded()) {
                        this._textureLoaded = false;
                        spriteFrame.once("load", this._renderCmd._spriteFrameLoadedCallback, this._renderCmd);
                    }
                    var rotated = cc._renderType === cc.game.RENDER_TYPE_CANVAS ? false : spriteFrame._rotated;
                    var ret = this.initWithTexture(spriteFrame.getTexture(), spriteFrame.getRect(), rotated);
                    this.setSpriteFrame(spriteFrame);
                    return ret;
                },
                initWithSpriteFrameName: function(spriteFrameName) {
                    cc.assert(spriteFrameName, cc._LogInfos.Sprite.initWithSpriteFrameName);
                    var frame = cc.spriteFrameCache.getSpriteFrame(spriteFrameName);
                    cc.assert(frame, spriteFrameName + cc._LogInfos.Sprite.initWithSpriteFrameName1);
                    return this.initWithSpriteFrame(frame);
                },
                useBatchNode: function(batchNode) {
                    this.textureAtlas = batchNode.getTextureAtlas();
                    this._batchNode = batchNode;
                },
                setVertexRect: function(rect) {
                    var locRect = this._rect;
                    locRect.x = rect.x;
                    locRect.y = rect.y;
                    locRect.width = rect.width;
                    locRect.height = rect.height;
                },
                sortAllChildren: function() {
                    if (this._reorderChildDirty) {
                        var _children = this._children;
                        var len = _children.length, i, j, tmp;
                        for (i = 1; i < len; i++) {
                            tmp = _children[i];
                            j = i - 1;
                            while (j >= 0) {
                                if (tmp._localZOrder < _children[j]._localZOrder) {
                                    _children[j + 1] = _children[j];
                                } else {
                                    if (tmp._localZOrder === _children[j]._localZOrder && tmp.arrivalOrder < _children[j].arrivalOrder) {
                                        _children[j + 1] = _children[j];
                                    } else {
                                        break;
                                    }
                                }
                                j--;
                            }
                            _children[j + 1] = tmp;
                        }
                        if (this._batchNode) {
                            this._arrayMakeObjectsPerformSelector(_children, _ccsg.Node._stateCallbackType.sortAllChildren);
                        }
                        this._reorderChildDirty = false;
                    }
                },
                reorderChild: function(child, zOrder) {
                    cc.assert(child, cc._LogInfos.Sprite.reorderChild_2);
                    if (-1 === this._children.indexOf(child)) {
                        cc.log(cc._LogInfos.Sprite.reorderChild);
                        return;
                    }
                    if (zOrder === child.zIndex) {
                        return;
                    }
                    if (this._batchNode && !this._reorderChildDirty) {
                        this._setReorderChildDirtyRecursively();
                        this._batchNode.reorderBatch(true);
                    }
                    _ccsg.Node.prototype.reorderChild.call(this, child, zOrder);
                },
                removeChild: function(child, cleanup) {
                    if (this._batchNode) {
                        this._batchNode.removeSpriteFromAtlas(child);
                    }
                    _ccsg.Node.prototype.removeChild.call(this, child, cleanup);
                },
                setVisible: function(visible) {
                    _ccsg.Node.prototype.setVisible.call(this, visible);
                    this._renderCmd.setDirtyRecursively(true);
                },
                removeAllChildren: function(cleanup) {
                    var locChildren = this._children, locBatchNode = this._batchNode;
                    if (locBatchNode && null != locChildren) {
                        for (var i = 0, len = locChildren.length; i < len; i++) {
                            locBatchNode.removeSpriteFromAtlas(locChildren[i]);
                        }
                    }
                    _ccsg.Node.prototype.removeAllChildren.call(this, cleanup);
                    this._hasChildren = false;
                },
                ignoreAnchorPointForPosition: function(relative) {
                    if (this._batchNode) {
                        cc.log(cc._LogInfos.Sprite.ignoreAnchorPointForPosition);
                        return;
                    }
                    _ccsg.Node.prototype.ignoreAnchorPointForPosition.call(this, relative);
                },
                setFlippedX: function(flippedX) {
                    if (this._flippedX !== flippedX) {
                        this._flippedX = flippedX;
                        this.setTextureRect(this._rect, this._rectRotated, this._contentSize);
                        this.setNodeDirty(true);
                    }
                },
                setFlippedY: function(flippedY) {
                    if (this._flippedY !== flippedY) {
                        this._flippedY = flippedY;
                        this.setTextureRect(this._rect, this._rectRotated, this._contentSize);
                        this.setNodeDirty(true);
                    }
                },
                isFlippedX: function() {
                    return this._flippedX;
                },
                isFlippedY: function() {
                    return this._flippedY;
                },
                setOpacityModifyRGB: function(modify) {
                    if (this._opacityModifyRGB !== modify) {
                        this._opacityModifyRGB = modify;
                        this._renderCmd._setColorDirty();
                    }
                },
                isOpacityModifyRGB: function() {
                    return this._opacityModifyRGB;
                },
                setDisplayFrameWithAnimationName: function(animationName, frameIndex) {
                    cc.assert(animationName, cc._LogInfos.Sprite.setDisplayFrameWithAnimationName_3);
                    var cache = cc.spriteFrameAnimationCache.getAnimation(animationName);
                    if (!cache) {
                        cc.log(cc._LogInfos.Sprite.setDisplayFrameWithAnimationName);
                        return;
                    }
                    var animFrame = cache.getFrames()[frameIndex];
                    if (!animFrame) {
                        cc.log(cc._LogInfos.Sprite.setDisplayFrameWithAnimationName_2);
                        return;
                    }
                    this.setSpriteFrame(animFrame.getSpriteFrame());
                },
                getBatchNode: function() {
                    return this._batchNode;
                },
                _setReorderChildDirtyRecursively: function() {
                    if (!this._reorderChildDirty) {
                        this._reorderChildDirty = true;
                        var pNode = this._parent;
                        while (pNode && pNode !== this._batchNode) {
                            pNode._setReorderChildDirtyRecursively();
                            pNode = pNode.parent;
                        }
                    }
                },
                getTexture: function() {
                    return this._texture;
                },
                _softInit: function(fileName, rect, rotated) {
                    if (void 0 === fileName) {
                        _ccsg.Sprite.prototype.init.call(this);
                    } else {
                        if (cc.js.isString(fileName)) {
                            if ("#" === fileName[0]) {
                                var frameName = fileName.substr(1, fileName.length - 1);
                                var spriteFrame = cc.spriteFrameCache.getSpriteFrame(frameName);
                                if (spriteFrame) {
                                    this.initWithSpriteFrame(spriteFrame);
                                } else {
                                    cc.log("%s does not exist", fileName);
                                }
                            } else {
                                _ccsg.Sprite.prototype.init.call(this, fileName, rect);
                            }
                        } else {
                            if ("object" === typeof fileName) {
                                if (fileName instanceof cc.Texture2D) {
                                    this.initWithTexture(fileName, rect, rotated);
                                } else {
                                    if (fileName instanceof cc.SpriteFrame) {
                                        this.initWithSpriteFrame(fileName);
                                    } else {
                                        if (fileName instanceof HTMLImageElement || fileName instanceof HTMLCanvasElement) {
                                            var texture2d = new cc.Texture2D();
                                            texture2d.initWithElement(fileName);
                                            texture2d.handleLoadedTexture();
                                            this.initWithTexture(texture2d);
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                getQuad: function() {
                    return this._renderCmd.getQuad();
                },
                setBlendFunc: function(src, dst) {
                    var locBlendFunc = this._blendFunc;
                    if (void 0 === dst) {
                        locBlendFunc.src = src.src;
                        locBlendFunc.dst = src.dst;
                    } else {
                        locBlendFunc.src = src;
                        locBlendFunc.dst = dst;
                    }
                    this._renderCmd.updateBlendFunc(locBlendFunc);
                },
                init: function() {
                    var _t = this;
                    if (arguments.length > 0) {
                        return _t.initWithFile(arguments[0], arguments[1]);
                    }
                    _ccsg.Node.prototype.init.call(_t);
                    _t.dirty = _t._recursiveDirty = false;
                    _t._blendFunc.src = cc.BLEND_SRC;
                    _t._blendFunc.dst = cc.BLEND_DST;
                    _t.texture = null;
                    _t._flippedX = _t._flippedY = false;
                    _t.anchorX = .5;
                    _t.anchorY = .5;
                    _t._offsetPosition.x = 0;
                    _t._offsetPosition.y = 0;
                    _t._hasChildren = false;
                    this._renderCmd._init();
                    _t.setTextureRect(cc.rect(0, 0, 0, 0), false, cc.size(0, 0));
                    return true;
                },
                initWithFile: function(filename, rect) {
                    cc.assert(filename, cc._LogInfos.Sprite.initWithFile);
                    var tex = cc.textureCache.getTextureForKey(filename);
                    if (!tex) {
                        tex = cc.textureCache.addImage(filename);
                        return this.initWithTexture(tex, rect || cc.rect(0, 0, tex._contentSize.width, tex._contentSize.height));
                    } else {
                        if (!rect) {
                            var size = tex.getContentSize();
                            rect = cc.rect(0, 0, size.width, size.height);
                        }
                        return this.initWithTexture(tex, rect);
                    }
                },
                initWithTexture: function(texture, rect, rotated, counterclockwise) {
                    var _t = this;
                    cc.assert(0 !== arguments.length, cc._LogInfos.SpriteBatchNode.initWithTexture);
                    rotated = rotated || false;
                    texture = this._renderCmd._handleTextureForRotatedTexture(texture, rect, rotated, counterclockwise);
                    if (!_ccsg.Node.prototype.init.call(_t)) {
                        return false;
                    }
                    _t._batchNode = null;
                    _t._recursiveDirty = false;
                    _t.dirty = false;
                    _t._opacityModifyRGB = true;
                    _t._blendFunc.src = cc.BLEND_SRC;
                    _t._blendFunc.dst = cc.BLEND_DST;
                    _t._flippedX = _t._flippedY = false;
                    _t.setAnchorPoint(.5, .5);
                    _t._offsetPosition.x = 0;
                    _t._offsetPosition.y = 0;
                    _t._hasChildren = false;
                    this._renderCmd._init();
                    var locTextureLoaded = texture.isLoaded();
                    _t._textureLoaded = locTextureLoaded;
                    if (!locTextureLoaded) {
                        _t._rectRotated = rotated;
                        if (rect) {
                            _t._rect.x = rect.x;
                            _t._rect.y = rect.y;
                            _t._rect.width = rect.width;
                            _t._rect.height = rect.height;
                        }
                        if (_t.texture) {
                            _t.texture.off("load", _t._renderCmd._textureLoadedCallback, _t._renderCmd);
                        }
                        texture.once("load", _t._renderCmd._textureLoadedCallback, _t._renderCmd);
                        _t.setTexture(texture);
                        return true;
                    }
                    if (!rect) {
                        rect = cc.rect(0, 0, texture.width, texture.height);
                    }
                    this._renderCmd._checkTextureBoundary(texture, rect, rotated);
                    _t.setTexture(texture);
                    _t.setTextureRect(rect, rotated);
                    _t.setBatchNode(null);
                    this.emit("load");
                    return true;
                },
                setTextureRect: function(rect, rotated, untrimmedSize, needConvert) {
                    var _t = this;
                    _t._rectRotated = rotated || false;
                    _t.setContentSize(untrimmedSize || rect);
                    _t.setVertexRect(rect);
                    _t._renderCmd._setTextureCoords(rect, needConvert);
                    var relativeOffsetX = _t._unflippedOffsetPositionFromCenter.x, relativeOffsetY = _t._unflippedOffsetPositionFromCenter.y;
                    if (_t._flippedX) {
                        relativeOffsetX = -relativeOffsetX;
                    }
                    if (_t._flippedY) {
                        relativeOffsetY = -relativeOffsetY;
                    }
                    var locRect = _t._rect;
                    _t._offsetPosition.x = relativeOffsetX + (_t._contentSize.width - locRect.width) / 2;
                    _t._offsetPosition.y = relativeOffsetY + (_t._contentSize.height - locRect.height) / 2;
                    if (_t._batchNode) {
                        _t.dirty = true;
                    } else {
                        this._renderCmd._resetForBatchNode();
                    }
                },
                updateTransform: function() {
                    this._renderCmd.updateTransform();
                },
                addChild: function(child, localZOrder, tag) {
                    cc.assert(child, cc._LogInfos.SpriteBatchNode.addChild_2);
                    if (null == localZOrder) {
                        localZOrder = child._localZOrder;
                    }
                    if (null == tag) {
                        tag = child.tag;
                    }
                    if (this._renderCmd._setBatchNodeForAddChild(child)) {
                        _ccsg.Node.prototype.addChild.call(this, child, localZOrder, tag);
                        this._hasChildren = true;
                    }
                },
                setSpriteFrame: function(newFrame) {
                    var _t = this;
                    if (cc.js.isString(newFrame)) {
                        newFrame = cc.spriteFrameCache.getSpriteFrame(newFrame);
                        cc.assert(newFrame, cc._LogInfos.Sprite.setSpriteFrame);
                    }
                    this.setNodeDirty(true);
                    var frameOffset = newFrame.getOffset();
                    _t._unflippedOffsetPositionFromCenter.x = frameOffset.x;
                    _t._unflippedOffsetPositionFromCenter.y = frameOffset.y;
                    var pNewTexture = newFrame.getTexture();
                    var locTextureLoaded = newFrame.textureLoaded();
                    if (!locTextureLoaded) {
                        if (pNewTexture !== _t._texture) {
                            _t.setTexture(pNewTexture);
                        }
                        _t._textureLoaded = false;
                        newFrame.once("load", function(event) {
                            var sender = event.currentTarget;
                            _t._textureLoaded = true;
                            _t.setTextureRect(sender.getRect(), sender.isRotated(), sender.getOriginalSize());
                            _t.emit("load");
                            _t.setColor(_t.color);
                        }, _t);
                    } else {
                        if (pNewTexture !== _t._texture) {
                            _t.setTexture(pNewTexture);
                        }
                        _t.setTextureRect(newFrame.getRect(), newFrame.isRotated(), newFrame.getOriginalSize());
                    }
                    this._renderCmd._updateForSetSpriteFrame(pNewTexture);
                },
                setDisplayFrame: function(newFrame) {
                    cc.log(cc._LogInfos.Sprite.setDisplayFrame);
                    this.setSpriteFrame(newFrame);
                },
                isFrameDisplayed: function(frame) {
                    return this._renderCmd.isFrameDisplayed(frame);
                },
                displayFrame: function() {
                    return this.getSpriteFrame();
                },
                getSpriteFrame: function() {
                    return new cc.SpriteFrame(this._texture, cc.rectPointsToPixels(this._rect), this._rectRotated, cc.pointPointsToPixels(this._unflippedOffsetPositionFromCenter), cc.sizePointsToPixels(this._contentSize));
                },
                setBatchNode: function(spriteBatchNode) {
                    var _t = this;
                    _t._batchNode = spriteBatchNode;
                    if (!_t._batchNode) {
                        _t.atlasIndex = _ccsg.Sprite.INDEX_NOT_INITIALIZED;
                        _t.textureAtlas = null;
                        _t._recursiveDirty = false;
                        _t.dirty = false;
                        this._renderCmd._resetForBatchNode();
                    } else {
                        _t._transformToBatch = cc.affineTransformIdentity();
                        _t.textureAtlas = _t._batchNode.getTextureAtlas();
                    }
                },
                setTexture: function(texture) {
                    if (!texture) {
                        return this._renderCmd._setTexture(null);
                    }
                    var isFileName = cc.js.isString(texture);
                    if (isFileName) {
                        texture = cc.textureCache.addImage(texture);
                    }
                    if (texture._textureLoaded) {
                        this._setTexture(texture, isFileName);
                        this.setColor(this._realColor);
                        this._textureLoaded = true;
                        this.emit("load");
                    } else {
                        this._renderCmd._setTexture(texture);
                        texture.once("load", function(event) {
                            this._setTexture(texture, isFileName);
                            this.setColor(this._realColor);
                            this._textureLoaded = true;
                            this.emit("load");
                        }, this);
                    }
                },
                _setTexture: function(texture, change) {
                    this._renderCmd._setTexture(texture);
                    if (change) {
                        this._changeRectWithTexture(texture);
                    }
                },
                _changeRectWithTexture: function(texture) {
                    var contentSize = texture._contentSize;
                    var rect = cc.rect(0, 0, contentSize.width, contentSize.height);
                    this.setTextureRect(rect);
                },
                _createRenderCmd: function() {
                    if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                        return new _ccsg.Sprite.CanvasRenderCmd(this);
                    } else {
                        return new _ccsg.Sprite.WebGLRenderCmd(this);
                    }
                }
            });
            _ccsg.Sprite.create = function(fileName, rect, rotated) {
                return new _ccsg.Sprite(fileName, rect, rotated);
            };
            _ccsg.Sprite.createWithTexture = _ccsg.Sprite.create;
            _ccsg.Sprite.createWithSpriteFrameName = _ccsg.Sprite.create;
            _ccsg.Sprite.createWithSpriteFrame = _ccsg.Sprite.create;
            _ccsg.Sprite.INDEX_NOT_INITIALIZED = -1;
            cc.js.addon(_ccsg.Sprite.prototype, EventTarget.prototype);
            cc.assert(cc.js.isFunction(cc._tmp.PrototypeSprite), cc._LogInfos.MissingFile, "SpritesPropertyDefine.js");
            cc._tmp.PrototypeSprite();
            delete cc._tmp.PrototypeSprite;
            !function() {
                _ccsg.Sprite.CanvasRenderCmd = function(renderable) {
                    _ccsg.Node.CanvasRenderCmd.call(this, renderable);
                    this._needDraw = true;
                    this._textureCoord = {
                        renderX: 0,
                        renderY: 0,
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0,
                        validRect: false
                    };
                    this._blendFuncStr = "source-over";
                    this._colorized = false;
                    this._textureToRender = null;
                };
                var proto = _ccsg.Sprite.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
                proto.constructor = _ccsg.Sprite.CanvasRenderCmd;
                proto._init = function() {};
                proto.setDirtyRecursively = function(value) {};
                proto._resetForBatchNode = function() {};
                proto._setTexture = function(texture) {
                    var node = this._node;
                    if (node._texture !== texture) {
                        if (texture) {
                            node._textureLoaded = texture._textureLoaded;
                        } else {
                            node._textureLoaded = false;
                        }
                        node._texture = texture;
                        this._updateColor();
                    }
                };
                proto._setColorDirty = function() {
                    this.setDirtyFlag(_ccsg.Node._dirtyFlags.colorDirty | _ccsg.Node._dirtyFlags.opacityDirty);
                };
                proto.isFrameDisplayed = function(frame) {
                    var node = this._node;
                    if (frame.getTexture() !== node._texture) {
                        return false;
                    }
                    return cc.rectEqualToRect(frame.getRect(), node._rect);
                };
                proto.updateBlendFunc = function(blendFunc) {
                    this._blendFuncStr = _ccsg.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc(blendFunc);
                };
                proto._setBatchNodeForAddChild = function(child) {
                    return true;
                };
                proto._handleTextureForRotatedTexture = function(texture, rect, rotated, counterclockwise) {
                    if (rotated && texture.isLoaded()) {
                        var tempElement = texture.getHtmlElementObj();
                        tempElement = _ccsg.Sprite.CanvasRenderCmd._cutRotateImageToCanvas(tempElement, rect, counterclockwise);
                        var tempTexture = new cc.Texture2D();
                        tempTexture.initWithElement(tempElement);
                        tempTexture.handleLoadedTexture();
                        texture = tempTexture;
                        rect.x = rect.y = 0;
                        this._node._rect = cc.rect(0, 0, rect.width, rect.height);
                    }
                    return texture;
                };
                proto._checkTextureBoundary = function(texture, rect, rotated) {
                    if (texture && texture.url) {
                        var _x = rect.x + rect.width, _y = rect.y + rect.height;
                        if (_x > texture.width) {
                            cc.error(cc._LogInfos.RectWidth, texture.url);
                        }
                        if (_y > texture.height) {
                            cc.error(cc._LogInfos.RectHeight, texture.url);
                        }
                    }
                };
                proto.rendering = function(ctx, scaleX, scaleY) {
                    var node = this._node;
                    var locTextureCoord = this._textureCoord, alpha = this._displayedOpacity / 255;
                    var texture = this._textureToRender || node._texture;
                    if (texture && (0 === locTextureCoord.width || 0 === locTextureCoord.height || !texture._textureLoaded) || 0 === alpha) {
                        return;
                    }
                    var wrapper = ctx || cc._renderContext, context = wrapper.getContext();
                    var locX = node._offsetPosition.x, locHeight = node._rect.height, locWidth = node._rect.width, locY = -node._offsetPosition.y - locHeight, image;
                    wrapper.setTransform(this._worldTransform, scaleX, scaleY);
                    wrapper.setCompositeOperation(this._blendFuncStr);
                    wrapper.setGlobalAlpha(alpha);
                    if (node._flippedX || node._flippedY) {
                        wrapper.save();
                    }
                    if (node._flippedX) {
                        locX = -locX - locWidth;
                        context.scale(-1, 1);
                    }
                    if (node._flippedY) {
                        locY = node._offsetPosition.y;
                        context.scale(1, -1);
                    }
                    var sx, sy, sw, sh, x, y, w, h;
                    if (this._colorized) {
                        sx = 0;
                        sy = 0;
                    } else {
                        sx = locTextureCoord.renderX;
                        sy = locTextureCoord.renderY;
                    }
                    sw = locTextureCoord.width;
                    sh = locTextureCoord.height;
                    x = locX * scaleX;
                    y = locY * scaleY;
                    w = locWidth * scaleX;
                    h = locHeight * scaleY;
                    if (texture) {
                        image = texture._htmlElementObj;
                        if ("" !== texture._pattern) {
                            wrapper.setFillStyle(context.createPattern(image, texture._pattern));
                            context.fillRect(x, y, w, h);
                        } else {
                            context.drawImage(image, sx, sy, sw, sh, x, y, w, h);
                        }
                    } else {
                        var contentSize = node._contentSize;
                        if (locTextureCoord.validRect) {
                            var curColor = this._displayedColor;
                            wrapper.setFillStyle("rgba(" + curColor.r + "," + curColor.g + "," + curColor.b + ",1)");
                            context.fillRect(x, y, contentSize.width * scaleX, contentSize.height * scaleY);
                        }
                    }
                    if (node._flippedX || node._flippedY) {
                        wrapper.restore();
                    }
                    cc.g_NumberOfDraws++;
                };
                proto._updateColor = function() {
                    var node = this._node;
                    var texture = node._texture, rect = this._textureCoord;
                    var dColor = this._displayedColor;
                    if (texture) {
                        if (255 !== dColor.r || 255 !== dColor.g || 255 !== dColor.b) {
                            this._textureToRender = texture._generateColorTexture(dColor.r, dColor.g, dColor.b, rect);
                            this._colorized = true;
                        } else {
                            if (texture) {
                                this._textureToRender = texture;
                                this._colorized = false;
                            }
                        }
                    }
                };
                proto.getQuad = function() {
                    return null;
                };
                proto._updateForSetSpriteFrame = function(pNewTexture, textureLoaded) {
                    this._colorized = false;
                    this._textureCoord.renderX = this._textureCoord.x;
                    this._textureCoord.renderY = this._textureCoord.y;
                    textureLoaded = textureLoaded || pNewTexture._textureLoaded;
                    if (textureLoaded) {
                        var curColor = this._node.getColor();
                        if (255 !== curColor.r || 255 !== curColor.g || 255 !== curColor.b) {
                            this._updateColor();
                        }
                    }
                };
                proto.updateTransform = function() {
                    var _t = this, node = this._node;
                    if (node.dirty) {
                        var locParent = node._parent;
                        if (!node._visible || locParent && locParent !== node._batchNode && locParent._shouldBeHidden) {
                            node._shouldBeHidden = true;
                        } else {
                            node._shouldBeHidden = false;
                            if (!locParent || locParent === node._batchNode) {
                                node._transformToBatch = _t.getNodeToParentTransform();
                            } else {
                                node._transformToBatch = cc.affineTransformConcat(_t.getNodeToParentTransform(), locParent._transformToBatch);
                            }
                        }
                        node._recursiveDirty = false;
                        node.dirty = false;
                    }
                    if (node._hasChildren) {
                        node._arrayMakeObjectsPerformSelector(node._children, _ccsg.Node._stateCallbackType.updateTransform);
                    }
                };
                proto._updateDisplayColor = function(parentColor) {
                    _ccsg.Node.CanvasRenderCmd.prototype._updateDisplayColor.call(this, parentColor);
                };
                proto._spriteFrameLoadedCallback = function(event) {
                    var node = this._node, spriteFrame = event.currentTarget;
                    node.setTextureRect(spriteFrame.getRect(), spriteFrame.isRotated(), spriteFrame.getOriginalSize());
                    this._updateColor();
                    node.emit("load");
                };
                proto._textureLoadedCallback = function(event) {
                    var node = this._node, sender = event.currentTarget;
                    if (node._textureLoaded) {
                        return;
                    }
                    node._textureLoaded = true;
                    var texture = node._texture, locRect = node._rect;
                    if (!locRect) {
                        locRect = cc.rect(0, 0, sender.width, sender.height);
                    } else {
                        if (cc._rectEqualToZero(locRect)) {
                            locRect.width = sender.width;
                            locRect.height = sender.height;
                        }
                    }
                    node.texture = sender;
                    node.setTextureRect(locRect, node._rectRotated);
                    var locColor = this._displayedColor;
                    if (255 !== locColor.r || 255 !== locColor.g || 255 !== locColor.b) {
                        this._updateColor();
                    }
                    node.setBatchNode(node._batchNode);
                    node.emit("load");
                };
                proto._setTextureCoords = function(rect, needConvert) {
                    if (void 0 === needConvert) {
                        needConvert = true;
                    }
                    var locTextureRect = this._textureCoord, scaleFactor = needConvert ? cc.contentScaleFactor() : 1;
                    locTextureRect.renderX = locTextureRect.x = 0 | rect.x * scaleFactor;
                    locTextureRect.renderY = locTextureRect.y = 0 | rect.y * scaleFactor;
                    locTextureRect.width = 0 | rect.width * scaleFactor;
                    locTextureRect.height = 0 | rect.height * scaleFactor;
                    locTextureRect.validRect = !(0 === locTextureRect.width || 0 === locTextureRect.height || locTextureRect.x < 0 || locTextureRect.y < 0);
                };
                _ccsg.Sprite.CanvasRenderCmd._cutRotateImageToCanvas = function(texture, rect, counterclockwise) {
                    if (!texture) {
                        return null;
                    }
                    if (!rect) {
                        return texture;
                    }
                    counterclockwise = null == counterclockwise ? true : counterclockwise;
                    var nCanvas = document.createElement("canvas");
                    nCanvas.width = rect.width;
                    nCanvas.height = rect.height;
                    var ctx = nCanvas.getContext("2d");
                    ctx.translate(nCanvas.width / 2, nCanvas.height / 2);
                    if (counterclockwise) {
                        ctx.rotate(-1.5707963267948966);
                    } else {
                        ctx.rotate(1.5707963267948966);
                    }
                    ctx.drawImage(texture, rect.x, rect.y, rect.height, rect.width, -rect.height / 2, -rect.width / 2, rect.height, rect.width);
                    return nCanvas;
                };
            }();
            !function() {
                _ccsg.Sprite.WebGLRenderCmd = function(renderable) {
                    _ccsg.Node.WebGLRenderCmd.call(this, renderable);
                    this._needDraw = true;
                    this._quad = new cc.V3F_C4B_T2F_Quad();
                    this._quadWebBuffer = cc._renderContext.createBuffer();
                    this._quadDirty = true;
                    this._dirty = false;
                    this._recursiveDirty = false;
                };
                var proto = _ccsg.Sprite.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
                proto.constructor = _ccsg.Sprite.WebGLRenderCmd;
                proto.updateBlendFunc = function(blendFunc) {};
                proto.setDirtyFlag = function(dirtyFlag) {
                    _ccsg.Node.WebGLRenderCmd.prototype.setDirtyFlag.call(this, dirtyFlag);
                    this._dirty = true;
                };
                proto.setDirtyRecursively = function(value) {
                    this._recursiveDirty = value;
                    this._dirty = value;
                    var locChildren = this._node._children, child, l = locChildren ? locChildren.length : 0;
                    for (var i = 0; i < l; i++) {
                        child = locChildren[i];
                        child instanceof _ccsg.Sprite && child._renderCmd.setDirtyRecursively(value);
                    }
                };
                proto._setBatchNodeForAddChild = function(child) {
                    var node = this._node;
                    if (node._batchNode) {
                        if (!(child instanceof _ccsg.Sprite)) {
                            cc.log(cc._LogInfos.Sprite.addChild);
                            return false;
                        }
                        if (child.texture._webTextureObj !== node.textureAtlas.texture._webTextureObj) {
                            cc.log(cc._LogInfos.Sprite_addChild_2);
                        }
                        node._batchNode.appendChild(child);
                        if (!node._reorderChildDirty) {
                            node._setReorderChildDirtyRecursively();
                        }
                    }
                    return true;
                };
                proto._handleTextureForRotatedTexture = function(texture) {
                    return texture;
                };
                proto.isFrameDisplayed = function(frame) {
                    var node = this._node;
                    return cc.rectEqualToRect(frame.getRect(), node._rect) && frame.getTexture().getName() === node._texture.getName() && cc.pointEqualToPoint(frame.getOffset(), node._unflippedOffsetPositionFromCenter);
                };
                proto._init = function() {
                    var tempColor = {
                        r: 255,
                        g: 255,
                        b: 255,
                        a: 255
                    }, quad = this._quad;
                    quad.bl.colors = tempColor;
                    quad.br.colors = tempColor;
                    quad.tl.colors = tempColor;
                    quad.tr.colors = tempColor;
                    this._quadDirty = true;
                };
                proto._resetForBatchNode = function() {
                    var node = this._node;
                    var x1 = node._offsetPosition.x;
                    var y1 = node._offsetPosition.y;
                    var x2 = x1 + node._rect.width;
                    var y2 = y1 + node._rect.height;
                    var locQuad = this._quad;
                    locQuad.bl.vertices = {
                        x: x1,
                        y: y1,
                        z: 0
                    };
                    locQuad.br.vertices = {
                        x: x2,
                        y: y1,
                        z: 0
                    };
                    locQuad.tl.vertices = {
                        x: x1,
                        y: y2,
                        z: 0
                    };
                    locQuad.tr.vertices = {
                        x: x2,
                        y: y2,
                        z: 0
                    };
                    this._quadDirty = true;
                };
                proto.getQuad = function() {
                    return this._quad;
                };
                proto._updateForSetSpriteFrame = function() {};
                proto._spriteFrameLoadedCallback = function(event) {
                    var spriteFrame = event.currentTarget;
                    this._node.setTextureRect(spriteFrame.getRect(), spriteFrame.isRotated(), spriteFrame.getOriginalSize());
                    this._node.emit("load");
                };
                proto._textureLoadedCallback = function(event) {
                    var node = this._node, sender = event.currentTarget;
                    if (node._textureLoaded) {
                        return;
                    }
                    node._textureLoaded = true;
                    var locRect = node._rect;
                    if (!locRect) {
                        locRect = cc.rect(0, 0, sender.width, sender.height);
                    } else {
                        if (cc._rectEqualToZero(locRect)) {
                            locRect.width = sender.width;
                            locRect.height = sender.height;
                        }
                    }
                    node.texture = sender;
                    node.setTextureRect(locRect, node._rectRotated);
                    node.setBatchNode(node._batchNode);
                    this._quadDirty = true;
                    node.emit("load");
                };
                proto._setTextureCoords = function(rect, needConvert) {
                    if (void 0 === needConvert) {
                        needConvert = true;
                    }
                    if (needConvert) {
                        rect = cc.rectPointsToPixels(rect);
                    }
                    var node = this._node;
                    var tex = node._batchNode ? node.textureAtlas.texture : node._texture;
                    if (!tex) {
                        return;
                    }
                    var atlasWidth = tex.pixelWidth;
                    var atlasHeight = tex.pixelHeight;
                    var left, right, top, bottom, tempSwap, locQuad = this._quad;
                    if (node._rectRotated) {
                        if (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL) {
                            left = (2 * rect.x + 1) / (2 * atlasWidth);
                            right = left + (2 * rect.height - 2) / (2 * atlasWidth);
                            top = (2 * rect.y + 1) / (2 * atlasHeight);
                            bottom = top + (2 * rect.width - 2) / (2 * atlasHeight);
                        } else {
                            left = rect.x / atlasWidth;
                            right = (rect.x + rect.height) / atlasWidth;
                            top = rect.y / atlasHeight;
                            bottom = (rect.y + rect.width) / atlasHeight;
                        }
                        if (node._flippedX) {
                            tempSwap = top;
                            top = bottom;
                            bottom = tempSwap;
                        }
                        if (node._flippedY) {
                            tempSwap = left;
                            left = right;
                            right = tempSwap;
                        }
                        locQuad.bl.texCoords.u = left;
                        locQuad.bl.texCoords.v = top;
                        locQuad.br.texCoords.u = left;
                        locQuad.br.texCoords.v = bottom;
                        locQuad.tl.texCoords.u = right;
                        locQuad.tl.texCoords.v = top;
                        locQuad.tr.texCoords.u = right;
                        locQuad.tr.texCoords.v = bottom;
                    } else {
                        if (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL) {
                            left = (2 * rect.x + 1) / (2 * atlasWidth);
                            right = left + (2 * rect.width - 2) / (2 * atlasWidth);
                            top = (2 * rect.y + 1) / (2 * atlasHeight);
                            bottom = top + (2 * rect.height - 2) / (2 * atlasHeight);
                        } else {
                            left = rect.x / atlasWidth;
                            right = (rect.x + rect.width) / atlasWidth;
                            top = rect.y / atlasHeight;
                            bottom = (rect.y + rect.height) / atlasHeight;
                        }
                        if (node._flippedX) {
                            tempSwap = left;
                            left = right;
                            right = tempSwap;
                        }
                        if (node._flippedY) {
                            tempSwap = top;
                            top = bottom;
                            bottom = tempSwap;
                        }
                        locQuad.bl.texCoords.u = left;
                        locQuad.bl.texCoords.v = bottom;
                        locQuad.br.texCoords.u = right;
                        locQuad.br.texCoords.v = bottom;
                        locQuad.tl.texCoords.u = left;
                        locQuad.tl.texCoords.v = top;
                        locQuad.tr.texCoords.u = right;
                        locQuad.tr.texCoords.v = top;
                    }
                    this._quadDirty = true;
                };
                proto.transform = function(parentCmd, recursive) {
                    _ccsg.Node.WebGLRenderCmd.prototype.transform.call(this, parentCmd, recursive);
                    this._dirty = true;
                };
                proto._setColorDirty = function() {};
                proto._updateColor = function() {
                    var node = this._node, locDisplayedColor = this._displayedColor, r = locDisplayedColor.r, g = locDisplayedColor.g, b = locDisplayedColor.b, a = locDisplayedColor.a = this._displayedOpacity;
                    if (node._opacityModifyRGB) {
                        locDisplayedColor.r *= a / 255;
                        locDisplayedColor.g *= a / 255;
                        locDisplayedColor.b *= a / 255;
                    }
                    var locQuad = this._quad;
                    locQuad.bl.colors = locDisplayedColor;
                    locQuad.br.colors = locDisplayedColor;
                    locQuad.tl.colors = locDisplayedColor;
                    locQuad.tr.colors = locDisplayedColor;
                    locDisplayedColor.r = r;
                    locDisplayedColor.g = g;
                    locDisplayedColor.b = b;
                    if (node._batchNode) {
                        if (node.atlasIndex !== _ccsg.Sprite.INDEX_NOT_INITIALIZED) {
                            node.textureAtlas.updateQuad(locQuad, node.atlasIndex);
                        } else {
                            this._dirty = true;
                        }
                    }
                    this._quadDirty = true;
                };
                proto._updateBlendFunc = function() {
                    if (this._batchNode) {
                        cc.log(cc._LogInfos.Sprite__updateBlendFunc);
                        return;
                    }
                    var node = this._node;
                    if (!node._texture || !node._texture.hasPremultipliedAlpha()) {
                        node._blendFunc.src = cc.SRC_ALPHA;
                        node._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA;
                        node.opacityModifyRGB = false;
                    } else {
                        node._blendFunc.src = cc.BLEND_SRC;
                        node._blendFunc.dst = cc.BLEND_DST;
                        node.opacityModifyRGB = true;
                    }
                };
                proto._setTexture = function(texture) {
                    var node = this._node;
                    if (node._batchNode) {
                        if (node._batchNode.texture !== texture) {
                            cc.log(cc._LogInfos.Sprite_setTexture);
                            return;
                        }
                    } else {
                        if (node._texture !== texture) {
                            node._textureLoaded = texture ? texture._textureLoaded : false;
                            node._texture = texture;
                            this._updateBlendFunc();
                        }
                    }
                    if (texture) {
                        this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
                    } else {
                        this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_COLOR);
                    }
                };
                proto.updateTransform = function() {
                    var _t = this, node = this._node;
                    if (this._dirty) {
                        var locQuad = _t._quad, locParent = node._parent;
                        if (!node._visible || locParent && locParent !== node._batchNode && locParent._shouldBeHidden) {
                            locQuad.br.vertices = locQuad.tl.vertices = locQuad.tr.vertices = locQuad.bl.vertices = {
                                x: 0,
                                y: 0,
                                z: 0
                            };
                            node._shouldBeHidden = true;
                        } else {
                            node._shouldBeHidden = false;
                            if (0 !== this._dirtyFlag) {
                                this.updateStatus();
                                this._dirtyFlag = 0;
                            }
                            if (!locParent || locParent === node._batchNode) {
                                node._transformToBatch = _t.getNodeToParentTransform();
                            } else {
                                node._transformToBatch = cc.affineTransformConcat(_t.getNodeToParentTransform(), locParent._transformToBatch);
                            }
                            var locTransformToBatch = node._transformToBatch;
                            var rect = node._rect;
                            var x1 = node._offsetPosition.x;
                            var y1 = node._offsetPosition.y;
                            var x2 = x1 + rect.width;
                            var y2 = y1 + rect.height;
                            var x = locTransformToBatch.tx;
                            var y = locTransformToBatch.ty;
                            var cr = locTransformToBatch.a;
                            var sr = locTransformToBatch.b;
                            var cr2 = locTransformToBatch.d;
                            var sr2 = -locTransformToBatch.c;
                            var ax = x1 * cr - y1 * sr2 + x;
                            var ay = x1 * sr + y1 * cr2 + y;
                            var bx = x2 * cr - y1 * sr2 + x;
                            var by = x2 * sr + y1 * cr2 + y;
                            var cx = x2 * cr - y2 * sr2 + x;
                            var cy = x2 * sr + y2 * cr2 + y;
                            var dx = x1 * cr - y2 * sr2 + x;
                            var dy = x1 * sr + y2 * cr2 + y;
                            var locVertexZ = node._vertexZ;
                            if (!cc.SPRITEBATCHNODE_RENDER_SUBPIXEL) {
                                ax = 0 | ax;
                                ay = 0 | ay;
                                bx = 0 | bx;
                                by = 0 | by;
                                cx = 0 | cx;
                                cy = 0 | cy;
                                dx = 0 | dx;
                                dy = 0 | dy;
                            }
                            locQuad.bl.vertices = {
                                x: ax,
                                y: ay,
                                z: locVertexZ
                            };
                            locQuad.br.vertices = {
                                x: bx,
                                y: by,
                                z: locVertexZ
                            };
                            locQuad.tl.vertices = {
                                x: dx,
                                y: dy,
                                z: locVertexZ
                            };
                            locQuad.tr.vertices = {
                                x: cx,
                                y: cy,
                                z: locVertexZ
                            };
                        }
                        node.textureAtlas.updateQuad(locQuad, node.atlasIndex);
                        node._recursiveDirty = false;
                        this._dirty = false;
                    }
                    if (node._hasChildren) {
                        node._arrayMakeObjectsPerformSelector(node._children, _ccsg.Node._stateCallbackType.updateTransform);
                    }
                };
                proto._checkTextureBoundary = function(texture, rect, rotated) {
                    if (texture && texture.url) {
                        var _x, _y;
                        if (rotated) {
                            _x = rect.x + rect.height;
                            _y = rect.y + rect.width;
                        } else {
                            _x = rect.x + rect.width;
                            _y = rect.y + rect.height;
                        }
                        if (_x > texture.width) {
                            cc.error(cc._LogInfos.RectWidth, texture.url);
                        }
                        if (_y > texture.height) {
                            cc.error(cc._LogInfos.RectHeight, texture.url);
                        }
                    }
                };
                proto.rendering = function(ctx) {
                    var node = this._node, locTexture = node._texture;
                    if (locTexture && !locTexture._textureLoaded || 0 === this._displayedOpacity) {
                        return;
                    }
                    var gl = ctx || cc._renderContext;
                    if (locTexture) {
                        if (locTexture._textureLoaded) {
                            this._shaderProgram.use();
                            this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
                            cc.glBlendFunc(node._blendFunc.src, node._blendFunc.dst);
                            cc.glBindTexture2DN(0, locTexture);
                            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
                            gl.bindBuffer(gl.ARRAY_BUFFER, this._quadWebBuffer);
                            if (this._quadDirty) {
                                gl.bufferData(gl.ARRAY_BUFFER, this._quad.arrayBuffer, gl.DYNAMIC_DRAW);
                                this._quadDirty = false;
                            }
                            gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 24, 0);
                            gl.vertexAttribPointer(1, 4, gl.UNSIGNED_BYTE, true, 24, 12);
                            gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 24, 16);
                            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                        }
                    } else {
                        this._shaderProgram.use();
                        this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
                        cc.glBlendFunc(node._blendFunc.src, node._blendFunc.dst);
                        cc.glBindTexture2D(null);
                        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR);
                        gl.bindBuffer(gl.ARRAY_BUFFER, this._quadWebBuffer);
                        if (this._quadDirty) {
                            gl.bufferData(gl.ARRAY_BUFFER, this._quad.arrayBuffer, gl.STATIC_DRAW);
                            this._quadDirty = false;
                        }
                        gl.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, gl.FLOAT, false, 24, 0);
                        gl.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, gl.UNSIGNED_BYTE, true, 24, 12);
                        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                    }
                    cc.g_NumberOfDraws++;
                    if (0 === cc.SPRITE_DEBUG_DRAW && !node._showNode) {
                        return;
                    }
                    cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
                    cc.current_stack.stack.push(cc.current_stack.top);
                    cc.current_stack.top = this._stackMatrix;
                    if (1 === cc.SPRITE_DEBUG_DRAW || node._showNode) {
                        var locQuad = this._quad;
                        var verticesG1 = [ cc.p(locQuad.tl.vertices.x, locQuad.tl.vertices.y), cc.p(locQuad.bl.vertices.x, locQuad.bl.vertices.y), cc.p(locQuad.br.vertices.x, locQuad.br.vertices.y), cc.p(locQuad.tr.vertices.x, locQuad.tr.vertices.y) ];
                        cc._drawingUtil.drawPoly(verticesG1, 4, true);
                    } else {
                        if (2 === cc.SPRITE_DEBUG_DRAW) {
                            var drawRectG2 = node.getTextureRect();
                            var offsetPixG2 = node.getOffsetPosition();
                            var verticesG2 = [ cc.p(offsetPixG2.x, offsetPixG2.y), cc.p(offsetPixG2.x + drawRectG2.width, offsetPixG2.y), cc.p(offsetPixG2.x + drawRectG2.width, offsetPixG2.y + drawRectG2.height), cc.p(offsetPixG2.x, offsetPixG2.y + drawRectG2.height) ];
                            cc._drawingUtil.drawPoly(verticesG2, 4, true);
                        }
                    }
                    cc.current_stack.top = cc.current_stack.stack.pop();
                };
            }();
            cc.BakeSprite = _ccsg.Sprite.extend({
                _cacheCanvas: null,
                _cacheContext: null,
                ctor: function() {
                    _ccsg.Sprite.prototype.ctor.call(this);
                    var canvasElement = document.createElement("canvas");
                    canvasElement.width = canvasElement.height = 10;
                    this._cacheCanvas = canvasElement;
                    this._cacheContext = new cc.CanvasContextWrapper(canvasElement.getContext("2d"));
                    var texture = new cc.Texture2D();
                    texture.initWithElement(canvasElement);
                    texture.handleLoadedTexture();
                    this.setTexture(texture);
                },
                getCacheContext: function() {
                    return this._cacheContext;
                },
                getCacheCanvas: function() {
                    return this._cacheCanvas;
                },
                resetCanvasSize: function(sizeOrWidth, height) {
                    var locCanvas = this._cacheCanvas, locContext = this._cacheContext, strokeStyle = locContext._context.strokeStyle, fillStyle = locContext._context.fillStyle;
                    if (void 0 === height) {
                        height = sizeOrWidth.height;
                        sizeOrWidth = sizeOrWidth.width;
                    }
                    locCanvas.width = sizeOrWidth;
                    locCanvas.height = height;
                    if (strokeStyle !== locContext._context.strokeStyle) {
                        locContext._context.strokeStyle = strokeStyle;
                    }
                    if (fillStyle !== locContext._context.fillStyle) {
                        locContext._context.fillStyle = fillStyle;
                    }
                    this.getTexture().handleLoadedTexture();
                    this.setTextureRect(cc.rect(0, 0, sizeOrWidth, height), false, null, false);
                }
            });
            cc.AnimationFrame = cc._Class.extend({
                _spriteFrame: null,
                _delayPerUnit: 0,
                _userInfo: null,
                ctor: function(spriteFrame, delayUnits, userInfo) {
                    this._spriteFrame = spriteFrame || null;
                    this._delayPerUnit = delayUnits || 0;
                    this._userInfo = userInfo || null;
                },
                clone: function() {
                    var frame = new cc.AnimationFrame();
                    frame.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo);
                    return frame;
                },
                copyWithZone: function(pZone) {
                    return cc.clone(this);
                },
                copy: function(pZone) {
                    var newFrame = new cc.AnimationFrame();
                    newFrame.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo);
                    return newFrame;
                },
                initWithSpriteFrame: function(spriteFrame, delayUnits, userInfo) {
                    this._spriteFrame = spriteFrame;
                    this._delayPerUnit = delayUnits;
                    this._userInfo = userInfo;
                    return true;
                },
                getSpriteFrame: function() {
                    return this._spriteFrame;
                },
                setSpriteFrame: function(spriteFrame) {
                    this._spriteFrame = spriteFrame;
                },
                getDelayUnits: function() {
                    return this._delayPerUnit;
                },
                setDelayUnits: function(delayUnits) {
                    this._delayPerUnit = delayUnits;
                },
                getUserInfo: function() {
                    return this._userInfo;
                },
                setUserInfo: function(userInfo) {
                    this._userInfo = userInfo;
                }
            });
            cc.AnimationFrame.create = function(spriteFrame, delayUnits, userInfo) {
                return new cc.AnimationFrame(spriteFrame, delayUnits, userInfo);
            };
            cc.SpriteFrameAnimation = cc._Class.extend({
                _frames: null,
                _loops: 0,
                _restoreOriginalFrame: false,
                _duration: 0,
                _delayPerUnit: 0,
                _totalDelayUnits: 0,
                ctor: function(frames, delay, loops) {
                    this._frames = [];
                    if (void 0 === frames) {
                        this.initWithSpriteFrames(null, 0);
                    } else {
                        var frame0 = frames[0];
                        if (frame0) {
                            if (frame0 instanceof cc.SpriteFrame) {
                                this.initWithSpriteFrames(frames, delay, loops);
                            } else {
                                if (frame0 instanceof cc.AnimationFrame) {
                                    this.initWithAnimationFrames(frames, delay, loops);
                                }
                            }
                        }
                    }
                },
                getFrames: function() {
                    return this._frames;
                },
                setFrames: function(frames) {
                    this._frames = frames;
                },
                addSpriteFrame: function(frame) {
                    var animFrame = new cc.AnimationFrame();
                    animFrame.initWithSpriteFrame(frame, 1, null);
                    this._frames.push(animFrame);
                    this._totalDelayUnits++;
                },
                addSpriteFrameWithFile: function(fileName) {
                    var texture = cc.textureCache.addImage(fileName);
                    var rect = cc.rect(0, 0, 0, 0);
                    rect.width = texture.width;
                    rect.height = texture.height;
                    var frame = new cc.SpriteFrame(texture, rect);
                    this.addSpriteFrame(frame);
                },
                addSpriteFrameWithTexture: function(texture, rect) {
                    var pFrame = new cc.SpriteFrame(texture, rect);
                    this.addSpriteFrame(pFrame);
                },
                initWithAnimationFrames: function(arrayOfAnimationFrames, delayPerUnit, loops) {
                    cc.js.array.verifyType(arrayOfAnimationFrames, cc.AnimationFrame);
                    this._delayPerUnit = delayPerUnit;
                    this._loops = void 0 === loops ? 1 : loops;
                    this._totalDelayUnits = 0;
                    var locFrames = this._frames;
                    locFrames.length = 0;
                    for (var i = 0; i < arrayOfAnimationFrames.length; i++) {
                        var animFrame = arrayOfAnimationFrames[i];
                        locFrames.push(animFrame);
                        this._totalDelayUnits += animFrame.getDelayUnits();
                    }
                    return true;
                },
                clone: function() {
                    var animation = new cc.SpriteFrameAnimation();
                    animation.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops);
                    animation.setRestoreOriginalFrame(this._restoreOriginalFrame);
                    return animation;
                },
                copyWithZone: function(pZone) {
                    var pCopy = new cc.SpriteFrameAnimation();
                    pCopy.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops);
                    pCopy.setRestoreOriginalFrame(this._restoreOriginalFrame);
                    return pCopy;
                },
                _copyFrames: function() {
                    var copyFrames = [];
                    for (var i = 0; i < this._frames.length; i++) {
                        copyFrames.push(this._frames[i].clone());
                    }
                    return copyFrames;
                },
                copy: function(pZone) {
                    return this.copyWithZone(null);
                },
                getLoops: function() {
                    return this._loops;
                },
                setLoops: function(value) {
                    this._loops = value;
                },
                setRestoreOriginalFrame: function(restOrigFrame) {
                    this._restoreOriginalFrame = restOrigFrame;
                },
                getRestoreOriginalFrame: function() {
                    return this._restoreOriginalFrame;
                },
                getDuration: function() {
                    return this._totalDelayUnits * this._delayPerUnit;
                },
                getDelayPerUnit: function() {
                    return this._delayPerUnit;
                },
                setDelayPerUnit: function(delayPerUnit) {
                    this._delayPerUnit = delayPerUnit;
                },
                getTotalDelayUnits: function() {
                    return this._totalDelayUnits;
                },
                initWithSpriteFrames: function(frames, delay, loops) {
                    cc.js.array.verifyType(frames, cc.SpriteFrame);
                    this._loops = void 0 === loops ? 1 : loops;
                    this._delayPerUnit = delay || 0;
                    this._totalDelayUnits = 0;
                    var locFrames = this._frames;
                    locFrames.length = 0;
                    if (frames) {
                        for (var i = 0; i < frames.length; i++) {
                            var frame = frames[i];
                            var animFrame = new cc.AnimationFrame();
                            animFrame.initWithSpriteFrame(frame, 1, null);
                            locFrames.push(animFrame);
                        }
                        this._totalDelayUnits += frames.length;
                    }
                    return true;
                },
                retain: function() {},
                release: function() {}
            });
            cc.SpriteFrameAnimation.create = function(frames, delay, loops) {
                return new cc.SpriteFrameAnimation(frames, delay, loops);
            };
            cc.SpriteFrameAnimation.createWithAnimationFrames = cc.SpriteFrameAnimation.create;
            cc.spriteFrameAnimationCache = {
                _animations: {},
                addAnimation: function(animation, name) {
                    this._animations[name] = animation;
                },
                removeAnimation: function(name) {
                    if (!name) {
                        return;
                    }
                    if (this._animations[name]) {
                        delete this._animations[name];
                    }
                },
                getAnimation: function(name) {
                    if (this._animations[name]) {
                        return this._animations[name];
                    }
                    return null;
                },
                _addAnimationsWithDictionary: function(dictionary, plist) {
                    var animations = dictionary["animations"];
                    if (!animations) {
                        cc.log(cc._LogInfos.spriteFrameAnimationCache._addAnimationsWithDictionary);
                        return;
                    }
                    var version = 1;
                    var properties = dictionary["properties"];
                    if (properties) {
                        version = null != properties["format"] ? parseInt(properties["format"]) : version;
                        var spritesheets = properties["spritesheets"];
                        var spriteFrameCache = cc.spriteFrameCache;
                        var path = cc.path;
                        for (var i = 0; i < spritesheets.length; i++) {
                            spriteFrameCache.addSpriteFrames(path.changeBasename(plist, spritesheets[i]));
                        }
                    }
                    switch (version) {
                      case 1:
                        this._parseVersion1(animations);
                        break;

                      case 2:
                        this._parseVersion2(animations);
                        break;

                      default:
                        cc.log(cc._LogInfos.spriteFrameAnimationCache._addAnimationsWithDictionary_2);
                    }
                },
                addAnimations: function(plist) {
                    cc.assert(plist, cc._LogInfos.spriteFrameAnimationCache.addAnimations_2);
                    var dict = cc.loader.getRes(plist);
                    if (!dict) {
                        cc.log(cc._LogInfos.spriteFrameAnimationCache.addAnimations);
                        return;
                    }
                    this._addAnimationsWithDictionary(dict, plist);
                },
                _parseVersion1: function(animations) {
                    var frameCache = cc.spriteFrameCache;
                    for (var key in animations) {
                        var animationDict = animations[key];
                        var frameNames = animationDict["frames"];
                        var delay = parseFloat(animationDict["delay"]) || 0;
                        var animation = null;
                        if (!frameNames) {
                            cc.log(cc._LogInfos.spriteFrameAnimationCache._parseVersion1, key);
                            continue;
                        }
                        var frames = [];
                        for (var i = 0; i < frameNames.length; i++) {
                            var spriteFrame = frameCache.getSpriteFrame(frameNames[i]);
                            if (!spriteFrame) {
                                cc.log(cc._LogInfos.spriteFrameAnimationCache._parseVersion1_2, key, frameNames[i]);
                                continue;
                            }
                            var animFrame = new cc.AnimationFrame();
                            animFrame.initWithSpriteFrame(spriteFrame, 1, null);
                            frames.push(animFrame);
                        }
                        if (0 === frames.length) {
                            cc.log(cc._LogInfos.spriteFrameAnimationCache._parseVersion1_3, key);
                            continue;
                        } else {
                            if (frames.length !== frameNames.length) {
                                cc.log(cc._LogInfos.spriteFrameAnimationCache._parseVersion1_4, key);
                            }
                        }
                        animation = new cc.SpriteFrameAnimation(frames, delay, 1);
                        cc.spriteFrameAnimationCache.addAnimation(animation, key);
                    }
                },
                _parseVersion2: function(animations) {
                    var frameCache = cc.spriteFrameCache;
                    for (var key in animations) {
                        var animationDict = animations[key];
                        var isLoop = animationDict["loop"];
                        var loopsTemp = parseInt(animationDict["loops"]);
                        var loops = isLoop ? cc.REPEAT_FOREVER : isNaN(loopsTemp) ? 1 : loopsTemp;
                        var restoreOriginalFrame = animationDict["restoreOriginalFrame"] && true == animationDict["restoreOriginalFrame"] ? true : false;
                        var frameArray = animationDict["frames"];
                        if (!frameArray) {
                            cc.log(cc._LogInfos.spriteFrameAnimationCache._parseVersion2, key);
                            continue;
                        }
                        var arr = [];
                        for (var i = 0; i < frameArray.length; i++) {
                            var entry = frameArray[i];
                            var spriteFrameName = entry["spriteframe"];
                            var spriteFrame = frameCache.getSpriteFrame(spriteFrameName);
                            if (!spriteFrame) {
                                cc.log(cc._LogInfos.spriteFrameAnimationCache._parseVersion2_2, key, spriteFrameName);
                                continue;
                            }
                            var delayUnits = parseFloat(entry["delayUnits"]) || 0;
                            var userInfo = entry["notification"];
                            var animFrame = new cc.AnimationFrame();
                            animFrame.initWithSpriteFrame(spriteFrame, delayUnits, userInfo);
                            arr.push(animFrame);
                        }
                        var delayPerUnit = parseFloat(animationDict["delayPerUnit"]) || 0;
                        var animation = new cc.SpriteFrameAnimation();
                        animation.initWithAnimationFrames(arr, delayPerUnit, loops);
                        animation.setRestoreOriginalFrame(restoreOriginalFrame);
                        cc.spriteFrameAnimationCache.addAnimation(animation, key);
                    }
                },
                _clear: function() {
                    this._animations = {};
                }
            };
            require("../cocos2d/core/sprites/CCSpriteFrame");
            cc.spriteFrameCache = {
                _CCNS_REG1: /^\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*$/,
                _CCNS_REG2: /^\s*\{\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*,\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*\}\s*$/,
                _spriteFrames: {},
                _spriteFramesAliases: {},
                _frameConfigCache: {},
                _rectFromString: function(content) {
                    var result = this._CCNS_REG2.exec(content);
                    if (!result) {
                        return cc.rect(0, 0, 0, 0);
                    }
                    return cc.rect(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]), parseFloat(result[4]));
                },
                _pointFromString: function(content) {
                    var result = this._CCNS_REG1.exec(content);
                    if (!result) {
                        return cc.p(0, 0);
                    }
                    return cc.p(parseFloat(result[1]), parseFloat(result[2]));
                },
                _sizeFromString: function(content) {
                    var result = this._CCNS_REG1.exec(content);
                    if (!result) {
                        return cc.size(0, 0);
                    }
                    return cc.size(parseFloat(result[1]), parseFloat(result[2]));
                },
                _getFrameConfig: function(url) {
                    var dict = cc.loader.getRes(url);
                    cc.assert(dict, cc._LogInfos.spriteFrameCache._getFrameConfig_2, url);
                    cc.loader.release(url);
                    if (dict._inited) {
                        this._frameConfigCache[url] = dict;
                        return dict;
                    }
                    this._frameConfigCache[url] = this._parseFrameConfig(dict);
                    return this._frameConfigCache[url];
                },
                _getFrameConfigByJsonObject: function(url, jsonObject) {
                    cc.assert(jsonObject, cc._LogInfos.spriteFrameCache._getFrameConfig_2, url);
                    this._frameConfigCache[url] = this._parseFrameConfig(jsonObject);
                    return this._frameConfigCache[url];
                },
                _parseFrameConfig: function(dict) {
                    var tempFrames = dict["frames"], tempMeta = dict["metadata"] || dict["meta"];
                    var frames = {}, meta = {};
                    var format = 0;
                    if (tempMeta) {
                        var tmpFormat = tempMeta["format"];
                        format = tmpFormat.length <= 1 ? parseInt(tmpFormat) : tmpFormat;
                        meta.image = tempMeta["textureFileName"] || tempMeta["textureFileName"] || tempMeta["image"];
                    }
                    for (var key in tempFrames) {
                        var frameDict = tempFrames[key];
                        if (!frameDict) {
                            continue;
                        }
                        var tempFrame = {};
                        if (0 == format) {
                            tempFrame.rect = cc.rect(frameDict["x"], frameDict["y"], frameDict["width"], frameDict["height"]);
                            tempFrame.rotated = false;
                            tempFrame.offset = cc.p(frameDict["offsetX"], frameDict["offsetY"]);
                            var ow = frameDict["originalWidth"];
                            var oh = frameDict["originalHeight"];
                            if (!ow || !oh) {
                                cc.log(cc._LogInfos.spriteFrameCache._getFrameConfig);
                            }
                            ow = Math.abs(ow);
                            oh = Math.abs(oh);
                            tempFrame.size = cc.size(ow, oh);
                        } else {
                            if (1 == format || 2 == format) {
                                tempFrame.rect = this._rectFromString(frameDict["frame"]);
                                tempFrame.rotated = frameDict["rotated"] || false;
                                tempFrame.offset = this._pointFromString(frameDict["offset"]);
                                tempFrame.size = this._sizeFromString(frameDict["sourceSize"]);
                            } else {
                                if (3 == format) {
                                    var spriteSize = this._sizeFromString(frameDict["spriteSize"]);
                                    var textureRect = this._rectFromString(frameDict["textureRect"]);
                                    if (spriteSize) {
                                        textureRect = cc.rect(textureRect.x, textureRect.y, spriteSize.width, spriteSize.height);
                                    }
                                    tempFrame.rect = textureRect;
                                    tempFrame.rotated = frameDict["textureRotated"] || false;
                                    tempFrame.offset = this._pointFromString(frameDict["spriteOffset"]);
                                    tempFrame.size = this._sizeFromString(frameDict["spriteSourceSize"]);
                                    tempFrame.aliases = frameDict["aliases"];
                                } else {
                                    var tmpFrame = frameDict["frame"], tmpSourceSize = frameDict["sourceSize"];
                                    key = frameDict["filename"] || key;
                                    tempFrame.rect = cc.rect(tmpFrame["x"], tmpFrame["y"], tmpFrame["w"], tmpFrame["h"]);
                                    tempFrame.rotated = frameDict["rotated"] || false;
                                    tempFrame.offset = cc.p(0, 0);
                                    tempFrame.size = cc.size(tmpSourceSize["w"], tmpSourceSize["h"]);
                                }
                            }
                        }
                        frames[key] = tempFrame;
                    }
                    return {
                        _inited: true,
                        frames: frames,
                        meta: meta
                    };
                },
                _addSpriteFramesByObject: function(url, jsonObject, texture) {
                    cc.assert(url, cc._LogInfos.spriteFrameCache.addSpriteFrames_2);
                    if (!jsonObject || !jsonObject["frames"]) {
                        return;
                    }
                    var frameConfig = this._frameConfigCache[url] || this._getFrameConfigByJsonObject(url, jsonObject);
                    this._createSpriteFrames(url, frameConfig, texture);
                },
                _createSpriteFrames: function(url, frameConfig, texture) {
                    var frames = frameConfig.frames, meta = frameConfig.meta;
                    if (!texture) {
                        var texturePath = cc.path.changeBasename(url, meta.image || ".png");
                        texture = cc.textureCache.addImage(texturePath);
                    } else {
                        if (texture instanceof cc.Texture2D) {
                            ;
                        } else {
                            if (cc.js.isString(texture)) {
                                texture = cc.textureCache.addImage(texture);
                            } else {
                                cc.assert(0, cc._LogInfos.spriteFrameCache.addSpriteFrames_3);
                            }
                        }
                    }
                    var spAliases = this._spriteFramesAliases, spriteFrames = this._spriteFrames;
                    for (var key in frames) {
                        var frame = frames[key];
                        var spriteFrame = spriteFrames[key];
                        if (!spriteFrame) {
                            spriteFrame = new cc.SpriteFrame(texture, frame.rect, frame.rotated, frame.offset, frame.size);
                            var aliases = frame.aliases;
                            if (aliases) {
                                for (var i = 0, li = aliases.length; i < li; i++) {
                                    var alias = aliases[i];
                                    if (spAliases[alias]) {
                                        cc.log(cc._LogInfos.spriteFrameCache.addSpriteFrames, alias);
                                    }
                                    spAliases[alias] = key;
                                }
                            }
                            if (cc._renderType === cc.game.RENDER_TYPE_CANVAS && spriteFrame.isRotated()) {
                                var locTexture = spriteFrame.getTexture();
                                if (locTexture.isLoaded()) {
                                    var tempElement = spriteFrame.getTexture().getHtmlElementObj();
                                    tempElement = _ccsg.Sprite.CanvasRenderCmd._cutRotateImageToCanvas(tempElement, spriteFrame.getRectInPixels());
                                    var tempTexture = new cc.Texture2D();
                                    tempTexture.initWithElement(tempElement);
                                    tempTexture.handleLoadedTexture();
                                    spriteFrame.setTexture(tempTexture);
                                    var rect = spriteFrame._rect;
                                    spriteFrame.setRect(cc.rect(0, 0, rect.width, rect.height));
                                }
                            }
                            spriteFrames[key] = spriteFrame;
                        }
                    }
                },
                addSpriteFrames: function(url, texture) {
                    cc.assert(url, cc._LogInfos.spriteFrameCache.addSpriteFrames_2);
                    var dict = this._frameConfigCache[url] || cc.loader.getRes(url);
                    if (!dict || !dict["frames"]) {
                        return;
                    }
                    var frameConfig = this._frameConfigCache[url] || this._getFrameConfig(url);
                    this._createSpriteFrames(url, frameConfig, texture);
                },
                _checkConflict: function(dictionary) {
                    var framesDict = dictionary["frames"];
                    for (var key in framesDict) {
                        if (this._spriteFrames[key]) {
                            cc.log(cc._LogInfos.spriteFrameCache._checkConflict, key);
                        }
                    }
                },
                addSpriteFrame: function(frame, frameName) {
                    this._spriteFrames[frameName] = frame;
                },
                removeSpriteFrames: function() {
                    this._spriteFrames = {};
                    this._spriteFramesAliases = {};
                },
                removeSpriteFrameByName: function(name) {
                    if (!name) {
                        return;
                    }
                    if (this._spriteFramesAliases[name]) {
                        delete this._spriteFramesAliases[name];
                    }
                    if (this._spriteFrames[name]) {
                        delete this._spriteFrames[name];
                    }
                },
                removeSpriteFramesFromFile: function(url) {
                    var self = this, spriteFrames = self._spriteFrames, aliases = self._spriteFramesAliases, cfg = self._frameConfigCache[url];
                    if (!cfg) {
                        return;
                    }
                    var frames = cfg.frames;
                    for (var key in frames) {
                        if (spriteFrames[key]) {
                            delete spriteFrames[key];
                            for (var alias in aliases) {
                                if (aliases[alias] === key) {
                                    delete aliases[alias];
                                }
                            }
                        }
                    }
                },
                removeSpriteFramesFromTexture: function(texture) {
                    var self = this, spriteFrames = self._spriteFrames, aliases = self._spriteFramesAliases;
                    for (var key in spriteFrames) {
                        var frame = spriteFrames[key];
                        if (frame && frame.getTexture() === texture) {
                            delete spriteFrames[key];
                            for (var alias in aliases) {
                                if (aliases[alias] === key) {
                                    delete aliases[alias];
                                }
                            }
                        }
                    }
                },
                getSpriteFrame: function(name) {
                    var self = this, frame = self._spriteFrames[name];
                    if (!frame) {
                        var key = self._spriteFramesAliases[name];
                        if (key) {
                            frame = self._spriteFrames[key.toString()];
                            if (!frame) {
                                delete self._spriteFramesAliases[name];
                            }
                        }
                    }
                    return frame;
                },
                _clear: function() {
                    this._spriteFrames = {};
                    this._spriteFramesAliases = {};
                    this._frameConfigCache = {};
                }
            };
            cc.SpriteBatchNode = _ccsg.Node.extend({
                _blendFunc: null,
                _descendants: null,
                _className: "SpriteBatchNode",
                ctor: function(fileImage, capacity) {
                    _ccsg.Node.prototype.ctor.call(this);
                    this._descendants = [];
                    this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
                    var texture2D;
                    capacity = capacity || cc.SpriteBatchNode.DEFAULT_CAPACITY;
                    if (cc.js.isString(fileImage)) {
                        texture2D = cc.textureCache.getTextureForKey(fileImage);
                        if (!texture2D) {
                            texture2D = cc.textureCache.addImage(fileImage);
                        }
                    } else {
                        if (fileImage instanceof cc.Texture2D) {
                            texture2D = fileImage;
                        }
                    }
                    texture2D && this.initWithTexture(texture2D, capacity);
                },
                addSpriteWithoutQuad: function(child, z, aTag) {
                    cc.assert(child, cc._LogInfos.SpriteBatchNode.addSpriteWithoutQuad_2);
                    if (!(child instanceof _ccsg.Sprite)) {
                        cc.log(cc._LogInfos.SpriteBatchNode.addSpriteWithoutQuad);
                        return null;
                    }
                    child.atlasIndex = z;
                    var i = 0, len, locDescendants = this._descendants;
                    if (locDescendants && locDescendants.length > 0) {
                        for (i = 0, len = locDescendants.length; i < len; i++) {
                            var obj = locDescendants[i];
                            if (obj && obj.atlasIndex >= z) {
                                break;
                            }
                        }
                    }
                    locDescendants.splice(i, 0, child);
                    _ccsg.Node.prototype.addChild.call(this, child, z, aTag);
                    this.reorderBatch(false);
                    return this;
                },
                getTextureAtlas: function() {
                    return this._renderCmd.getTextureAtlas();
                },
                setTextureAtlas: function(textureAtlas) {
                    this._renderCmd.getTextureAtlas(textureAtlas);
                },
                getDescendants: function() {
                    return this._descendants;
                },
                initWithFile: function(fileImage, capacity) {
                    var texture2D = cc.textureCache.getTextureForKey(fileImage);
                    if (!texture2D) {
                        texture2D = cc.textureCache.addImage(fileImage);
                    }
                    return this.initWithTexture(texture2D, capacity);
                },
                _setNodeDirtyForCache: function() {
                    if (this._renderCmd && this._renderCmd._setNodeDirtyForCache) {
                        this._renderCmd._setNodeDirtyForCache();
                    }
                },
                init: function(fileImage, capacity) {
                    var texture2D = cc.textureCache.getTextureForKey(fileImage);
                    if (!texture2D) {
                        texture2D = cc.textureCache.addImage(fileImage);
                    }
                    return this.initWithTexture(texture2D, capacity);
                },
                increaseAtlasCapacity: function() {
                    this._renderCmd.increaseAtlasCapacity();
                },
                removeChildAtIndex: function(index, doCleanup) {
                    this.removeChild(this._children[index], doCleanup);
                },
                rebuildIndexInOrder: function(pobParent, index) {
                    var children = pobParent.children;
                    if (children && children.length > 0) {
                        for (var i = 0; i < children.length; i++) {
                            var obj = children[i];
                            if (obj && obj.zIndex < 0) {
                                index = this.rebuildIndexInOrder(obj, index);
                            }
                        }
                    }
                    if (!pobParent === this) {
                        pobParent.atlasIndex = index;
                        index++;
                    }
                    if (children && children.length > 0) {
                        for (i = 0; i < children.length; i++) {
                            obj = children[i];
                            if (obj && obj.zIndex >= 0) {
                                index = this.rebuildIndexInOrder(obj, index);
                            }
                        }
                    }
                    return index;
                },
                highestAtlasIndexInChild: function(sprite) {
                    var children = sprite.children;
                    if (!children || 0 === children.length) {
                        return sprite.atlasIndex;
                    } else {
                        return this.highestAtlasIndexInChild(children[children.length - 1]);
                    }
                },
                lowestAtlasIndexInChild: function(sprite) {
                    var children = sprite.children;
                    if (!children || 0 === children.length) {
                        return sprite.atlasIndex;
                    } else {
                        return this.lowestAtlasIndexInChild(children[children.length - 1]);
                    }
                },
                atlasIndexForChild: function(sprite, nZ) {
                    var selParent = sprite.parent;
                    var brothers = selParent.children;
                    var childIndex = brothers.indexOf(sprite);
                    var ignoreParent = selParent === this;
                    var previous = null;
                    if (childIndex > 0 && childIndex < cc.UINT_MAX) {
                        previous = brothers[childIndex - 1];
                    }
                    if (ignoreParent) {
                        if (0 === childIndex) {
                            return 0;
                        }
                        return this.highestAtlasIndexInChild(previous) + 1;
                    }
                    if (0 === childIndex) {
                        if (nZ < 0) {
                            return selParent.atlasIndex;
                        } else {
                            return selParent.atlasIndex + 1;
                        }
                    } else {
                        if (previous.zIndex < 0 && nZ < 0 || previous.zIndex >= 0 && nZ >= 0) {
                            return this.highestAtlasIndexInChild(previous) + 1;
                        }
                        return selParent.atlasIndex + 1;
                    }
                },
                reorderBatch: function(reorder) {
                    this._reorderChildDirty = reorder;
                },
                setBlendFunc: function(src, dst) {
                    if (void 0 === dst) {
                        this._blendFunc = src;
                    } else {
                        this._blendFunc = {
                            src: src,
                            dst: dst
                        };
                    }
                },
                getBlendFunc: function() {
                    return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst);
                },
                reorderChild: function(child, zOrder) {
                    cc.assert(child, cc._LogInfos.SpriteBatchNode.reorderChild_2);
                    if (-1 === this._children.indexOf(child)) {
                        cc.log(cc._LogInfos.SpriteBatchNode.reorderChild);
                        return;
                    }
                    if (zOrder === child.zIndex) {
                        return;
                    }
                    _ccsg.Node.prototype.reorderChild.call(this, child, zOrder);
                },
                removeChild: function(child, cleanup) {
                    if (null == child) {
                        return;
                    }
                    if (-1 === this._children.indexOf(child)) {
                        cc.log(cc._LogInfos.SpriteBatchNode.removeChild);
                        return;
                    }
                    this.removeSpriteFromAtlas(child);
                    _ccsg.Node.prototype.removeChild.call(this, child, cleanup);
                },
                updateQuadFromSprite: function(sprite, index) {
                    cc.assert(sprite, cc._LogInfos.SpriteBatchNode.updateQuadFromSprite_2);
                    if (!(sprite instanceof _ccsg.Sprite)) {
                        cc.log(cc._LogInfos.SpriteBatchNode.updateQuadFromSprite);
                        return;
                    }
                    this._renderCmd.checkAtlasCapacity();
                    sprite.batchNode = this;
                    sprite.atlasIndex = index;
                    sprite.dirty = true;
                    sprite.updateTransform();
                },
                insertQuadFromSprite: function(sprite, index) {
                    cc.assert(sprite, cc._LogInfos.SpriteBatchNode.insertQuadFromSprite_2);
                    if (!(sprite instanceof _ccsg.Sprite)) {
                        cc.log(cc._LogInfos.SpriteBatchNode.insertQuadFromSprite);
                        return;
                    }
                    this._renderCmd.insertQuad(sprite, index);
                    sprite.batchNode = this;
                    sprite.atlasIndex = index;
                    sprite.dirty = true;
                    sprite.updateTransform();
                    this._renderCmd.cutting(sprite, index);
                },
                initWithTexture: function(tex, capacity) {
                    this._children.length = 0;
                    this._descendants.length = 0;
                    capacity = capacity || cc.SpriteBatchNode.DEFAULT_CAPACITY;
                    this._renderCmd.initWithTexture(tex, capacity);
                    return true;
                },
                insertChild: function(sprite, index) {
                    sprite.batchNode = this;
                    sprite.atlasIndex = index;
                    sprite.dirty = true;
                    this._renderCmd.insertQuad(sprite, index);
                    this._descendants.splice(index, 0, sprite);
                    var i = index + 1, locDescendant = this._descendants;
                    if (locDescendant && locDescendant.length > 0) {
                        for (;i < locDescendant.length; i++) {
                            locDescendant[i].atlasIndex++;
                        }
                    }
                    var locChildren = sprite.children, child, l;
                    if (locChildren) {
                        for (i = 0, l = locChildren.length || 0; i < l; i++) {
                            child = locChildren[i];
                            if (child) {
                                var getIndex = this.atlasIndexForChild(child, child.zIndex);
                                this.insertChild(child, getIndex);
                            }
                        }
                    }
                },
                appendChild: function(sprite) {
                    this._reorderChildDirty = true;
                    sprite.batchNode = this;
                    sprite.dirty = true;
                    this._descendants.push(sprite);
                    var index = this._descendants.length - 1;
                    sprite.atlasIndex = index;
                    this._renderCmd.insertQuad(sprite, index);
                    var children = sprite.children;
                    for (var i = 0, l = children.length || 0; i < l; i++) {
                        this.appendChild(children[i]);
                    }
                },
                removeSpriteFromAtlas: function(sprite) {
                    this._renderCmd.removeQuadAtIndex(sprite.atlasIndex);
                    sprite.batchNode = null;
                    var locDescendants = this._descendants;
                    var index = locDescendants.indexOf(sprite);
                    if (-1 !== index) {
                        locDescendants.splice(index, 1);
                        var len = locDescendants.length;
                        for (;index < len; ++index) {
                            var s = locDescendants[index];
                            s.atlasIndex--;
                        }
                    }
                    var children = sprite.children;
                    if (children) {
                        for (var i = 0, l = children.length || 0; i < l; i++) {
                            children[i] && this.removeSpriteFromAtlas(children[i]);
                        }
                    }
                },
                getTexture: function() {
                    return this._renderCmd.getTexture();
                },
                setTexture: function(texture) {
                    this._renderCmd.setTexture(texture);
                },
                addChild: function(child, zOrder, tag) {
                    cc.assert(null != child, cc._LogInfos.SpriteBatchNode.addChild_3);
                    if (!this._renderCmd.isValidChild(child)) {
                        return;
                    }
                    zOrder = null == zOrder ? child.zIndex : zOrder;
                    tag = null == tag ? child.tag : tag;
                    _ccsg.Node.prototype.addChild.call(this, child, zOrder, tag);
                    this.appendChild(child);
                },
                removeAllChildren: function(cleanup) {
                    var locDescendants = this._descendants;
                    if (locDescendants && locDescendants.length > 0) {
                        for (var i = 0, len = locDescendants.length; i < len; i++) {
                            if (locDescendants[i]) {
                                locDescendants[i].batchNode = null;
                            }
                        }
                    }
                    _ccsg.Node.prototype.removeAllChildren.call(this, cleanup);
                    this._descendants.length = 0;
                    this._renderCmd.removeAllQuads();
                },
                sortAllChildren: function() {
                    if (this._reorderChildDirty) {
                        var childrenArr = this._children;
                        var i, j = 0, length = childrenArr.length, tempChild;
                        for (i = 1; i < length; i++) {
                            var tempItem = childrenArr[i];
                            j = i - 1;
                            tempChild = childrenArr[j];
                            while (j >= 0 && (tempItem._localZOrder < tempChild._localZOrder || tempItem._localZOrder === tempChild._localZOrder && tempItem.arrivalOrder < tempChild.arrivalOrder)) {
                                childrenArr[j + 1] = tempChild;
                                j -= 1;
                                tempChild = childrenArr[j];
                            }
                            childrenArr[j + 1] = tempItem;
                        }
                        if (childrenArr.length > 0) {
                            this._arrayMakeObjectsPerformSelector(childrenArr, _ccsg.Node._stateCallbackType.sortAllChildren);
                            this._renderCmd.updateChildrenAtlasIndex(childrenArr);
                        }
                        this._reorderChildDirty = false;
                    }
                },
                _createRenderCmd: function() {
                    if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                        return new cc.SpriteBatchNode.CanvasRenderCmd(this);
                    } else {
                        return new cc.SpriteBatchNode.WebGLRenderCmd(this);
                    }
                }
            });
            var _p = cc.SpriteBatchNode.prototype;
            cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
            cc.defineGetterSetter(_p, "textureAtlas", _p.getTextureAtlas, _p.setTextureAtlas);
            _p.descendants;
            cc.defineGetterSetter(_p, "descendants", _p.getDescendants);
            cc.SpriteBatchNode.DEFAULT_CAPACITY = 29;
            cc.SpriteBatchNode.create = function(fileImage, capacity) {
                return new cc.SpriteBatchNode(fileImage, capacity);
            };
            cc.SpriteBatchNode.createWithTexture = cc.SpriteBatchNode.create;
            !function() {
                cc.SpriteBatchNode.CanvasRenderCmd = function(renderable) {
                    _ccsg.Node.CanvasRenderCmd.call(this, renderable);
                    this._texture = null;
                    this._textureToRender = null;
                };
                var proto = cc.SpriteBatchNode.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
                proto.constructor = cc.SpriteBatchNode.CanvasRenderCmd;
                proto.checkAtlasCapacity = function() {};
                proto.isValidChild = function(child) {
                    if (!(child instanceof _ccsg.Sprite)) {
                        cc.log(cc._LogInfos.Sprite.addChild_4);
                        return false;
                    }
                    return true;
                };
                proto.initWithTexture = function(texture, capacity) {
                    this._textureToRender = this._texture = texture;
                };
                proto.insertQuad = function(sprite, index) {};
                proto.increaseAtlasCapacity = function() {};
                proto.removeQuadAtIndex = function() {};
                proto.removeAllQuads = function() {};
                proto.getTexture = function() {
                    return this._texture;
                };
                proto.setTexture = function(texture) {
                    this._texture = texture;
                    var locChildren = this._node._children;
                    for (var i = 0; i < locChildren.length; i++) {
                        locChildren[i].setTexture(texture);
                    }
                };
                proto.updateChildrenAtlasIndex = function(children) {
                    this._node._descendants.length = 0;
                    for (var i = 0, len = children.length; i < len; i++) {
                        this._updateAtlasIndex(children[i]);
                    }
                };
                proto._updateAtlasIndex = function(sprite) {
                    var locDescendants = this._node._descendants;
                    var pArray = sprite.children, i, len = pArray.length;
                    for (i = 0; i < len; i++) {
                        if (pArray[i]._localZOrder < 0) {
                            locDescendants.push(pArray[i]);
                        } else {
                            break;
                        }
                    }
                    locDescendants.push(sprite);
                    for (;i < len; i++) {
                        locDescendants.push(pArray[i]);
                    }
                };
                proto.getTextureAtlas = function() {};
                proto.setTextureAtlas = function(textureAtlas) {};
                proto.cutting = function(sprite, index) {
                    var node = this._node;
                    node._children.splice(index, 0, sprite);
                };
            }();
            !function() {
                cc.SpriteBatchNode.WebGLRenderCmd = function(renderable) {
                    _ccsg.Node.WebGLRenderCmd.call(this, renderable);
                    this._needDraw = true;
                    this._textureAtlas = null;
                };
                var proto = cc.SpriteBatchNode.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
                proto.constructor = cc.SpriteBatchNode.WebGLRenderCmd;
                proto.isValidChild = function(child) {
                    if (!(child instanceof _ccsg.Sprite)) {
                        cc.log(cc._LogInfos.Sprite.addChild_4);
                        return false;
                    }
                    if (child.texture != this.getTexture()) {
                        cc.log(cc._LogInfos.Sprite.addChild_5);
                        return false;
                    }
                    return true;
                };
                proto.rendering = function() {
                    var node = this._node;
                    if (0 === this._textureAtlas.totalQuads) {
                        return;
                    }
                    this._shaderProgram.use();
                    this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
                    node._arrayMakeObjectsPerformSelector(node._children, _ccsg.Node._stateCallbackType.updateTransform);
                    cc.glBlendFunc(node._blendFunc.src, node._blendFunc.dst);
                    this._textureAtlas.drawQuads();
                };
                proto.visit = function(parentCmd) {
                    var node = this._node;
                    if (!node._visible) {
                        return;
                    }
                    if (node._parent && node._parent._renderCmd) {
                        this._curLevel = node._parent._renderCmd._curLevel + 1;
                    }
                    var currentStack = cc.current_stack;
                    currentStack.stack.push(currentStack.top);
                    if (!(this._dirtyFlag & _ccsg.Node._dirtyFlags.transformDirty)) {
                        this.transform(parentCmd);
                    }
                    this.updateStatus(parentCmd);
                    currentStack.top = this._stackMatrix;
                    node.sortAllChildren();
                    cc.renderer.pushRenderCommand(this);
                    this._dirtyFlag = 0;
                    currentStack.top = currentStack.stack.pop();
                };
                proto.checkAtlasCapacity = function(index) {
                    var locAtlas = this._textureAtlas;
                    while (index >= locAtlas.capacity || locAtlas.capacity === locAtlas.totalQuads) {
                        this.increaseAtlasCapacity();
                    }
                };
                proto.increaseAtlasCapacity = function() {
                    var locCapacity = this._textureAtlas.capacity;
                    var quantity = Math.floor(4 * (locCapacity + 1) / 3);
                    cc.log(cc._LogInfos.SpriteBatchNode.increaseAtlasCapacity, locCapacity, quantity);
                    if (!this._textureAtlas.resizeCapacity(quantity)) {
                        cc.log(cc._LogInfos.SpriteBatchNode.increaseAtlasCapacity_2);
                    }
                };
                proto.initWithTexture = function(texture, capacity) {
                    this._textureAtlas = new cc.TextureAtlas();
                    this._textureAtlas.initWithTexture(texture, capacity);
                    this._updateBlendFunc();
                    this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
                };
                proto.insertQuad = function(sprite, index) {
                    var locTextureAtlas = this._textureAtlas;
                    if (locTextureAtlas.totalQuads >= locTextureAtlas.capacity) {
                        this.increaseAtlasCapacity();
                    }
                    locTextureAtlas.insertQuad(sprite.quad, index);
                };
                proto.removeQuadAtIndex = function(index) {
                    this._textureAtlas.removeQuadAtIndex(index);
                };
                proto.getTexture = function() {
                    return this._textureAtlas.texture;
                };
                proto.setTexture = function(texture) {
                    this._textureAtlas.setTexture(texture);
                    if (texture) {
                        this._updateBlendFunc();
                    }
                };
                proto.removeAllQuads = function() {
                    this._textureAtlas.removeAllQuads();
                };
                proto._swap = function(oldIndex, newIndex) {
                    var locDescendants = this._node._descendants;
                    var locTextureAtlas = this._textureAtlas;
                    var quads = locTextureAtlas.quads;
                    var tempItem = locDescendants[oldIndex];
                    var tempIteQuad = cc.V3F_C4B_T2F_QuadCopy(quads[oldIndex]);
                    locDescendants[newIndex].atlasIndex = oldIndex;
                    locDescendants[oldIndex] = locDescendants[newIndex];
                    locTextureAtlas.updateQuad(quads[newIndex], oldIndex);
                    locDescendants[newIndex] = tempItem;
                    locTextureAtlas.updateQuad(tempIteQuad, newIndex);
                };
                proto._updateAtlasIndex = function(sprite, curIndex) {
                    var count = 0;
                    var pArray = sprite.children;
                    if (pArray) {
                        count = pArray.length;
                    }
                    var oldIndex = 0;
                    if (0 === count) {
                        oldIndex = sprite.atlasIndex;
                        sprite.atlasIndex = curIndex;
                        sprite.arrivalOrder = 0;
                        if (oldIndex !== curIndex) {
                            this._swap(oldIndex, curIndex);
                        }
                        curIndex++;
                    } else {
                        var needNewIndex = true;
                        if (pArray[0].zIndex >= 0) {
                            oldIndex = sprite.atlasIndex;
                            sprite.atlasIndex = curIndex;
                            sprite.arrivalOrder = 0;
                            if (oldIndex !== curIndex) {
                                this._swap(oldIndex, curIndex);
                            }
                            curIndex++;
                            needNewIndex = false;
                        }
                        for (var i = 0; i < pArray.length; i++) {
                            var child = pArray[i];
                            if (needNewIndex && child.zIndex >= 0) {
                                oldIndex = sprite.atlasIndex;
                                sprite.atlasIndex = curIndex;
                                sprite.arrivalOrder = 0;
                                if (oldIndex !== curIndex) {
                                    this._swap(oldIndex, curIndex);
                                }
                                curIndex++;
                                needNewIndex = false;
                            }
                            curIndex = this._updateAtlasIndex(child, curIndex);
                        }
                        if (needNewIndex) {
                            oldIndex = sprite.atlasIndex;
                            sprite.atlasIndex = curIndex;
                            sprite.arrivalOrder = 0;
                            if (oldIndex !== curIndex) {
                                this._swap(oldIndex, curIndex);
                            }
                            curIndex++;
                        }
                    }
                    return curIndex;
                };
                proto.updateChildrenAtlasIndex = function(children) {
                    var index = 0;
                    for (var i = 0; i < children.length; i++) {
                        index = this._updateAtlasIndex(children[i], index);
                    }
                };
                proto._updateBlendFunc = function() {
                    if (!this._textureAtlas.texture.hasPremultipliedAlpha()) {
                        var blendFunc = this._node._blendFunc;
                        blendFunc.src = cc.SRC_ALPHA;
                        blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA;
                    }
                };
                proto.getTextureAtlas = function() {
                    return this._textureAtlas;
                };
                proto.setTextureAtlas = function(textureAtlas) {
                    if (textureAtlas !== this._textureAtlas) {
                        this._textureAtlas = textureAtlas;
                    }
                };
                proto.cutting = function() {};
            }();
            EventTarget = require("../cocos2d/core/event/event-target");
            cc.Scale9Sprite = _ccsg.Node.extend({
                _spriteFrame: null,
                _insetLeft: 0,
                _insetRight: 0,
                _insetTop: 0,
                _insetBottom: 0,
                _blendFunc: null,
                _renderingType: 1,
                _brightState: 0,
                _quads: [],
                _quadsDirty: true,
                ctor: function(textureOrSpriteFrame) {
                    _ccsg.Node.prototype.ctor.call(this);
                    this._renderCmd.setState(this._brightState);
                    this._blendFunc = cc.BlendFunc._alphaNonPremultiplied();
                    this.setAnchorPoint(cc.p(.5, .5));
                    if ("string" === typeof textureOrSpriteFrame) {
                        var frame = cc.spriteFrameCache.getSpriteFrame(textureOrSpriteFrame);
                        if (frame) {
                            this.initWithSpriteFrame(frame);
                        } else {
                            this.initWithTexture(textureOrSpriteFrame);
                        }
                    } else {
                        if (textureOrSpriteFrame instanceof cc.SpriteFrame) {
                            this.initWithSpriteFrame(textureOrSpriteFrame);
                        } else {
                            if (textureOrSpriteFrame instanceof cc.Texture2D) {
                                this.initWithTexture(textureOrSpriteFrame);
                            }
                        }
                    }
                },
                loaded: function() {
                    if (null === this._spriteFrame) {
                        return false;
                    } else {
                        return this._spriteFrame.textureLoaded();
                    }
                },
                initWithTexture: function(textureOrTextureFile) {
                    this.setTexture(textureOrTextureFile);
                },
                initWithSpriteFrame: function(spriteFrameOrSFName) {
                    this.setSpriteFrame(spriteFrameOrSFName);
                },
                setTexture: function(textureOrTextureFile) {
                    var spriteFrame = cc.SpriteFrame.createWithTexture(textureOrTextureFile);
                    this.setSpriteFrame(spriteFrame);
                },
                setSpriteFrame: function(spriteFrameOrSFName) {
                    var spriteFrame;
                    if (spriteFrameOrSFName instanceof cc.SpriteFrame) {
                        spriteFrame = spriteFrameOrSFName;
                    } else {
                        spriteFrame = cc.spriteFrameCache.getSpriteFrame(spriteFrameOrSFName);
                    }
                    if (spriteFrame) {
                        this._spriteFrame = spriteFrame;
                        this._quadsDirty = true;
                        var self = this;
                        var onResourceDataLoaded = function() {
                            if (cc.sizeEqualToSize(self._contentSize, cc.size(0, 0))) {
                                self.setContentSize(self._spriteFrame.getRect());
                            }
                        };
                        if (spriteFrame.textureLoaded()) {
                            onResourceDataLoaded();
                        } else {
                            spriteFrame.once("load", onResourceDataLoaded, this);
                        }
                    }
                },
                setBlendFunc: function(blendFunc, dst) {
                    if (void 0 === dst) {
                        this._blendFunc.src = blendFunc.src || cc.BLEND_SRC;
                        this._blendFunc.dst = blendFunc.dst || cc.BLEND_DST;
                    } else {
                        this._blendFunc.src = blendFunc || cc.BLEND_SRC;
                        this._blendFunc.dst = dst || cc.BLEND_DST;
                    }
                },
                getBlendFunc: function() {
                    return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst);
                },
                setContentSize: function(width, height) {
                    if (void 0 === height) {
                        height = width.height;
                        width = width.width;
                    }
                    if (width === this._contentSize.width && height === this._contentSize.height) {
                        return;
                    }
                    _ccsg.Node.prototype.setContentSize.call(this, width, height);
                    this._quadsDirty = true;
                },
                setState: function(state) {
                    this._brightState = state;
                    this._renderCmd.setState(state);
                },
                getState: function() {
                    return this._brightState;
                },
                setRenderingType: function(type) {
                    if (this._renderingType === type) {
                        return;
                    }
                    this._renderingType = type;
                    this._quadsDirty = true;
                },
                getRenderingType: function() {
                    return this._renderingType;
                },
                setInsetLeft: function(insetLeft) {
                    this._insetLeft = insetLeft;
                    this._quadsDirty = true;
                },
                getInsetLeft: function() {
                    return this._insetLeft;
                },
                setInsetTop: function(insetTop) {
                    this._insetTop = insetTop;
                    this._quadsDirty = true;
                },
                getInsetTop: function() {
                    return this._insetTop;
                },
                setInsetRight: function(insetRight) {
                    this._insetRight = insetRight;
                    this._quadsDirty = true;
                },
                getInsetRight: function() {
                    return this._insetRight;
                },
                setInsetBottom: function(insetBottom) {
                    this._insetBottom = insetBottom;
                    this._quadsDirty = true;
                },
                getInsetBottom: function() {
                    return this._insetBottom;
                },
                _rebuildQuads: function() {
                    if (!this.loaded() || false === this._quadsDirty) {
                        return;
                    }
                    var spriteFrame = this._spriteFrame;
                    var color = this.getDisplayedColor();
                    color.a = this.getDisplayedOpacity();
                    this._quads = [];
                    var vertices = this._calculateVertices();
                    var uvs = this._calculateUVs();
                    var quad;
                    if (this._renderingType == cc.Scale9Sprite.RenderingType.SIMPLE) {
                        quad = new cc.V3F_C4B_T2F_Quad();
                        quad._bl.colors = color;
                        quad._br.colors = color;
                        quad._tl.colors = color;
                        quad._tr.colors = color;
                        quad._bl.vertices = new cc.Vertex3F(vertices[0].x, vertices[0].y, 0);
                        quad._br.vertices = new cc.Vertex3F(vertices[3].x, vertices[0].y, 0);
                        quad._tl.vertices = new cc.Vertex3F(vertices[0].x, vertices[3].y, 0);
                        quad._tr.vertices = new cc.Vertex3F(vertices[3].x, vertices[3].y, 0);
                        if (!spriteFrame._rotated) {
                            quad._bl.texCoords = new cc.Tex2F(uvs[0].x, uvs[0].y);
                            quad._br.texCoords = new cc.Tex2F(uvs[3].x, uvs[0].y);
                            quad._tl.texCoords = new cc.Tex2F(uvs[0].x, uvs[3].y);
                            quad._tr.texCoords = new cc.Tex2F(uvs[3].x, uvs[3].y);
                        } else {
                            quad._bl.texCoords = new cc.Tex2F(uvs[0].x, uvs[3].y);
                            quad._br.texCoords = new cc.Tex2F(uvs[0].x, uvs[0].y);
                            quad._tl.texCoords = new cc.Tex2F(uvs[3].x, uvs[3].y);
                            quad._tr.texCoords = new cc.Tex2F(uvs[3].x, uvs[0].y);
                        }
                        this._quads.push(quad);
                    } else {
                        for (var i = 0; i < 3; ++i) {
                            for (var j = 0; j < 3; ++j) {
                                quad = new cc.V3F_C4B_T2F_Quad();
                                quad._bl.colors = color;
                                quad._br.colors = color;
                                quad._tl.colors = color;
                                quad._tr.colors = color;
                                quad._bl.vertices = new cc.Vertex3F(vertices[i].x, vertices[j].y, 0);
                                quad._br.vertices = new cc.Vertex3F(vertices[i + 1].x, vertices[j].y, 0);
                                quad._tl.vertices = new cc.Vertex3F(vertices[i].x, vertices[j + 1].y, 0);
                                quad._tr.vertices = new cc.Vertex3F(vertices[i + 1].x, vertices[j + 1].y, 0);
                                if (!spriteFrame._rotated) {
                                    quad._bl.texCoords = new cc.Tex2F(uvs[i].x, uvs[j].y);
                                    quad._br.texCoords = new cc.Tex2F(uvs[i + 1].x, uvs[j].y);
                                    quad._tl.texCoords = new cc.Tex2F(uvs[i].x, uvs[j + 1].y);
                                    quad._tr.texCoords = new cc.Tex2F(uvs[i + 1].x, uvs[j + 1].y);
                                } else {
                                    quad._bl.texCoords = new cc.Tex2F(uvs[j].x, uvs[3 - i].y);
                                    quad._br.texCoords = new cc.Tex2F(uvs[j].x, uvs[3 - (i + 1)].y);
                                    quad._tl.texCoords = new cc.Tex2F(uvs[j + 1].x, uvs[3 - i].y);
                                    quad._tr.texCoords = new cc.Tex2F(uvs[j + 1].x, uvs[3 - (i + 1)].y);
                                }
                                this._quads.push(quad);
                            }
                        }
                    }
                    this._quadsDirty = false;
                },
                _calculateVertices: function() {
                    var leftWidth, centerWidth, rightWidth;
                    var topHeight, centerHeight, bottomHeight;
                    var spriteFrame = this._spriteFrame;
                    var rect = spriteFrame._rect;
                    leftWidth = this._insetLeft;
                    rightWidth = this._insetRight;
                    centerWidth = rect.width - leftWidth - rightWidth;
                    topHeight = this._insetTop;
                    bottomHeight = this._insetBottom;
                    centerHeight = rect.height - topHeight - bottomHeight;
                    var preferSize = this.getContentSize();
                    var sizableWidth = preferSize.width - leftWidth - rightWidth;
                    var sizableHeight = preferSize.height - topHeight - bottomHeight;
                    var xScale = preferSize.width / (leftWidth + rightWidth);
                    var yScale = preferSize.height / (topHeight + bottomHeight);
                    xScale = xScale > 1 ? 1 : xScale;
                    yScale = yScale > 1 ? 1 : yScale;
                    sizableWidth = sizableWidth < 0 ? 0 : sizableWidth;
                    sizableHeight = sizableHeight < 0 ? 0 : sizableHeight;
                    var x0, x1, x2, x3;
                    var y0, y1, y2, y3;
                    x0 = 0;
                    x1 = leftWidth * xScale;
                    x2 = x1 + sizableWidth;
                    x3 = preferSize.width;
                    y0 = 0;
                    y1 = bottomHeight * yScale;
                    y2 = y1 + sizableHeight;
                    y3 = preferSize.height;
                    x0 /= cc.contentScaleFactor();
                    x1 /= cc.contentScaleFactor();
                    x2 /= cc.contentScaleFactor();
                    x3 /= cc.contentScaleFactor();
                    y0 /= cc.contentScaleFactor();
                    y1 /= cc.contentScaleFactor();
                    y2 /= cc.contentScaleFactor();
                    y3 /= cc.contentScaleFactor();
                    var vertices = [];
                    vertices.push(cc.p(x0, y0));
                    vertices.push(cc.p(x1, y1));
                    vertices.push(cc.p(x2, y2));
                    vertices.push(cc.p(x3, y3));
                    return vertices;
                },
                _calculateUVs: function() {
                    var spriteFrame = this._spriteFrame;
                    var rect = spriteFrame._rect;
                    var atlasWidth = spriteFrame._texture.getPixelWidth();
                    var atlasHeight = spriteFrame._texture.getPixelHeight();
                    var leftWidth, centerWidth, rightWidth;
                    var topHeight, centerHeight, bottomHeight;
                    leftWidth = this._insetLeft;
                    rightWidth = this._insetRight;
                    centerWidth = rect.width - leftWidth - rightWidth;
                    topHeight = this._insetTop;
                    bottomHeight = this._insetBottom;
                    centerHeight = rect.height - topHeight - bottomHeight;
                    var textureRect = cc.rectPointsToPixels(spriteFrame.getRect());
                    var u0, u1, u2, u3;
                    var v0, v1, v2, v3;
                    if (spriteFrame._rotated) {
                        u0 = textureRect.x / atlasWidth;
                        u1 = (bottomHeight + textureRect.x) / atlasWidth;
                        u2 = (bottomHeight + centerHeight + textureRect.x) / atlasWidth;
                        u3 = (textureRect.x + textureRect.height) / atlasWidth;
                        v0 = textureRect.y / atlasHeight;
                        v1 = (leftWidth + textureRect.y) / atlasHeight;
                        v2 = (leftWidth + centerWidth + textureRect.y) / atlasHeight;
                        v3 = (textureRect.y + textureRect.width) / atlasHeight;
                    } else {
                        u0 = textureRect.x / atlasWidth;
                        u1 = (leftWidth + textureRect.x) / atlasWidth;
                        u2 = (leftWidth + centerWidth + textureRect.x) / atlasWidth;
                        u3 = (textureRect.x + textureRect.width) / atlasWidth;
                        v0 = textureRect.y / atlasHeight;
                        v1 = (topHeight + textureRect.y) / atlasHeight;
                        v2 = (topHeight + centerHeight + textureRect.y) / atlasHeight;
                        v3 = (textureRect.y + textureRect.height) / atlasHeight;
                    }
                    var uvCoordinates = [];
                    uvCoordinates.push(cc.p(u0, v3));
                    uvCoordinates.push(cc.p(u1, v2));
                    uvCoordinates.push(cc.p(u2, v1));
                    uvCoordinates.push(cc.p(u3, v0));
                    return uvCoordinates;
                },
                _onColorOpacityDirty: function() {
                    var color = this.getDisplayedColor();
                    color.a = this.getDisplayedOpacity();
                    var index;
                    var quadLength = this._quads.length;
                    for (index = 0; index < quadLength; ++index) {
                        this._quads[index]._bl.colors = color;
                        this._quads[index]._br.colors = color;
                        this._quads[index]._tl.colors = color;
                        this._quads[index]._tr.colors = color;
                    }
                },
                _createRenderCmd: function() {
                    if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                        return new cc.Scale9Sprite.CanvasRenderCmd(this);
                    } else {
                        return new cc.Scale9Sprite.WebGLRenderCmd(this);
                    }
                }
            });
            var _p = cc.Scale9Sprite.prototype;
            cc.js.addon(_p, EventTarget.prototype);
            _p.insetLeft;
            cc.defineGetterSetter(_p, "insetLeft", _p.getInsetLeft, _p.setInsetLeft);
            _p.insetTop;
            cc.defineGetterSetter(_p, "insetTop", _p.getInsetTop, _p.setInsetTop);
            _p.insetRight;
            cc.defineGetterSetter(_p, "insetRight", _p.getInsetRight, _p.setInsetRight);
            _p.insetBottom;
            cc.defineGetterSetter(_p, "insetBottom", _p.getInsetBottom, _p.setInsetBottom);
            _p = null;
            cc.Scale9Sprite.create = function(file) {
                return new cc.Scale9Sprite(file);
            };
            cc.Scale9Sprite.createWithSpriteFrame = function(spriteFrame) {
                return new cc.Scale9Sprite(spriteFrame);
            };
            cc.Scale9Sprite.createWithSpriteFrameName = function(spriteFrameName) {
                return new cc.Scale9Sprite(spriteFrameName);
            };
            cc.Scale9Sprite.state = {
                NORMAL: 0,
                GRAY: 1
            };
            cc.Scale9Sprite.RenderingType = {
                SIMPLE: 0,
                SLICE: 1
            };
            !function() {
                cc.Scale9Sprite.CanvasRenderCmd = function(renderable) {
                    _ccsg.Node.CanvasRenderCmd.call(this, renderable);
                    this._needDraw = true;
                    this._state = cc.Scale9Sprite.state.NORMAL;
                    this._textureToRender = null;
                };
                var proto = cc.Scale9Sprite.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
                proto.constructor = cc.Scale9Sprite.CanvasRenderCmd;
                proto._updateDisplayOpacity = function(parentOpacity) {
                    _ccsg.Node.WebGLRenderCmd.prototype._updateDisplayOpacity.call(this, parentOpacity);
                    var node = this._node;
                };
                proto._updateDisplayColor = function(parentColor) {
                    _ccsg.Node.WebGLRenderCmd.prototype._updateDisplayColor.call(this, parentColor);
                    var node = this._node;
                    this._textureToRender = null;
                };
                proto.setState = function(state) {
                    if (this._state === state) {
                        return;
                    }
                    this._state = state;
                    this._textureToRender = null;
                };
                proto.rendering = function(ctx, scaleX, scaleY) {
                    var node = this._node;
                    var locDisplayOpacity = this._displayedOpacity;
                    var alpha = locDisplayOpacity / 255;
                    var locTexture = null;
                    if (node._spriteFrame) {
                        locTexture = node._spriteFrame._texture;
                    }
                    if (!node.loaded() || 0 === locDisplayOpacity) {
                        return;
                    }
                    if (null === this._textureToRender) {
                        this._textureToRender = locTexture;
                        if (cc.Scale9Sprite.state.GRAY === this._state) {
                            this._textureToRender = this._textureToRender._generateGrayTexture();
                        }
                        var color = node.getDisplayedColor();
                        if (locTexture && (255 !== color.r || 255 !== color.g || 255 !== color.b)) {
                            this._textureToRender = locTexture._generateColorTexture(color.r, color.g, color.b);
                        }
                    }
                    var wrapper = ctx || cc._renderContext, context = wrapper.getContext();
                    wrapper.setTransform(this._worldTransform, scaleX, scaleY);
                    wrapper.setCompositeOperation(_ccsg.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc(node._blendFunc));
                    wrapper.setGlobalAlpha(alpha);
                    if (this._textureToRender) {
                        if (node._quadsDirty) {
                            node._rebuildQuads();
                        }
                        var quads = node._quads;
                        for (var i = 0; i < quads.length; ++i) {
                            var sx, sy, sw, sh;
                            var x, y, w, h;
                            x = quads[i]._bl.vertices.x;
                            y = quads[i]._bl.vertices.y;
                            w = quads[i]._tr.vertices.x - quads[i]._bl.vertices.x;
                            h = quads[i]._tr.vertices.y - quads[i]._bl.vertices.y;
                            y = -y - h;
                            var textureWidth = this._textureToRender.getPixelWidth();
                            var textureHeight = this._textureToRender.getPixelHeight();
                            sx = quads[i]._tl.texCoords.u * textureWidth;
                            sy = quads[i]._tl.texCoords.v * textureHeight;
                            sw = (quads[i]._tr.texCoords.u - quads[i]._bl.texCoords.u) * textureWidth;
                            sh = (quads[i]._bl.texCoords.v - quads[i]._tr.texCoords.v) * textureHeight;
                            x *= scaleX;
                            y *= scaleY;
                            w *= scaleX;
                            h *= scaleY;
                            var image = this._textureToRender._htmlElementObj;
                            if ("" !== this._textureToRender._pattern) {
                                wrapper.setFillStyle(context.createPattern(image, this._textureToRender._pattern));
                                context.fillRect(x, y, w, h);
                            } else {
                                if (0 !== sw && 0 !== sh && 0 !== w && 0 !== h) {
                                    context.drawImage(image, sx, sy, sw, sh, x, y, w, h);
                                }
                            }
                        }
                    }
                    cc.g_NumberOfDraws += quads.length;
                };
            }();
            !function() {
                if (!_ccsg.Node.WebGLRenderCmd) {
                    return;
                }
                cc.Scale9Sprite.WebGLRenderCmd = function(renderable) {
                    _ccsg.Node.WebGLRenderCmd.call(this, renderable);
                    this._needDraw = true;
                    this._cachedParent = null;
                    this._cacheDirty = false;
                    this._quadWebBuffer = cc._renderContext.createBuffer();
                    this._colorOpacityDirty = false;
                };
                var proto = cc.Scale9Sprite.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
                proto.constructor = cc.Scale9Sprite.WebGLRenderCmd;
                proto.rendering = function(ctx) {
                    var node = this._node;
                    var locTexture = null;
                    if (node._spriteFrame) {
                        locTexture = node._spriteFrame._texture;
                    }
                    if (!node.loaded() || 0 === this._displayedOpacity) {
                        return;
                    }
                    var needRebuildWebBuffer = false;
                    if (node._quadsDirty) {
                        node._rebuildQuads();
                        this._colorOpacityDirty = false;
                        needRebuildWebBuffer = true;
                    }
                    if (this._colorOpacityDirty) {
                        node._onColorOpacityDirty();
                        this._colorOpacityDirty = false;
                        needRebuildWebBuffer = true;
                    }
                    var gl = ctx || cc._renderContext;
                    if (null != locTexture) {
                        this._shaderProgram.use();
                        this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
                        cc.glBlendFunc(node._blendFunc.src, node._blendFunc.dst);
                        cc.glBindTexture2DN(0, locTexture);
                        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
                        gl.bindBuffer(gl.ARRAY_BUFFER, this._quadWebBuffer);
                        var quads = node._quads;
                        var bufferOffset = 0;
                        var quadsLength = quads.length;
                        if (0 == quadsLength) {
                            return;
                        }
                        if (needRebuildWebBuffer) {
                            gl.bufferData(gl.ARRAY_BUFFER, quads[0].arrayBuffer.byteLength * quads.length, gl.DYNAMIC_DRAW);
                            for (var i = 0; i < quads.length; ++i) {
                                gl.bufferSubData(gl.ARRAY_BUFFER, bufferOffset, quads[i].arrayBuffer);
                                bufferOffset += quads[i].arrayBuffer.byteLength;
                            }
                        }
                        bufferOffset = 0;
                        for (var i = 0; i < quads.length; ++i) {
                            gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 24, bufferOffset);
                            gl.vertexAttribPointer(1, 4, gl.UNSIGNED_BYTE, true, 24, 12 + bufferOffset);
                            gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 24, 16 + bufferOffset);
                            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                            bufferOffset += quads[i].arrayBuffer.byteLength;
                        }
                        cc.g_NumberOfDraws += quads.length;
                    }
                };
                proto._updateDisplayOpacity = function(parentOpacity) {
                    _ccsg.Node.WebGLRenderCmd.prototype._updateDisplayOpacity.call(this, parentOpacity);
                    var node = this._node;
                    this._colorOpacityDirty = true;
                };
                proto._updateDisplayColor = function(parentColor) {
                    _ccsg.Node.WebGLRenderCmd.prototype._updateDisplayColor.call(this, parentColor);
                    var node = this._node;
                    this._colorOpacityDirty = true;
                };
                proto.setState = function(state) {
                    var node = this._node;
                    if (state === cc.Scale9Sprite.state.NORMAL) {
                        node.setShaderProgram(cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR));
                    } else {
                        if (state === cc.Scale9Sprite.state.GRAY) {
                            node.setShaderProgram(cc.Scale9Sprite.WebGLRenderCmd._getGrayShaderProgram());
                        }
                    }
                };
                cc.Scale9Sprite.WebGLRenderCmd._grayShaderProgram = null;
                cc.Scale9Sprite.WebGLRenderCmd._getGrayShaderProgram = function() {
                    var grayShader = cc.Scale9Sprite.WebGLRenderCmd._grayShaderProgram;
                    if (grayShader) {
                        return grayShader;
                    }
                    grayShader = new cc.GLProgram();
                    grayShader.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, cc.Scale9Sprite.WebGLRenderCmd._grayShaderFragment);
                    grayShader.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                    grayShader.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                    grayShader.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                    grayShader.link();
                    grayShader.updateUniforms();
                    cc.Scale9Sprite.WebGLRenderCmd._grayShaderProgram = grayShader;
                    return grayShader;
                };
                cc.Scale9Sprite.WebGLRenderCmd._grayShaderFragment = "precision lowp float;\nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nvoid main() \n{ \n    vec4 c = texture2D(CC_Texture0, v_texCoord); \n    gl_FragColor.xyz = vec3(0.2126*c.r + 0.7152*c.g + 0.0722*c.b); \n     gl_FragColor.w = c.w ; \n}";
            }();
            cc.configuration = {
                ERROR: 0,
                STRING: 1,
                INT: 2,
                DOUBLE: 3,
                BOOLEAN: 4,
                _maxTextureSize: 0,
                _maxModelviewStackDepth: 0,
                _supportsPVRTC: false,
                _supportsNPOT: false,
                _supportsBGRA8888: false,
                _supportsDiscardFramebuffer: false,
                _supportsShareableVAO: false,
                _maxSamplesAllowed: 0,
                _maxTextureUnits: 0,
                _GlExtensions: "",
                _valueDict: {},
                _inited: false,
                _init: function() {
                    var locValueDict = this._valueDict;
                    locValueDict["cocos2d.x.version"] = cc.ENGINE_VERSION;
                    locValueDict["cocos2d.x.compiled_with_profiler"] = false;
                    locValueDict["cocos2d.x.compiled_with_gl_state_cache"] = cc.ENABLE_GL_STATE_CACHE;
                    this._inited = true;
                },
                getMaxTextureSize: function() {
                    return this._maxTextureSize;
                },
                getMaxModelviewStackDepth: function() {
                    return this._maxModelviewStackDepth;
                },
                getMaxTextureUnits: function() {
                    return this._maxTextureUnits;
                },
                supportsNPOT: function() {
                    return this._supportsNPOT;
                },
                supportsPVRTC: function() {
                    return this._supportsPVRTC;
                },
                supportsETC: function() {
                    return false;
                },
                supportsS3TC: function() {
                    return false;
                },
                supportsATITC: function() {
                    return false;
                },
                supportsBGRA8888: function() {
                    return this._supportsBGRA8888;
                },
                supportsDiscardFramebuffer: function() {
                    return this._supportsDiscardFramebuffer;
                },
                supportsShareableVAO: function() {
                    return this._supportsShareableVAO;
                },
                checkForGLExtension: function(searchName) {
                    return this._GlExtensions.indexOf(searchName) > -1;
                },
                getValue: function(key, default_value) {
                    if (!this._inited) {
                        this._init();
                    }
                    var locValueDict = this._valueDict;
                    if (locValueDict[key]) {
                        return locValueDict[key];
                    }
                    return default_value;
                },
                setValue: function(key, value) {
                    this._valueDict[key] = value;
                },
                dumpInfo: function() {
                    if (0 === cc.ENABLE_GL_STATE_CACHE) {
                        cc.log("");
                        cc.log(cc._LogInfos.configuration.dumpInfo);
                        cc.log("");
                    }
                },
                gatherGPUInfo: function() {
                    if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                        return;
                    }
                    if (!this._inited) {
                        this._init();
                    }
                    var gl = cc._renderContext;
                    var locValueDict = this._valueDict;
                    locValueDict["gl.vendor"] = gl.getParameter(gl.VENDOR);
                    locValueDict["gl.renderer"] = gl.getParameter(gl.RENDERER);
                    locValueDict["gl.version"] = gl.getParameter(gl.VERSION);
                    this._GlExtensions = "";
                    var extArr = gl.getSupportedExtensions();
                    for (var i = 0; i < extArr.length; i++) {
                        this._GlExtensions += extArr[i] + " ";
                    }
                    this._maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                    locValueDict["gl.max_texture_size"] = this._maxTextureSize;
                    this._maxTextureUnits = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
                    locValueDict["gl.max_texture_units"] = this._maxTextureUnits;
                    this._supportsPVRTC = this.checkForGLExtension("GL_IMG_texture_compression_pvrtc");
                    locValueDict["gl.supports_PVRTC"] = this._supportsPVRTC;
                    this._supportsNPOT = false;
                    locValueDict["gl.supports_NPOT"] = this._supportsNPOT;
                    this._supportsBGRA8888 = this.checkForGLExtension("GL_IMG_texture_format_BGRA888");
                    locValueDict["gl.supports_BGRA8888"] = this._supportsBGRA8888;
                    this._supportsDiscardFramebuffer = this.checkForGLExtension("GL_EXT_discard_framebuffer");
                    locValueDict["gl.supports_discard_framebuffer"] = this._supportsDiscardFramebuffer;
                    this._supportsShareableVAO = this.checkForGLExtension("vertex_array_object");
                    locValueDict["gl.supports_vertex_array_object"] = this._supportsShareableVAO;
                    cc.checkGLErrorDebug();
                },
                loadConfigFile: function(url) {
                    if (!this._inited) {
                        this._init();
                    }
                    var dict = cc.loader.getRes(url);
                    if (!dict) {
                        throw new Error("Please load the resource first : " + url);
                    }
                    cc.assert(dict, cc._LogInfos.configuration.loadConfigFile_2, url);
                    var getDatas = dict["data"];
                    if (!getDatas) {
                        cc.log(cc._LogInfos.configuration.loadConfigFile, url);
                        return;
                    }
                    for (var selKey in getDatas) {
                        this._valueDict[selKey] = getDatas[selKey];
                    }
                }
            };
            cc.Camera = cc._Class.extend({
                _eyeX: null,
                _eyeY: null,
                _eyeZ: null,
                _centerX: null,
                _centerY: null,
                _centerZ: null,
                _upX: null,
                _upY: null,
                _upZ: null,
                _dirty: false,
                _lookupMatrix: null,
                ctor: function() {
                    this._lookupMatrix = new cc.math.Matrix4();
                    this.restore();
                },
                description: function() {
                    return "<CCCamera | center =(" + this._centerX + "," + this._centerY + "," + this._centerZ + ")>";
                },
                setDirty: function(value) {
                    this._dirty = value;
                },
                isDirty: function() {
                    return this._dirty;
                },
                restore: function() {
                    this._eyeX = this._eyeY = 0;
                    this._eyeZ = cc.Camera.getZEye();
                    this._centerX = this._centerY = this._centerZ = 0;
                    this._upX = 0;
                    this._upY = 1;
                    this._upZ = 0;
                    this._lookupMatrix.identity();
                    this._dirty = false;
                },
                locate: function() {
                    if (this._dirty) {
                        var eye = new cc.math.Vec3(this._eyeX, this._eyeY, this._eyeZ), center = new cc.math.Vec3(this._centerX, this._centerY, this._centerZ), up = new cc.math.Vec3(this._upX, this._upY, this._upZ);
                        this._lookupMatrix.lookAt(eye, center, up);
                        this._dirty = false;
                    }
                    cc.kmGLMultMatrix(this._lookupMatrix);
                },
                _locateForRenderer: function(matrix) {
                    if (this._dirty) {
                        var eye = new cc.math.Vec3(this._eyeX, this._eyeY, this._eyeZ), center = new cc.math.Vec3(this._centerX, this._centerY, this._centerZ), up = new cc.math.Vec3(this._upX, this._upY, this._upZ);
                        this._lookupMatrix.lookAt(eye, center, up);
                        this._dirty = false;
                    }
                    matrix.multiply(this._lookupMatrix);
                },
                setEyeXYZ: function(eyeX, eyeY, eyeZ) {
                    this.setEye(eyeX, eyeY, eyeZ);
                },
                setEye: function(eyeX, eyeY, eyeZ) {
                    this._eyeX = eyeX;
                    this._eyeY = eyeY;
                    this._eyeZ = eyeZ;
                    this._dirty = true;
                },
                setCenterXYZ: function(centerX, centerY, centerZ) {
                    this.setCenter(centerX, centerY, centerZ);
                },
                setCenter: function(centerX, centerY, centerZ) {
                    this._centerX = centerX;
                    this._centerY = centerY;
                    this._centerZ = centerZ;
                    this._dirty = true;
                },
                setUpXYZ: function(upX, upY, upZ) {
                    this.setUp(upX, upY, upZ);
                },
                setUp: function(upX, upY, upZ) {
                    this._upX = upX;
                    this._upY = upY;
                    this._upZ = upZ;
                    this._dirty = true;
                },
                getEyeXYZ: function(eyeX, eyeY, eyeZ) {
                    return {
                        x: this._eyeX,
                        y: this._eyeY,
                        z: this._eyeZ
                    };
                },
                getEye: function() {
                    return {
                        x: this._eyeX,
                        y: this._eyeY,
                        z: this._eyeZ
                    };
                },
                getCenterXYZ: function(centerX, centerY, centerZ) {
                    return {
                        x: this._centerX,
                        y: this._centerY,
                        z: this._centerZ
                    };
                },
                getCenter: function() {
                    return {
                        x: this._centerX,
                        y: this._centerY,
                        z: this._centerZ
                    };
                },
                getUpXYZ: function(upX, upY, upZ) {
                    return {
                        x: this._upX,
                        y: this._upY,
                        z: this._upZ
                    };
                },
                getUp: function() {
                    return {
                        x: this._upX,
                        y: this._upY,
                        z: this._upZ
                    };
                },
                _DISALLOW_COPY_AND_ASSIGN: function(CCCamera) {}
            });
            cc.Camera.getZEye = function() {
                return cc.FLT_EPSILON;
            };
            cc.PRIORITY_NON_SYSTEM = cc.PRIORITY_SYSTEM + 1;
            cc.ListEntry = function(prev, next, callback, target, priority, paused, markedForDeletion) {
                this.prev = prev;
                this.next = next;
                this.callback = callback;
                this.target = target;
                this.priority = priority;
                this.paused = paused;
                this.markedForDeletion = markedForDeletion;
            };
            cc.ListEntry.prototype.trigger = function(dt) {
                this.callback.call(this.target, dt);
            };
            cc.HashUpdateEntry = function(list, entry, target, callback, hh) {
                this.list = list;
                this.entry = entry;
                this.target = target;
                this.callback = callback;
                this.hh = hh;
            };
            cc.HashTimerEntry = cc.hashSelectorEntry = function(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused, hh) {
                var _t = this;
                _t.timers = timers;
                _t.target = target;
                _t.timerIndex = timerIndex;
                _t.currentTimer = currentTimer;
                _t.currentTimerSalvaged = currentTimerSalvaged;
                _t.paused = paused;
                _t.hh = hh;
            };
            cc.Timer = cc._Class.extend({
                _scheduler: null,
                _elapsed: 0,
                _runForever: false,
                _useDelay: false,
                _timesExecuted: 0,
                _repeat: 0,
                _delay: 0,
                _interval: 0,
                getInterval: function() {
                    return this._interval;
                },
                setInterval: function(interval) {
                    this._interval = interval;
                },
                setupTimerWithInterval: function(seconds, repeat, delay) {
                    this._elapsed = -1;
                    this._interval = seconds;
                    this._delay = delay;
                    this._useDelay = this._delay > 0;
                    this._repeat = repeat;
                    this._runForever = this._repeat === cc.REPEAT_FOREVER;
                },
                trigger: function() {
                    return 0;
                },
                cancel: function() {
                    return 0;
                },
                ctor: function() {
                    this._scheduler = null;
                    this._elapsed = -1;
                    this._runForever = false;
                    this._useDelay = false;
                    this._timesExecuted = 0;
                    this._repeat = 0;
                    this._delay = 0;
                    this._interval = 0;
                },
                update: function(dt) {
                    if (-1 === this._elapsed) {
                        this._elapsed = 0;
                        this._timesExecuted = 0;
                    } else {
                        this._elapsed += dt;
                        if (this._runForever && !this._useDelay) {
                            if (this._elapsed >= this._interval) {
                                this.trigger();
                                this._elapsed = 0;
                            }
                        } else {
                            if (this._useDelay) {
                                if (this._elapsed >= this._delay) {
                                    this.trigger();
                                    this._elapsed -= this._delay;
                                    this._timesExecuted += 1;
                                    this._useDelay = false;
                                }
                            } else {
                                if (this._elapsed >= this._interval) {
                                    this.trigger();
                                    this._elapsed = 0;
                                    this._timesExecuted += 1;
                                }
                            }
                            if (!this._runForever && this._timesExecuted > this._repeat) {
                                this.cancel();
                            }
                        }
                    }
                }
            });
            cc.TimerTargetSelector = cc.Timer.extend({
                _target: null,
                _selector: null,
                ctor: function() {
                    this._target = null;
                    this._selector = null;
                },
                initWithSelector: function(scheduler, selector, target, seconds, repeat, delay) {
                    this._scheduler = scheduler;
                    this._target = target;
                    this._selector = selector;
                    this.setupTimerWithInterval(seconds, repeat, delay);
                    return true;
                },
                getSelector: function() {
                    return this._selector;
                },
                trigger: function() {
                    if (this._target && this._selector) {
                        this._target.call(this._selector, this._elapsed);
                    }
                },
                cancel: function() {
                    this._scheduler.unschedule(this._selector, this._target);
                }
            });
            cc.TimerTargetCallback = cc.Timer.extend({
                _target: null,
                _callback: null,
                _key: null,
                ctor: function() {
                    this._target = null;
                    this._callback = null;
                },
                initWithCallback: function(scheduler, callback, target, key, seconds, repeat, delay) {
                    this._scheduler = scheduler;
                    this._target = target;
                    this._callback = callback;
                    this._key = key;
                    this.setupTimerWithInterval(seconds, repeat, delay);
                    return true;
                },
                getCallback: function() {
                    return this._callback;
                },
                getKey: function() {
                    return this._key;
                },
                trigger: function() {
                    if (this._callback) {
                        this._callback.call(this._target, this._elapsed);
                    }
                },
                cancel: function() {
                    this._scheduler.unschedule(this._callback, this._target);
                }
            });
            var getTargetId = function(target) {
                return target.__instanceId || target.uuid;
            };
            cc.Scheduler = cc._Class.extend({
                _timeScale: 1,
                _updatesNegList: null,
                _updates0List: null,
                _updatesPosList: null,
                _hashForTimers: null,
                _arrayForTimers: null,
                _hashForUpdates: null,
                _currentTarget: null,
                _currentTargetSalvaged: false,
                _updateHashLocked: false,
                ctor: function() {
                    this._timeScale = 1;
                    this._updatesNegList = [];
                    this._updates0List = [];
                    this._updatesPosList = [];
                    this._hashForUpdates = {};
                    this._hashForTimers = {};
                    this._currentTarget = null;
                    this._currentTargetSalvaged = false;
                    this._updateHashLocked = false;
                    this._arrayForTimers = [];
                },
                _schedulePerFrame: function(callback, target, priority, paused) {
                    var hashElement = this._hashForUpdates[getTargetId(target)];
                    if (hashElement && hashElement.entry) {
                        if (hashElement.entry.priority !== priority) {
                            if (this._updateHashLocked) {
                                cc.log("warning: you CANNOT change update priority in scheduled function");
                                hashElement.entry.markedForDeletion = false;
                                hashElement.entry.paused = paused;
                                return;
                            } else {
                                this.unscheduleUpdate(target);
                            }
                        } else {
                            hashElement.entry.markedForDeletion = false;
                            hashElement.entry.paused = paused;
                            return;
                        }
                    }
                    if (0 === priority) {
                        this._appendIn(this._updates0List, callback, target, paused);
                    } else {
                        if (priority < 0) {
                            this._priorityIn(this._updatesNegList, callback, target, priority, paused);
                        } else {
                            this._priorityIn(this._updatesPosList, callback, target, priority, paused);
                        }
                    }
                },
                _removeHashElement: function(element) {
                    delete this._hashForTimers[getTargetId(element.target)];
                    cc.js.array.remove(this._arrayForTimers, element);
                    element.Timer = null;
                    element.target = null;
                    element = null;
                },
                _removeUpdateFromHash: function(entry) {
                    var self = this, element = self._hashForUpdates[getTargetId(entry.target)];
                    if (element) {
                        cc.js.array.remove(element.list, element.entry);
                        delete self._hashForUpdates[getTargetId(element.target)];
                        element.entry = null;
                        element.target = null;
                    }
                },
                _priorityIn: function(ppList, callback, target, priority, paused) {
                    var self = this, listElement = new cc.ListEntry(null, null, callback, target, priority, paused, false);
                    if (!ppList) {
                        ppList = [];
                        ppList.push(listElement);
                    } else {
                        var index2Insert = ppList.length - 1;
                        for (var i = 0; i <= index2Insert; i++) {
                            if (priority < ppList[i].priority) {
                                index2Insert = i;
                                break;
                            }
                        }
                        ppList.splice(i, 0, listElement);
                    }
                    self._hashForUpdates[getTargetId(target)] = new cc.HashUpdateEntry(ppList, listElement, target, null);
                    return ppList;
                },
                _appendIn: function(ppList, callback, target, paused) {
                    var self = this, listElement = new cc.ListEntry(null, null, callback, target, 0, paused, false);
                    ppList.push(listElement);
                    self._hashForUpdates[getTargetId(target)] = new cc.HashUpdateEntry(ppList, listElement, target, null, null);
                },
                setTimeScale: function(timeScale) {
                    this._timeScale = timeScale;
                },
                getTimeScale: function() {
                    return this._timeScale;
                },
                update: function(dt) {
                    this._updateHashLocked = true;
                    if (1 !== this._timeScale) {
                        dt *= this._timeScale;
                    }
                    var i, list, len, entry;
                    for (i = 0, list = this._updatesNegList, len = list.length; i < len; i++) {
                        entry = list[i];
                        if (!entry.paused && !entry.markedForDeletion) {
                            entry.trigger(dt);
                        }
                    }
                    for (i = 0, list = this._updates0List, len = list.length; i < len; i++) {
                        entry = list[i];
                        if (!entry.paused && !entry.markedForDeletion) {
                            entry.trigger(dt);
                        }
                    }
                    for (i = 0, list = this._updatesPosList, len = list.length; i < len; i++) {
                        entry = list[i];
                        if (!entry.paused && !entry.markedForDeletion) {
                            entry.trigger(dt);
                        }
                    }
                    var elt, arr = this._arrayForTimers;
                    for (i = 0; i < arr.length; i++) {
                        elt = arr[i];
                        this._currentTarget = elt;
                        this._currentTargetSalvaged = false;
                        if (!elt.paused) {
                            for (elt.timerIndex = 0; elt.timerIndex < elt.timers.length; ++elt.timerIndex) {
                                elt.currentTimer = elt.timers[elt.timerIndex];
                                elt.currentTimerSalvaged = false;
                                elt.currentTimer.update(dt);
                                elt.currentTimer = null;
                            }
                        }
                        if (this._currentTargetSalvaged && 0 === this._currentTarget.timers.length) {
                            this._removeHashElement(this._currentTarget);
                        }
                    }
                    for (i = 0, list = this._updatesNegList; i < list.length; ) {
                        entry = list[i];
                        if (entry.markedForDeletion) {
                            this._removeUpdateFromHash(entry);
                        } else {
                            i++;
                        }
                    }
                    for (i = 0, list = this._updates0List; i < list.length; ) {
                        entry = list[i];
                        if (entry.markedForDeletion) {
                            this._removeUpdateFromHash(entry);
                        } else {
                            i++;
                        }
                    }
                    for (i = 0, list = this._updatesPosList; i < list.length; ) {
                        entry = list[i];
                        if (entry.markedForDeletion) {
                            this._removeUpdateFromHash(entry);
                        } else {
                            i++;
                        }
                    }
                    this._updateHashLocked = false;
                    this._currentTarget = null;
                },
                scheduleCallbackForTarget: function(target, callback_fn, interval, repeat, delay, paused) {
                    this.schedule(callback_fn, target, interval, repeat, delay, paused, getTargetId(target) + "");
                },
                schedule: function(callback, target, interval, repeat, delay, paused, key) {
                    var isSelector = false;
                    if ("function" !== typeof callback) {
                        var selector = callback;
                        isSelector = true;
                    }
                    if (false === isSelector) {
                        if (4 === arguments.length || 5 === arguments.length) {
                            key = delay;
                            paused = repeat;
                            delay = 0;
                            repeat = cc.REPEAT_FOREVER;
                        }
                    } else {
                        if (4 === arguments.length) {
                            paused = repeat;
                            repeat = cc.REPEAT_FOREVER;
                            delay = 0;
                        }
                    }
                    if (void 0 === key) {
                        key = target.__instanceId + "";
                    }
                    cc.assert(target, cc._LogInfos.Scheduler_scheduleCallbackForTarget_3);
                    var instanceId = getTargetId(target);
                    var element = this._hashForTimers[instanceId];
                    if (!element) {
                        element = new cc.HashTimerEntry(null, target, 0, null, null, paused, null);
                        this._arrayForTimers.push(element);
                        this._hashForTimers[instanceId] = element;
                    } else {
                        cc.assert(element.paused === paused, "");
                    }
                    var timer, i;
                    if (null == element.timers) {
                        element.timers = [];
                    } else {
                        if (false === isSelector) {
                            for (i = 0; i < element.timers.length; i++) {
                                timer = element.timers[i];
                                if (callback === timer._callback) {
                                    cc.log(cc._LogInfos.Scheduler.scheduleCallbackForTarget, timer.getInterval().toFixed(4), interval.toFixed(4));
                                    timer._interval = interval;
                                    return;
                                }
                            }
                        } else {
                            for (i = 0; i < element.timers.length; ++i) {
                                timer = element.timers[i];
                                if (timer && selector === timer.getSelector()) {
                                    cc.log("CCScheduler#scheduleSelector. Selector already scheduled. Updating interval from: %.4f to %.4f", timer.getInterval(), interval);
                                    timer.setInterval(interval);
                                    return;
                                }
                            }
                        }
                    }
                    if (false === isSelector) {
                        timer = new cc.TimerTargetCallback();
                        timer.initWithCallback(this, callback, target, key, interval, repeat, delay);
                        element.timers.push(timer);
                    } else {
                        timer = new cc.TimerTargetSelector();
                        timer.initWithSelector(this, selector, target, interval, repeat, delay);
                        element.timers.push(timer);
                    }
                },
                scheduleUpdate: function(target, priority, paused, updateFunc) {
                    updateFunc = updateFunc || target.update;
                    this._schedulePerFrame(updateFunc, target, priority, paused);
                },
                _getUnscheduleMark: function(key, timer) {
                    switch (typeof key) {
                      case "number":
                      case "string":
                        return key === timer.getKey();

                      case "function":
                        return key === timer._callback;

                      default:
                        return key === timer.getSelector();
                    }
                },
                unschedule: function(key, target) {
                    if (!target || !key) {
                        return;
                    }
                    var self = this, element = self._hashForTimers[getTargetId(target)];
                    if (element) {
                        var timers = element.timers;
                        for (var i = 0, li = timers.length; i < li; i++) {
                            var timer = timers[i];
                            if (this._getUnscheduleMark(key, timer)) {
                                if (timer === element.currentTimer && !element.currentTimerSalvaged) {
                                    element.currentTimerSalvaged = true;
                                }
                                timers.splice(i, 1);
                                if (element.timerIndex >= i) {
                                    element.timerIndex--;
                                }
                                if (0 === timers.length) {
                                    if (self._currentTarget === element) {
                                        self._currentTargetSalvaged = true;
                                    } else {
                                        self._removeHashElement(element);
                                    }
                                }
                                return;
                            }
                        }
                    }
                },
                unscheduleUpdate: function(target) {
                    if (null == target) {
                        return;
                    }
                    var element = this._hashForUpdates[getTargetId(target)];
                    if (element) {
                        if (this._updateHashLocked) {
                            element.entry.markedForDeletion = true;
                        } else {
                            this._removeUpdateFromHash(element.entry);
                        }
                    }
                },
                unscheduleAllForTarget: function(target) {
                    if (null == target) {
                        return;
                    }
                    var element = this._hashForTimers[getTargetId(target)];
                    if (element) {
                        if (element.timers.indexOf(element.currentTimer) > -1 && !element.currentTimerSalvaged) {
                            element.currentTimerSalvaged = true;
                        }
                        element.timers.length = 0;
                        if (this._currentTarget === element) {
                            this._currentTargetSalvaged = true;
                        } else {
                            this._removeHashElement(element);
                        }
                    }
                    this.unscheduleUpdate(target);
                },
                unscheduleAll: function() {
                    this.unscheduleAllWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
                },
                unscheduleAllWithMinPriority: function(minPriority) {
                    var i, element, arr = this._arrayForTimers;
                    for (i = arr.length - 1; i >= 0; i--) {
                        element = arr[i];
                        this.unscheduleAllForTarget(element.target);
                    }
                    var entry;
                    var temp_length = 0;
                    if (minPriority < 0) {
                        for (i = 0; i < this._updatesNegList.length; ) {
                            temp_length = this._updatesNegList.length;
                            entry = this._updatesNegList[i];
                            if (entry && entry.priority >= minPriority) {
                                this.unscheduleUpdate(entry.target);
                            }
                            if (temp_length == this._updatesNegList.length) {
                                i++;
                            }
                        }
                    }
                    if (minPriority <= 0) {
                        for (i = 0; i < this._updates0List.length; ) {
                            temp_length = this._updates0List.length;
                            entry = this._updates0List[i];
                            if (entry) {
                                this.unscheduleUpdate(entry.target);
                            }
                            if (temp_length == this._updates0List.length) {
                                i++;
                            }
                        }
                    }
                    for (i = 0; i < this._updatesPosList.length; ) {
                        temp_length = this._updatesPosList.length;
                        entry = this._updatesPosList[i];
                        if (entry && entry.priority >= minPriority) {
                            this.unscheduleUpdate(entry.target);
                        }
                        if (temp_length == this._updatesPosList.length) {
                            i++;
                        }
                    }
                },
                isScheduled: function(key, target) {
                    cc.assert(key, "Argument key must not be empty");
                    cc.assert(target, "Argument target must be non-nullptr");
                    var element = this._hashForUpdates[getTargetId(target)];
                    if (!element) {
                        return false;
                    }
                    if (null == element.timers) {
                        return false;
                    } else {
                        var timers = element.timers;
                        for (var i = 0; i < timers.length; ++i) {
                            var timer = timers[i];
                            if (key === timer.getKey()) {
                                return true;
                            }
                        }
                        return false;
                    }
                },
                pauseAllTargets: function() {
                    return this.pauseAllTargetsWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
                },
                pauseAllTargetsWithMinPriority: function(minPriority) {
                    var idsWithSelectors = [];
                    var self = this, element, locArrayForTimers = self._arrayForTimers;
                    var i, li;
                    for (i = 0, li = locArrayForTimers.length; i < li; i++) {
                        element = locArrayForTimers[i];
                        if (element) {
                            element.paused = true;
                            idsWithSelectors.push(element.target);
                        }
                    }
                    var entry;
                    if (minPriority < 0) {
                        for (i = 0; i < this._updatesNegList.length; i++) {
                            entry = this._updatesNegList[i];
                            if (entry) {
                                if (entry.priority >= minPriority) {
                                    entry.paused = true;
                                    idsWithSelectors.push(entry.target);
                                }
                            }
                        }
                    }
                    if (minPriority <= 0) {
                        for (i = 0; i < this._updates0List.length; i++) {
                            entry = this._updates0List[i];
                            if (entry) {
                                entry.paused = true;
                                idsWithSelectors.push(entry.target);
                            }
                        }
                    }
                    for (i = 0; i < this._updatesPosList.length; i++) {
                        entry = this._updatesPosList[i];
                        if (entry) {
                            if (entry.priority >= minPriority) {
                                entry.paused = true;
                                idsWithSelectors.push(entry.target);
                            }
                        }
                    }
                    return idsWithSelectors;
                },
                resumeTargets: function(targetsToResume) {
                    if (!targetsToResume) {
                        return;
                    }
                    for (var i = 0; i < targetsToResume.length; i++) {
                        this.resumeTarget(targetsToResume[i]);
                    }
                },
                pauseTarget: function(target) {
                    cc.assert(target, cc._LogInfos.Scheduler.pauseTarget);
                    var self = this, instanceId = getTargetId(target), element = self._hashForTimers[instanceId];
                    if (element) {
                        element.paused = true;
                    }
                    var elementUpdate = self._hashForUpdates[instanceId];
                    if (elementUpdate) {
                        elementUpdate.entry.paused = true;
                    }
                },
                resumeTarget: function(target) {
                    cc.assert(target, cc._LogInfos.Scheduler.resumeTarget);
                    var self = this, instanceId = getTargetId(target), element = self._hashForTimers[instanceId];
                    if (element) {
                        element.paused = false;
                    }
                    var elementUpdate = self._hashForUpdates[instanceId];
                    if (elementUpdate) {
                        elementUpdate.entry.paused = false;
                    }
                },
                isTargetPaused: function(target) {
                    cc.assert(target, cc._LogInfos.Scheduler.isTargetPaused);
                    var instanceId = getTargetId(target), element = this._hashForTimers[instanceId];
                    if (element) {
                        return element.paused;
                    }
                    var elementUpdate = this._hashForUpdates[instanceId];
                    if (elementUpdate) {
                        return elementUpdate.entry.paused;
                    }
                    return false;
                },
                scheduleUpdateForTarget: function(target, priority, paused) {
                    this.scheduleUpdate(target, priority, paused);
                },
                unscheduleCallbackForTarget: function(target, callback) {
                    this.unschedule(callback, target);
                },
                unscheduleUpdateForTarget: function(target) {
                    this.unscheduleUpdate(target);
                },
                unscheduleAllCallbacksForTarget: function(target) {
                    this.unschedule(getTargetId(target) + "", target);
                },
                unscheduleAllCallbacks: function() {
                    this.unscheduleAllWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
                },
                unscheduleAllCallbacksWithMinPriority: function(minPriority) {
                    this.unscheduleAllWithMinPriority(minPriority);
                }
            });
            cc.Scheduler.PRIORITY_SYSTEM = -2147483648;
            cc.PI2 = 2 * Math.PI;
            cc.DrawingPrimitiveCanvas = cc._Class.extend({
                _cacheArray: [],
                _renderContext: null,
                ctor: function(renderContext) {
                    this._renderContext = renderContext;
                },
                drawPoint: function(point, size) {
                    if (!size) {
                        size = 1;
                    }
                    var locScaleX = cc.view.getScaleX(), locScaleY = cc.view.getScaleY();
                    var newPoint = cc.p(point.x * locScaleX, point.y * locScaleY);
                    var ctx = this._renderContext.getContext();
                    ctx.beginPath();
                    ctx.arc(newPoint.x, -newPoint.y, size * locScaleX, 0, 2 * Math.PI, false);
                    ctx.closePath();
                    ctx.fill();
                },
                drawPoints: function(points, numberOfPoints, size) {
                    if (null == points) {
                        return;
                    }
                    if (!size) {
                        size = 1;
                    }
                    var locContext = this._renderContext.getContext(), locScaleX = cc.view.getScaleX(), locScaleY = cc.view.getScaleY();
                    locContext.beginPath();
                    for (var i = 0, len = points.length; i < len; i++) {
                        locContext.arc(points[i].x * locScaleX, -points[i].y * locScaleY, size * locScaleX, 0, 2 * Math.PI, false);
                    }
                    locContext.closePath();
                    locContext.fill();
                },
                drawLine: function(origin, destination) {
                    var locContext = this._renderContext.getContext(), locScaleX = cc.view.getScaleX(), locScaleY = cc.view.getScaleY();
                    locContext.beginPath();
                    locContext.moveTo(origin.x * locScaleX, -origin.y * locScaleY);
                    locContext.lineTo(destination.x * locScaleX, -destination.y * locScaleY);
                    locContext.closePath();
                    locContext.stroke();
                },
                drawRect: function(origin, destination) {
                    this.drawLine(cc.p(origin.x, origin.y), cc.p(destination.x, origin.y));
                    this.drawLine(cc.p(destination.x, origin.y), cc.p(destination.x, destination.y));
                    this.drawLine(cc.p(destination.x, destination.y), cc.p(origin.x, destination.y));
                    this.drawLine(cc.p(origin.x, destination.y), cc.p(origin.x, origin.y));
                },
                drawSolidRect: function(origin, destination, color) {
                    var vertices = [ origin, cc.p(destination.x, origin.y), destination, cc.p(origin.x, destination.y) ];
                    this.drawSolidPoly(vertices, 4, color);
                },
                drawPoly: function(vertices, numOfVertices, closePolygon, fill) {
                    fill = fill || false;
                    if (null == vertices) {
                        return;
                    }
                    if (vertices.length < 3) {
                        throw new Error("Polygon's point must greater than 2");
                    }
                    var firstPoint = vertices[0], locContext = this._renderContext.getContext();
                    var locScaleX = cc.view.getScaleX(), locScaleY = cc.view.getScaleY();
                    locContext.beginPath();
                    locContext.moveTo(firstPoint.x * locScaleX, -firstPoint.y * locScaleY);
                    for (var i = 1, len = vertices.length; i < len; i++) {
                        locContext.lineTo(vertices[i].x * locScaleX, -vertices[i].y * locScaleY);
                    }
                    if (closePolygon) {
                        locContext.closePath();
                    }
                    if (fill) {
                        locContext.fill();
                    } else {
                        locContext.stroke();
                    }
                },
                drawSolidPoly: function(polygons, numberOfPoints, color) {
                    this.setDrawColor(color.r, color.g, color.b, color.a);
                    this.drawPoly(polygons, numberOfPoints, true, true);
                },
                drawCircle: function(center, radius, angle, segments, drawLineToCenter) {
                    drawLineToCenter = drawLineToCenter || false;
                    var locContext = this._renderContext.getContext();
                    var locScaleX = cc.view.getScaleX(), locScaleY = cc.view.getScaleY();
                    locContext.beginPath();
                    var endAngle = angle - 2 * Math.PI;
                    locContext.arc(0 | center.x * locScaleX, 0 | -(center.y * locScaleY), radius * locScaleX, -angle, -endAngle, false);
                    if (drawLineToCenter) {
                        locContext.lineTo(0 | center.x * locScaleX, 0 | -(center.y * locScaleY));
                    }
                    locContext.stroke();
                },
                drawQuadBezier: function(origin, control, destination, segments) {
                    var vertices = this._cacheArray;
                    vertices.length = 0;
                    var t = 0;
                    for (var i = 0; i < segments; i++) {
                        var x = Math.pow(1 - t, 2) * origin.x + 2 * (1 - t) * t * control.x + t * t * destination.x;
                        var y = Math.pow(1 - t, 2) * origin.y + 2 * (1 - t) * t * control.y + t * t * destination.y;
                        vertices.push(cc.p(x, y));
                        t += 1 / segments;
                    }
                    vertices.push(cc.p(destination.x, destination.y));
                    this.drawPoly(vertices, segments + 1, false, false);
                },
                drawCubicBezier: function(origin, control1, control2, destination, segments) {
                    var vertices = this._cacheArray;
                    vertices.length = 0;
                    var t = 0;
                    for (var i = 0; i < segments; i++) {
                        var x = Math.pow(1 - t, 3) * origin.x + 3 * Math.pow(1 - t, 2) * t * control1.x + 3 * (1 - t) * t * t * control2.x + t * t * t * destination.x;
                        var y = Math.pow(1 - t, 3) * origin.y + 3 * Math.pow(1 - t, 2) * t * control1.y + 3 * (1 - t) * t * t * control2.y + t * t * t * destination.y;
                        vertices.push(cc.p(x, y));
                        t += 1 / segments;
                    }
                    vertices.push(cc.p(destination.x, destination.y));
                    this.drawPoly(vertices, segments + 1, false, false);
                },
                drawCatmullRom: function(points, segments) {
                    this.drawCardinalSpline(points, .5, segments);
                },
                drawCardinalSpline: function(config, tension, segments) {
                    cc._renderContext.setStrokeStyle("rgba(255,255,255,1)");
                    var points = this._cacheArray;
                    points.length = 0;
                    var p, lt;
                    var deltaT = 1 / config.length;
                    for (var i = 0; i < segments + 1; i++) {
                        var dt = i / segments;
                        if (1 === dt) {
                            p = config.length - 1;
                            lt = 1;
                        } else {
                            p = 0 | dt / deltaT;
                            lt = (dt - deltaT * p) / deltaT;
                        }
                        var newPos = cc.CardinalSplineAt(cc.getControlPointAt(config, p - 1), cc.getControlPointAt(config, p - 0), cc.getControlPointAt(config, p + 1), cc.getControlPointAt(config, p + 2), tension, lt);
                        points.push(newPos);
                    }
                    this.drawPoly(points, segments + 1, false, false);
                },
                drawImage: function(image, sourcePoint, sourceSize, destPoint, destSize) {
                    var len = arguments.length;
                    var ctx = this._renderContext.getContext();
                    switch (len) {
                      case 2:
                        var height = image.height;
                        ctx.drawImage(image, sourcePoint.x, -(sourcePoint.y + height));
                        break;

                      case 3:
                        ctx.drawImage(image, sourcePoint.x, -(sourcePoint.y + sourceSize.height), sourceSize.width, sourceSize.height);
                        break;

                      case 5:
                        ctx.drawImage(image, sourcePoint.x, sourcePoint.y, sourceSize.width, sourceSize.height, destPoint.x, -(destPoint.y + destSize.height), destSize.width, destSize.height);
                        break;

                      default:
                        throw new Error("Argument must be non-nil");
                    }
                },
                drawStar: function(ctx, radius, color) {
                    var wrapper = ctx || this._renderContext;
                    var context = wrapper.getContext();
                    radius *= cc.view.getScaleX();
                    var colorStr = "rgba(" + (0 | color.r) + "," + (0 | color.g) + "," + (0 | color.b);
                    wrapper.setFillStyle(colorStr + ",1)");
                    var subRadius = radius / 10;
                    context.beginPath();
                    context.moveTo(-radius, radius);
                    context.lineTo(0, subRadius);
                    context.lineTo(radius, radius);
                    context.lineTo(subRadius, 0);
                    context.lineTo(radius, -radius);
                    context.lineTo(0, -subRadius);
                    context.lineTo(-radius, -radius);
                    context.lineTo(-subRadius, 0);
                    context.lineTo(-radius, radius);
                    context.closePath();
                    context.fill();
                    var rg = context.createRadialGradient(0, 0, subRadius, 0, 0, radius);
                    rg.addColorStop(0, colorStr + ", 1)");
                    rg.addColorStop(.3, colorStr + ", 0.8)");
                    rg.addColorStop(1, colorStr + ", 0.0)");
                    wrapper.setFillStyle(rg);
                    context.beginPath();
                    var startAngle_1 = 0;
                    var endAngle_1 = cc.PI2;
                    context.arc(0, 0, radius - subRadius, startAngle_1, endAngle_1, false);
                    context.closePath();
                    context.fill();
                },
                drawColorBall: function(ctx, radius, color) {
                    var wrapper = ctx || this._renderContext;
                    var context = wrapper.getContext();
                    radius *= cc.view.getScaleX();
                    var colorStr = "rgba(" + (0 | color.r) + "," + (0 | color.g) + "," + (0 | color.b);
                    var subRadius = radius / 10;
                    var g1 = context.createRadialGradient(0, 0, subRadius, 0, 0, radius);
                    g1.addColorStop(0, colorStr + ", 1)");
                    g1.addColorStop(.3, colorStr + ", 0.8)");
                    g1.addColorStop(.6, colorStr + ", 0.4)");
                    g1.addColorStop(1, colorStr + ", 0.0)");
                    wrapper.setFillStyle(g1);
                    context.beginPath();
                    var startAngle_1 = 0;
                    var endAngle_1 = cc.PI2;
                    context.arc(0, 0, radius, startAngle_1, endAngle_1, false);
                    context.closePath();
                    context.fill();
                },
                fillText: function(strText, x, y) {
                    this._renderContext.getContext().fillText(strText, x, -y);
                },
                setDrawColor: function(r, g, b, a) {
                    this._renderContext.setFillStyle("rgba(" + r + "," + g + "," + b + "," + a / 255 + ")");
                    this._renderContext.setStrokeStyle("rgba(" + r + "," + g + "," + b + "," + a / 255 + ")");
                },
                setPointSize: function(pointSize) {},
                setLineWidth: function(width) {
                    this._renderContext.getContext().lineWidth = width * cc.view.getScaleX();
                }
            });
            cc.DrawingPrimitiveWebGL = cc._Class.extend({
                _renderContext: null,
                _initialized: false,
                _shader: null,
                _colorLocation: -1,
                _colorArray: null,
                _pointSizeLocation: -1,
                _pointSize: -1,
                ctor: function(ctx) {
                    if (null == ctx) {
                        ctx = cc._renderContext;
                    }
                    if (!ctx instanceof WebGLRenderingContext) {
                        throw new Error("Can't initialise DrawingPrimitiveWebGL. context need is WebGLRenderingContext");
                    }
                    this._renderContext = ctx;
                    this._colorArray = new Float32Array([ 1, 1, 1, 1 ]);
                },
                lazy_init: function() {
                    var _t = this;
                    if (!_t._initialized) {
                        _t._shader = cc.shaderCache.programForKey(cc.SHADER_POSITION_UCOLOR);
                        _t._colorLocation = _t._renderContext.getUniformLocation(_t._shader.getProgram(), "u_color");
                        _t._pointSizeLocation = _t._renderContext.getUniformLocation(_t._shader.getProgram(), "u_pointSize");
                        _t._initialized = true;
                    }
                },
                drawInit: function() {
                    this._initialized = false;
                },
                drawPoint: function(point) {
                    this.lazy_init();
                    var glContext = this._renderContext;
                    this._shader.use();
                    this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
                    cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
                    glContext.uniform4fv(this._colorLocation, this._colorArray);
                    this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
                    var pointBuffer = glContext.createBuffer();
                    glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
                    glContext.bufferData(glContext.ARRAY_BUFFER, new Float32Array([ point.x, point.y ]), glContext.STATIC_DRAW);
                    glContext.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
                    glContext.drawArrays(glContext.POINTS, 0, 1);
                    glContext.deleteBuffer(pointBuffer);
                    cc.incrementGLDraws(1);
                },
                drawPoints: function(points, numberOfPoints) {
                    if (!points || 0 === points.length) {
                        return;
                    }
                    this.lazy_init();
                    var glContext = this._renderContext;
                    this._shader.use();
                    this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
                    cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
                    glContext.uniform4fv(this._colorLocation, this._colorArray);
                    this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
                    var pointBuffer = glContext.createBuffer();
                    glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
                    glContext.bufferData(glContext.ARRAY_BUFFER, this._pointsToTypeArray(points), glContext.STATIC_DRAW);
                    glContext.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
                    glContext.drawArrays(glContext.POINTS, 0, points.length);
                    glContext.deleteBuffer(pointBuffer);
                    cc.incrementGLDraws(1);
                },
                _pointsToTypeArray: function(points) {
                    var typeArr = new Float32Array(2 * points.length);
                    for (var i = 0; i < points.length; i++) {
                        typeArr[2 * i] = points[i].x;
                        typeArr[2 * i + 1] = points[i].y;
                    }
                    return typeArr;
                },
                drawLine: function(origin, destination) {
                    this.lazy_init();
                    var glContext = this._renderContext;
                    this._shader.use();
                    this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
                    cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
                    glContext.uniform4fv(this._colorLocation, this._colorArray);
                    var pointBuffer = glContext.createBuffer();
                    glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
                    glContext.bufferData(glContext.ARRAY_BUFFER, this._pointsToTypeArray([ origin, destination ]), glContext.STATIC_DRAW);
                    glContext.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
                    glContext.drawArrays(glContext.LINES, 0, 2);
                    glContext.deleteBuffer(pointBuffer);
                    cc.incrementGLDraws(1);
                },
                drawRect: function(origin, destination) {
                    this.drawLine(cc.p(origin.x, origin.y), cc.p(destination.x, origin.y));
                    this.drawLine(cc.p(destination.x, origin.y), cc.p(destination.x, destination.y));
                    this.drawLine(cc.p(destination.x, destination.y), cc.p(origin.x, destination.y));
                    this.drawLine(cc.p(origin.x, destination.y), cc.p(origin.x, origin.y));
                },
                drawSolidRect: function(origin, destination, color) {
                    var vertices = [ origin, cc.p(destination.x, origin.y), destination, cc.p(origin.x, destination.y) ];
                    this.drawSolidPoly(vertices, 4, color);
                },
                drawPoly: function(vertices, numOfVertices, closePolygon) {
                    this.lazy_init();
                    var glContext = this._renderContext;
                    this._shader.use();
                    this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
                    cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
                    glContext.uniform4fv(this._colorLocation, this._colorArray);
                    var pointBuffer = glContext.createBuffer();
                    glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
                    glContext.bufferData(glContext.ARRAY_BUFFER, this._pointsToTypeArray(vertices), glContext.STATIC_DRAW);
                    glContext.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
                    if (closePolygon) {
                        glContext.drawArrays(glContext.LINE_LOOP, 0, vertices.length);
                    } else {
                        glContext.drawArrays(glContext.LINE_STRIP, 0, vertices.length);
                    }
                    glContext.deleteBuffer(pointBuffer);
                    cc.incrementGLDraws(1);
                },
                drawSolidPoly: function(poli, numberOfPoints, color) {
                    this.lazy_init();
                    if (color) {
                        this.setDrawColor(color.r, color.g, color.b, color.a);
                    }
                    var glContext = this._renderContext;
                    this._shader.use();
                    this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
                    cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
                    glContext.uniform4fv(this._colorLocation, this._colorArray);
                    var pointBuffer = glContext.createBuffer();
                    glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
                    glContext.bufferData(glContext.ARRAY_BUFFER, this._pointsToTypeArray(poli), glContext.STATIC_DRAW);
                    glContext.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
                    glContext.drawArrays(glContext.TRIANGLE_FAN, 0, poli.length);
                    glContext.deleteBuffer(pointBuffer);
                    cc.incrementGLDraws(1);
                },
                drawCircle: function(center, radius, angle, segments, drawLineToCenter) {
                    this.lazy_init();
                    var additionalSegment = 1;
                    if (drawLineToCenter) {
                        additionalSegment++;
                    }
                    var coef = 2 * Math.PI / segments;
                    var vertices = new Float32Array(2 * (segments + 2));
                    if (!vertices) {
                        return;
                    }
                    for (var i = 0; i <= segments; i++) {
                        var rads = i * coef;
                        var j = radius * Math.cos(rads + angle) + center.x;
                        var k = radius * Math.sin(rads + angle) + center.y;
                        vertices[2 * i] = j;
                        vertices[2 * i + 1] = k;
                    }
                    vertices[2 * (segments + 1)] = center.x;
                    vertices[2 * (segments + 1) + 1] = center.y;
                    var glContext = this._renderContext;
                    this._shader.use();
                    this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
                    cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
                    glContext.uniform4fv(this._colorLocation, this._colorArray);
                    var pointBuffer = glContext.createBuffer();
                    glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
                    glContext.bufferData(glContext.ARRAY_BUFFER, vertices, glContext.STATIC_DRAW);
                    glContext.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
                    glContext.drawArrays(glContext.LINE_STRIP, 0, segments + additionalSegment);
                    glContext.deleteBuffer(pointBuffer);
                    cc.incrementGLDraws(1);
                },
                drawQuadBezier: function(origin, control, destination, segments) {
                    this.lazy_init();
                    var vertices = new Float32Array(2 * (segments + 1));
                    var t = 0;
                    for (var i = 0; i < segments; i++) {
                        vertices[2 * i] = Math.pow(1 - t, 2) * origin.x + 2 * (1 - t) * t * control.x + t * t * destination.x;
                        vertices[2 * i + 1] = Math.pow(1 - t, 2) * origin.y + 2 * (1 - t) * t * control.y + t * t * destination.y;
                        t += 1 / segments;
                    }
                    vertices[2 * segments] = destination.x;
                    vertices[2 * segments + 1] = destination.y;
                    var glContext = this._renderContext;
                    this._shader.use();
                    this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
                    cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
                    glContext.uniform4fv(this._colorLocation, this._colorArray);
                    var pointBuffer = glContext.createBuffer();
                    glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
                    glContext.bufferData(glContext.ARRAY_BUFFER, vertices, glContext.STATIC_DRAW);
                    glContext.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
                    glContext.drawArrays(glContext.LINE_STRIP, 0, segments + 1);
                    glContext.deleteBuffer(pointBuffer);
                    cc.incrementGLDraws(1);
                },
                drawCubicBezier: function(origin, control1, control2, destination, segments) {
                    this.lazy_init();
                    var vertices = new Float32Array(2 * (segments + 1));
                    var t = 0;
                    for (var i = 0; i < segments; i++) {
                        vertices[2 * i] = Math.pow(1 - t, 3) * origin.x + 3 * Math.pow(1 - t, 2) * t * control1.x + 3 * (1 - t) * t * t * control2.x + t * t * t * destination.x;
                        vertices[2 * i + 1] = Math.pow(1 - t, 3) * origin.y + 3 * Math.pow(1 - t, 2) * t * control1.y + 3 * (1 - t) * t * t * control2.y + t * t * t * destination.y;
                        t += 1 / segments;
                    }
                    vertices[2 * segments] = destination.x;
                    vertices[2 * segments + 1] = destination.y;
                    var glContext = this._renderContext;
                    this._shader.use();
                    this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
                    cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
                    glContext.uniform4fv(this._colorLocation, this._colorArray);
                    var pointBuffer = glContext.createBuffer();
                    glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
                    glContext.bufferData(glContext.ARRAY_BUFFER, vertices, glContext.STATIC_DRAW);
                    glContext.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
                    glContext.drawArrays(glContext.LINE_STRIP, 0, segments + 1);
                    glContext.deleteBuffer(pointBuffer);
                    cc.incrementGLDraws(1);
                },
                drawCatmullRom: function(points, segments) {
                    this.drawCardinalSpline(points, .5, segments);
                },
                drawCardinalSpline: function(config, tension, segments) {
                    this.lazy_init();
                    var vertices = new Float32Array(2 * (segments + 1));
                    var p, lt, deltaT = 1 / config.length;
                    for (var i = 0; i < segments + 1; i++) {
                        var dt = i / segments;
                        if (1 === dt) {
                            p = config.length - 1;
                            lt = 1;
                        } else {
                            p = 0 | dt / deltaT;
                            lt = (dt - deltaT * p) / deltaT;
                        }
                        var newPos = cc.cardinalSplineAt(cc.getControlPointAt(config, p - 1), cc.getControlPointAt(config, p), cc.getControlPointAt(config, p + 1), cc.getControlPointAt(config, p + 2), tension, lt);
                        vertices[2 * i] = newPos.x;
                        vertices[2 * i + 1] = newPos.y;
                    }
                    var glContext = this._renderContext;
                    this._shader.use();
                    this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
                    cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
                    glContext.uniform4fv(this._colorLocation, this._colorArray);
                    var pointBuffer = glContext.createBuffer();
                    glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
                    glContext.bufferData(glContext.ARRAY_BUFFER, vertices, glContext.STATIC_DRAW);
                    glContext.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
                    glContext.drawArrays(glContext.LINE_STRIP, 0, segments + 1);
                    glContext.deleteBuffer(pointBuffer);
                    cc.incrementGLDraws(1);
                },
                setDrawColor: function(r, g, b, a) {
                    this._colorArray[0] = r / 255;
                    this._colorArray[1] = g / 255;
                    this._colorArray[2] = b / 255;
                    this._colorArray[3] = a / 255;
                },
                setPointSize: function(pointSize) {
                    this._pointSize = pointSize * cc.contentScaleFactor();
                },
                setLineWidth: function(width) {
                    if (this._renderContext.lineWidth) {
                        this._renderContext.lineWidth(width);
                    }
                }
            });
            cc._fntLoader = {
                INFO_EXP: /info [^\n]*(\n|$)/gi,
                COMMON_EXP: /common [^\n]*(\n|$)/gi,
                PAGE_EXP: /page [^\n]*(\n|$)/gi,
                CHAR_EXP: /char [^\n]*(\n|$)/gi,
                KERNING_EXP: /kerning [^\n]*(\n|$)/gi,
                ITEM_EXP: /\w+=[^ \r\n]+/gi,
                INT_EXP: /^[\-]?\d+$/,
                _parseStrToObj: function(str) {
                    var arr = str.match(this.ITEM_EXP);
                    var obj = {};
                    if (arr) {
                        for (var i = 0, li = arr.length; i < li; i++) {
                            var tempStr = arr[i];
                            var index = tempStr.indexOf("=");
                            var key = tempStr.substring(0, index);
                            var value = tempStr.substring(index + 1);
                            if (value.match(this.INT_EXP)) {
                                value = parseInt(value);
                            } else {
                                if ('"' === value[0]) {
                                    value = value.substring(1, value.length - 1);
                                }
                            }
                            obj[key] = value;
                        }
                    }
                    return obj;
                },
                parseFnt: function(fntStr, url) {
                    var self = this, fnt = {};
                    var infoObj = self._parseStrToObj(fntStr.match(self.INFO_EXP)[0]);
                    var paddingArr = infoObj["padding"].split(",");
                    var padding = {
                        left: parseInt(paddingArr[0]),
                        top: parseInt(paddingArr[1]),
                        right: parseInt(paddingArr[2]),
                        bottom: parseInt(paddingArr[3])
                    };
                    var commonObj = self._parseStrToObj(fntStr.match(self.COMMON_EXP)[0]);
                    fnt.commonHeight = commonObj["lineHeight"];
                    fnt.fontSize = infoObj["size"];
                    if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
                        var texSize = cc.configuration.getMaxTextureSize();
                        if (commonObj["scaleW"] > texSize.width || commonObj["scaleH"] > texSize.height) {
                            cc.log("cc.LabelBMFont._parseCommonArguments(): page can't be larger than supported");
                        }
                    }
                    if (1 !== commonObj["pages"]) {
                        cc.log("cc.LabelBMFont._parseCommonArguments(): only supports 1 page");
                    }
                    var pageObj = self._parseStrToObj(fntStr.match(self.PAGE_EXP)[0]);
                    if (0 !== pageObj["id"]) {
                        cc.log("cc.LabelBMFont._parseImageFileName() : file could not be found");
                    }
                    fnt.atlasName = cc.path.changeBasename(url, pageObj["file"]);
                    var charLines = fntStr.match(self.CHAR_EXP);
                    var fontDefDictionary = fnt.fontDefDictionary = {};
                    for (var i = 0, li = charLines.length; i < li; i++) {
                        var charObj = self._parseStrToObj(charLines[i]);
                        var charId = charObj["id"];
                        fontDefDictionary[charId] = {
                            rect: {
                                x: charObj["x"],
                                y: charObj["y"],
                                width: charObj["width"],
                                height: charObj["height"]
                            },
                            xOffset: charObj["xoffset"],
                            yOffset: charObj["yoffset"],
                            xAdvance: charObj["xadvance"]
                        };
                    }
                    var kerningDict = fnt.kerningDict = {};
                    var kerningLines = fntStr.match(self.KERNING_EXP);
                    if (kerningLines) {
                        for (var i = 0, li = kerningLines.length; i < li; i++) {
                            var kerningObj = self._parseStrToObj(kerningLines[i]);
                            kerningDict[kerningObj["first"] << 16 | 65535 & kerningObj["second"]] = kerningObj["amount"];
                        }
                    }
                    return fnt;
                },
                load: function(realUrl, url, res, cb) {
                    var self = this;
                    cc.loader.loadTxt(realUrl, function(err, txt) {
                        if (err) {
                            return cb(err);
                        }
                        cb(null, self.parseFnt(txt, url));
                    });
                }
            };
            cc.loader.register([ "fnt" ], cc._fntLoader);
            var EventTarget = require("../cocos2d/core/event/event-target");
            cc.FontLetterDefinition = function() {
                this._u = 0;
                this._v = 0;
                this._width = 0;
                this._height = 0;
                this._offsetX = 0;
                this._offsetY = 0;
                this._textureID = 0;
                this._validDefinition = false;
                this._xAdvance = 0;
            };
            cc.FontAtlas = function(fntConfig) {
                this._lineHeight = fntConfig.commonHeight;
                this._fontSize = fntConfig.fontSize;
                this._letterDefinitions = {};
                this._fntConfig = fntConfig;
            };
            cc.FontAtlas.prototype = {
                constructor: cc.FontAtlas,
                setFontSize: function(fontSize) {
                    this._fontSize = fontSize;
                },
                getOriginalFontSize: function() {
                    return this._fntConfig.fontSize;
                },
                addLetterDefinitions: function(letter, letterDefinition) {
                    this._letterDefinitions[letter] = letterDefinition;
                },
                cloneLetterDefinition: function() {
                    var copyLetterDefinitions = {};
                    for (var key in this._letterDefinitions) {
                        var value = new cc.FontLetterDefinition();
                        cc.js.mixin(value, this._letterDefinitions[key]);
                        copyLetterDefinitions[key] = value;
                    }
                    return copyLetterDefinitions;
                },
                assignLetterDefinitions: function(letterDefinition) {
                    for (var key in this._letterDefinitions) {
                        var newValue = letterDefinition[key];
                        var oldValue = this._letterDefinitions[key];
                        cc.js.mixin(oldValue, newValue);
                    }
                },
                scaleFontLetterDefinition: function(scaleFactor) {
                    for (var fontDefinition in this._letterDefinitions) {
                        var letterDefinitions = this._letterDefinitions[fontDefinition];
                        letterDefinitions._width *= scaleFactor;
                        letterDefinitions._height *= scaleFactor;
                        letterDefinitions._offsetX *= scaleFactor;
                        letterDefinitions._offsetY *= scaleFactor;
                        letterDefinitions._xAdvance *= scaleFactor;
                    }
                },
                getLetterDefinitionForChar: function(char) {
                    var hasKey = this._letterDefinitions.hasOwnProperty(char.charCodeAt(0));
                    var letterDefinition;
                    if (hasKey) {
                        letterDefinition = this._letterDefinitions[char.charCodeAt(0)];
                    } else {
                        letterDefinition = null;
                    }
                    return letterDefinition;
                }
            };
            cc.LetterInfo = function() {
                this._char = "";
                this._valid = true;
                this._positionX = 0;
                this._positionY = 0;
                this._atlasIndex = 0;
                this._lineIndex = 0;
            };
            _ccsg.Label = _ccsg.Node.extend({
                _hAlign: cc.TextAlignment.LEFT,
                _vAlign: cc.VerticalTextAlignment.TOP,
                _string: "",
                _fontSize: 40,
                _overFlow: 1,
                _isWrapText: true,
                _spacingX: 0,
                _blendFunc: null,
                _isUseSystemFont: true,
                _labelSkinDirty: true,
                _labelType: 0,
                _fontHandle: "",
                _lineSpacing: 0,
                _maxLineWidth: 0,
                _labelDimensions: cc.size(0, 0),
                _labelWidth: 0,
                _labelHeight: 0,
                _lineHeight: 40,
                _className: "Label",
                ctor: function(string, fontHandle) {
                    EventTarget.call(this);
                    fontHandle = fontHandle || "";
                    this._fontHandle = fontHandle;
                    string = string || "";
                    this._string = string;
                    _ccsg.Node.prototype.ctor.call(this);
                    this.setAnchorPoint(cc.p(.5, .5));
                    this.setContentSize(cc.size(128, 128));
                    this._blendFunc = cc.BlendFunc._alphaNonPremultiplied();
                    this.setFontFileOrFamily(fontHandle);
                    this.setString(this._string);
                },
                _resetBMFont: function() {
                    this._imageOffset = cc.p(0, 0);
                    this._cascadeColorEnabled = true;
                    this._cascadeOpacityEnabled = true;
                    this._fontAtlas = null;
                    this._config = null;
                    this._numberOfLines = 0;
                    this._lettersInfo = [];
                    this._linesWidth = [];
                    this._linesOffsetX = [];
                    this._bmFontSize = 0;
                    this._textDesiredHeight = 0;
                    this._letterOffsetY = 0;
                    this._tailoredTopY = 0;
                    this._tailoredBottomY = 0;
                    this._config = null;
                    this._fontAtlas = null;
                    this._bmfontScale = 1;
                    this._additionalKerning = 0;
                    this._horizontalKernings = [];
                    this._lineBreakWithoutSpaces = false;
                    this._reusedRect = cc.rect(0, 0, 0, 0);
                    this._textureLoaded = false;
                    if (this._spriteBatchNode) {
                        this.removeChild(this._spriteBatchNode);
                        this._spriteBatchNode = null;
                    }
                },
                isSystemFontUsed: function() {
                    return this._isUseSystemFont;
                },
                setSystemFontUsed: function(value) {
                    if (this._isUseSystemFont === value) {
                        return;
                    }
                    if (value) {
                        this.setFontFileOrFamily("Arial");
                    }
                    this._isUseSystemFont = value;
                },
                setHorizontalAlign: function(align) {
                    if (this._hAlign === align) {
                        return;
                    }
                    this._hAlign = align;
                    this._notifyLabelSkinDirty();
                },
                getHorizontalAlign: function() {
                    return this._hAlign;
                },
                setVerticalAlign: function(align) {
                    if (this._vAlign === align) {
                        return;
                    }
                    this._vAlign = align;
                    this._notifyLabelSkinDirty();
                },
                getVerticalAlign: function() {
                    return this._vAlign;
                },
                setString: function(string) {
                    if ("string" !== typeof string) {
                        string = "" + string;
                    }
                    if (this._string === string) {
                        return;
                    }
                    this._string = string;
                    this._notifyLabelSkinDirty();
                },
                getString: function() {
                    return this._string;
                },
                getStringLength: function() {
                    return this._string.length;
                },
                enableWrapText: function(enabled) {
                    if (this._isWrapText === enabled) {
                        return;
                    }
                    if (this._overFlow === _ccsg.Label.Overflow.RESIZE_HEIGHT) {
                        return;
                    }
                    this._isWrapText = enabled;
                    this._rescaleWithOriginalFontSize();
                    this._notifyLabelSkinDirty();
                },
                isWrapTextEnabled: function() {
                    return this._isWrapText;
                },
                getFontName: function() {
                    return this._fontHandle;
                },
                setFontSize: function(fntSize) {
                    this._fontSize = fntSize;
                    this._bmFontSize = fntSize;
                    this._notifyLabelSkinDirty();
                },
                getFontSize: function() {
                    return this._fontSize;
                },
                setOverflow: function(overflow) {
                    if (this._overFlow === overflow) {
                        return;
                    }
                    this._overFlow = overflow;
                    if (this._overFlow === _ccsg.Label.Overflow.RESIZE_HEIGHT) {
                        this._setDimensions(this._labelDimensions.width, 0);
                        this._isWrapText = true;
                    }
                    this._rescaleWithOriginalFontSize();
                    this._notifyLabelSkinDirty();
                },
                getOverflow: function() {
                    return this._overFlow;
                },
                setSpacingX: function(spacing) {
                    if (this._spacingX === spacing) {
                        return;
                    }
                    this._spacingX = spacing;
                },
                setLineHeight: function(lineHeight) {
                    if (this._lineHeight === lineHeight) {
                        return;
                    }
                    this._lineHeight = lineHeight;
                    this._notifyLabelSkinDirty();
                },
                setLineBreakWithoutSpace: function(lineBreakFlag) {
                    if (this._lineBreakWithoutSpaces === lineBreakFlag) {
                        return;
                    }
                    this._lineBreakWithoutSpaces = lineBreakFlag;
                    this._notifyLabelSkinDirty();
                },
                getSpacingX: function() {
                    return this._spacingX;
                },
                getLineHeight: function() {
                    return this._lineHeight;
                },
                setFontFileOrFamily: function(fontHandle) {
                    fontHandle = fontHandle || "Arial";
                    var extName = cc.path.extname(fontHandle);
                    this._resetBMFont();
                    if (null === extName) {
                        this._fontHandle = fontHandle;
                        this._labelType = _ccsg.Label.Type.SystemFont;
                        this._notifyLabelSkinDirty();
                        this._isUseSystemFont = true;
                        return;
                    }
                    fontHandle = cc.path.join(cc.loader.resPath, fontHandle);
                    this._isUseSystemFont = false;
                    if (".ttf" === extName) {
                        this._labelType = _ccsg.Label.Type.TTF;
                        this._fontHandle = this._loadTTFFont(fontHandle);
                    } else {
                        if (".fnt" === extName) {
                            this._labelType = _ccsg.Label.Type.BMFont;
                            this._initBMFontWithString(this._string, fontHandle);
                        }
                    }
                },
                _loadTTFFont: function(fontHandle) {
                    var ttfIndex = fontHandle.lastIndexOf(".ttf");
                    if (-1 === ttfIndex) {
                        return fontHandle;
                    }
                    var slashPos = fontHandle.lastIndexOf("/");
                    var fontFamilyName;
                    if (-1 === slashPos) {
                        fontFamilyName = fontHandle.substring(0, ttfIndex) + "_LABEL";
                    } else {
                        fontFamilyName = fontHandle.substring(slashPos + 1, ttfIndex) + "_LABEL";
                    }
                    var self = this;
                    if (window.FontFace) {
                        var fontFace = new FontFace(fontFamilyName, "url('" + fontHandle + "')");
                        fontFace.load().then(function(loadedFace) {
                            document.fonts.add(loadedFace);
                            self._notifyLabelSkinDirty();
                        });
                    } else {
                        var doc = document, fontStyle = document.createElement("style");
                        fontStyle.type = "text/css";
                        doc.body.appendChild(fontStyle);
                        var fontStr = "";
                        if (isNaN(fontFamilyName - 0)) {
                            fontStr += "@font-face { font-family:" + fontFamilyName + "; src:";
                        } else {
                            fontStr += "@font-face { font-family:'" + fontFamilyName + "'; src:";
                        }
                        fontStr += "url('" + fontHandle + "');";
                        fontStyle.textContent = fontStr + "}";
                        var preloadDiv = document.createElement("div");
                        var _divStyle = preloadDiv.style;
                        _divStyle.fontFamily = fontFamilyName;
                        preloadDiv.innerHTML = ".";
                        _divStyle.position = "absolute";
                        _divStyle.left = "-100px";
                        _divStyle.top = "-100px";
                        doc.body.appendChild(preloadDiv);
                        self.scheduleOnce(self._notifyLabelSkinDirty, 2);
                    }
                    return fontFamilyName;
                },
                setContentSize: function(size, height) {
                    var oldWidth = this._contentSize.width;
                    var oldHeight = this._contentSize.height;
                    if (this._labelType === _ccsg.Label.Type.TTF || this._labelType === _ccsg.Label.Type.SystemFont) {
                        _ccsg.Node.prototype.setContentSize.call(this, size, height);
                        if (oldWidth === this._contentSize.width && oldHeight === this._contentSize.height) {
                            return;
                        }
                        var newWidth = size.width || size;
                        var newHeight = size.height || height;
                        this._labelWidth = newWidth;
                        this._labelHeight = newHeight;
                        this._labelDimensions.width = newWidth;
                        this._labelDimensions.height = newHeight;
                        this._maxLineWidth = newWidth;
                        this._notifyLabelSkinDirty();
                    } else {
                        if (this._labelType === _ccsg.Label.Type.BMFont) {
                            if (!height) {
                                if (oldWidth === size.width && oldHeight === size.height) {
                                    return;
                                }
                                this._setDimensions(size.width, size.height);
                            } else {
                                if (oldWidth === size && oldHeight === height) {
                                    return;
                                }
                                this._setDimensions(size, height);
                            }
                        }
                    }
                },
                setBlendFunc: function(src, dst) {
                    var locBlendFunc = this._blendFunc;
                    if (void 0 === dst) {
                        locBlendFunc.src = src.src;
                        locBlendFunc.dst = src.dst;
                    } else {
                        locBlendFunc.src = src;
                        locBlendFunc.dst = dst;
                    }
                },
                getBlendFunc: function() {
                    return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst);
                },
                _notifyLabelSkinDirty: function() {
                    if (false) {
                        if (this._labelType === _ccsg.Label.Type.BMFont) {
                            this._updateContent();
                            this.setColor(this.color);
                            this._labelSkinDirty = false;
                        } else {
                            if (this._labelType === _ccsg.Label.Type.TTF || this._labelType === _ccsg.Label.Type.SystemFont) {
                                this._labelSkinDirty = true;
                            }
                        }
                    } else {
                        this._labelSkinDirty = true;
                    }
                },
                _createRenderCmd: function() {
                    if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
                        return new _ccsg.Label.WebGLRenderCmd(this);
                    } else {
                        return new _ccsg.Label.CanvasRenderCmd(this);
                    }
                },
                getContentSize: function(foreceUpdate) {
                    if (foreceUpdate) {
                        if (this._labelType === _ccsg.Label.Type.BMFont && this._labelSkinDirty) {
                            this._updateContent();
                        }
                    }
                    return _ccsg.Node.prototype.getContentSize.call(this);
                }
            });
            cc.BMFontHelper = {
                _alignText: function() {
                    var ret = true;
                    do {
                        if (!this._spriteBatchNode) {
                            return true;
                        }
                        this._textDesiredHeight = 0;
                        this._linesWidth = [];
                        if (this._maxLineWidth > 0 && !this._lineBreakWithoutSpaces) {
                            this._multilineTextWrapByWord();
                        } else {
                            this._multilineTextWrapByChar();
                        }
                        this._computeAlignmentOffset();
                        if (this._overFlow === _ccsg.Label.Overflow.SHRINK) {
                            var fontSize = this.getFontSize();
                            if (fontSize > 0 && this._isVerticalClamp()) {
                                this._shrinkLabelToContentSize(this._isVerticalClamp.bind(this));
                            }
                        }
                        if (!this._updateQuads()) {
                            ret = false;
                            if (this._overFlow === _ccsg.Label.Overflow.SHRINK) {
                                this._shrinkLabelToContentSize(this._isHorizontalClamp.bind(this));
                            }
                            break;
                        }
                    } while (0);
                    return ret;
                },
                _isHorizontalClamped: function(px, lineIndex) {
                    var wordWidth = this._linesWidth[lineIndex];
                    var letterOverClamp = px > this._contentSize.width || px < 0;
                    if (!this._isWrapText) {
                        return letterOverClamp;
                    } else {
                        return wordWidth > this._contentSize.width && letterOverClamp;
                    }
                },
                _updateQuads: function() {
                    var ret = true;
                    this._spriteBatchNode.removeAllChildren();
                    var letterClamp = false;
                    for (var ctr = 0; ctr < this._string.length; ++ctr) {
                        if (this._lettersInfo[ctr]._valid) {
                            var letterDef = this._fontAtlas._letterDefinitions[this._lettersInfo[ctr]._char];
                            this._reusedRect.height = letterDef._height;
                            this._reusedRect.width = letterDef._width;
                            this._reusedRect.x = letterDef._u;
                            this._reusedRect.y = letterDef._v;
                            var py = this._lettersInfo[ctr]._positionY + this._letterOffsetY;
                            if (this._labelHeight > 0) {
                                if (py > this._tailoredTopY) {
                                    var clipTop = py - this._tailoredTopY;
                                    this._reusedRect.y += clipTop;
                                    this._reusedRect.height -= clipTop;
                                    py -= clipTop;
                                }
                                if (py - letterDef._height * this._bmfontScale < this._tailoredBottomY) {
                                    this._reusedRect.height = py < this._tailoredBottomY ? 0 : py - this._tailoredBottomY;
                                }
                            }
                            var lineIndex = this._lettersInfo[ctr]._lineIndex;
                            var px = this._lettersInfo[ctr]._positionX + letterDef._width / 2 * this._bmfontScale + this._linesOffsetX[lineIndex];
                            if (this._labelWidth > 0) {
                                if (this._isHorizontalClamped(px, lineIndex)) {
                                    if (this._overFlow === _ccsg.Label.Overflow.CLAMP) {
                                        this._reusedRect.width = 0;
                                    } else {
                                        if (this._overFlow === _ccsg.Label.Overflow.SHRINK) {
                                            if (this._contentSize.width > letterDef._width) {
                                                letterClamp = true;
                                                ret = false;
                                                break;
                                            } else {
                                                this._reusedRect.width = 0;
                                            }
                                        }
                                    }
                                }
                            }
                            if (this._reusedRect.height > 0 && this._reusedRect.width > 0) {
                                var fontChar = this.getChildByTag(ctr);
                                var locTexture = this._spriteBatchNode._renderCmd._texture || this._spriteBatchNode.textureAtlas.texture;
                                if (!fontChar) {
                                    fontChar = new _ccsg.Sprite();
                                    fontChar.initWithTexture(locTexture);
                                    fontChar.setAnchorPoint(cc.p(0, 1));
                                }
                                fontChar.setTextureRect(this._reusedRect, false, this._reusedRect.size);
                                var letterPositionX = this._lettersInfo[ctr]._positionX + this._linesOffsetX[this._lettersInfo[ctr]._lineIndex];
                                fontChar.setPosition(letterPositionX, py);
                                var index = this._spriteBatchNode.getChildrenCount();
                                this._lettersInfo[ctr]._atlasIndex = index;
                                this._updateLetterSpriteScale(fontChar);
                                this._spriteBatchNode.addChild(fontChar);
                            }
                        }
                    }
                    return ret;
                },
                _updateLetterSpriteScale: function(sprite) {
                    if (this._labelType === _ccsg.Label.Type.BMFont && this._fontSize > 0) {
                        sprite.setScale(this._bmfontScale);
                    }
                },
                _recordPlaceholderInfo: function(letterIndex, char) {
                    if (letterIndex >= this._lettersInfo.length) {
                        var tmpInfo = new cc.LetterInfo();
                        this._lettersInfo.push(tmpInfo);
                    }
                    this._lettersInfo[letterIndex]._char = char;
                    this._lettersInfo[letterIndex]._valid = false;
                },
                _recordLetterInfo: function(letterPosition, character, letterIndex, lineIndex) {
                    if (letterIndex >= this._lettersInfo.length) {
                        var tmpInfo = new cc.LetterInfo();
                        this._lettersInfo.push(tmpInfo);
                    }
                    character = character.charCodeAt(0);
                    this._lettersInfo[letterIndex]._lineIndex = lineIndex;
                    this._lettersInfo[letterIndex]._char = character;
                    this._lettersInfo[letterIndex]._valid = this._fontAtlas._letterDefinitions[character]._validDefinition;
                    this._lettersInfo[letterIndex]._positionX = letterPosition.x;
                    this._lettersInfo[letterIndex]._positionY = letterPosition.y;
                },
                _setDimensions: function(width, height) {
                    if (this._overFlow === _ccsg.Label.Overflow.RESIZE_HEIGHT) {
                        height = 0;
                    }
                    if (height !== this._labelHeight || width !== this._labelWidth) {
                        this._labelWidth = width;
                        this._labelHeight = height;
                        this._labelDimensions.width = width;
                        this._labelDimensions.height = height;
                        this._maxLineWidth = width;
                        if (this._overFlow === _ccsg.Label.Overflow.SHRINK) {
                            if (this._bmFontSize > 0) {
                                this._restoreFontSize();
                            }
                        }
                        this._notifyLabelSkinDirty();
                    }
                },
                _restoreFontSize: function() {
                    if (this._labelType === _ccsg.Label.Type.BMFont) {
                        this._fontSize = this._bmFontSize;
                    }
                },
                _multilineTextWrap: function(nextTokenFunc) {
                    var textLen = this.getStringLength();
                    var lineIndex = 0;
                    var nextTokenX = 0;
                    var nextTokenY = 0;
                    var longestLine = 0;
                    var letterRight = 0;
                    var contentScaleFactor = cc.contentScaleFactor();
                    var lineSpacing = this._lineSpacing * contentScaleFactor;
                    var highestY = 0;
                    var lowestY = 0;
                    var letterDef = null;
                    var letterPosition = cc.p(0, 0);
                    this._updateBMFontScale();
                    for (var index = 0; index < textLen; ) {
                        var character = this._string.charAt(index);
                        if ("\n" === character) {
                            this._linesWidth.push(letterRight);
                            letterRight = 0;
                            lineIndex++;
                            nextTokenX = 0;
                            nextTokenY -= this._lineHeight * this._bmfontScale + lineSpacing;
                            this._recordPlaceholderInfo(index, character);
                            index++;
                            continue;
                        }
                        var tokenLen = nextTokenFunc(this._string, index, textLen);
                        var tokenHighestY = highestY;
                        var tokenLowestY = lowestY;
                        var tokenRight = letterRight;
                        var nextLetterX = nextTokenX;
                        var newLine = false;
                        for (var tmp = 0; tmp < tokenLen; ++tmp) {
                            var letterIndex = index + tmp;
                            character = this._string.charAt(letterIndex);
                            if ("\r" === character) {
                                this._recordPlaceholderInfo(letterIndex, character);
                                continue;
                            }
                            letterDef = this._fontAtlas.getLetterDefinitionForChar(character);
                            if (!letterDef) {
                                this._recordPlaceholderInfo(letterIndex, character);
                                console.log("Can't find letter definition in font file for letter:" + character);
                                continue;
                            }
                            var letterX = (nextLetterX + letterDef._offsetX * this._bmfontScale) / contentScaleFactor;
                            if (this._isWrapText && this._maxLineWidth > 0 && nextTokenX > 0 && letterX + letterDef._width * this._bmfontScale > this._maxLineWidth && !this._isspace_unicode(character)) {
                                this._linesWidth.push(letterRight);
                                letterRight = 0;
                                lineIndex++;
                                nextTokenX = 0;
                                nextTokenY -= this._lineHeight * this._bmfontScale + lineSpacing;
                                newLine = true;
                                break;
                            } else {
                                letterPosition.x = letterX;
                            }
                            letterPosition.y = (nextTokenY - letterDef._offsetY * this._bmfontScale) / contentScaleFactor;
                            this._recordLetterInfo(letterPosition, character, letterIndex, lineIndex);
                            if (letterIndex + 1 < this._horizontalKernings.length && letterIndex < textLen - 1) {
                                nextLetterX += this._horizontalKernings[letterIndex + 1];
                            }
                            nextLetterX += letterDef._xAdvance * this._bmfontScale + this._additionalKerning;
                            tokenRight = letterPosition.x + letterDef._width * this._bmfontScale;
                            if (tokenHighestY < letterPosition.y) {
                                tokenHighestY = letterPosition.y;
                            }
                            if (tokenLowestY > letterPosition.y - letterDef._height * this._bmfontScale) {
                                tokenLowestY = letterPosition.y - letterDef._height * this._bmfontScale;
                            }
                        }
                        if (newLine) {
                            continue;
                        }
                        nextTokenX = nextLetterX;
                        letterRight = tokenRight;
                        if (highestY < tokenHighestY) {
                            highestY = tokenHighestY;
                        }
                        if (lowestY > tokenLowestY) {
                            lowestY = tokenLowestY;
                        }
                        if (longestLine < letterRight) {
                            longestLine = letterRight;
                        }
                        index += tokenLen;
                    }
                    this._linesWidth.push(letterRight);
                    this._numberOfLines = lineIndex + 1;
                    this._textDesiredHeight = this._numberOfLines * this._lineHeight * this._bmfontScale / contentScaleFactor;
                    if (this._numberOfLines > 1) {
                        this._textDesiredHeight += (this._numberOfLines - 1) * this._lineSpacing;
                    }
                    var contentSize = cc.size(this._labelWidth, this._labelHeight);
                    if (this._labelWidth <= 0) {
                        contentSize.width = longestLine;
                    }
                    if (this._labelHeight <= 0) {
                        contentSize.height = this._textDesiredHeight;
                    }
                    _ccsg.Node.prototype.setContentSize.call(this, contentSize);
                    this._tailoredTopY = contentSize.height;
                    this._tailoredBottomY = 0;
                    if (highestY > 0) {
                        this._tailoredTopY = contentSize.height + highestY;
                    }
                    if (lowestY < -this._textDesiredHeight) {
                        this._tailoredBottomY = this._textDesiredHeight + lowestY;
                    }
                    return true;
                },
                _multilineTextWrapByWord: function() {
                    return this._multilineTextWrap(this._getFirstWordLen.bind(this));
                },
                _multilineTextWrapByChar: function() {
                    return this._multilineTextWrap(this._getFirstCharLen.bind(this));
                },
                _isVerticalClamp: function() {
                    if (this._textDesiredHeight > this._contentSize.height) {
                        return true;
                    } else {
                        return false;
                    }
                },
                _isHorizontalClamp: function() {
                    var letterClamp = false;
                    for (var ctr = 0; ctr < this.getStringLength(); ++ctr) {
                        if (this._lettersInfo[ctr]._valid) {
                            var letterDef = this._fontAtlas._letterDefinitions[this._lettersInfo[ctr]._char];
                            var px = this._lettersInfo[ctr]._positionX + letterDef._width / 2 * this._bmfontScale;
                            var lineIndex = this._lettersInfo[ctr]._lineIndex;
                            if (this._labelWidth > 0) {
                                if (!this._isWrapText) {
                                    if (px > this._contentSize.width) {
                                        letterClamp = true;
                                        break;
                                    }
                                } else {
                                    var wordWidth = this._linesWidth[lineIndex];
                                    if (wordWidth > this._contentSize.width && (px > this._contentSize.width || px < 0)) {
                                        letterClamp = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    return letterClamp;
                },
                _shrinkLabelToContentSize: function(lambda) {
                    var fontSize = this.getFontSize();
                    var i = 0;
                    var tempLetterDefinition = this._fontAtlas.cloneLetterDefinition();
                    var originalLineHeight = this._lineHeight;
                    var flag = true;
                    while (lambda()) {
                        ++i;
                        var newFontSize = fontSize - i;
                        flag = false;
                        if (newFontSize <= 0) {
                            break;
                        }
                        var scale = newFontSize / fontSize;
                        this._fontAtlas.assignLetterDefinitions(tempLetterDefinition);
                        this._fontAtlas.scaleFontLetterDefinition(scale);
                        this._lineHeight = originalLineHeight * scale;
                        if (this._maxLineWidth > 0 && !this._lineBreakWithoutSpaces) {
                            this._multilineTextWrapByWord();
                        } else {
                            this._multilineTextWrapByChar();
                        }
                        this._computeAlignmentOffset();
                    }
                    this._lineHeight = originalLineHeight;
                    this._fontAtlas.assignLetterDefinitions(tempLetterDefinition);
                    if (!flag) {
                        if (fontSize - i >= 0) {
                            this._scaleFontSizeDown(fontSize - i);
                        }
                    }
                },
                _scaleFontSizeDown: function(fontSize) {
                    var shouldUpdateContent = true;
                    if (this._labelType === _ccsg.Label.Type.BMFont) {
                        if (!fontSize) {
                            fontSize = .1;
                            shouldUpdateContent = false;
                        }
                        this._fontSize = fontSize;
                    }
                    if (shouldUpdateContent) {
                        this._updateContent();
                    }
                },
                _updateContent: function() {
                    var updateFinished = true;
                    if (this._fontAtlas) {
                        this._computeHorizontalKerningForText(this._string);
                        updateFinished = this._alignText();
                    }
                    if (updateFinished) {
                        this._labelSkinDirty = false;
                    }
                },
                _computeAlignmentOffset: function() {
                    this._linesOffsetX = [];
                    switch (this._hAlign) {
                      case cc.TextAlignment.LEFT:
                        for (var i = 0; i < this._numberOfLines; ++i) {
                            this._linesOffsetX.push(0);
                        }
                        break;

                      case cc.TextAlignment.CENTER:
                        this._linesWidth.forEach(function(lineWidth) {
                            this._linesOffsetX.push((this._contentSize.width - lineWidth) / 2);
                        }.bind(this));
                        break;

                      case cc.TextAlignment.RIGHT:
                        this._linesWidth.forEach(function(lineWidth) {
                            this._linesOffsetX.push(this._contentSize.width - lineWidth);
                        }.bind(this));
                    }
                    switch (this._vAlign) {
                      case cc.VerticalTextAlignment.TOP:
                        this._letterOffsetY = this._contentSize.height;
                        break;

                      case cc.VerticalTextAlignment.CENTER:
                        this._letterOffsetY = (this._contentSize.height + this._textDesiredHeight) / 2;
                        break;

                      case cc.VerticalTextAlignment.BOTTOM:
                        this._letterOffsetY = this._textDesiredHeight;
                    }
                },
                _getFirstCharLen: function(text, startIndex, textLen) {
                    return 1;
                },
                _isCJK_unicode: function(ch) {
                    var __CHINESE_REG = /^[\u4E00-\u9FFF\u3400-\u4DFF]+$/;
                    var __JAPANESE_REG = /[\u3000-\u303F]|[\u3040-\u309F]|[\u30A0-\u30FF]|[\uFF00-\uFFEF]|[\u4E00-\u9FAF]|[\u2605-\u2606]|[\u2190-\u2195]|\u203B/g;
                    var __KOREAN_REG = /^[\u1100-\u11FF]|[\u3130-\u318F]|[\uA960-\uA97F]|[\uAC00-\uD7AF]|[\uD7B0-\uD7FF]+$/;
                    return __CHINESE_REG.test(ch) || __JAPANESE_REG.test(ch) || __KOREAN_REG.test(ch);
                },
                _isspace_unicode: function(ch) {
                    ch = ch.charCodeAt(0);
                    return ch >= 9 && ch <= 13 || 32 === ch || 133 === ch || 160 === ch || 5760 === ch || ch >= 8192 && ch <= 8202 || 8232 === ch || 8233 === ch || 8239 === ch || 8287 === ch || 12288 === ch;
                },
                _getFirstWordLen: function(text, startIndex, textLen) {
                    var character = text.charAt(startIndex);
                    if (this._isCJK_unicode(character) || "\n" === character || this._isspace_unicode(character)) {
                        return 1;
                    }
                    var len = 1;
                    for (var index = startIndex + 1; index < textLen; ++index) {
                        character = text.charAt(index);
                        if ("\n" === character || this._isspace_unicode(character) || this._isCJK_unicode(character)) {
                            break;
                        }
                        len++;
                    }
                    return len;
                },
                _updateBMFontScale: function() {
                    if (this._labelType === _ccsg.Label.Type.BMFont) {
                        var originalFontSize = this._fontAtlas._fontSize;
                        this._bmfontScale = this._fontSize * cc.contentScaleFactor() / originalFontSize;
                    } else {
                        this._bmfontScale = 1;
                    }
                },
                _initBMFontWithString: function(str, fntFile) {
                    var self = this;
                    if (self._config) {
                        cc.log("_ccsg.Label._initBMFontWithString(): re-init is no longer supported");
                        return false;
                    }
                    this._string = str;
                    this._setBMFontFile(fntFile);
                },
                _createSpriteBatchNode: function(texture) {
                    this._spriteBatchNode = new cc.SpriteBatchNode(texture, this._string.length);
                    this._spriteBatchNode.setCascadeColorEnabled(true);
                    this._spriteBatchNode.setCascadeOpacityEnabled(true);
                    this.addChild(this._spriteBatchNode);
                    this._updateContent();
                    this.setColor(this.color);
                },
                _createFontChars: function() {
                    if (!this._config) {
                        return;
                    }
                    this._fontAtlas = new cc.FontAtlas(this._config);
                    if (!this._lineHeight) {
                        this._lineHeight = this._fontAtlas._lineHeight;
                    }
                    var locCfg = this._config;
                    var locFontDict = locCfg.fontDefDictionary;
                    for (var fontDef in locFontDict) {
                        var letterDefinition = new cc.FontLetterDefinition();
                        var tempRect = locFontDict[fontDef].rect;
                        cc.rectPointsToPixels(tempRect);
                        letterDefinition._offsetX = locFontDict[fontDef].xOffset;
                        letterDefinition._offsetY = locFontDict[fontDef].yOffset;
                        letterDefinition._width = tempRect.width;
                        letterDefinition._height = tempRect.height;
                        letterDefinition._u = tempRect.x + this._imageOffset.x;
                        letterDefinition._v = tempRect.y + this._imageOffset.y;
                        letterDefinition._textureID = 0;
                        letterDefinition._validDefinition = true;
                        letterDefinition._xAdvance = locFontDict[fontDef].xAdvance;
                        this._fontAtlas.addLetterDefinitions(fontDef, letterDefinition);
                    }
                },
                _rescaleWithOriginalFontSize: function() {
                    var renderingFontSize = this.getFontSize();
                    if (this._bmFontSize - renderingFontSize >= 1 && this._overFlow === _ccsg.Label.Overflow.SHRINK) {
                        this._scaleFontSizeDown(this._bmFontSize);
                    }
                },
                _computeHorizontalKerningForText: function(text) {
                    var stringLen = this.getStringLength();
                    var locKerningDict = this._config.kerningDict;
                    var prev = -1;
                    for (var i = 0; i < stringLen; ++i) {
                        var key = this._string.charCodeAt(i);
                        var kerningAmount = locKerningDict[prev << 16 | 65535 & key] || 0;
                        if (i < stringLen - 1) {
                            this._horizontalKernings[i] = kerningAmount;
                        } else {
                            this._horizontalKernings[i] = 0;
                        }
                        prev = key;
                    }
                },
                _setBMFontFile: function(filename) {
                    if (filename) {
                        this._fontHandle = filename;
                        var self = this;
                        if (this._labelType === _ccsg.Label.Type.BMFont) {
                            this._resetBMFont();
                            var texture;
                            cc.loader.load(this._fontHandle, function(err, results) {
                                if (err) {
                                    cc.log("_ccsg.Label._initBMFontWithString(): Impossible to create font. Please check file");
                                }
                                self._config = results[0];
                                self._createFontChars();
                                texture = cc.textureCache.addImage(self._config.atlasName);
                                var locIsLoaded = texture.isLoaded();
                                self._textureLoaded = locIsLoaded;
                                if (!locIsLoaded) {
                                    texture.once("load", function(event) {
                                        var self = this;
                                        if (!self._spriteBatchNode) {
                                            self._createSpriteBatchNode(texture);
                                        }
                                        self._textureLoaded = true;
                                        self.emit("load");
                                    }, self);
                                } else {
                                    self._createSpriteBatchNode(texture);
                                }
                            });
                        }
                    }
                }
            };
            var _p = _ccsg.Label.prototype;
            cc.js.addon(_p, EventTarget.prototype);
            cc.js.mixin(_p, cc.BMFontHelper);
            _ccsg.Label.Type = cc.Enum({
                TTF: 0,
                BMFont: 1,
                SystemFont: 2
            });
            _ccsg.Label.Overflow = cc.Enum({
                NONE: 0,
                CLAMP: 1,
                SHRINK: 2,
                RESIZE_HEIGHT: 3
            });
            !function() {
                _ccsg.Label.TTFLabelBaker = function() {};
                var proto = _ccsg.Label.TTFLabelBaker.prototype = Object.create(Object.prototype);
                proto._getLineHeight = function() {
                    var nodeSpacingY = this._node.getLineHeight();
                    if (0 === nodeSpacingY) {
                        nodeSpacingY = this._drawFontsize;
                    } else {
                        nodeSpacingY = nodeSpacingY * this._drawFontsize / this._node._fontSize;
                    }
                    return 0 | nodeSpacingY;
                };
                proto._prepareQuad = function() {
                    var quad = this._quad;
                    var white = cc.color(255, 255, 255, this._displayedOpacity);
                    var width = this._node._contentSize.width;
                    var height = this._node._contentSize.height;
                    quad._bl.colors = white;
                    quad._br.colors = white;
                    quad._tl.colors = white;
                    quad._tr.colors = white;
                    quad._bl.vertices = new cc.Vertex3F(0, 0, 0);
                    quad._br.vertices = new cc.Vertex3F(width, 0, 0);
                    quad._tl.vertices = new cc.Vertex3F(0, height, 0);
                    quad._tr.vertices = new cc.Vertex3F(width, height, 0);
                    quad._bl.texCoords = new cc.Tex2F(0, 1);
                    quad._br.texCoords = new cc.Tex2F(1, 1);
                    quad._tl.texCoords = new cc.Tex2F(0, 0);
                    quad._tr.texCoords = new cc.Tex2F(1, 0);
                    this._quadDirty = true;
                };
                var label_wrapinspection = true;
                var label_wordRex = /([a-zA-Z0-9]+|\S)/;
                var label_symbolRex = /^[!,.:;}\]%\?>]/;
                var label_lastWordRex = /([a-zA-Z0-9]+|\S)$/;
                var label_lastEnglish = /[a-zA-Z0-9]+$/;
                var label_firsrEnglish = /^[a-zA-Z0-9]/;
                proto._fragmentText = function(strArr, maxWidth, ctx) {
                    var wrappedWords = [];
                    var text = strArr;
                    var allWidth = ctx.measureText(text).width;
                    while (allWidth > maxWidth && text.length > 1) {
                        var fuzzyLen = text.length * (maxWidth / allWidth) | 0;
                        var tmpText = text.substr(fuzzyLen);
                        var width = allWidth - ctx.measureText(tmpText).width;
                        var sLine = tmpText;
                        var pushNum = 0;
                        var checkWhile = 0;
                        while (width > maxWidth && checkWhile++ < 100) {
                            fuzzyLen *= maxWidth / width;
                            fuzzyLen = 0 | fuzzyLen;
                            tmpText = text.substr(fuzzyLen);
                            width = allWidth - ctx.measureText(tmpText).width;
                        }
                        checkWhile = 0;
                        while (width < maxWidth && checkWhile++ < 100) {
                            if (tmpText) {
                                var exec = label_wordRex.exec(tmpText);
                                pushNum = exec ? exec[0].length : 1;
                                sLine = tmpText;
                            }
                            fuzzyLen += pushNum;
                            tmpText = text.substr(fuzzyLen);
                            width = allWidth - ctx.measureText(tmpText).width;
                        }
                        fuzzyLen -= pushNum;
                        if (0 === fuzzyLen) {
                            fuzzyLen = 1;
                            sLine = sLine.substr(1);
                        }
                        var sText = text.substr(0, fuzzyLen), result;
                        if (label_wrapinspection) {
                            if (label_symbolRex.test(sLine || tmpText)) {
                                result = label_lastWordRex.exec(sText);
                                fuzzyLen -= result ? result[0].length : 0;
                                if (0 === fuzzyLen) {
                                    fuzzyLen = 1;
                                }
                                sLine = text.substr(fuzzyLen);
                                sText = text.substr(0, fuzzyLen);
                            }
                        }
                        if (label_firsrEnglish.test(sLine)) {
                            result = label_lastEnglish.exec(sText);
                            if (result && sText !== result[0]) {
                                fuzzyLen -= result[0].length;
                                sLine = text.substr(fuzzyLen);
                                sText = text.substr(0, fuzzyLen);
                            }
                        }
                        wrappedWords.push(sText);
                        text = sLine || tmpText;
                        allWidth = ctx.measureText(text).width;
                    }
                    if (text.length > 0) {
                        wrappedWords.push(text);
                    }
                    return wrappedWords;
                };
                proto._updateDisplayOpacity = function(parentOpacity) {
                    _ccsg.Node.RenderCmd.prototype._updateDisplayOpacity.call(this, parentOpacity);
                    var color = cc.color(255, 255, 255, this._displayedOpacity);
                    var quad = this._quad;
                    quad._bl.colors = color;
                    quad._br.colors = color;
                    quad._tl.colors = color;
                    quad._tr.colors = color;
                    this._quadDirty = true;
                };
                proto._updateDisplayColor = function(parentColor) {
                    _ccsg.Node.RenderCmd.prototype._updateDisplayColor.call(this, parentColor);
                    var node = this._node;
                    node._labelSkinDirty = true;
                };
                proto._bakeLabel = function() {
                    var node = this._node;
                    this._drawFontsize = node._fontSize;
                    var ctx = this._labelContext;
                    var canvasSizeX = node._contentSize.width;
                    var canvasSizeY = node._contentSize.height;
                    if (canvasSizeX <= 0) {
                        canvasSizeX = 1;
                    }
                    if (canvasSizeY <= 0) {
                        canvasSizeY = 1;
                    }
                    var paragraphedStrings = node._string.split("\n");
                    var paragraphLength = [];
                    this._drawFontsize = node._fontSize;
                    var fontDesc = this._drawFontsize.toString() + "px ";
                    var fontFamily = 0 === node._fontHandle.length ? "serif" : node._fontHandle;
                    fontDesc += fontFamily;
                    this._labelContext.font = fontDesc;
                    for (var i = 0; i < paragraphedStrings.length; ++i) {
                        var textMetric = ctx.measureText(paragraphedStrings[i]);
                        paragraphLength.push(textMetric.width);
                    }
                    if (_ccsg.Label.Overflow.CLAMP === node._overFlow) {
                        if (node._isWrapText) {
                            this._splitedStrings = [];
                            for (var i = 0; i < paragraphedStrings.length; ++i) {
                                this._splitedStrings = this._splitedStrings.concat(this._fragmentText(paragraphedStrings[i], canvasSizeX, ctx));
                            }
                        } else {
                            this._splitedStrings = paragraphedStrings;
                        }
                    } else {
                        if (_ccsg.Label.Overflow.RESIZE_HEIGHT === node._overFlow) {
                            if (node._isWrapText) {
                                this._splitedStrings = [];
                                for (var i = 0; i < paragraphedStrings.length; ++i) {
                                    this._splitedStrings = this._splitedStrings.concat(this._fragmentText(paragraphedStrings[i], canvasSizeX, ctx));
                                }
                                canvasSizeY = this._splitedStrings.length * this._getLineHeight();
                                node.setContentSize(cc.size(canvasSizeX, canvasSizeY));
                            } else {
                                this._splitedStrings = paragraphedStrings;
                                canvasSizeY = this._splitedStrings.length * this._getLineHeight();
                                node.setContentSize(cc.size(canvasSizeX, canvasSizeY));
                            }
                        } else {
                            if (_ccsg.Label.Overflow.SHRINK === node._overFlow) {
                                this._splitedStrings = paragraphedStrings;
                                if (node._isWrapText) {
                                    var totalLength = 0;
                                    for (var i = 0; i < paragraphedStrings.length; ++i) {
                                        totalLength += (paragraphLength[i] / canvasSizeX + 1 | 0) * canvasSizeX;
                                    }
                                    var scale = canvasSizeX * (canvasSizeY / this._getLineHeight() | 0) / totalLength;
                                    this._drawFontsize = this._drawFontsize * Math.min(Math.sqrt(scale), 1) | 0;
                                    fontDesc = this._drawFontsize.toString() + "px " + fontFamily;
                                    this._labelContext.font = fontDesc;
                                    this._splitedStrings = [];
                                    for (var i = 0; i < paragraphedStrings.length; ++i) {
                                        this._splitedStrings = this._splitedStrings.concat(this._fragmentText(paragraphedStrings[i], canvasSizeX, ctx));
                                    }
                                } else {
                                    var maxLength = 0;
                                    var totalHeight = paragraphedStrings.length * this._getLineHeight();
                                    for (var i = 0; i < paragraphedStrings.length; ++i) {
                                        if (maxLength < paragraphLength[i]) {
                                            maxLength = paragraphLength[i];
                                        }
                                    }
                                    var scaleX = canvasSizeX / maxLength;
                                    var scaleY = canvasSizeY / totalHeight;
                                    this._drawFontsize = this._drawFontsize * Math.min(1, scaleX, scaleY) | 0;
                                    fontDesc = this._drawFontsize.toString() + "px " + fontFamily;
                                    this._splitedStrings = paragraphedStrings;
                                }
                            } else {
                                if (node._isWrapText) {
                                    this._splitedStrings = [];
                                    for (var i = 0; i < paragraphedStrings.length; ++i) {
                                        this._splitedStrings = this._splitedStrings.concat(this._fragmentText(paragraphedStrings[i], canvasSizeX, ctx));
                                    }
                                } else {
                                    this._splitedStrings = paragraphedStrings;
                                }
                            }
                        }
                    }
                    this._labelCanvas.width = canvasSizeX;
                    this._labelCanvas.height = canvasSizeY;
                    this._labelContext.clearRect(0, 0, this._labelCanvas.width, this._labelCanvas.height);
                    var color = this._displayedColor;
                    this._labelContext.fillStyle = "rgb(" + color.r + "," + color.g + "," + color.b + ")";
                    var lineHeight = this._getLineHeight();
                    var lineCount = this._splitedStrings.length;
                    var labelX;
                    var firstLinelabelY;
                    var hAlign;
                    var vAlign;
                    if (cc.TextAlignment.RIGHT === node._hAlign) {
                        hAlign = "right";
                        labelX = canvasSizeX;
                    } else {
                        if (cc.TextAlignment.CENTER === node._hAlign) {
                            hAlign = "center";
                            labelX = canvasSizeX / 2;
                        } else {
                            hAlign = "left";
                            labelX = 0;
                        }
                    }
                    this._labelContext.textAlign = hAlign;
                    if (cc.VerticalTextAlignment.TOP === node._vAlign) {
                        vAlign = "top";
                        firstLinelabelY = 0;
                    } else {
                        if (cc.VerticalTextAlignment.CENTER === node._vAlign) {
                            vAlign = "middle";
                            firstLinelabelY = canvasSizeY / 2 - lineHeight * (lineCount - 1) / 2;
                        } else {
                            vAlign = "bottom";
                            firstLinelabelY = canvasSizeY - lineHeight * (lineCount - 1);
                        }
                    }
                    this._labelContext.textBaseline = vAlign;
                    this._labelContext.font = fontDesc;
                    for (var i = 0; i < this._splitedStrings.length; ++i) {
                        this._labelContext.fillText(this._splitedStrings[i], labelX, firstLinelabelY + i * lineHeight);
                    }
                    this._labelTexture._textureLoaded = false;
                    this._labelTexture.handleLoadedTexture();
                };
                proto._rebuildLabelSkin = function() {
                    var node = this._node;
                    if (node._labelSkinDirty) {
                        if (node._labelType === _ccsg.Label.Type.TTF || node._labelType === _ccsg.Label.Type.SystemFont) {
                            this._bakeLabel();
                            this._prepareQuad();
                        } else {
                            node._updateContent();
                        }
                        this._node._labelSkinDirty = false;
                    }
                };
            }();
            !function() {
                _ccsg.Label.CanvasRenderCmd = function(renderableObject) {
                    _ccsg.Node.CanvasRenderCmd.call(this, renderableObject);
                    this._needDraw = true;
                    this._labelTexture = new cc.Texture2D();
                    this._labelCanvas = document.createElement("canvas");
                    this._labelCanvas.width = 1;
                    this._labelCanvas.height = 1;
                    this._labelContext = this._labelCanvas.getContext("2d");
                    this._labelTexture.initWithElement(this._labelCanvas);
                    this._quad = new cc.V3F_C4B_T2F_Quad();
                    this._quadDirty = true;
                    this._splitedStrings = null;
                    this._drawFontsize = 0;
                };
                var proto = _ccsg.Label.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
                cc.js.mixin(proto, _ccsg.Label.TTFLabelBaker.prototype);
                proto.constructor = _ccsg.Label.CanvasRenderCmd;
                proto.rendering = function(ctx, scaleX, scaleY) {
                    this._rebuildLabelSkin();
                    var node = this._node;
                    if (node._labelType === _ccsg.Label.Type.TTF || node._labelType === _ccsg.Label.Type.SystemFont) {
                        var locDisplayOpacity = this._displayedOpacity;
                        var alpha = locDisplayOpacity / 255;
                        if (0 === locDisplayOpacity) {
                            return;
                        }
                        var wrapper = ctx || cc._renderContext, context = wrapper.getContext();
                        wrapper.setTransform(this._worldTransform, scaleX, scaleY);
                        wrapper.setCompositeOperation(_ccsg.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc(node._blendFunc));
                        wrapper.setGlobalAlpha(alpha);
                        if (this._labelTexture) {
                            var sx, sy, sw, sh;
                            var x, y, w, h;
                            x = 0;
                            y = -this._node._contentSize.height;
                            w = this._node._contentSize.width;
                            h = this._node._contentSize.height;
                            var textureWidth = this._labelTexture.getPixelWidth();
                            var textureHeight = this._labelTexture.getPixelHeight();
                            sx = 0;
                            sy = 0;
                            sw = textureWidth;
                            sh = textureHeight;
                            x *= scaleX;
                            y *= scaleY;
                            w *= scaleX;
                            h *= scaleY;
                            var image = this._labelTexture._htmlElementObj;
                            if ("" !== this._labelTexture._pattern) {
                                wrapper.setFillStyle(context.createPattern(image, this._labelTexture._pattern));
                                context.fillRect(x, y, w, h);
                            } else {
                                if (0 !== sw && 0 !== sh && 0 !== w && 0 !== h) {
                                    context.drawImage(image, sx, sy, sw, sh, x, y, w, h);
                                }
                            }
                        }
                        cc.g_NumberOfDraws = cc.g_NumberOfDraws + 1;
                    }
                };
            }();
            !function() {
                _ccsg.Label.WebGLRenderCmd = function(renderableObject) {
                    _ccsg.Node.WebGLRenderCmd.call(this, renderableObject);
                    this._needDraw = true;
                    this._labelTexture = new cc.Texture2D();
                    this._quadWebBuffer = cc._renderContext.createBuffer();
                    this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
                    this._quad = new cc.V3F_C4B_T2F_Quad();
                    this._labelCanvas = document.createElement("canvas");
                    this._labelTexture.initWithElement(this._labelCanvas);
                    this._labelContext = this._labelCanvas.getContext("2d");
                    this._labelCanvas.width = 1;
                    this._labelCanvas.height = 1;
                    this._quadDirty = true;
                    this._splitedStrings = null;
                    this._drawFontsize = 0;
                };
                var proto = _ccsg.Label.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
                cc.js.mixin(proto, _ccsg.Label.TTFLabelBaker.prototype);
                proto.constructor = _ccsg.Label.WebGLRenderCmd;
                proto.rendering = function(ctx) {
                    var node = this._node;
                    this._rebuildLabelSkin();
                    if (node._labelType === _ccsg.Label.Type.TTF || node._labelType === _ccsg.Label.Type.SystemFont) {
                        var gl = ctx || cc._renderContext;
                        this._shaderProgram.use();
                        this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
                        cc.glBlendFunc(node._blendFunc.src, node._blendFunc.dst);
                        cc.glBindTexture2DN(0, this._labelTexture);
                        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
                        gl.bindBuffer(gl.ARRAY_BUFFER, this._quadWebBuffer);
                        if (this._quadDirty) {
                            gl.bufferData(gl.ARRAY_BUFFER, this._quad.arrayBuffer, gl.DYNAMIC_DRAW);
                            this._quadDirty = false;
                        }
                        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 24, 0);
                        gl.vertexAttribPointer(1, 4, gl.UNSIGNED_BYTE, true, 24, 12);
                        gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 24, 16);
                        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                    }
                };
            }();
            cc.math = cc.math || {};
            cc.math.EPSILON = 1 / 64;
            cc.math.square = function(s) {
                return s * s;
            };
            cc.math.almostEqual = function(lhs, rhs) {
                return lhs + cc.math.EPSILON > rhs && lhs - cc.math.EPSILON < rhs;
            };
            !function(cc) {
                cc.math.Vec2 = function(x, y) {
                    if (void 0 === y) {
                        this.x = x.x;
                        this.y = x.y;
                    } else {
                        this.x = x || 0;
                        this.y = y || 0;
                    }
                };
                var proto = cc.math.Vec2.prototype;
                proto.fill = function(x, y) {
                    this.x = x;
                    this.y = y;
                };
                proto.length = function() {
                    return Math.sqrt(cc.math.square(this.x) + cc.math.square(this.y));
                };
                proto.lengthSq = function() {
                    return cc.math.square(this.x) + cc.math.square(this.y);
                };
                proto.normalize = function() {
                    var l = 1 / this.length();
                    this.x *= l;
                    this.y *= l;
                    return this;
                };
                cc.math.Vec2.add = function(pOut, pV1, pV2) {
                    pOut.x = pV1.x + pV2.x;
                    pOut.y = pV1.y + pV2.y;
                    return pOut;
                };
                proto.add = function(vec) {
                    this.x += vec.x;
                    this.y += vec.y;
                    return this;
                };
                proto.dot = function(vec) {
                    return this.x * vec.x + this.y * vec.y;
                };
                cc.math.Vec2.subtract = function(pOut, pV1, pV2) {
                    pOut.x = pV1.x - pV2.x;
                    pOut.y = pV1.y - pV2.y;
                    return pOut;
                };
                proto.subtract = function(vec) {
                    this.x -= vec.x;
                    this.y -= vec.y;
                    return this;
                };
                proto.transform = function(mat3) {
                    var x = this.x, y = this.y;
                    this.x = x * mat3.mat[0] + y * mat3.mat[3] + mat3.mat[6];
                    this.y = x * mat3.mat[1] + y * mat3.mat[4] + mat3.mat[7];
                    return this;
                };
                cc.math.Vec2.scale = function(pOut, pIn, s) {
                    pOut.x = pIn.x * s;
                    pOut.y = pIn.y * s;
                    return pOut;
                };
                proto.scale = function(s) {
                    this.x *= s;
                    this.y *= s;
                    return this;
                };
                proto.equals = function(vec) {
                    return this.x < vec.x + cc.math.EPSILON && this.x > vec.x - cc.math.EPSILON && this.y < vec.y + cc.math.EPSILON && this.y > vec.y - cc.math.EPSILON;
                };
            }(cc);
            !function(cc) {
                cc.kmVec3 = cc.math.Vec3 = function(x, y, z) {
                    if (x && void 0 === y) {
                        this.x = x.x;
                        this.y = x.y;
                        this.z = x.z;
                    } else {
                        this.x = x || 0;
                        this.y = y || 0;
                        this.z = z || 0;
                    }
                };
                cc.math.vec3 = function(x, y, z) {
                    return new cc.math.Vec3(x, y, z);
                };
                var proto = cc.math.Vec3.prototype;
                proto.fill = function(x, y, z) {
                    if (x && void 0 === y) {
                        this.x = x.x;
                        this.y = x.y;
                        this.z = x.z;
                    } else {
                        this.x = x;
                        this.y = y;
                        this.z = z;
                    }
                    return this;
                };
                proto.length = function() {
                    return Math.sqrt(cc.math.square(this.x) + cc.math.square(this.y) + cc.math.square(this.z));
                };
                proto.lengthSq = function() {
                    return cc.math.square(this.x) + cc.math.square(this.y) + cc.math.square(this.z);
                };
                proto.normalize = function() {
                    var l = 1 / this.length();
                    this.x *= l;
                    this.y *= l;
                    this.z *= l;
                    return this;
                };
                proto.cross = function(vec3) {
                    var x = this.x, y = this.y, z = this.z;
                    this.x = y * vec3.z - z * vec3.y;
                    this.y = z * vec3.x - x * vec3.z;
                    this.z = x * vec3.y - y * vec3.x;
                    return this;
                };
                proto.dot = function(vec) {
                    return this.x * vec.x + this.y * vec.y + this.z * vec.z;
                };
                proto.add = function(vec) {
                    this.x += vec.x;
                    this.y += vec.y;
                    this.z += vec.z;
                    return this;
                };
                proto.subtract = function(vec) {
                    this.x -= vec.x;
                    this.y -= vec.y;
                    this.z -= vec.z;
                    return this;
                };
                proto.transform = function(mat4) {
                    var x = this.x, y = this.y, z = this.z, mat = mat4.mat;
                    this.x = x * mat[0] + y * mat[4] + z * mat[8] + mat[12];
                    this.y = x * mat[1] + y * mat[5] + z * mat[9] + mat[13];
                    this.z = x * mat[2] + y * mat[6] + z * mat[10] + mat[14];
                    return this;
                };
                proto.transformNormal = function(mat4) {
                    var x = this.x, y = this.y, z = this.z, mat = mat4.mat;
                    this.x = x * mat[0] + y * mat[4] + z * mat[8];
                    this.y = x * mat[1] + y * mat[5] + z * mat[9];
                    this.z = x * mat[2] + y * mat[6] + z * mat[10];
                    return this;
                };
                proto.transformCoord = function(mat4) {
                    var v = new cc.math.Vec4(this.x, this.y, this.z, 1);
                    v.transform(mat4);
                    this.x = v.x / v.w;
                    this.y = v.y / v.w;
                    this.z = v.z / v.w;
                    return this;
                };
                proto.scale = function(scale) {
                    this.x *= scale;
                    this.y *= scale;
                    this.z *= scale;
                    return this;
                };
                proto.equals = function(vec) {
                    var EPSILON = cc.math.EPSILON;
                    return this.x < vec.x + EPSILON && this.x > vec.x - EPSILON && this.y < vec.y + EPSILON && this.y > vec.y - EPSILON && this.z < vec.z + EPSILON && this.z > vec.z - EPSILON;
                };
                proto.inverseTransform = function(mat4) {
                    var mat = mat4.mat;
                    var v1 = new cc.math.Vec3(this.x - mat[12], this.y - mat[13], this.z - mat[14]);
                    this.x = v1.x * mat[0] + v1.y * mat[1] + v1.z * mat[2];
                    this.y = v1.x * mat[4] + v1.y * mat[5] + v1.z * mat[6];
                    this.z = v1.x * mat[8] + v1.y * mat[9] + v1.z * mat[10];
                    return this;
                };
                proto.inverseTransformNormal = function(mat4) {
                    var x = this.x, y = this.y, z = this.z, mat = mat4.mat;
                    this.x = x * mat[0] + y * mat[1] + z * mat[2];
                    this.y = x * mat[4] + y * mat[5] + z * mat[6];
                    this.z = x * mat[8] + y * mat[9] + z * mat[10];
                    return this;
                };
                proto.assignFrom = function(vec) {
                    if (!vec) {
                        return this;
                    }
                    this.x = vec.x;
                    this.y = vec.y;
                    this.z = vec.z;
                    return this;
                };
                cc.math.Vec3.zero = function(vec) {
                    vec.x = vec.y = vec.z = 0;
                    return vec;
                };
                proto.toTypeArray = function() {
                    var tyArr = new Float32Array(3);
                    tyArr[0] = this.x;
                    tyArr[1] = this.y;
                    tyArr[2] = this.z;
                    return tyArr;
                };
            }(cc);
            !function(cc) {
                cc.math.Vec4 = function(x, y, z, w) {
                    if (x && void 0 === y) {
                        this.x = x.x;
                        this.y = x.y;
                        this.z = x.z;
                        this.w = x.w;
                    } else {
                        this.x = x || 0;
                        this.y = y || 0;
                        this.z = z || 0;
                        this.w = w || 0;
                    }
                };
                cc.kmVec4 = cc.math.Vec4;
                var proto = cc.math.Vec4.prototype;
                proto.fill = function(x, y, z, w) {
                    if (x && void 0 === y) {
                        this.x = x.x;
                        this.y = x.y;
                        this.z = x.z;
                        this.w = x.w;
                    } else {
                        this.x = x;
                        this.y = y;
                        this.z = z;
                        this.w = w;
                    }
                };
                proto.add = function(vec) {
                    if (!vec) {
                        return this;
                    }
                    this.x += vec.x;
                    this.y += vec.y;
                    this.z += vec.z;
                    this.w += vec.w;
                    return this;
                };
                proto.dot = function(vec) {
                    return this.x * vec.x + this.y * vec.y + this.z * vec.z + this.w * vec.w;
                };
                proto.length = function() {
                    return Math.sqrt(cc.math.square(this.x) + cc.math.square(this.y) + cc.math.square(this.z) + cc.math.square(this.w));
                };
                proto.lengthSq = function() {
                    return cc.math.square(this.x) + cc.math.square(this.y) + cc.math.square(this.z) + cc.math.square(this.w);
                };
                proto.lerp = function(vec, t) {
                    return this;
                };
                proto.normalize = function() {
                    var l = 1 / this.length();
                    this.x *= l;
                    this.y *= l;
                    this.z *= l;
                    this.w *= l;
                    return this;
                };
                proto.scale = function(scale) {
                    this.normalize();
                    this.x *= scale;
                    this.y *= scale;
                    this.z *= scale;
                    this.w *= scale;
                    return this;
                };
                proto.subtract = function(vec) {
                    this.x -= vec.x;
                    this.y -= vec.y;
                    this.z -= vec.z;
                    this.w -= vec.w;
                };
                proto.transform = function(mat4) {
                    var x = this.x, y = this.y, z = this.z, w = this.w, mat = mat4.mat;
                    this.x = x * mat[0] + y * mat[4] + z * mat[8] + w * mat[12];
                    this.y = x * mat[1] + y * mat[5] + z * mat[9] + w * mat[13];
                    this.z = x * mat[2] + y * mat[6] + z * mat[10] + w * mat[14];
                    this.w = x * mat[3] + y * mat[7] + z * mat[11] + w * mat[15];
                    return this;
                };
                cc.math.Vec4.transformArray = function(vecArray, mat4) {
                    var retArray = [];
                    for (var i = 0; i < vecArray.length; i++) {
                        var selVec = new cc.math.Vec4(vecArray[i]);
                        selVec.transform(mat4);
                        retArray.push(selVec);
                    }
                    return retArray;
                };
                proto.equals = function(vec) {
                    var EPSILON = cc.math.EPSILON;
                    return this.x < vec.x + EPSILON && this.x > vec.x - EPSILON && this.y < vec.y + EPSILON && this.y > vec.y - EPSILON && this.z < vec.z + EPSILON && this.z > vec.z - EPSILON && this.w < vec.w + EPSILON && this.w > vec.w - EPSILON;
                };
                proto.assignFrom = function(vec) {
                    this.x = vec.x;
                    this.y = vec.y;
                    this.z = vec.z;
                    this.w = vec.w;
                    return this;
                };
                proto.toTypeArray = function() {
                    var tyArr = new Float32Array(4);
                    tyArr[0] = this.x;
                    tyArr[1] = this.y;
                    tyArr[2] = this.z;
                    tyArr[3] = this.w;
                    return tyArr;
                };
            }(cc);
            !function(cc) {
                cc.math.Ray2 = function(start, dir) {
                    this.start = start || new cc.math.Vec2();
                    this.dir = dir || new cc.math.Vec2();
                };
                cc.math.Ray2.prototype.fill = function(px, py, vx, vy) {
                    this.start.x = px;
                    this.start.y = py;
                    this.dir.x = vx;
                    this.dir.y = vy;
                };
                cc.math.Ray2.prototype.intersectLineSegment = function(p1, p2, intersection) {
                    var x1 = this.start.x, y1 = this.start.y;
                    var x2 = this.start.x + this.dir.x, y2 = this.start.y + this.dir.y;
                    var x3 = p1.x, y3 = p1.y;
                    var x4 = p2.x, y4 = p2.y;
                    var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
                    var ua, x, y;
                    if (denom > -cc.math.EPSILON && denom < cc.math.EPSILON) {
                        return false;
                    }
                    ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
                    x = x1 + ua * (x2 - x1);
                    y = y1 + ua * (y2 - y1);
                    if (x < Math.min(p1.x, p2.x) - cc.math.EPSILON || x > Math.max(p1.x, p2.x) + cc.math.EPSILON || y < Math.min(p1.y, p2.y) - cc.math.EPSILON || y > Math.max(p1.y, p2.y) + cc.math.EPSILON) {
                        return false;
                    }
                    if (x < Math.min(x1, x2) - cc.math.EPSILON || x > Math.max(x1, x2) + cc.math.EPSILON || y < Math.min(y1, y2) - cc.math.EPSILON || y > Math.max(y1, y2) + cc.math.EPSILON) {
                        return false;
                    }
                    intersection.x = x;
                    intersection.y = y;
                    return true;
                };
                function calculate_line_normal(p1, p2, normalOut) {
                    var tmp = new cc.math.Vec2(p2);
                    tmp.subtract(p1);
                    normalOut.x = -tmp.y;
                    normalOut.y = tmp.x;
                    normalOut.normalize();
                }
                cc.math.Ray2.prototype.intersectTriangle = function(p1, p2, p3, intersection, normal_out) {
                    var intersect = new cc.math.Vec2(), final_intersect = new cc.math.Vec2();
                    var normal = new cc.math.Vec2(), distance = 1e4, intersected = false;
                    var this_distance;
                    if (this.intersectLineSegment(p1, p2, intersect)) {
                        intersected = true;
                        this_distance = intersect.subtract(this.start).length();
                        if (this_distance < distance) {
                            final_intersect.x = intersect.x;
                            final_intersect.y = intersect.y;
                            distance = this_distance;
                            calculate_line_normal(p1, p2, normal);
                        }
                    }
                    if (this.intersectLineSegment(p2, p3, intersect)) {
                        intersected = true;
                        this_distance = intersect.subtract(this.start).length();
                        if (this_distance < distance) {
                            final_intersect.x = intersect.x;
                            final_intersect.y = intersect.y;
                            distance = this_distance;
                            calculate_line_normal(p2, p3, normal);
                        }
                    }
                    if (this.intersectLineSegment(p3, p1, intersect)) {
                        intersected = true;
                        this_distance = intersect.subtract(this.start).length();
                        if (this_distance < distance) {
                            final_intersect.x = intersect.x;
                            final_intersect.y = intersect.y;
                            distance = this_distance;
                            calculate_line_normal(p3, p1, normal);
                        }
                    }
                    if (intersected) {
                        intersection.x = final_intersect.x;
                        intersection.y = final_intersect.y;
                        if (normal_out) {
                            normal_out.x = normal.x;
                            normal_out.y = normal.y;
                        }
                    }
                    return intersected;
                };
            }(cc);
            window.Uint16Array = window.Uint16Array || window.Array;
            window.Float32Array = window.Float32Array || window.Array;
            !function(cc) {
                cc.math.Matrix3 = function(mat3) {
                    if (mat3 && mat3.mat) {
                        this.mat = new Float32Array(mat3.mat);
                    } else {
                        this.mat = new Float32Array(9);
                    }
                };
                cc.kmMat3 = cc.math.Matrix3;
                var proto = cc.math.Matrix3.prototype;
                proto.fill = function(mat3) {
                    var mat = this.mat, matIn = mat3.mat;
                    mat[0] = matIn[0];
                    mat[1] = matIn[1];
                    mat[2] = matIn[2];
                    mat[3] = matIn[3];
                    mat[4] = matIn[4];
                    mat[5] = matIn[5];
                    mat[6] = matIn[6];
                    mat[7] = matIn[7];
                    mat[8] = matIn[8];
                    return this;
                };
                proto.adjugate = function() {
                    var mat = this.mat;
                    var m0 = mat[0], m1 = mat[1], m2 = mat[2], m3 = mat[3], m4 = mat[4], m5 = mat[5], m6 = mat[6], m7 = mat[7], m8 = mat[8];
                    mat[0] = m4 * m8 - m5 * m7;
                    mat[1] = m2 * m7 - m1 * m8;
                    mat[2] = m1 * m5 - m2 * m4;
                    mat[3] = m5 * m6 - m3 * m8;
                    mat[4] = m0 * m8 - m2 * m6;
                    mat[5] = m2 * m3 - m0 * m5;
                    mat[6] = m3 * m7 - m4 * m6;
                    mat[8] = m0 * m4 - m1 * m3;
                    return this;
                };
                proto.identity = function() {
                    var mat = this.mat;
                    mat[1] = mat[2] = mat[3] = mat[5] = mat[6] = mat[7] = 0;
                    mat[0] = mat[4] = mat[8] = 1;
                    return this;
                };
                var tmpMatrix = new cc.math.Matrix3();
                proto.inverse = function(determinate) {
                    if (0 === determinate) {
                        return this;
                    }
                    tmpMatrix.assignFrom(this);
                    var detInv = 1 / determinate;
                    this.adjugate();
                    this.multiplyScalar(detInv);
                    return this;
                };
                proto.isIdentity = function() {
                    var mat = this.mat;
                    return 1 === mat[0] && 0 === mat[1] && 0 === mat[2] && 0 === mat[3] && 1 === mat[4] && 0 === mat[5] && 0 === mat[6] && 0 === mat[7] && 1 === mat[8];
                };
                proto.transpose = function() {
                    var mat = this.mat;
                    var m1 = mat[1], m2 = mat[2], m3 = mat[3], m5 = mat[5], m6 = mat[6], m7 = mat[7];
                    mat[1] = m3;
                    mat[2] = m6;
                    mat[3] = m1;
                    mat[5] = m7;
                    mat[6] = m2;
                    mat[7] = m5;
                    return this;
                };
                proto.determinant = function() {
                    var mat = this.mat;
                    var output = mat[0] * mat[4] * mat[8] + mat[1] * mat[5] * mat[6] + mat[2] * mat[3] * mat[7];
                    output -= mat[2] * mat[4] * mat[6] + mat[0] * mat[5] * mat[7] + mat[1] * mat[3] * mat[8];
                    return output;
                };
                proto.multiply = function(mat3) {
                    var m1 = this.mat, m2 = mat3.mat;
                    var a0 = m1[0], a1 = m1[1], a2 = m1[2], a3 = m1[3], a4 = m1[4], a5 = m1[5], a6 = m1[6], a7 = m1[7], a8 = m1[8];
                    var b0 = m2[0], b1 = m2[1], b2 = m2[2], b3 = m2[3], b4 = m2[4], b5 = m2[5], b6 = m2[6], b7 = m2[7], b8 = m2[8];
                    m1[0] = a0 * b0 + a3 * b1 + a6 * b2;
                    m1[1] = a1 * b0 + a4 * b1 + a7 * b2;
                    m1[2] = a2 * b0 + a5 * b1 + a8 * b2;
                    m1[3] = a2 * b0 + a5 * b1 + a8 * b2;
                    m1[4] = a1 * b3 + a4 * b4 + a7 * b5;
                    m1[5] = a2 * b3 + a5 * b4 + a8 * b5;
                    m1[6] = a0 * b6 + a3 * b7 + a6 * b8;
                    m1[7] = a1 * b6 + a4 * b7 + a7 * b8;
                    m1[8] = a2 * b6 + a5 * b7 + a8 * b8;
                    return this;
                };
                proto.multiplyScalar = function(factor) {
                    var mat = this.mat;
                    mat[0] *= factor;
                    mat[1] *= factor;
                    mat[2] *= factor;
                    mat[3] *= factor;
                    mat[4] *= factor;
                    mat[5] *= factor;
                    mat[6] *= factor;
                    mat[7] *= factor;
                    mat[8] *= factor;
                    return this;
                };
                cc.math.Matrix3.rotationAxisAngle = function(axis, radians) {
                    var rcos = Math.cos(radians), rsin = Math.sin(radians);
                    var retMat = new cc.math.Matrix3();
                    var mat = retMat.mat;
                    mat[0] = rcos + axis.x * axis.x * (1 - rcos);
                    mat[1] = axis.z * rsin + axis.y * axis.x * (1 - rcos);
                    mat[2] = -axis.y * rsin + axis.z * axis.x * (1 - rcos);
                    mat[3] = -axis.z * rsin + axis.x * axis.y * (1 - rcos);
                    mat[4] = rcos + axis.y * axis.y * (1 - rcos);
                    mat[5] = axis.x * rsin + axis.z * axis.y * (1 - rcos);
                    mat[6] = axis.y * rsin + axis.x * axis.z * (1 - rcos);
                    mat[7] = -axis.x * rsin + axis.y * axis.z * (1 - rcos);
                    mat[8] = rcos + axis.z * axis.z * (1 - rcos);
                    return retMat;
                };
                proto.assignFrom = function(matIn) {
                    if (this === matIn) {
                        cc.log("cc.math.Matrix3.assign(): current matrix equals matIn");
                        return this;
                    }
                    var mat = this.mat, m2 = matIn.mat;
                    mat[0] = m2[0];
                    mat[1] = m2[1];
                    mat[2] = m2[2];
                    mat[3] = m2[3];
                    mat[4] = m2[4];
                    mat[5] = m2[5];
                    mat[6] = m2[6];
                    mat[7] = m2[7];
                    mat[8] = m2[8];
                    return this;
                };
                proto.equals = function(mat3) {
                    if (this === mat3) {
                        return true;
                    }
                    var EPSILON = cc.math.EPSILON, m1 = this.mat, m2 = mat3.mat;
                    for (var i = 0; i < 9; ++i) {
                        if (!(m1[i] + EPSILON > m2[i] && m1[i] - EPSILON < m2[i])) {
                            return false;
                        }
                    }
                    return true;
                };
                cc.math.Matrix3.createByRotationX = function(radians) {
                    var retMat = new cc.math.Matrix3(), mat = retMat.mat;
                    mat[0] = 1;
                    mat[1] = 0;
                    mat[2] = 0;
                    mat[3] = 0;
                    mat[4] = Math.cos(radians);
                    mat[5] = Math.sin(radians);
                    mat[6] = 0;
                    mat[7] = -Math.sin(radians);
                    mat[8] = Math.cos(radians);
                    return retMat;
                };
                cc.math.Matrix3.createByRotationY = function(radians) {
                    var retMat = new cc.math.Matrix3(), mat = retMat.mat;
                    mat[0] = Math.cos(radians);
                    mat[1] = 0;
                    mat[2] = -Math.sin(radians);
                    mat[3] = 0;
                    mat[4] = 1;
                    mat[5] = 0;
                    mat[6] = Math.sin(radians);
                    mat[7] = 0;
                    mat[8] = Math.cos(radians);
                    return retMat;
                };
                cc.math.Matrix3.createByRotationZ = function(radians) {
                    var retMat = new cc.math.Matrix3(), mat = retMat.mat;
                    mat[0] = Math.cos(radians);
                    mat[1] = -Math.sin(radians);
                    mat[2] = 0;
                    mat[3] = Math.sin(radians);
                    mat[4] = Math.cos(radians);
                    mat[5] = 0;
                    mat[6] = 0;
                    mat[7] = 0;
                    mat[8] = 1;
                    return retMat;
                };
                cc.math.Matrix3.createByRotation = function(radians) {
                    var retMat = new cc.math.Matrix3(), mat = retMat.mat;
                    mat[0] = Math.cos(radians);
                    mat[1] = Math.sin(radians);
                    mat[2] = 0;
                    mat[3] = -Math.sin(radians);
                    mat[4] = Math.cos(radians);
                    mat[5] = 0;
                    mat[6] = 0;
                    mat[7] = 0;
                    mat[8] = 1;
                    return retMat;
                };
                cc.math.Matrix3.createByScale = function(x, y) {
                    var ret = new cc.math.Matrix3();
                    ret.identity();
                    ret.mat[0] = x;
                    ret.mat[4] = y;
                    return ret;
                };
                cc.math.Matrix3.createByTranslation = function(x, y) {
                    var ret = new cc.math.Matrix3();
                    ret.identity();
                    ret.mat[6] = x;
                    ret.mat[7] = y;
                    return ret;
                };
                cc.math.Matrix3.createByQuaternion = function(quaternion) {
                    if (!quaternion) {
                        return null;
                    }
                    var ret = new cc.math.Matrix3(), mat = ret.mat;
                    mat[0] = 1 - 2 * (quaternion.y * quaternion.y + quaternion.z * quaternion.z);
                    mat[1] = 2 * (quaternion.x * quaternion.y - quaternion.w * quaternion.z);
                    mat[2] = 2 * (quaternion.x * quaternion.z + quaternion.w * quaternion.y);
                    mat[3] = 2 * (quaternion.x * quaternion.y + quaternion.w * quaternion.z);
                    mat[4] = 1 - 2 * (quaternion.x * quaternion.x + quaternion.z * quaternion.z);
                    mat[5] = 2 * (quaternion.y * quaternion.z - quaternion.w * quaternion.x);
                    mat[6] = 2 * (quaternion.x * quaternion.z - quaternion.w * quaternion.y);
                    mat[7] = 2 * (quaternion.y * quaternion.z + quaternion.w * quaternion.x);
                    mat[8] = 1 - 2 * (quaternion.x * quaternion.x + quaternion.y * quaternion.y);
                    return ret;
                };
                proto.rotationToAxisAngle = function() {
                    return cc.math.Quaternion.rotationMatrix(this).toAxisAndAngle();
                };
            }(cc);
            !function(cc) {
                cc.math.Matrix4 = function(mat4) {
                    if (mat4 && mat4.mat) {
                        this.mat = new Float32Array(mat4.mat);
                    } else {
                        this.mat = new Float32Array(16);
                    }
                };
                cc.kmMat4 = cc.math.Matrix4;
                var proto = cc.math.Matrix4.prototype;
                proto.fill = function(scalarArr) {
                    var mat = this.mat;
                    for (var i = 0; i < 16; i++) {
                        mat[i] = scalarArr[i];
                    }
                    return this;
                };
                cc.kmMat4Identity = function(pOut) {
                    var mat = pOut.mat;
                    mat[1] = mat[2] = mat[3] = mat[4] = mat[6] = mat[7] = mat[8] = mat[9] = mat[11] = mat[12] = mat[13] = mat[14] = 0;
                    mat[0] = mat[5] = mat[10] = mat[15] = 1;
                    return pOut;
                };
                proto.identity = function() {
                    var mat = this.mat;
                    mat[1] = mat[2] = mat[3] = mat[4] = mat[6] = mat[7] = mat[8] = mat[9] = mat[11] = mat[12] = mat[13] = mat[14] = 0;
                    mat[0] = mat[5] = mat[10] = mat[15] = 1;
                    return this;
                };
                proto.get = function(row, col) {
                    return this.mat[row + 4 * col];
                };
                proto.set = function(row, col, value) {
                    this.mat[row + 4 * col] = value;
                };
                proto.swap = function(r1, c1, r2, c2) {
                    var mat = this.mat, tmp = mat[r1 + 4 * c1];
                    mat[r1 + 4 * c1] = mat[r2 + 4 * c2];
                    mat[r2 + 4 * c2] = tmp;
                };
                cc.math.Matrix4._gaussj = function(a, b) {
                    var i, icol = 0, irow = 0, j, k, l, ll, n = 4, m = 4, selElement;
                    var big, dum, pivinv;
                    var indxc = [ 0, 0, 0, 0 ], indxr = [ 0, 0, 0, 0 ], ipiv = [ 0, 0, 0, 0 ];
                    for (i = 0; i < n; i++) {
                        big = 0;
                        for (j = 0; j < n; j++) {
                            if (1 !== ipiv[j]) {
                                for (k = 0; k < n; k++) {
                                    if (0 === ipiv[k]) {
                                        selElement = Math.abs(a.get(j, k));
                                        if (selElement >= big) {
                                            big = selElement;
                                            irow = j;
                                            icol = k;
                                        }
                                    }
                                }
                            }
                        }
                        ++ipiv[icol];
                        if (irow !== icol) {
                            for (l = 0; l < n; l++) {
                                a.swap(irow, l, icol, l);
                            }
                            for (l = 0; l < m; l++) {
                                b.swap(irow, l, icol, l);
                            }
                        }
                        indxr[i] = irow;
                        indxc[i] = icol;
                        if (0 === a.get(icol, icol)) {
                            return false;
                        }
                        pivinv = 1 / a.get(icol, icol);
                        a.set(icol, icol, 1);
                        for (l = 0; l < n; l++) {
                            a.set(icol, l, a.get(icol, l) * pivinv);
                        }
                        for (l = 0; l < m; l++) {
                            b.set(icol, l, b.get(icol, l) * pivinv);
                        }
                        for (ll = 0; ll < n; ll++) {
                            if (ll !== icol) {
                                dum = a.get(ll, icol);
                                a.set(ll, icol, 0);
                                for (l = 0; l < n; l++) {
                                    a.set(ll, l, a.get(ll, l) - a.get(icol, l) * dum);
                                }
                                for (l = 0; l < m; l++) {
                                    b.set(ll, l, a.get(ll, l) - b.get(icol, l) * dum);
                                }
                            }
                        }
                    }
                    for (l = n - 1; l >= 0; l--) {
                        if (indxr[l] !== indxc[l]) {
                            for (k = 0; k < n; k++) {
                                a.swap(k, indxr[l], k, indxc[l]);
                            }
                        }
                    }
                    return true;
                };
                var identityMatrix = new cc.math.Matrix4().identity();
                cc.kmMat4Inverse = function(pOut, pM) {
                    var inv = new cc.math.Matrix4(pM);
                    var tmp = new cc.math.Matrix4(identityMatrix);
                    if (false === cc.math.Matrix4._gaussj(inv, tmp)) {
                        return null;
                    }
                    pOut.assignFrom(inv);
                    return pOut;
                };
                proto.inverse = function() {
                    var inv = new cc.math.Matrix4(this);
                    var tmp = new cc.math.Matrix4(identityMatrix);
                    if (false === cc.math.Matrix4._gaussj(inv, tmp)) {
                        return null;
                    }
                    return inv;
                };
                proto.isIdentity = function() {
                    var mat = this.mat;
                    return 1 === mat[0] && 0 === mat[1] && 0 === mat[2] && 0 === mat[3] && 0 === mat[4] && 1 === mat[5] && 0 === mat[6] && 0 === mat[7] && 0 === mat[8] && 0 === mat[9] && 1 === mat[10] && 0 === mat[11] && 0 === mat[12] && 0 === mat[13] && 0 === mat[14] && 1 === mat[15];
                };
                proto.transpose = function() {
                    var mat = this.mat;
                    var m1 = mat[1], m2 = mat[2], m3 = mat[3], m4 = mat[4], m6 = mat[6], m7 = mat[7], m8 = mat[8], m9 = mat[9], m11 = mat[11], m12 = mat[12], m13 = mat[13], m14 = mat[14];
                    mat[1] = m4;
                    mat[2] = m8;
                    mat[3] = m12;
                    mat[4] = m1;
                    mat[6] = m9;
                    mat[7] = m13;
                    mat[8] = m2;
                    mat[9] = m6;
                    mat[11] = m14;
                    mat[12] = m3;
                    mat[13] = m7;
                    mat[14] = m11;
                    return this;
                };
                cc.kmMat4Multiply = function(pOut, pM1, pM2) {
                    var outArray = pOut.mat, mat1 = pM1.mat, mat2 = pM2.mat;
                    var a00 = mat1[0], a01 = mat1[1], a02 = mat1[2], a03 = mat1[3];
                    var a10 = mat1[4], a11 = mat1[5], a12 = mat1[6], a13 = mat1[7];
                    var a20 = mat1[8], a21 = mat1[9], a22 = mat1[10], a23 = mat1[11];
                    var a30 = mat1[12], a31 = mat1[13], a32 = mat1[14], a33 = mat1[15];
                    var b00 = mat2[0], b01 = mat2[1], b02 = mat2[2], b03 = mat2[3];
                    var b10 = mat2[4], b11 = mat2[5], b12 = mat2[6], b13 = mat2[7];
                    var b20 = mat2[8], b21 = mat2[9], b22 = mat2[10], b23 = mat2[11];
                    var b30 = mat2[12], b31 = mat2[13], b32 = mat2[14], b33 = mat2[15];
                    outArray[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
                    outArray[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
                    outArray[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
                    outArray[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;
                    outArray[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
                    outArray[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
                    outArray[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
                    outArray[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;
                    outArray[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
                    outArray[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
                    outArray[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
                    outArray[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;
                    outArray[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
                    outArray[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
                    outArray[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
                    outArray[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;
                    return pOut;
                };
                proto.multiply = function(mat4) {
                    var mat = this.mat, mat2 = mat4.mat;
                    var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];
                    var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];
                    var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];
                    var a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];
                    var b00 = mat2[0], b01 = mat2[1], b02 = mat2[2], b03 = mat2[3];
                    var b10 = mat2[4], b11 = mat2[5], b12 = mat2[6], b13 = mat2[7];
                    var b20 = mat2[8], b21 = mat2[9], b22 = mat2[10], b23 = mat2[11];
                    var b30 = mat2[12], b31 = mat2[13], b32 = mat2[14], b33 = mat2[15];
                    mat[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
                    mat[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
                    mat[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
                    mat[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;
                    mat[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
                    mat[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
                    mat[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
                    mat[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;
                    mat[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
                    mat[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
                    mat[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
                    mat[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;
                    mat[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
                    mat[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
                    mat[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
                    mat[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;
                    return this;
                };
                cc.getMat4MultiplyValue = function(pM1, pM2) {
                    var m1 = pM1.mat, m2 = pM2.mat;
                    var mat = new Float32Array(16);
                    mat[0] = m1[0] * m2[0] + m1[4] * m2[1] + m1[8] * m2[2] + m1[12] * m2[3];
                    mat[1] = m1[1] * m2[0] + m1[5] * m2[1] + m1[9] * m2[2] + m1[13] * m2[3];
                    mat[2] = m1[2] * m2[0] + m1[6] * m2[1] + m1[10] * m2[2] + m1[14] * m2[3];
                    mat[3] = m1[3] * m2[0] + m1[7] * m2[1] + m1[11] * m2[2] + m1[15] * m2[3];
                    mat[4] = m1[0] * m2[4] + m1[4] * m2[5] + m1[8] * m2[6] + m1[12] * m2[7];
                    mat[5] = m1[1] * m2[4] + m1[5] * m2[5] + m1[9] * m2[6] + m1[13] * m2[7];
                    mat[6] = m1[2] * m2[4] + m1[6] * m2[5] + m1[10] * m2[6] + m1[14] * m2[7];
                    mat[7] = m1[3] * m2[4] + m1[7] * m2[5] + m1[11] * m2[6] + m1[15] * m2[7];
                    mat[8] = m1[0] * m2[8] + m1[4] * m2[9] + m1[8] * m2[10] + m1[12] * m2[11];
                    mat[9] = m1[1] * m2[8] + m1[5] * m2[9] + m1[9] * m2[10] + m1[13] * m2[11];
                    mat[10] = m1[2] * m2[8] + m1[6] * m2[9] + m1[10] * m2[10] + m1[14] * m2[11];
                    mat[11] = m1[3] * m2[8] + m1[7] * m2[9] + m1[11] * m2[10] + m1[15] * m2[11];
                    mat[12] = m1[0] * m2[12] + m1[4] * m2[13] + m1[8] * m2[14] + m1[12] * m2[15];
                    mat[13] = m1[1] * m2[12] + m1[5] * m2[13] + m1[9] * m2[14] + m1[13] * m2[15];
                    mat[14] = m1[2] * m2[12] + m1[6] * m2[13] + m1[10] * m2[14] + m1[14] * m2[15];
                    mat[15] = m1[3] * m2[12] + m1[7] * m2[13] + m1[11] * m2[14] + m1[15] * m2[15];
                    return mat;
                };
                cc.kmMat4Assign = function(pOut, pIn) {
                    if (pOut === pIn) {
                        cc.log("cc.kmMat4Assign(): pOut equals pIn");
                        return pOut;
                    }
                    var outArr = pOut.mat;
                    var inArr = pIn.mat;
                    outArr[0] = inArr[0];
                    outArr[1] = inArr[1];
                    outArr[2] = inArr[2];
                    outArr[3] = inArr[3];
                    outArr[4] = inArr[4];
                    outArr[5] = inArr[5];
                    outArr[6] = inArr[6];
                    outArr[7] = inArr[7];
                    outArr[8] = inArr[8];
                    outArr[9] = inArr[9];
                    outArr[10] = inArr[10];
                    outArr[11] = inArr[11];
                    outArr[12] = inArr[12];
                    outArr[13] = inArr[13];
                    outArr[14] = inArr[14];
                    outArr[15] = inArr[15];
                    return pOut;
                };
                proto.assignFrom = function(mat4) {
                    if (this === mat4) {
                        cc.log("cc.mat.Matrix4.assignFrom(): mat4 equals current matrix");
                        return this;
                    }
                    var outArr = this.mat, inArr = mat4.mat;
                    outArr[0] = inArr[0];
                    outArr[1] = inArr[1];
                    outArr[2] = inArr[2];
                    outArr[3] = inArr[3];
                    outArr[4] = inArr[4];
                    outArr[5] = inArr[5];
                    outArr[6] = inArr[6];
                    outArr[7] = inArr[7];
                    outArr[8] = inArr[8];
                    outArr[9] = inArr[9];
                    outArr[10] = inArr[10];
                    outArr[11] = inArr[11];
                    outArr[12] = inArr[12];
                    outArr[13] = inArr[13];
                    outArr[14] = inArr[14];
                    outArr[15] = inArr[15];
                    return this;
                };
                proto.equals = function(mat4) {
                    if (this === mat4) {
                        cc.log("cc.kmMat4AreEqual(): pMat1 and pMat2 are same object.");
                        return true;
                    }
                    var matA = this.mat, matB = mat4.mat, EPSILON = cc.math.EPSILON;
                    for (var i = 0; i < 16; i++) {
                        if (!(matA[i] + EPSILON > matB[i] && matA[i] - EPSILON < matB[i])) {
                            return false;
                        }
                    }
                    return true;
                };
                cc.math.Matrix4.createByRotationX = function(radians, matrix) {
                    matrix = matrix || new cc.math.Matrix4();
                    var mat = matrix.mat;
                    mat[0] = 1;
                    mat[3] = mat[2] = mat[1] = 0;
                    mat[4] = 0;
                    mat[5] = Math.cos(radians);
                    mat[6] = Math.sin(radians);
                    mat[7] = 0;
                    mat[8] = 0;
                    mat[9] = -Math.sin(radians);
                    mat[10] = Math.cos(radians);
                    mat[11] = 0;
                    mat[14] = mat[13] = mat[12] = 0;
                    mat[15] = 1;
                    return matrix;
                };
                cc.math.Matrix4.createByRotationY = function(radians, matrix) {
                    matrix = matrix || new cc.math.Matrix4();
                    var mat = matrix.mat;
                    mat[0] = Math.cos(radians);
                    mat[1] = 0;
                    mat[2] = -Math.sin(radians);
                    mat[3] = 0;
                    mat[7] = mat[6] = mat[4] = 0;
                    mat[5] = 1;
                    mat[8] = Math.sin(radians);
                    mat[9] = 0;
                    mat[10] = Math.cos(radians);
                    mat[11] = 0;
                    mat[14] = mat[13] = mat[12] = 0;
                    mat[15] = 1;
                    return matrix;
                };
                cc.math.Matrix4.createByRotationZ = function(radians, matrix) {
                    matrix = matrix || new cc.math.Matrix4();
                    var mat = matrix.mat;
                    mat[0] = Math.cos(radians);
                    mat[1] = Math.sin(radians);
                    mat[3] = mat[2] = 0;
                    mat[4] = -Math.sin(radians);
                    mat[5] = Math.cos(radians);
                    mat[7] = mat[6] = 0;
                    mat[11] = mat[9] = mat[8] = 0;
                    mat[10] = 1;
                    mat[14] = mat[13] = mat[12] = 0;
                    mat[15] = 1;
                    return matrix;
                };
                cc.math.Matrix4.createByPitchYawRoll = function(pitch, yaw, roll, matrix) {
                    matrix = matrix || new cc.math.Matrix4();
                    var cr = Math.cos(pitch), sr = Math.sin(pitch);
                    var cp = Math.cos(yaw), sp = Math.sin(yaw);
                    var cy = Math.cos(roll), sy = Math.sin(roll);
                    var srsp = sr * sp, crsp = cr * sp;
                    var mat = matrix.mat;
                    mat[0] = cp * cy;
                    mat[4] = cp * sy;
                    mat[8] = -sp;
                    mat[1] = srsp * cy - cr * sy;
                    mat[5] = srsp * sy + cr * cy;
                    mat[9] = sr * cp;
                    mat[2] = crsp * cy + sr * sy;
                    mat[6] = crsp * sy - sr * cy;
                    mat[10] = cr * cp;
                    mat[3] = mat[7] = mat[11] = 0;
                    mat[15] = 1;
                    return matrix;
                };
                cc.math.Matrix4.createByQuaternion = function(quaternion, matrix) {
                    matrix = matrix || new cc.math.Matrix4();
                    var mat = matrix.mat;
                    mat[0] = 1 - 2 * (quaternion.y * quaternion.y + quaternion.z * quaternion.z);
                    mat[1] = 2 * (quaternion.x * quaternion.y + quaternion.z * quaternion.w);
                    mat[2] = 2 * (quaternion.x * quaternion.z - quaternion.y * quaternion.w);
                    mat[3] = 0;
                    mat[4] = 2 * (quaternion.x * quaternion.y - quaternion.z * quaternion.w);
                    mat[5] = 1 - 2 * (quaternion.x * quaternion.x + quaternion.z * quaternion.z);
                    mat[6] = 2 * (quaternion.z * quaternion.y + quaternion.x * quaternion.w);
                    mat[7] = 0;
                    mat[8] = 2 * (quaternion.x * quaternion.z + quaternion.y * quaternion.w);
                    mat[9] = 2 * (quaternion.y * quaternion.z - quaternion.x * quaternion.w);
                    mat[10] = 1 - 2 * (quaternion.x * quaternion.x + quaternion.y * quaternion.y);
                    mat[11] = 0;
                    mat[14] = mat[13] = mat[12] = 0;
                    mat[15] = 1;
                    return matrix;
                };
                cc.math.Matrix4.createByRotationTranslation = function(rotation, translation, matrix) {
                    matrix = matrix || new cc.math.Matrix4();
                    var mat = matrix.mat, rMat = rotation.mat;
                    mat[0] = rMat[0];
                    mat[1] = rMat[1];
                    mat[2] = rMat[2];
                    mat[3] = 0;
                    mat[4] = rMat[3];
                    mat[5] = rMat[4];
                    mat[6] = rMat[5];
                    mat[7] = 0;
                    mat[8] = rMat[6];
                    mat[9] = rMat[7];
                    mat[10] = rMat[8];
                    mat[11] = 0;
                    mat[12] = translation.x;
                    mat[13] = translation.y;
                    mat[14] = translation.z;
                    mat[15] = 1;
                    return matrix;
                };
                cc.math.Matrix4.createByScale = function(x, y, z, matrix) {
                    matrix = matrix || new cc.math.Matrix4();
                    var mat = matrix.mat;
                    mat[0] = x;
                    mat[5] = y;
                    mat[10] = z;
                    mat[15] = 1;
                    mat[1] = mat[2] = mat[3] = mat[4] = mat[6] = mat[7] = mat[8] = mat[9] = mat[11] = mat[12] = mat[13] = mat[14] = 0;
                    return matrix;
                };
                cc.kmMat4Translation = function(pOut, x, y, z) {
                    pOut.mat[0] = pOut.mat[5] = pOut.mat[10] = pOut.mat[15] = 1;
                    pOut.mat[1] = pOut.mat[2] = pOut.mat[3] = pOut.mat[4] = pOut.mat[6] = pOut.mat[7] = pOut.mat[8] = pOut.mat[9] = pOut.mat[11] = 0;
                    pOut.mat[12] = x;
                    pOut.mat[13] = y;
                    pOut.mat[14] = z;
                    return pOut;
                };
                cc.math.Matrix4.createByTranslation = function(x, y, z, matrix) {
                    matrix = matrix || new cc.math.Matrix4();
                    matrix.identity();
                    matrix.mat[12] = x;
                    matrix.mat[13] = y;
                    matrix.mat[14] = z;
                    return matrix;
                };
                proto.getUpVec3 = function() {
                    var mat = this.mat;
                    var ret = new cc.math.Vec3(mat[4], mat[5], mat[6]);
                    return ret.normalize();
                };
                proto.getRightVec3 = function() {
                    var mat = this.mat;
                    var ret = new cc.math.Vec3(mat[0], mat[1], mat[2]);
                    return ret.normalize();
                };
                proto.getForwardVec3 = function() {
                    var mat = this.mat;
                    var ret = new cc.math.Vec3(mat[8], mat[9], mat[10]);
                    return ret.normalize();
                };
                cc.kmMat4PerspectiveProjection = function(pOut, fovY, aspect, zNear, zFar) {
                    var r = cc.degreesToRadians(fovY / 2);
                    var deltaZ = zFar - zNear;
                    var s = Math.sin(r);
                    if (0 === deltaZ || 0 === s || 0 === aspect) {
                        return null;
                    }
                    var cotangent = Math.cos(r) / s;
                    pOut.identity();
                    pOut.mat[0] = cotangent / aspect;
                    pOut.mat[5] = cotangent;
                    pOut.mat[10] = -(zFar + zNear) / deltaZ;
                    pOut.mat[11] = -1;
                    pOut.mat[14] = -2 * zNear * zFar / deltaZ;
                    pOut.mat[15] = 0;
                    return pOut;
                };
                cc.math.Matrix4.createPerspectiveProjection = function(fovY, aspect, zNear, zFar) {
                    var r = cc.degreesToRadians(fovY / 2), deltaZ = zFar - zNear;
                    var s = Math.sin(r);
                    if (0 === deltaZ || 0 === s || 0 === aspect) {
                        return null;
                    }
                    var cotangent = Math.cos(r) / s;
                    var matrix = new cc.math.Matrix4(), mat = matrix.mat;
                    matrix.identity();
                    mat[0] = cotangent / aspect;
                    mat[5] = cotangent;
                    mat[10] = -(zFar + zNear) / deltaZ;
                    mat[11] = -1;
                    mat[14] = -2 * zNear * zFar / deltaZ;
                    mat[15] = 0;
                    return matrix;
                };
                cc.kmMat4OrthographicProjection = function(pOut, left, right, bottom, top, nearVal, farVal) {
                    pOut.identity();
                    pOut.mat[0] = 2 / (right - left);
                    pOut.mat[5] = 2 / (top - bottom);
                    pOut.mat[10] = -2 / (farVal - nearVal);
                    pOut.mat[12] = -((right + left) / (right - left));
                    pOut.mat[13] = -((top + bottom) / (top - bottom));
                    pOut.mat[14] = -((farVal + nearVal) / (farVal - nearVal));
                    return pOut;
                };
                cc.math.Matrix4.createOrthographicProjection = function(left, right, bottom, top, nearVal, farVal) {
                    var matrix = new cc.math.Matrix4(), mat = matrix.mat;
                    matrix.identity();
                    mat[0] = 2 / (right - left);
                    mat[5] = 2 / (top - bottom);
                    mat[10] = -2 / (farVal - nearVal);
                    mat[12] = -((right + left) / (right - left));
                    mat[13] = -((top + bottom) / (top - bottom));
                    mat[14] = -((farVal + nearVal) / (farVal - nearVal));
                    return matrix;
                };
                cc.kmMat4LookAt = function(pOut, pEye, pCenter, pUp) {
                    var f = new cc.math.Vec3(pCenter), up = new cc.math.Vec3(pUp);
                    f.subtract(pEye);
                    f.normalize();
                    up.normalize();
                    var s = new cc.math.Vec3(f);
                    s.cross(up);
                    s.normalize();
                    var u = new cc.math.Vec3(s);
                    u.cross(f);
                    s.normalize();
                    pOut.identity();
                    pOut.mat[0] = s.x;
                    pOut.mat[4] = s.y;
                    pOut.mat[8] = s.z;
                    pOut.mat[1] = u.x;
                    pOut.mat[5] = u.y;
                    pOut.mat[9] = u.z;
                    pOut.mat[2] = -f.x;
                    pOut.mat[6] = -f.y;
                    pOut.mat[10] = -f.z;
                    var translate = cc.math.Matrix4.createByTranslation(-pEye.x, -pEye.y, -pEye.z);
                    pOut.multiply(translate);
                    return pOut;
                };
                var tempMatrix = new cc.math.Matrix4();
                proto.lookAt = function(eyeVec, centerVec, upVec) {
                    var f = new cc.math.Vec3(centerVec), up = new cc.math.Vec3(upVec), mat = this.mat;
                    f.subtract(eyeVec);
                    f.normalize();
                    up.normalize();
                    var s = new cc.math.Vec3(f);
                    s.cross(up);
                    s.normalize();
                    var u = new cc.math.Vec3(s);
                    u.cross(f);
                    s.normalize();
                    this.identity();
                    mat[0] = s.x;
                    mat[4] = s.y;
                    mat[8] = s.z;
                    mat[1] = u.x;
                    mat[5] = u.y;
                    mat[9] = u.z;
                    mat[2] = -f.x;
                    mat[6] = -f.y;
                    mat[10] = -f.z;
                    tempMatrix = cc.math.Matrix4.createByTranslation(-eyeVec.x, -eyeVec.y, -eyeVec.z, tempMatrix);
                    this.multiply(tempMatrix);
                    return this;
                };
                cc.kmMat4RotationAxisAngle = function(pOut, axis, radians) {
                    var rcos = Math.cos(radians), rsin = Math.sin(radians);
                    var normalizedAxis = new cc.math.Vec3(axis);
                    normalizedAxis.normalize();
                    pOut.mat[0] = rcos + normalizedAxis.x * normalizedAxis.x * (1 - rcos);
                    pOut.mat[1] = normalizedAxis.z * rsin + normalizedAxis.y * normalizedAxis.x * (1 - rcos);
                    pOut.mat[2] = -normalizedAxis.y * rsin + normalizedAxis.z * normalizedAxis.x * (1 - rcos);
                    pOut.mat[3] = 0;
                    pOut.mat[4] = -normalizedAxis.z * rsin + normalizedAxis.x * normalizedAxis.y * (1 - rcos);
                    pOut.mat[5] = rcos + normalizedAxis.y * normalizedAxis.y * (1 - rcos);
                    pOut.mat[6] = normalizedAxis.x * rsin + normalizedAxis.z * normalizedAxis.y * (1 - rcos);
                    pOut.mat[7] = 0;
                    pOut.mat[8] = normalizedAxis.y * rsin + normalizedAxis.x * normalizedAxis.z * (1 - rcos);
                    pOut.mat[9] = -normalizedAxis.x * rsin + normalizedAxis.y * normalizedAxis.z * (1 - rcos);
                    pOut.mat[10] = rcos + normalizedAxis.z * normalizedAxis.z * (1 - rcos);
                    pOut.mat[11] = 0;
                    pOut.mat[12] = 0;
                    pOut.mat[13] = 0;
                    pOut.mat[14] = 0;
                    pOut.mat[15] = 1;
                    return pOut;
                };
                cc.math.Matrix4.createByAxisAndAngle = function(axis, radians, matrix) {
                    matrix = matrix || new cc.math.Matrix4();
                    var mat = this.mat, rcos = Math.cos(radians), rsin = Math.sin(radians);
                    var normalizedAxis = new cc.math.Vec3(axis);
                    normalizedAxis.normalize();
                    mat[0] = rcos + normalizedAxis.x * normalizedAxis.x * (1 - rcos);
                    mat[1] = normalizedAxis.z * rsin + normalizedAxis.y * normalizedAxis.x * (1 - rcos);
                    mat[2] = -normalizedAxis.y * rsin + normalizedAxis.z * normalizedAxis.x * (1 - rcos);
                    mat[3] = 0;
                    mat[4] = -normalizedAxis.z * rsin + normalizedAxis.x * normalizedAxis.y * (1 - rcos);
                    mat[5] = rcos + normalizedAxis.y * normalizedAxis.y * (1 - rcos);
                    mat[6] = normalizedAxis.x * rsin + normalizedAxis.z * normalizedAxis.y * (1 - rcos);
                    mat[7] = 0;
                    mat[8] = normalizedAxis.y * rsin + normalizedAxis.x * normalizedAxis.z * (1 - rcos);
                    mat[9] = -normalizedAxis.x * rsin + normalizedAxis.y * normalizedAxis.z * (1 - rcos);
                    mat[10] = rcos + normalizedAxis.z * normalizedAxis.z * (1 - rcos);
                    mat[11] = 0;
                    mat[12] = mat[13] = mat[14] = 0;
                    mat[15] = 1;
                    return matrix;
                };
                proto.extractRotation = function() {
                    var matrix = new cc.math.Matrix3(), mat4 = this.mat, mat3 = matrix.mat;
                    mat3[0] = mat4[0];
                    mat3[1] = mat4[1];
                    mat3[2] = mat4[2];
                    mat3[3] = mat4[4];
                    mat3[4] = mat4[5];
                    mat3[5] = mat4[6];
                    mat3[6] = mat4[8];
                    mat3[7] = mat4[9];
                    mat3[8] = mat4[10];
                    return matrix;
                };
                proto.extractPlane = function(planeType) {
                    var plane = new cc.math.Plane(), mat = this.mat;
                    switch (planeType) {
                      case cc.math.Plane.RIGHT:
                        plane.a = mat[3] - mat[0];
                        plane.b = mat[7] - mat[4];
                        plane.c = mat[11] - mat[8];
                        plane.d = mat[15] - mat[12];
                        break;

                      case cc.math.Plane.LEFT:
                        plane.a = mat[3] + mat[0];
                        plane.b = mat[7] + mat[4];
                        plane.c = mat[11] + mat[8];
                        plane.d = mat[15] + mat[12];
                        break;

                      case cc.math.Plane.BOTTOM:
                        plane.a = mat[3] + mat[1];
                        plane.b = mat[7] + mat[5];
                        plane.c = mat[11] + mat[9];
                        plane.d = mat[15] + mat[13];
                        break;

                      case cc.math.Plane.TOP:
                        plane.a = mat[3] - mat[1];
                        plane.b = mat[7] - mat[5];
                        plane.c = mat[11] - mat[9];
                        plane.d = mat[15] - mat[13];
                        break;

                      case cc.math.Plane.FAR:
                        plane.a = mat[3] - mat[2];
                        plane.b = mat[7] - mat[6];
                        plane.c = mat[11] - mat[10];
                        plane.d = mat[15] - mat[14];
                        break;

                      case cc.math.Plane.NEAR:
                        plane.a = mat[3] + mat[2];
                        plane.b = mat[7] + mat[6];
                        plane.c = mat[11] + mat[10];
                        plane.d = mat[15] + mat[14];
                        break;

                      default:
                        cc.log("cc.math.Matrix4.extractPlane: Invalid plane index");
                    }
                    var t = Math.sqrt(plane.a * plane.a + plane.b * plane.b + plane.c * plane.c);
                    plane.a /= t;
                    plane.b /= t;
                    plane.c /= t;
                    plane.d /= t;
                    return plane;
                };
                proto.toAxisAndAngle = function() {
                    var rotation = this.extractRotation();
                    var temp = cc.math.Quaternion.rotationMatrix(rotation);
                    return temp.toAxisAndAngle();
                };
            }(cc);
            !function(cc) {
                cc.math.Plane = function(a, b, c, d) {
                    if (a && void 0 === b) {
                        this.a = a.a;
                        this.b = a.b;
                        this.c = a.c;
                        this.d = a.d;
                    } else {
                        this.a = a || 0;
                        this.b = b || 0;
                        this.c = c || 0;
                        this.d = d || 0;
                    }
                };
                cc.kmPlane = cc.math.Plane;
                var proto = cc.math.Plane.prototype;
                cc.math.Plane.LEFT = 0;
                cc.math.Plane.RIGHT = 1;
                cc.math.Plane.BOTTOM = 2;
                cc.math.Plane.TOP = 3;
                cc.math.Plane.NEAR = 4;
                cc.math.Plane.FAR = 5;
                cc.math.Plane.POINT_INFRONT_OF_PLANE = 0;
                cc.math.Plane.POINT_BEHIND_PLANE = 1;
                cc.math.Plane.POINT_ON_PLANE = 2;
                proto.dot = function(vec4) {
                    return this.a * vec4.x + this.b * vec4.y + this.c * vec4.z + this.d * vec4.w;
                };
                proto.dotCoord = function(vec3) {
                    return this.a * vec3.x + this.b * vec3.y + this.c * vec3.z + this.d;
                };
                proto.dotNormal = function(vec3) {
                    return this.a * vec3.x + this.b * vec3.y + this.c * vec3.z;
                };
                cc.math.Plane.fromPointNormal = function(vec3, normal) {
                    return new cc.math.Plane(normal.x, normal.y, normal.z, -normal.dot(vec3));
                };
                cc.math.Plane.fromPoints = function(vec1, vec2, vec3) {
                    var v1 = new cc.math.Vec3(vec2), v2 = new cc.math.Vec3(vec3), plane = new cc.math.Plane();
                    v1.subtract(vec1);
                    v2.subtract(vec1);
                    v1.cross(v2);
                    v1.normalize();
                    plane.a = v1.x;
                    plane.b = v1.y;
                    plane.c = v1.z;
                    plane.d = v1.scale(-1).dot(vec1);
                    return plane;
                };
                proto.normalize = function() {
                    var n = new cc.math.Vec3(this.a, this.b, this.c), l = 1 / n.length();
                    n.normalize();
                    this.a = n.x;
                    this.b = n.y;
                    this.c = n.z;
                    this.d = this.d * l;
                    return this;
                };
                proto.classifyPoint = function(vec3) {
                    var distance = this.a * vec3.x + this.b * vec3.y + this.c * vec3.z + this.d;
                    if (distance > .001) {
                        return cc.math.Plane.POINT_INFRONT_OF_PLANE;
                    }
                    if (distance < -.001) {
                        return cc.math.Plane.POINT_BEHIND_PLANE;
                    }
                    return cc.math.Plane.POINT_ON_PLANE;
                };
            }(cc);
            !function(cc) {
                cc.math.Quaternion = function(x, y, z, w) {
                    if (x && void 0 === y) {
                        this.x = x.x;
                        this.y = x.y;
                        this.z = x.z;
                        this.w = x.w;
                    } else {
                        this.x = x || 0;
                        this.y = y || 0;
                        this.z = z || 0;
                        this.w = w || 0;
                    }
                };
                cc.kmQuaternion = cc.math.Quaternion;
                var proto = cc.math.Quaternion.prototype;
                proto.conjugate = function(quaternion) {
                    this.x = -quaternion.x;
                    this.y = -quaternion.y;
                    this.z = -quaternion.z;
                    this.w = quaternion.w;
                    return this;
                };
                proto.dot = function(quaternion) {
                    return this.w * quaternion.w + this.x * quaternion.x + this.y * quaternion.y + this.z * quaternion.z;
                };
                proto.exponential = function() {
                    return this;
                };
                proto.identity = function() {
                    this.x = 0;
                    this.y = 0;
                    this.z = 0;
                    this.w = 1;
                    return this;
                };
                proto.inverse = function() {
                    var len = this.length();
                    if (Math.abs(len) > cc.math.EPSILON) {
                        this.x = 0;
                        this.y = 0;
                        this.z = 0;
                        this.w = 0;
                        return this;
                    }
                    this.conjugate(this).scale(1 / len);
                    return this;
                };
                proto.isIdentity = function() {
                    return 0 === this.x && 0 === this.y && 0 === this.z && 1 === this.w;
                };
                proto.length = function() {
                    return Math.sqrt(this.lengthSq());
                };
                proto.lengthSq = function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
                };
                proto.multiply = function(quaternion) {
                    var x = this.x, y = this.y, z = this.z, w = this.w;
                    this.w = w * quaternion.w - x * quaternion.x - y * quaternion.y - z * quaternion.z;
                    this.x = w * quaternion.x + x * quaternion.w + y * quaternion.z - z * quaternion.y;
                    this.y = w * quaternion.y + y * quaternion.w + z * quaternion.x - x * quaternion.z;
                    this.z = w * quaternion.z + z * quaternion.w + x * quaternion.y - y * quaternion.x;
                    return this;
                };
                proto.normalize = function() {
                    var length = this.length();
                    if (Math.abs(length) <= cc.math.EPSILON) {
                        throw new Error("current quaternion is an invalid value");
                    }
                    this.scale(1 / length);
                    return this;
                };
                proto.rotationAxis = function(axis, angle) {
                    var rad = .5 * angle, scale = Math.sin(rad);
                    this.w = Math.cos(rad);
                    this.x = axis.x * scale;
                    this.y = axis.y * scale;
                    this.z = axis.z * scale;
                    return this;
                };
                cc.math.Quaternion.rotationMatrix = function(mat3) {
                    if (!mat3) {
                        return null;
                    }
                    var x, y, z, w;
                    var m4x4 = [], mat = mat3.mat, scale = 0;
                    m4x4[0] = mat[0];
                    m4x4[1] = mat[3];
                    m4x4[2] = mat[6];
                    m4x4[4] = mat[1];
                    m4x4[5] = mat[4];
                    m4x4[6] = mat[7];
                    m4x4[8] = mat[2];
                    m4x4[9] = mat[5];
                    m4x4[10] = mat[8];
                    m4x4[15] = 1;
                    var pMatrix = m4x4[0];
                    var diagonal = pMatrix[0] + pMatrix[5] + pMatrix[10] + 1;
                    if (diagonal > cc.math.EPSILON) {
                        scale = 2 * Math.sqrt(diagonal);
                        x = (pMatrix[9] - pMatrix[6]) / scale;
                        y = (pMatrix[2] - pMatrix[8]) / scale;
                        z = (pMatrix[4] - pMatrix[1]) / scale;
                        w = .25 * scale;
                    } else {
                        if (pMatrix[0] > pMatrix[5] && pMatrix[0] > pMatrix[10]) {
                            scale = 2 * Math.sqrt(1 + pMatrix[0] - pMatrix[5] - pMatrix[10]);
                            x = .25 * scale;
                            y = (pMatrix[4] + pMatrix[1]) / scale;
                            z = (pMatrix[2] + pMatrix[8]) / scale;
                            w = (pMatrix[9] - pMatrix[6]) / scale;
                        } else {
                            if (pMatrix[5] > pMatrix[10]) {
                                scale = 2 * Math.sqrt(1 + pMatrix[5] - pMatrix[0] - pMatrix[10]);
                                x = (pMatrix[4] + pMatrix[1]) / scale;
                                y = .25 * scale;
                                z = (pMatrix[9] + pMatrix[6]) / scale;
                                w = (pMatrix[2] - pMatrix[8]) / scale;
                            } else {
                                scale = 2 * Math.sqrt(1 + pMatrix[10] - pMatrix[0] - pMatrix[5]);
                                x = (pMatrix[2] + pMatrix[8]) / scale;
                                y = (pMatrix[9] + pMatrix[6]) / scale;
                                z = .25 * scale;
                                w = (pMatrix[4] - pMatrix[1]) / scale;
                            }
                        }
                    }
                    return new cc.math.Quaternion(x, y, z, w);
                };
                cc.math.Quaternion.rotationYawPitchRoll = function(yaw, pitch, roll) {
                    var ex, ey, ez;
                    var cr, cp, cy, sr, sp, sy, cpcy, spsy;
                    ex = cc.degreesToRadians(pitch) / 2;
                    ey = cc.degreesToRadians(yaw) / 2;
                    ez = cc.degreesToRadians(roll) / 2;
                    cr = Math.cos(ex);
                    cp = Math.cos(ey);
                    cy = Math.cos(ez);
                    sr = Math.sin(ex);
                    sp = Math.sin(ey);
                    sy = Math.sin(ez);
                    cpcy = cp * cy;
                    spsy = sp * sy;
                    var ret = new cc.math.Quaternion();
                    ret.w = cr * cpcy + sr * spsy;
                    ret.x = sr * cpcy - cr * spsy;
                    ret.y = cr * sp * cy + sr * cp * sy;
                    ret.z = cr * cp * sy - sr * sp * cy;
                    ret.normalize();
                    return ret;
                };
                proto.slerp = function(quaternion, t) {
                    if (this.x === quaternion.x && this.y === quaternion.y && this.z === quaternion.z && this.w === quaternion.w) {
                        return this;
                    }
                    var ct = this.dot(quaternion), theta = Math.acos(ct), st = Math.sqrt(1 - cc.math.square(ct));
                    var stt = Math.sin(t * theta) / st, somt = Math.sin((1 - t) * theta) / st;
                    var temp2 = new cc.math.Quaternion(quaternion);
                    this.scale(somt);
                    temp2.scale(stt);
                    this.add(temp2);
                    return this;
                };
                proto.toAxisAndAngle = function() {
                    var tempAngle;
                    var scale;
                    var retAngle, retAxis = new cc.math.Vec3();
                    tempAngle = Math.acos(this.w);
                    scale = Math.sqrt(cc.math.square(this.x) + cc.math.square(this.y) + cc.math.square(this.z));
                    if (scale > -cc.math.EPSILON && scale < cc.math.EPSILON || scale < 2 * Math.PI + cc.math.EPSILON && scale > 2 * Math.PI - cc.math.EPSILON) {
                        retAngle = 0;
                        retAxis.x = 0;
                        retAxis.y = 0;
                        retAxis.z = 1;
                    } else {
                        retAngle = 2 * tempAngle;
                        retAxis.x = this.x / scale;
                        retAxis.y = this.y / scale;
                        retAxis.z = this.z / scale;
                        retAxis.normalize();
                    }
                    return {
                        axis: retAxis,
                        angle: retAngle
                    };
                };
                proto.scale = function(scale) {
                    this.x *= scale;
                    this.y *= scale;
                    this.z *= scale;
                    this.w *= scale;
                    return this;
                };
                proto.assignFrom = function(quaternion) {
                    this.x = quaternion.x;
                    this.y = quaternion.y;
                    this.z = quaternion.z;
                    this.w = quaternion.w;
                    return this;
                };
                proto.add = function(quaternion) {
                    this.x += quaternion.x;
                    this.y += quaternion.y;
                    this.z += quaternion.z;
                    this.w += quaternion.w;
                    return this;
                };
                cc.math.Quaternion.rotationBetweenVec3 = function(vec1, vec2, fallback) {
                    var v1 = new cc.math.Vec3(vec1), v2 = new cc.math.Vec3(vec2);
                    v1.normalize();
                    v2.normalize();
                    var a = v1.dot(v2), quaternion = new cc.math.Quaternion();
                    if (a >= 1) {
                        quaternion.identity();
                        return quaternion;
                    }
                    if (a < 1e-6 - 1) {
                        if (Math.abs(fallback.lengthSq()) < cc.math.EPSILON) {
                            quaternion.rotationAxis(fallback, Math.PI);
                        } else {
                            var axis = new cc.math.Vec3(1, 0, 0);
                            axis.cross(vec1);
                            if (Math.abs(axis.lengthSq()) < cc.math.EPSILON) {
                                axis.fill(0, 1, 0);
                                axis.cross(vec1);
                            }
                            axis.normalize();
                            quaternion.rotationAxis(axis, Math.PI);
                        }
                    } else {
                        var s = Math.sqrt(2 * (1 + a)), invs = 1 / s;
                        v1.cross(v2);
                        quaternion.x = v1.x * invs;
                        quaternion.y = v1.y * invs;
                        quaternion.z = v1.z * invs;
                        quaternion.w = .5 * s;
                        quaternion.normalize();
                    }
                    return quaternion;
                };
                proto.multiplyVec3 = function(vec) {
                    var x = this.x, y = this.y, z = this.z, retVec = new cc.math.Vec3(vec);
                    var uv = new cc.math.Vec3(x, y, z), uuv = new cc.math.Vec3(x, y, z);
                    uv.cross(vec);
                    uuv.cross(uv);
                    uv.scale(2 * q.w);
                    uuv.scale(2);
                    retVec.add(uv);
                    retVec.add(uuv);
                    return retVec;
                };
            }(cc);
            cc.math.AABB = function(min, max) {
                this.min = min || new cc.math.Vec3();
                this.max = max || new cc.math.Vec3();
            };
            cc.math.AABB.prototype.containsPoint = function(point) {
                return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;
            };
            cc.math.AABB.containsPoint = function(pPoint, pBox) {
                return pPoint.x >= pBox.min.x && pPoint.x <= pBox.max.x && pPoint.y >= pBox.min.y && pPoint.y <= pBox.max.y && pPoint.z >= pBox.min.z && pPoint.z <= pBox.max.z;
            };
            cc.math.AABB.prototype.assignFrom = function(aabb) {
                this.min.assignFrom(aabb.min);
                this.max.assignFrom(aabb.max);
            };
            cc.math.AABB.assign = function(pOut, pIn) {
                pOut.min.assignFrom(pIn.min);
                pOut.max.assignFrom(pIn.max);
                return pOut;
            };
            !function(cc) {
                cc.math.Matrix4Stack = function(top, stack) {
                    this.top = top;
                    this.stack = stack || [];
                };
                cc.km_mat4_stack = cc.math.Matrix4Stack;
                var proto = cc.math.Matrix4Stack.prototype;
                proto.initialize = function() {
                    this.stack.length = 0;
                    this.top = null;
                };
                cc.km_mat4_stack_push = function(stack, item) {
                    stack.stack.push(stack.top);
                    stack.top = new cc.math.Matrix4(item);
                };
                cc.km_mat4_stack_pop = function(stack, pOut) {
                    stack.top = stack.stack.pop();
                };
                cc.km_mat4_stack_release = function(stack) {
                    stack.stack = null;
                    stack.top = null;
                };
                proto.push = function(item) {
                    item = item || this.top;
                    this.stack.push(this.top);
                    this.top = new cc.math.Matrix4(item);
                };
                proto.pop = function() {
                    this.top = this.stack.pop();
                };
                proto.release = function() {
                    this.stack = null;
                    this.top = null;
                    this._matrixPool = null;
                };
                proto._getFromPool = function(item) {
                    var pool = this._matrixPool;
                    if (0 === pool.length) {
                        return new cc.math.Matrix4(item);
                    }
                    var ret = pool.pop();
                    ret.assignFrom(item);
                    return ret;
                };
                proto._putInPool = function(matrix) {
                    this._matrixPool.push(matrix);
                };
            }(cc);
            !function(cc) {
                cc.KM_GL_MODELVIEW = 5888;
                cc.KM_GL_PROJECTION = 5889;
                cc.KM_GL_TEXTURE = 5890;
                cc.modelview_matrix_stack = new cc.math.Matrix4Stack();
                cc.projection_matrix_stack = new cc.math.Matrix4Stack();
                cc.texture_matrix_stack = new cc.math.Matrix4Stack();
                cc.current_stack = null;
                var initialized = false;
                cc.lazyInitialize = function() {
                    if (!initialized) {
                        var identity = new cc.math.Matrix4();
                        cc.modelview_matrix_stack.initialize();
                        cc.projection_matrix_stack.initialize();
                        cc.texture_matrix_stack.initialize();
                        cc.current_stack = cc.modelview_matrix_stack;
                        cc.initialized = true;
                        identity.identity();
                        cc.modelview_matrix_stack.push(identity);
                        cc.projection_matrix_stack.push(identity);
                        cc.texture_matrix_stack.push(identity);
                    }
                };
                cc.lazyInitialize();
                cc.kmGLFreeAll = function() {
                    cc.modelview_matrix_stack.release();
                    cc.modelview_matrix_stack = null;
                    cc.projection_matrix_stack.release();
                    cc.projection_matrix_stack = null;
                    cc.texture_matrix_stack.release();
                    cc.texture_matrix_stack = null;
                    cc.initialized = false;
                    cc.current_stack = null;
                };
                cc.kmGLPushMatrix = function() {
                    cc.current_stack.push(cc.current_stack.top);
                };
                cc.kmGLPushMatrixWitMat4 = function(saveMat) {
                    cc.current_stack.stack.push(cc.current_stack.top);
                    saveMat.assignFrom(cc.current_stack.top);
                    cc.current_stack.top = saveMat;
                };
                cc.kmGLPopMatrix = function() {
                    cc.current_stack.top = cc.current_stack.stack.pop();
                };
                cc.kmGLMatrixMode = function(mode) {
                    switch (mode) {
                      case cc.KM_GL_MODELVIEW:
                        cc.current_stack = cc.modelview_matrix_stack;
                        break;

                      case cc.KM_GL_PROJECTION:
                        cc.current_stack = cc.projection_matrix_stack;
                        break;

                      case cc.KM_GL_TEXTURE:
                        cc.current_stack = cc.texture_matrix_stack;
                        break;

                      default:
                        throw new Error("Invalid matrix mode specified");
                    }
                };
                cc.kmGLLoadIdentity = function() {
                    cc.current_stack.top.identity();
                };
                cc.kmGLLoadMatrix = function(pIn) {
                    cc.current_stack.top.assignFrom(pIn);
                };
                cc.kmGLMultMatrix = function(pIn) {
                    cc.current_stack.top.multiply(pIn);
                };
                var tempMatrix = new cc.math.Matrix4();
                cc.kmGLTranslatef = function(x, y, z) {
                    var translation = cc.math.Matrix4.createByTranslation(x, y, z, tempMatrix);
                    cc.current_stack.top.multiply(translation);
                };
                var tempVector3 = new cc.math.Vec3();
                cc.kmGLRotatef = function(angle, x, y, z) {
                    tempVector3.fill(x, y, z);
                    var rotation = cc.math.Matrix4.createByAxisAndAngle(tempVector3, cc.degreesToRadians(angle), tempMatrix);
                    cc.current_stack.top.multiply(rotation);
                };
                cc.kmGLScalef = function(x, y, z) {
                    var scaling = cc.math.Matrix4.createByScale(x, y, z, tempMatrix);
                    cc.current_stack.top.multiply(scaling);
                };
                cc.kmGLGetMatrix = function(mode, pOut) {
                    switch (mode) {
                      case cc.KM_GL_MODELVIEW:
                        pOut.assignFrom(cc.modelview_matrix_stack.top);
                        break;

                      case cc.KM_GL_PROJECTION:
                        pOut.assignFrom(cc.projection_matrix_stack.top);
                        break;

                      case cc.KM_GL_TEXTURE:
                        pOut.assignFrom(cc.texture_matrix_stack.top);
                        break;

                      default:
                        throw new Error("Invalid matrix mode specified");
                    }
                };
            }(cc);
            cc.SHADER_POSITION_UCOLOR_FRAG = "precision lowp float;\nvarying vec4 v_fragmentColor;\nvoid main()                              \n{ \n    gl_FragColor = v_fragmentColor;      \n}\n";
            cc.SHADER_POSITION_UCOLOR_VERT = "attribute vec4 a_position;\nuniform    vec4 u_color;\nuniform float u_pointSize;\nvarying lowp vec4 v_fragmentColor; \nvoid main(void)   \n{\n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    gl_PointSize = u_pointSize;          \n    v_fragmentColor = u_color;           \n}";
            cc.SHADER_POSITION_COLOR_FRAG = "precision lowp float; \nvarying vec4 v_fragmentColor; \nvoid main() \n{ \n     gl_FragColor = v_fragmentColor; \n} ";
            cc.SHADER_POSITION_COLOR_VERT = "attribute vec4 a_position;\nattribute vec4 a_color;\nvarying lowp vec4 v_fragmentColor;\nvoid main()\n{\n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor = a_color;             \n}";
            cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG = "// #extension GL_OES_standard_derivatives : enable\nvarying mediump vec4 v_color;\nvarying mediump vec2 v_texcoord;\nvoid main()	\n{ \n// #if defined GL_OES_standard_derivatives	\n// gl_FragColor = v_color*smoothstep(0.0, length(fwidth(v_texcoord)), 1.0 - length(v_texcoord)); \n// #else	\ngl_FragColor = v_color * step(0.0, 1.0 - length(v_texcoord)); \n// #endif \n}";
            cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT = "attribute mediump vec4 a_position; \nattribute mediump vec2 a_texcoord; \nattribute mediump vec4 a_color;	\nvarying mediump vec4 v_color; \nvarying mediump vec2 v_texcoord;	\nvoid main() \n{ \n     v_color = a_color;//vec4(a_color.rgb * a_color.a, a_color.a); \n     v_texcoord = a_texcoord; \n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n}";
            cc.SHADER_POSITION_TEXTURE_FRAG = "precision lowp float;   \nvarying vec2 v_texCoord;  \nvoid main() \n{  \n    gl_FragColor =  texture2D(CC_Texture0, v_texCoord);   \n}";
            cc.SHADER_POSITION_TEXTURE_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_texCoord = a_texCoord;               \n}";
            cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG = "precision lowp float;  \nuniform vec4 u_color; \nvarying vec2 v_texCoord; \nvoid main() \n{  \n    gl_FragColor =  texture2D(CC_Texture0, v_texCoord) * u_color;    \n}";
            cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT = "attribute vec4 a_position;\nattribute vec2 a_texCoord; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_texCoord = a_texCoord;                 \n}";
            cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG = "precision lowp float;  \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nvoid main() \n{ \n    gl_FragColor = vec4( v_fragmentColor.rgb,         \n        v_fragmentColor.a * texture2D(CC_Texture0, v_texCoord).a   \n    ); \n}";
            cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nattribute vec4 a_color;  \nvarying lowp vec4 v_fragmentColor; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor = a_color; \n    v_texCoord = a_texCoord; \n}";
            cc.SHADER_POSITION_TEXTURE_COLOR_FRAG = "precision lowp float;\nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nvoid main() \n{ \n    gl_FragColor = v_fragmentColor * texture2D(CC_Texture0, v_texCoord); \n}";
            cc.SHADER_POSITION_TEXTURE_COLOR_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nattribute vec4 a_color;  \nvarying lowp vec4 v_fragmentColor; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor = a_color; \n    v_texCoord = a_texCoord; \n}";
            cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG = "precision lowp float;   \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord;   \nuniform float CC_alpha_value; \nvoid main() \n{  \n    vec4 texColor = texture2D(CC_Texture0, v_texCoord);  \n    if ( texColor.a <= CC_alpha_value )          \n        discard; \n    gl_FragColor = texColor * v_fragmentColor;  \n}";
            cc.SHADEREX_SWITCHMASK_FRAG = "precision lowp float; \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nuniform sampler2D u_texture;  \nuniform sampler2D   u_mask;   \nvoid main()  \n{  \n    vec4 texColor   = texture2D(u_texture, v_texCoord);  \n    vec4 maskColor  = texture2D(u_mask, v_texCoord); \n    vec4 finalColor = vec4(texColor.r, texColor.g, texColor.b, maskColor.a * texColor.a);        \n    gl_FragColor    = v_fragmentColor * finalColor; \n}";
            cc.shaderCache = {
                TYPE_POSITION_TEXTURECOLOR: 0,
                TYPE_POSITION_TEXTURECOLOR_ALPHATEST: 1,
                TYPE_POSITION_COLOR: 2,
                TYPE_POSITION_TEXTURE: 3,
                TYPE_POSITION_TEXTURE_UCOLOR: 4,
                TYPE_POSITION_TEXTURE_A8COLOR: 5,
                TYPE_POSITION_UCOLOR: 6,
                TYPE_POSITION_LENGTH_TEXTURECOLOR: 7,
                TYPE_MAX: 8,
                _programs: {},
                _init: function() {
                    this.loadDefaultShaders();
                    return true;
                },
                _loadDefaultShader: function(program, type) {
                    switch (type) {
                      case this.TYPE_POSITION_TEXTURECOLOR:
                        program.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_FRAG);
                        program.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                        program.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                        program.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                        break;

                      case this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST:
                        program.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG);
                        program.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                        program.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                        program.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                        break;

                      case this.TYPE_POSITION_COLOR:
                        program.initWithVertexShaderByteArray(cc.SHADER_POSITION_COLOR_VERT, cc.SHADER_POSITION_COLOR_FRAG);
                        program.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                        program.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                        break;

                      case this.TYPE_POSITION_TEXTURE:
                        program.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_VERT, cc.SHADER_POSITION_TEXTURE_FRAG);
                        program.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                        program.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                        break;

                      case this.TYPE_POSITION_TEXTURE_UCOLOR:
                        program.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT, cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG);
                        program.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                        program.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                        break;

                      case this.TYPE_POSITION_TEXTURE_A8COLOR:
                        program.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT, cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG);
                        program.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                        program.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                        program.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                        break;

                      case this.TYPE_POSITION_UCOLOR:
                        program.initWithVertexShaderByteArray(cc.SHADER_POSITION_UCOLOR_VERT, cc.SHADER_POSITION_UCOLOR_FRAG);
                        program.addAttribute("aVertex", cc.VERTEX_ATTRIB_POSITION);
                        break;

                      case this.TYPE_POSITION_LENGTH_TEXTURECOLOR:
                        program.initWithVertexShaderByteArray(cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT, cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG);
                        program.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                        program.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                        program.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                        break;

                      default:
                        cc.log("cocos2d: cc.shaderCache._loadDefaultShader, error shader type");
                        return;
                    }
                    program.link();
                    program.updateUniforms();
                },
                loadDefaultShaders: function() {
                    var program = new cc.GLProgram();
                    this._loadDefaultShader(program, this.TYPE_POSITION_TEXTURECOLOR);
                    this._programs[cc.SHADER_POSITION_TEXTURECOLOR] = program;
                    this._programs["ShaderPositionTextureColor"] = program;
                    program = new cc.GLProgram();
                    this._loadDefaultShader(program, this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST);
                    this._programs[cc.SHADER_POSITION_TEXTURECOLORALPHATEST] = program;
                    this._programs["ShaderPositionTextureColorAlphaTest"] = program;
                    program = new cc.GLProgram();
                    this._loadDefaultShader(program, this.TYPE_POSITION_COLOR);
                    this._programs[cc.SHADER_POSITION_COLOR] = program;
                    this._programs["ShaderPositionColor"] = program;
                    program = new cc.GLProgram();
                    this._loadDefaultShader(program, this.TYPE_POSITION_TEXTURE);
                    this._programs[cc.SHADER_POSITION_TEXTURE] = program;
                    this._programs["ShaderPositionTexture"] = program;
                    program = new cc.GLProgram();
                    this._loadDefaultShader(program, this.TYPE_POSITION_TEXTURE_UCOLOR);
                    this._programs[cc.SHADER_POSITION_TEXTURE_UCOLOR] = program;
                    this._programs["ShaderPositionTextureUColor"] = program;
                    program = new cc.GLProgram();
                    this._loadDefaultShader(program, this.TYPE_POSITION_TEXTURE_A8COLOR);
                    this._programs[cc.SHADER_POSITION_TEXTUREA8COLOR] = program;
                    this._programs["ShaderPositionTextureA8Color"] = program;
                    program = new cc.GLProgram();
                    this._loadDefaultShader(program, this.TYPE_POSITION_UCOLOR);
                    this._programs[cc.SHADER_POSITION_UCOLOR] = program;
                    this._programs["ShaderPositionUColor"] = program;
                    program = new cc.GLProgram();
                    this._loadDefaultShader(program, this.TYPE_POSITION_LENGTH_TEXTURECOLOR);
                    this._programs[cc.SHADER_POSITION_LENGTHTEXTURECOLOR] = program;
                    this._programs["ShaderPositionLengthTextureColor"] = program;
                },
                reloadDefaultShaders: function() {
                    var program = this.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
                    program.reset();
                    this._loadDefaultShader(program, this.TYPE_POSITION_TEXTURECOLOR);
                    program = this.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST);
                    program.reset();
                    this._loadDefaultShader(program, this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST);
                    program = this.programForKey(cc.SHADER_POSITION_COLOR);
                    program.reset();
                    this._loadDefaultShader(program, this.TYPE_POSITION_COLOR);
                    program = this.programForKey(cc.SHADER_POSITION_TEXTURE);
                    program.reset();
                    this._loadDefaultShader(program, this.TYPE_POSITION_TEXTURE);
                    program = this.programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR);
                    program.reset();
                    this._loadDefaultShader(program, this.TYPE_POSITION_TEXTURE_UCOLOR);
                    program = this.programForKey(cc.SHADER_POSITION_TEXTUREA8COLOR);
                    program.reset();
                    this._loadDefaultShader(program, this.TYPE_POSITION_TEXTURE_A8COLOR);
                    program = this.programForKey(cc.SHADER_POSITION_UCOLOR);
                    program.reset();
                    this._loadDefaultShader(program, this.TYPE_POSITION_UCOLOR);
                },
                programForKey: function(key) {
                    return this._programs[key];
                },
                getProgram: function(shaderName) {
                    return this._programs[shaderName];
                },
                addProgram: function(program, key) {
                    this._programs[key] = program;
                }
            };
            cc.HashUniformEntry = function(value, location, hh) {
                this.value = value;
                this.location = location;
                this.hh = hh || {};
            };
            cc.GLProgram = cc._Class.extend({
                _glContext: null,
                _programObj: null,
                _vertShader: null,
                _fragShader: null,
                _uniforms: null,
                _hashForUniforms: null,
                _usesTime: false,
                _updateUniformLocation: function(location, data, bytes) {
                    if (null == location) {
                        return false;
                    }
                    var updated = true;
                    var element = null;
                    for (var i = 0; i < this._hashForUniforms.length; i++) {
                        if (this._hashForUniforms[i].location == location) {
                            element = this._hashForUniforms[i];
                        }
                    }
                    if (!element) {
                        element = new cc.HashUniformEntry();
                        element.location = location;
                        element.value = data;
                        this._hashForUniforms.push(element);
                    } else {
                        if (element.value == data) {
                            updated = false;
                        } else {
                            element.value = data;
                        }
                    }
                    return updated;
                },
                _description: function() {
                    return "<CCGLProgram = " + this.toString() + " | Program = " + this._programObj.toString() + ", VertexShader = " + this._vertShader.toString() + ", FragmentShader = " + this._fragShader.toString() + ">";
                },
                _compileShader: function(shader, type, source) {
                    if (!source || !shader) {
                        return false;
                    }
                    var preStr = cc.GLProgram._isHighpSupported() ? "precision highp float;\n" : "precision mediump float;\n";
                    source = preStr + "uniform mat4 CC_PMatrix;         \nuniform mat4 CC_MVMatrix;        \nuniform mat4 CC_MVPMatrix;       \nuniform vec4 CC_Time;            \nuniform vec4 CC_SinTime;         \nuniform vec4 CC_CosTime;         \nuniform vec4 CC_Random01;        \nuniform sampler2D CC_Texture0;   \n//CC INCLUDES END                \n" + source;
                    this._glContext.shaderSource(shader, source);
                    this._glContext.compileShader(shader);
                    var status = this._glContext.getShaderParameter(shader, this._glContext.COMPILE_STATUS);
                    if (!status) {
                        cc.log("cocos2d: ERROR: Failed to compile shader:\n" + this._glContext.getShaderSource(shader));
                        if (type === this._glContext.VERTEX_SHADER) {
                            cc.log("cocos2d: \n" + this.vertexShaderLog());
                        } else {
                            cc.log("cocos2d: \n" + this.fragmentShaderLog());
                        }
                    }
                    return true === status;
                },
                ctor: function(vShaderFileName, fShaderFileName, glContext) {
                    this._uniforms = [];
                    this._hashForUniforms = [];
                    this._glContext = glContext || cc._renderContext;
                    vShaderFileName && fShaderFileName && this.init(vShaderFileName, fShaderFileName);
                },
                destroyProgram: function() {
                    this._vertShader = null;
                    this._fragShader = null;
                    this._uniforms = null;
                    this._hashForUniforms = null;
                    this._glContext.deleteProgram(this._programObj);
                },
                initWithVertexShaderByteArray: function(vertShaderStr, fragShaderStr) {
                    var locGL = this._glContext;
                    this._programObj = locGL.createProgram();
                    this._vertShader = null;
                    this._fragShader = null;
                    if (vertShaderStr) {
                        this._vertShader = locGL.createShader(locGL.VERTEX_SHADER);
                        if (!this._compileShader(this._vertShader, locGL.VERTEX_SHADER, vertShaderStr)) {
                            cc.log("cocos2d: ERROR: Failed to compile vertex shader");
                        }
                    }
                    if (fragShaderStr) {
                        this._fragShader = locGL.createShader(locGL.FRAGMENT_SHADER);
                        if (!this._compileShader(this._fragShader, locGL.FRAGMENT_SHADER, fragShaderStr)) {
                            cc.log("cocos2d: ERROR: Failed to compile fragment shader");
                        }
                    }
                    if (this._vertShader) {
                        locGL.attachShader(this._programObj, this._vertShader);
                    }
                    cc.checkGLErrorDebug();
                    if (this._fragShader) {
                        locGL.attachShader(this._programObj, this._fragShader);
                    }
                    this._hashForUniforms.length = 0;
                    cc.checkGLErrorDebug();
                    return true;
                },
                initWithString: function(vertShaderStr, fragShaderStr) {
                    return this.initWithVertexShaderByteArray(vertShaderStr, fragShaderStr);
                },
                initWithVertexShaderFilename: function(vShaderFilename, fShaderFileName) {
                    var vertexSource = cc.loader.getRes(vShaderFilename);
                    if (!vertexSource) {
                        throw new Error("Please load the resource firset : " + vShaderFilename);
                    }
                    var fragmentSource = cc.loader.getRes(fShaderFileName);
                    if (!fragmentSource) {
                        throw new Error("Please load the resource firset : " + fShaderFileName);
                    }
                    return this.initWithVertexShaderByteArray(vertexSource, fragmentSource);
                },
                init: function(vShaderFilename, fShaderFileName) {
                    return this.initWithVertexShaderFilename(vShaderFilename, fShaderFileName);
                },
                addAttribute: function(attributeName, index) {
                    this._glContext.bindAttribLocation(this._programObj, index, attributeName);
                },
                link: function() {
                    if (!this._programObj) {
                        cc.log("cc.GLProgram.link(): Cannot link invalid program");
                        return false;
                    }
                    this._glContext.linkProgram(this._programObj);
                    if (this._vertShader) {
                        this._glContext.deleteShader(this._vertShader);
                    }
                    if (this._fragShader) {
                        this._glContext.deleteShader(this._fragShader);
                    }
                    this._vertShader = null;
                    this._fragShader = null;
                    if (cc.game.config[cc.game.CONFIG_KEY.debugMode]) {
                        var status = this._glContext.getProgramParameter(this._programObj, this._glContext.LINK_STATUS);
                        if (!status) {
                            cc.log("cocos2d: ERROR: Failed to link program: " + this._glContext.getProgramInfoLog(this._programObj));
                            cc.glDeleteProgram(this._programObj);
                            this._programObj = null;
                            return false;
                        }
                    }
                    return true;
                },
                use: function() {
                    cc.glUseProgram(this._programObj);
                },
                updateUniforms: function() {
                    this._uniforms[cc.UNIFORM_PMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_PMATRIX_S);
                    this._uniforms[cc.UNIFORM_MVMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_MVMATRIX_S);
                    this._uniforms[cc.UNIFORM_MVPMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_MVPMATRIX_S);
                    this._uniforms[cc.UNIFORM_TIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_TIME_S);
                    this._uniforms[cc.UNIFORM_SINTIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_SINTIME_S);
                    this._uniforms[cc.UNIFORM_COSTIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_COSTIME_S);
                    this._usesTime = null != this._uniforms[cc.UNIFORM_TIME] || null != this._uniforms[cc.UNIFORM_SINTIME] || null != this._uniforms[cc.UNIFORM_COSTIME];
                    this._uniforms[cc.UNIFORM_RANDOM01] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_RANDOM01_S);
                    this._uniforms[cc.UNIFORM_SAMPLER] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_SAMPLER_S);
                    this.use();
                    this.setUniformLocationWith1i(this._uniforms[cc.UNIFORM_SAMPLER], 0);
                },
                getUniformLocationForName: function(name) {
                    if (!name) {
                        throw new Error("cc.GLProgram.getUniformLocationForName(): uniform name should be non-null");
                    }
                    if (!this._programObj) {
                        throw new Error("cc.GLProgram.getUniformLocationForName(): Invalid operation. Cannot get uniform location when program is not initialized");
                    }
                    return this._glContext.getUniformLocation(this._programObj, name);
                },
                getUniformMVPMatrix: function() {
                    return this._uniforms[cc.UNIFORM_MVPMATRIX];
                },
                getUniformSampler: function() {
                    return this._uniforms[cc.UNIFORM_SAMPLER];
                },
                setUniformLocationWith1i: function(location, i1) {
                    var updated = this._updateUniformLocation(location, i1);
                    if (updated) {
                        this._glContext.uniform1i(location, i1);
                    }
                },
                setUniformLocationWith2i: function(location, i1, i2) {
                    var intArray = [ i1, i2 ];
                    var updated = this._updateUniformLocation(location, intArray);
                    if (updated) {
                        this._glContext.uniform2i(location, i1, i2);
                    }
                },
                setUniformLocationWith3i: function(location, i1, i2, i3) {
                    var intArray = [ i1, i2, i3 ];
                    var updated = this._updateUniformLocation(location, intArray);
                    if (updated) {
                        this._glContext.uniform3i(location, i1, i2, i3);
                    }
                },
                setUniformLocationWith4i: function(location, i1, i2, i3, i4) {
                    var intArray = [ i1, i2, i3, i4 ];
                    var updated = this._updateUniformLocation(location, intArray);
                    if (updated) {
                        this._glContext.uniform4i(location, i1, i2, i3, i4);
                    }
                },
                setUniformLocationWith2iv: function(location, intArray, numberOfArrays) {
                    var updated = this._updateUniformLocation(location, intArray);
                    if (updated) {
                        this._glContext.uniform2iv(location, intArray);
                    }
                },
                setUniformLocationWith3iv: function(location, intArray, numberOfArrays) {
                    var updated = this._updateUniformLocation(location, intArray);
                    if (updated) {
                        this._glContext.uniform3iv(location, intArray);
                    }
                },
                setUniformLocationWith4iv: function(location, intArray, numberOfArrays) {
                    var updated = this._updateUniformLocation(location, intArray);
                    if (updated) {
                        this._glContext.uniform4iv(location, intArray);
                    }
                },
                setUniformLocationI32: function(location, i1) {
                    this.setUniformLocationWith1i(arguments[0], arguments[1]);
                },
                setUniformLocationWith1f: function(location, f1) {
                    var updated = this._updateUniformLocation(location, f1);
                    if (updated) {
                        this._glContext.uniform1f(location, f1);
                    }
                },
                setUniformLocationWith2f: function(location, f1, f2) {
                    var floats = [ f1, f2 ];
                    var updated = this._updateUniformLocation(location, floats);
                    if (updated) {
                        this._glContext.uniform2f(location, f1, f2);
                    }
                },
                setUniformLocationWith3f: function(location, f1, f2, f3) {
                    var floats = [ f1, f2, f3 ];
                    var updated = this._updateUniformLocation(location, floats);
                    if (updated) {
                        this._glContext.uniform3f(location, f1, f2, f3);
                    }
                },
                setUniformLocationWith4f: function(location, f1, f2, f3, f4) {
                    var floats = [ f1, f2, f3, f4 ];
                    var updated = this._updateUniformLocation(location, floats);
                    if (updated) {
                        this._glContext.uniform4f(location, f1, f2, f3, f4);
                    }
                },
                setUniformLocationWith2fv: function(location, floatArray, numberOfArrays) {
                    var updated = this._updateUniformLocation(location, floatArray);
                    if (updated) {
                        this._glContext.uniform2fv(location, floatArray);
                    }
                },
                setUniformLocationWith3fv: function(location, floatArray, numberOfArrays) {
                    var updated = this._updateUniformLocation(location, floatArray);
                    if (updated) {
                        this._glContext.uniform3fv(location, floatArray);
                    }
                },
                setUniformLocationWith4fv: function(location, floatArray, numberOfArrays) {
                    var updated = this._updateUniformLocation(location, floatArray);
                    if (updated) {
                        this._glContext.uniform4fv(location, floatArray);
                    }
                },
                setUniformLocationWithMatrix4fv: function(location, matrixArray, numberOfMatrices) {
                    var updated = this._updateUniformLocation(location, matrixArray);
                    if (updated) {
                        this._glContext.uniformMatrix4fv(location, false, matrixArray);
                    }
                },
                setUniformLocationF32: function() {
                    if (arguments.length < 2) {
                        return;
                    }
                    switch (arguments.length) {
                      case 2:
                        this.setUniformLocationWith1f(arguments[0], arguments[1]);
                        break;

                      case 3:
                        this.setUniformLocationWith2f(arguments[0], arguments[1], arguments[2]);
                        break;

                      case 4:
                        this.setUniformLocationWith3f(arguments[0], arguments[1], arguments[2], arguments[3]);
                        break;

                      case 5:
                        this.setUniformLocationWith4f(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);
                    }
                },
                setUniformsForBuiltins: function() {
                    var matrixP = new cc.math.Matrix4();
                    var matrixMV = new cc.math.Matrix4();
                    var matrixMVP = new cc.math.Matrix4();
                    cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, matrixP);
                    cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, matrixMV);
                    cc.kmMat4Multiply(matrixMVP, matrixP, matrixMV);
                    this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], matrixP.mat, 1);
                    this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], matrixMV.mat, 1);
                    this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], matrixMVP.mat, 1);
                    if (this._usesTime) {
                        var director = cc.director;
                        var time = director.getTotalFrames() * director.getAnimationInterval();
                        this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_TIME], time / 10, time, 2 * time, 4 * time);
                        this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_SINTIME], time / 8, time / 4, time / 2, Math.sin(time));
                        this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_COSTIME], time / 8, time / 4, time / 2, Math.cos(time));
                    }
                    if (-1 !== this._uniforms[cc.UNIFORM_RANDOM01]) {
                        this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_RANDOM01], Math.random(), Math.random(), Math.random(), Math.random());
                    }
                },
                _setUniformsForBuiltinsForRenderer: function(node) {
                    if (!node || !node._renderCmd) {
                        return;
                    }
                    var matrixP = new cc.math.Matrix4();
                    var matrixMVP = new cc.math.Matrix4();
                    cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, matrixP);
                    cc.kmMat4Multiply(matrixMVP, matrixP, node._renderCmd._stackMatrix);
                    this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], matrixP.mat, 1);
                    this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], node._renderCmd._stackMatrix.mat, 1);
                    this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], matrixMVP.mat, 1);
                    if (this._usesTime) {
                        var director = cc.director;
                        var time = director.getTotalFrames() * director.getAnimationInterval();
                        this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_TIME], time / 10, time, 2 * time, 4 * time);
                        this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_SINTIME], time / 8, time / 4, time / 2, Math.sin(time));
                        this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_COSTIME], time / 8, time / 4, time / 2, Math.cos(time));
                    }
                    if (-1 !== this._uniforms[cc.UNIFORM_RANDOM01]) {
                        this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_RANDOM01], Math.random(), Math.random(), Math.random(), Math.random());
                    }
                },
                setUniformForModelViewProjectionMatrix: function() {
                    this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], false, cc.getMat4MultiplyValue(cc.projection_matrix_stack.top, cc.modelview_matrix_stack.top));
                },
                setUniformForModelViewProjectionMatrixWithMat4: function(swapMat4) {
                    cc.kmMat4Multiply(swapMat4, cc.projection_matrix_stack.top, cc.modelview_matrix_stack.top);
                    this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], false, swapMat4.mat);
                },
                setUniformForModelViewAndProjectionMatrixWithMat4: function() {
                    this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], false, cc.modelview_matrix_stack.top.mat);
                    this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], false, cc.projection_matrix_stack.top.mat);
                },
                _setUniformForMVPMatrixWithMat4: function(modelViewMatrix) {
                    if (!modelViewMatrix) {
                        throw new Error("modelView matrix is undefined.");
                    }
                    this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], false, modelViewMatrix.mat);
                    this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], false, cc.projection_matrix_stack.top.mat);
                },
                vertexShaderLog: function() {
                    return this._glContext.getShaderInfoLog(this._vertShader);
                },
                getVertexShaderLog: function() {
                    return this._glContext.getShaderInfoLog(this._vertShader);
                },
                getFragmentShaderLog: function() {
                    return this._glContext.getShaderInfoLog(this._vertShader);
                },
                fragmentShaderLog: function() {
                    return this._glContext.getShaderInfoLog(this._fragShader);
                },
                programLog: function() {
                    return this._glContext.getProgramInfoLog(this._programObj);
                },
                getProgramLog: function() {
                    return this._glContext.getProgramInfoLog(this._programObj);
                },
                reset: function() {
                    this._vertShader = null;
                    this._fragShader = null;
                    this._uniforms.length = 0;
                    this._glContext.deleteProgram(this._programObj);
                    this._programObj = null;
                    for (var i = 0; i < this._hashForUniforms.length; i++) {
                        this._hashForUniforms[i].value = null;
                        this._hashForUniforms[i] = null;
                    }
                    this._hashForUniforms.length = 0;
                },
                getProgram: function() {
                    return this._programObj;
                },
                retain: function() {},
                release: function() {}
            });
            cc.GLProgram.create = function(vShaderFileName, fShaderFileName) {
                return new cc.GLProgram(vShaderFileName, fShaderFileName);
            };
            cc.GLProgram._highpSupported = null;
            cc.GLProgram._isHighpSupported = function() {
                if (null == cc.GLProgram._highpSupported) {
                    var ctx = cc._renderContext;
                    var highp = ctx.getShaderPrecisionFormat(ctx.FRAGMENT_SHADER, ctx.HIGH_FLOAT);
                    cc.GLProgram._highpSupported = 0 !== highp.precision;
                }
                return cc.GLProgram._highpSupported;
            };
            cc.setProgram = function(node, program) {
                node.shaderProgram = program;
                var children = node.children;
                if (!children) {
                    return;
                }
                for (var i = 0; i < children.length; i++) {
                    cc.setProgram(children[i], program);
                }
            };
            cc._currentProjectionMatrix = -1;
            cc._vertexAttribPosition = false;
            cc._vertexAttribColor = false;
            cc._vertexAttribTexCoords = false;
            if (cc.ENABLE_GL_STATE_CACHE) {
                cc.MAX_ACTIVETEXTURE = 16;
                cc._currentShaderProgram = -1;
                cc._currentBoundTexture = [ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 ];
                cc._blendingSource = -1;
                cc._blendingDest = -1;
                cc._GLServerState = 0;
                if (cc.TEXTURE_ATLAS_USE_VAO) {
                    cc._uVAO = 0;
                }
            }
            cc.glInvalidateStateCache = function() {
                cc.kmGLFreeAll();
                cc._currentProjectionMatrix = -1;
                cc._vertexAttribPosition = false;
                cc._vertexAttribColor = false;
                cc._vertexAttribTexCoords = false;
                if (cc.ENABLE_GL_STATE_CACHE) {
                    cc._currentShaderProgram = -1;
                    for (var i = 0; i < cc.MAX_ACTIVETEXTURE; i++) {
                        cc._currentBoundTexture[i] = -1;
                    }
                    cc._blendingSource = -1;
                    cc._blendingDest = -1;
                    cc._GLServerState = 0;
                }
            };
            cc.glUseProgram = function(program) {
                if (program !== cc._currentShaderProgram) {
                    cc._currentShaderProgram = program;
                    cc._renderContext.useProgram(program);
                }
            };
            if (!cc.ENABLE_GL_STATE_CACHE) {
                cc.glUseProgram = function(program) {
                    cc._renderContext.useProgram(program);
                };
            }
            cc.glDeleteProgram = function(program) {
                if (cc.ENABLE_GL_STATE_CACHE) {
                    if (program === cc._currentShaderProgram) {
                        cc._currentShaderProgram = -1;
                    }
                }
                gl.deleteProgram(program);
            };
            cc.glBlendFunc = function(sfactor, dfactor) {
                if (sfactor !== cc._blendingSource || dfactor !== cc._blendingDest) {
                    cc._blendingSource = sfactor;
                    cc._blendingDest = dfactor;
                    cc.setBlending(sfactor, dfactor);
                }
            };
            cc.setBlending = function(sfactor, dfactor) {
                var ctx = cc._renderContext;
                if (sfactor === ctx.ONE && dfactor === ctx.ZERO) {
                    ctx.disable(ctx.BLEND);
                } else {
                    ctx.enable(ctx.BLEND);
                    cc._renderContext.blendFunc(sfactor, dfactor);
                }
            };
            cc.glBlendFuncForParticle = function(sfactor, dfactor) {
                if (sfactor !== cc._blendingSource || dfactor !== cc._blendingDest) {
                    cc._blendingSource = sfactor;
                    cc._blendingDest = dfactor;
                    var ctx = cc._renderContext;
                    if (sfactor === ctx.ONE && dfactor === ctx.ZERO) {
                        ctx.disable(ctx.BLEND);
                    } else {
                        ctx.enable(ctx.BLEND);
                        ctx.blendFuncSeparate(ctx.SRC_ALPHA, dfactor, sfactor, dfactor);
                    }
                }
            };
            if (!cc.ENABLE_GL_STATE_CACHE) {
                cc.glBlendFunc = cc.setBlending;
            }
            cc.glBlendResetToCache = function() {
                var ctx = cc._renderContext;
                ctx.blendEquation(ctx.FUNC_ADD);
                if (cc.ENABLE_GL_STATE_CACHE) {
                    cc.setBlending(cc._blendingSource, cc._blendingDest);
                } else {
                    cc.setBlending(ctx.BLEND_SRC, ctx.BLEND_DST);
                }
            };
            cc.setProjectionMatrixDirty = function() {
                cc._currentProjectionMatrix = -1;
            };
            cc.glEnableVertexAttribs = function(flags) {
                var ctx = cc._renderContext;
                var enablePosition = flags & cc.VERTEX_ATTRIB_FLAG_POSITION;
                if (enablePosition !== cc._vertexAttribPosition) {
                    if (enablePosition) {
                        ctx.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION);
                    } else {
                        ctx.disableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION);
                    }
                    cc._vertexAttribPosition = enablePosition;
                }
                var enableColor = flags & cc.VERTEX_ATTRIB_FLAG_COLOR;
                if (enableColor !== cc._vertexAttribColor) {
                    if (enableColor) {
                        ctx.enableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR);
                    } else {
                        ctx.disableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR);
                    }
                    cc._vertexAttribColor = enableColor;
                }
                var enableTexCoords = flags & cc.VERTEX_ATTRIB_FLAG_TEX_COORDS;
                if (enableTexCoords !== cc._vertexAttribTexCoords) {
                    if (enableTexCoords) {
                        ctx.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS);
                    } else {
                        ctx.disableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS);
                    }
                    cc._vertexAttribTexCoords = enableTexCoords;
                }
            };
            cc.glBindTexture2D = function(textureId) {
                cc.glBindTexture2DN(0, textureId);
            };
            cc.glBindTexture2DN = function(textureUnit, textureId) {
                if (cc._currentBoundTexture[textureUnit] === textureId) {
                    return;
                }
                cc._currentBoundTexture[textureUnit] = textureId;
                var ctx = cc._renderContext;
                ctx.activeTexture(ctx.TEXTURE0 + textureUnit);
                if (textureId) {
                    ctx.bindTexture(ctx.TEXTURE_2D, textureId._webTextureObj);
                } else {
                    ctx.bindTexture(ctx.TEXTURE_2D, null);
                }
            };
            if (!cc.ENABLE_GL_STATE_CACHE) {
                cc.glBindTexture2DN = function(textureUnit, textureId) {
                    var ctx = cc._renderContext;
                    ctx.activeTexture(ctx.TEXTURE0 + textureUnit);
                    if (textureId) {
                        ctx.bindTexture(ctx.TEXTURE_2D, textureId._webTextureObj);
                    } else {
                        ctx.bindTexture(ctx.TEXTURE_2D, null);
                    }
                };
            }
            cc.glDeleteTexture2D = function(textureId) {
                cc.glDeleteTexture2DN(0, textureId);
            };
            cc.glDeleteTexture2DN = function(textureUnit, textureId) {
                if (cc.ENABLE_GL_STATE_CACHE) {
                    if (textureId === cc._currentBoundTexture[textureUnit]) {
                        cc._currentBoundTexture[textureUnit] = -1;
                    }
                }
                cc._renderContext.deleteTexture(textureId._webTextureObj);
            };
            cc.glBindVAO = function(vaoId) {
                if (!cc.TEXTURE_ATLAS_USE_VAO) {
                    return;
                }
                if (cc.ENABLE_GL_STATE_CACHE) {
                    if (cc._uVAO !== vaoId) {
                        cc._uVAO = vaoId;
                    }
                } else {}
            };
            cc.glEnable = function(flags) {
                if (cc.ENABLE_GL_STATE_CACHE) {
                    ;
                } else {}
            };
            cc.IMAGE_FORMAT_JPEG = 0;
            cc.IMAGE_FORMAT_PNG = 1;
            cc.IMAGE_FORMAT_RAWDATA = 9;
            cc.NextPOT = function(x) {
                x -= 1;
                x |= x >> 1;
                x |= x >> 2;
                x |= x >> 4;
                x |= x >> 8;
                x |= x >> 16;
                return x + 1;
            };
            cc.RenderTexture = _ccsg.Node.extend({
                sprite: null,
                clearFlags: 0,
                clearDepthVal: 0,
                autoDraw: false,
                _texture: null,
                _pixelFormat: 0,
                clearStencilVal: 0,
                _clearColor: null,
                _className: "RenderTexture",
                ctor: function(width, height, format, depthStencilFormat) {
                    _ccsg.Node.prototype.ctor.call(this);
                    this._cascadeColorEnabled = true;
                    this._cascadeOpacityEnabled = true;
                    this._pixelFormat = cc.Texture2D.PIXEL_FORMAT_RGBA8888;
                    this._clearColor = new cc.Color(0, 0, 0, 255);
                    if (void 0 !== width && void 0 !== height) {
                        format = format || cc.Texture2D.PIXEL_FORMAT_RGBA8888;
                        depthStencilFormat = depthStencilFormat || 0;
                        this.initWithWidthAndHeight(width, height, format, depthStencilFormat);
                    }
                    this.setAnchorPoint(0, 0);
                },
                _createRenderCmd: function() {
                    if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                        return new cc.RenderTexture.CanvasRenderCmd(this);
                    } else {
                        return new cc.RenderTexture.WebGLRenderCmd(this);
                    }
                },
                cleanup: function() {
                    _ccsg.Node.prototype.onExit.call(this);
                    this._renderCmd.cleanup();
                },
                getSprite: function() {
                    return this.sprite;
                },
                setSprite: function(sprite) {
                    this.sprite = sprite;
                },
                setVirtualViewport: function(rtBegin, fullRect, fullViewport) {
                    this._renderCmd.setVirtualViewport(rtBegin, fullRect, fullViewport);
                },
                initWithWidthAndHeight: function(width, height, format, depthStencilFormat) {
                    return this._renderCmd.initWithWidthAndHeight(width, height, format, depthStencilFormat);
                },
                begin: function() {
                    cc.renderer._turnToCacheMode(this.__instanceId);
                    this._renderCmd.begin();
                },
                beginWithClear: function(r, g, b, a, depthValue, stencilValue) {
                    var gl = cc._renderContext;
                    depthValue = depthValue || gl.COLOR_BUFFER_BIT;
                    stencilValue = stencilValue || gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT;
                    this._beginWithClear(r, g, b, a, depthValue, stencilValue, gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
                },
                _beginWithClear: function(r, g, b, a, depthValue, stencilValue, flags) {
                    this.begin();
                    this._renderCmd._beginWithClear(r, g, b, a, depthValue, stencilValue, flags);
                },
                end: function() {
                    this._renderCmd.end();
                },
                clear: function(r, g, b, a) {
                    this.beginWithClear(r, g, b, a);
                    this.end();
                },
                clearRect: function(x, y, width, height) {
                    this._renderCmd.clearRect(x, y, width, height);
                },
                clearDepth: function(depthValue) {
                    this._renderCmd.clearDepth(depthValue);
                },
                clearStencil: function(stencilValue) {
                    this._renderCmd.clearStencil(stencilValue);
                },
                getClearFlags: function() {
                    return this.clearFlags;
                },
                setClearFlags: function(clearFlags) {
                    this.clearFlags = clearFlags;
                },
                getClearColor: function() {
                    return this._clearColor;
                },
                setClearColor: function(clearColor) {
                    var locClearColor = this._clearColor;
                    locClearColor.r = clearColor.r;
                    locClearColor.g = clearColor.g;
                    locClearColor.b = clearColor.b;
                    locClearColor.a = clearColor.a;
                    this._renderCmd.updateClearColor(clearColor);
                },
                getClearDepth: function() {
                    return this.clearDepthVal;
                },
                setClearDepth: function(clearDepth) {
                    this.clearDepthVal = clearDepth;
                },
                getClearStencil: function() {
                    return this.clearStencilVal;
                },
                setClearStencil: function(clearStencil) {
                    this.clearStencilVal = clearStencil;
                },
                isAutoDraw: function() {
                    return this.autoDraw;
                },
                setAutoDraw: function(autoDraw) {
                    this.autoDraw = autoDraw;
                },
                saveToFile: function(filePath, format) {
                    cc.log("saveToFile isn't supported on Cocos2d-Html5");
                },
                newCCImage: function(flipImage) {
                    cc.log("saveToFile isn't supported on cocos2d-html5");
                    return null;
                },
                listenToBackground: function(obj) {},
                listenToForeground: function(obj) {}
            });
            var _p = cc.RenderTexture.prototype;
            _p.clearColorVal;
            cc.defineGetterSetter(_p, "clearColorVal", _p.getClearColor, _p.setClearColor);
            cc.RenderTexture.create = function(width, height, format, depthStencilFormat) {
                return new cc.RenderTexture(width, height, format, depthStencilFormat);
            };
            !function() {
                cc.RenderTexture.CanvasRenderCmd = function(renderableObject) {
                    _ccsg.Node.CanvasRenderCmd.call(this, renderableObject);
                    this._needDraw = true;
                    this._clearColorStr = "rgba(255,255,255,1)";
                    this._cacheCanvas = document.createElement("canvas");
                    this._cacheContext = new cc.CanvasContextWrapper(this._cacheCanvas.getContext("2d"));
                };
                var proto = cc.RenderTexture.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
                proto.constructor = cc.RenderTexture.CanvasRenderCmd;
                proto.cleanup = function() {
                    this._cacheContext = null;
                    this._cacheCanvas = null;
                };
                proto.clearStencil = function(stencilValue) {};
                proto.setVirtualViewport = function(rtBegin, fullRect, fullViewport) {};
                proto.updateClearColor = function(clearColor) {
                    this._clearColorStr = "rgba(" + (0 | clearColor.r) + "," + (0 | clearColor.g) + "," + (0 | clearColor.b) + "," + clearColor.a / 255 + ")";
                };
                proto.initWithWidthAndHeight = function(width, height, format, depthStencilFormat) {
                    var node = this._node;
                    var locCacheCanvas = this._cacheCanvas, locScaleFactor = cc.contentScaleFactor();
                    locCacheCanvas.width = 0 | width * locScaleFactor;
                    locCacheCanvas.height = 0 | height * locScaleFactor;
                    var texture = new cc.Texture2D();
                    texture.initWithElement(locCacheCanvas);
                    texture.handleLoadedTexture();
                    var locSprite = node.sprite = new _ccsg.Sprite(texture);
                    locSprite.setBlendFunc(cc.ONE, cc.ONE_MINUS_SRC_ALPHA);
                    node.autoDraw = false;
                    node.addChild(locSprite);
                    return true;
                };
                proto.begin = function() {};
                proto._beginWithClear = function(r, g, b, a, depthValue, stencilValue, flags) {
                    r = r || 0;
                    g = g || 0;
                    b = b || 0;
                    a = isNaN(a) ? 255 : a;
                    var context = this._cacheContext.getContext();
                    var locCanvas = this._cacheCanvas;
                    context.setTransform(1, 0, 0, 1, 0, 0);
                    this._cacheContext.setFillStyle("rgba(" + (0 | r) + "," + (0 | g) + "," + (0 | b) + "," + a / 255 + ")");
                    context.clearRect(0, 0, locCanvas.width, locCanvas.height);
                    context.fillRect(0, 0, locCanvas.width, locCanvas.height);
                };
                proto.end = function() {
                    var node = this._node;
                    var scale = cc.contentScaleFactor();
                    cc.renderer._renderingToCacheCanvas(this._cacheContext, node.__instanceId, scale, scale);
                };
                proto.clearRect = function(x, y, width, height) {
                    this._cacheContext.clearRect(x, y, width, -height);
                };
                proto.clearDepth = function(depthValue) {
                    cc.log("clearDepth isn't supported on Cocos2d-Html5");
                };
                proto.visit = function(parentCmd) {
                    var node = this._node;
                    this._syncStatus(parentCmd);
                    node.sprite.visit(this);
                    this._dirtyFlag = 0;
                };
            }();
            !function() {
                cc.RenderTexture.WebGLRenderCmd = function(renderableObject) {
                    _ccsg.Node.WebGLRenderCmd.call(this, renderableObject);
                    this._needDraw = true;
                    this._fBO = null;
                    this._oldFBO = null;
                    this._textureCopy = null;
                    this._depthRenderBuffer = null;
                    this._rtTextureRect = new cc.Rect();
                    this._fullRect = new cc.Rect();
                    this._fullViewport = new cc.Rect();
                };
                var proto = cc.RenderTexture.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
                proto.constructor = cc.RenderTexture.WebGLRenderCmd;
                proto.setVirtualViewport = function(rtBegin, fullRect, fullViewport) {
                    this._rtTextureRect.x = rtBegin.x;
                    this._rtTextureRect.y = rtBegin.y;
                    this._fullRect = fullRect;
                    this._fullViewport = fullViewport;
                };
                proto.rendering = function(ctx) {
                    var gl = ctx || cc._renderContext;
                    var node = this._node;
                    if (node.autoDraw) {
                        node.begin();
                        var locClearFlags = node.clearFlags;
                        if (locClearFlags) {
                            var oldClearColor = [ 0, 0, 0, 0 ];
                            var oldDepthClearValue = 0;
                            var oldStencilClearValue = 0;
                            if (locClearFlags & gl.COLOR_BUFFER_BIT) {
                                oldClearColor = gl.getParameter(gl.COLOR_CLEAR_VALUE);
                                gl.clearColor(node._clearColor.r / 255, node._clearColor.g / 255, node._clearColor.b / 255, node._clearColor.a / 255);
                            }
                            if (locClearFlags & gl.DEPTH_BUFFER_BIT) {
                                oldDepthClearValue = gl.getParameter(gl.DEPTH_CLEAR_VALUE);
                                gl.clearDepth(node.clearDepthVal);
                            }
                            if (locClearFlags & gl.STENCIL_BUFFER_BIT) {
                                oldStencilClearValue = gl.getParameter(gl.STENCIL_CLEAR_VALUE);
                                gl.clearStencil(node.clearStencilVal);
                            }
                            gl.clear(locClearFlags);
                            if (locClearFlags & gl.COLOR_BUFFER_BIT) {
                                gl.clearColor(oldClearColor[0], oldClearColor[1], oldClearColor[2], oldClearColor[3]);
                            }
                            if (locClearFlags & gl.DEPTH_BUFFER_BIT) {
                                gl.clearDepth(oldDepthClearValue);
                            }
                            if (locClearFlags & gl.STENCIL_BUFFER_BIT) {
                                gl.clearStencil(oldStencilClearValue);
                            }
                        }
                        node.sortAllChildren();
                        var locChildren = node._children;
                        for (var i = 0; i < locChildren.length; i++) {
                            var getChild = locChildren[i];
                            if (getChild !== node.sprite) {
                                getChild._renderCmd.visit(node.sprite._renderCmd);
                            }
                        }
                        node.end();
                    }
                };
                proto.clearStencil = function(stencilValue) {
                    var gl = cc._renderContext;
                    var stencilClearValue = gl.getParameter(gl.STENCIL_CLEAR_VALUE);
                    gl.clearStencil(stencilValue);
                    gl.clear(gl.STENCIL_BUFFER_BIT);
                    gl.clearStencil(stencilClearValue);
                };
                proto.cleanup = function() {
                    var node = this._node;
                    this._textureCopy = null;
                    var gl = cc._renderContext;
                    gl.deleteFramebuffer(this._fBO);
                    if (this._depthRenderBuffer) {
                        gl.deleteRenderbuffer(this._depthRenderBuffer);
                    }
                };
                proto.updateClearColor = function(clearColor) {};
                proto.initWithWidthAndHeight = function(width, height, format, depthStencilFormat) {
                    var node = this._node;
                    if (format === cc.Texture2D.PIXEL_FORMAT_A8) {
                        cc.log("cc.RenderTexture._initWithWidthAndHeightForWebGL() : only RGB and RGBA formats are valid for a render texture;");
                    }
                    var gl = cc._renderContext, locScaleFactor = cc.contentScaleFactor();
                    this._fullRect = new cc.Rect(0, 0, width, height);
                    this._fullViewport = new cc.Rect(0, 0, width, height);
                    width = 0 | width * locScaleFactor;
                    height = 0 | height * locScaleFactor;
                    this._oldFBO = gl.getParameter(gl.FRAMEBUFFER_BINDING);
                    var powW, powH;
                    if (cc.configuration.supportsNPOT()) {
                        powW = width;
                        powH = height;
                    } else {
                        powW = cc.NextPOT(width);
                        powH = cc.NextPOT(height);
                    }
                    var dataLen = powW * powH * 4;
                    var data = new Uint8Array(dataLen);
                    for (var i = 0; i < powW * powH * 4; i++) {
                        data[i] = 0;
                    }
                    this._pixelFormat = format;
                    var locTexture = node._texture = new cc.Texture2D();
                    if (!node._texture) {
                        return false;
                    }
                    locTexture.initWithData(data, node._pixelFormat, powW, powH, cc.size(width, height));
                    var oldRBO = gl.getParameter(gl.RENDERBUFFER_BINDING);
                    if (cc.configuration.checkForGLExtension("GL_QCOM")) {
                        this._textureCopy = new cc.Texture2D();
                        if (!this._textureCopy) {
                            return false;
                        }
                        this._textureCopy.initWithData(data, node._pixelFormat, powW, powH, cc.size(width, height));
                    }
                    this._fBO = gl.createFramebuffer();
                    gl.bindFramebuffer(gl.FRAMEBUFFER, this._fBO);
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, locTexture._webTextureObj, 0);
                    if (0 !== depthStencilFormat) {
                        this._depthRenderBuffer = gl.createRenderbuffer();
                        gl.bindRenderbuffer(gl.RENDERBUFFER, this._depthRenderBuffer);
                        gl.renderbufferStorage(gl.RENDERBUFFER, depthStencilFormat, powW, powH);
                        if (depthStencilFormat === gl.DEPTH_STENCIL) {
                            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this._depthRenderBuffer);
                        } else {
                            if (depthStencilFormat === gl.STENCIL_INDEX || depthStencilFormat === gl.STENCIL_INDEX8) {
                                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, gl.RENDERBUFFER, this._depthRenderBuffer);
                            } else {
                                if (depthStencilFormat === gl.DEPTH_COMPONENT16) {
                                    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._depthRenderBuffer);
                                }
                            }
                        }
                    }
                    if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
                        cc.log("Could not attach texture to the framebuffer");
                    }
                    locTexture.setAliasTexParameters();
                    var locSprite = node.sprite = new _ccsg.Sprite(locTexture);
                    locSprite.scaleY = -1;
                    locSprite.setBlendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                    gl.bindRenderbuffer(gl.RENDERBUFFER, oldRBO);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, this._oldFBO);
                    node.autoDraw = false;
                    node.addChild(locSprite);
                    return true;
                };
                proto.begin = function() {
                    var node = this._node;
                    cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
                    cc.kmGLPushMatrix();
                    cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
                    cc.kmGLPushMatrix();
                    var gl = cc._renderContext;
                    var director = cc.director;
                    director.setProjection(director.getProjection());
                    var texSize = node._texture.getContentSizeInPixels();
                    var size = cc.director.getWinSizeInPixels();
                    var widthRatio = size.width / texSize.width;
                    var heightRatio = size.height / texSize.height;
                    var orthoMatrix = cc.math.Matrix4.createOrthographicProjection(-1 / widthRatio, 1 / widthRatio, -1 / heightRatio, 1 / heightRatio, -1, 1);
                    cc.kmGLMultMatrix(orthoMatrix);
                    var viewport = new cc.Rect(0, 0, 0, 0);
                    viewport.width = this._fullViewport.width;
                    viewport.height = this._fullViewport.height;
                    var viewPortRectWidthRatio = viewport.width / this._fullRect.width;
                    var viewPortRectHeightRatio = viewport.height / this._fullRect.height;
                    viewport.x = (this._fullRect.x - this._rtTextureRect.x) * viewPortRectWidthRatio;
                    viewport.y = (this._fullRect.y - this._rtTextureRect.y) * viewPortRectHeightRatio;
                    gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
                    this._oldFBO = gl.getParameter(gl.FRAMEBUFFER_BINDING);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, this._fBO);
                    if (cc.configuration.checkForGLExtension("GL_QCOM")) {
                        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._textureCopy._webTextureObj, 0);
                        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, node._texture._webTextureObj, 0);
                    }
                };
                proto._beginWithClear = function(r, g, b, a, depthValue, stencilValue, flags) {
                    r /= 255;
                    g /= 255;
                    b /= 255;
                    a /= 255;
                    var gl = cc._renderContext;
                    var clearColor = [ 0, 0, 0, 0 ];
                    var depthClearValue = 0;
                    var stencilClearValue = 0;
                    if (flags & gl.COLOR_BUFFER_BIT) {
                        clearColor = gl.getParameter(gl.COLOR_CLEAR_VALUE);
                        gl.clearColor(r, g, b, a);
                    }
                    if (flags & gl.DEPTH_BUFFER_BIT) {
                        depthClearValue = gl.getParameter(gl.DEPTH_CLEAR_VALUE);
                        gl.clearDepth(depthValue);
                    }
                    if (flags & gl.STENCIL_BUFFER_BIT) {
                        stencilClearValue = gl.getParameter(gl.STENCIL_CLEAR_VALUE);
                        gl.clearStencil(stencilValue);
                    }
                    gl.clear(flags);
                    if (flags & gl.COLOR_BUFFER_BIT) {
                        gl.clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
                    }
                    if (flags & gl.DEPTH_BUFFER_BIT) {
                        gl.clearDepth(depthClearValue);
                    }
                    if (flags & gl.STENCIL_BUFFER_BIT) {
                        gl.clearStencil(stencilClearValue);
                    }
                };
                proto.end = function() {
                    var node = this._node;
                    cc.renderer._renderingToBuffer(node.__instanceId);
                    var gl = cc._renderContext;
                    var director = cc.director;
                    gl.bindFramebuffer(gl.FRAMEBUFFER, this._oldFBO);
                    director.setViewport();
                    cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
                    cc.kmGLPopMatrix();
                    cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
                    cc.kmGLPopMatrix();
                };
                proto.clearRect = function(x, y, width, height) {};
                proto.clearDepth = function(depthValue) {
                    var node = this._node;
                    node.begin();
                    var gl = cc._renderContext;
                    var depthClearValue = gl.getParameter(gl.DEPTH_CLEAR_VALUE);
                    gl.clearDepth(depthValue);
                    gl.clear(gl.DEPTH_BUFFER_BIT);
                    gl.clearDepth(depthClearValue);
                    node.end();
                };
                proto.visit = function(parentCmd) {
                    var node = this._node;
                    if (!node._visible) {
                        return;
                    }
                    cc.kmGLPushMatrix();
                    this._syncStatus(parentCmd);
                    cc.renderer.pushRenderCommand(this);
                    node.sprite.visit(this);
                    this._dirtyFlag = 0;
                    cc.kmGLPopMatrix();
                };
            }();
            cc.v2fzero = function() {
                return {
                    x: 0,
                    y: 0
                };
            };
            cc.v2f = function(x, y) {
                return {
                    x: x,
                    y: y
                };
            };
            cc.v2fadd = function(v0, v1) {
                return cc.v2f(v0.x + v1.x, v0.y + v1.y);
            };
            cc.v2fsub = function(v0, v1) {
                return cc.v2f(v0.x - v1.x, v0.y - v1.y);
            };
            cc.v2fmult = function(v, s) {
                return cc.v2f(v.x * s, v.y * s);
            };
            cc.v2fperp = function(p0) {
                return cc.v2f(-p0.y, p0.x);
            };
            cc.v2fneg = function(p0) {
                return cc.v2f(-p0.x, -p0.y);
            };
            cc.v2fdot = function(p0, p1) {
                return p0.x * p1.x + p0.y * p1.y;
            };
            cc.v2fforangle = function(_a_) {
                return cc.v2f(Math.cos(_a_), Math.sin(_a_));
            };
            cc.v2fnormalize = function(p) {
                var r = cc.pNormalize(cc.p(p.x, p.y));
                return cc.v2f(r.x, r.y);
            };
            cc.__v2f = function(v) {
                return cc.v2f(v.x, v.y);
            };
            cc.__t = function(v) {
                return {
                    u: v.x,
                    v: v.y
                };
            };
            cc.DrawNode = _ccsg.Node.extend({
                _buffer: null,
                _blendFunc: null,
                _lineWidth: 1,
                _drawColor: null,
                getBlendFunc: function() {
                    return this._blendFunc;
                },
                setBlendFunc: function(blendFunc, dst) {
                    if (void 0 === dst) {
                        this._blendFunc.src = blendFunc.src;
                        this._blendFunc.dst = blendFunc.dst;
                    } else {
                        this._blendFunc.src = blendFunc;
                        this._blendFunc.dst = dst;
                    }
                },
                setLineWidth: function(width) {
                    this._lineWidth = width;
                },
                getLineWidth: function() {
                    return this._lineWidth;
                },
                setDrawColor: function(color) {
                    var locDrawColor = this._drawColor;
                    locDrawColor.r = color.r;
                    locDrawColor.g = color.g;
                    locDrawColor.b = color.b;
                    locDrawColor.a = null == color.a ? 255 : color.a;
                },
                getDrawColor: function() {
                    return cc.color(this._drawColor.r, this._drawColor.g, this._drawColor.b, this._drawColor.a);
                }
            });
            cc.DrawNode.create = function() {
                return new cc.DrawNode();
            };
            cc.DrawNode.TYPE_DOT = 0;
            cc.DrawNode.TYPE_SEGMENT = 1;
            cc.DrawNode.TYPE_POLY = 2;
            cc.game.once(cc.game.EVENT_RENDERER_INITED, function() {
                if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                    cc._DrawNodeElement = function(type, verts, fillColor, lineWidth, lineColor, lineCap, isClosePolygon, isFill, isStroke) {
                        var _t = this;
                        _t.type = type;
                        _t.verts = verts || null;
                        _t.fillColor = fillColor || null;
                        _t.lineWidth = lineWidth || 0;
                        _t.lineColor = lineColor || null;
                        _t.lineCap = lineCap || "butt";
                        _t.isClosePolygon = isClosePolygon || false;
                        _t.isFill = isFill || false;
                        _t.isStroke = isStroke || false;
                    };
                    cc.js.mixin(cc.DrawNode.prototype, {
                        _className: "DrawNodeCanvas",
                        ctor: function() {
                            _ccsg.Node.prototype.ctor.call(this);
                            var locCmd = this._renderCmd;
                            locCmd._buffer = this._buffer = [];
                            locCmd._drawColor = this._drawColor = cc.color(255, 255, 255, 255);
                            locCmd._blendFunc = this._blendFunc = new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
                            this.init();
                        },
                        drawRect: function(origin, destination, fillColor, lineWidth, lineColor) {
                            lineWidth = null == lineWidth ? this._lineWidth : lineWidth;
                            lineColor = lineColor || this.getDrawColor();
                            if (null == lineColor.a) {
                                lineColor.a = 255;
                            }
                            var vertices = [ origin, cc.p(destination.x, origin.y), destination, cc.p(origin.x, destination.y) ];
                            var element = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
                            element.verts = vertices;
                            element.lineWidth = lineWidth;
                            element.lineColor = lineColor;
                            element.isClosePolygon = true;
                            element.isStroke = true;
                            element.lineCap = "butt";
                            element.fillColor = fillColor;
                            if (fillColor) {
                                if (null == fillColor.a) {
                                    fillColor.a = 255;
                                }
                                element.isFill = true;
                            }
                            this._buffer.push(element);
                        },
                        drawCircle: function(center, radius, angle, segments, drawLineToCenter, lineWidth, color) {
                            lineWidth = lineWidth || this._lineWidth;
                            color = color || this.getDrawColor();
                            if (null == color.a) {
                                color.a = 255;
                            }
                            var coef = 2 * Math.PI / segments;
                            var vertices = [];
                            for (var i = 0; i <= segments; i++) {
                                var rads = i * coef;
                                var j = radius * Math.cos(rads + angle) + center.x;
                                var k = radius * Math.sin(rads + angle) + center.y;
                                vertices.push(cc.p(j, k));
                            }
                            if (drawLineToCenter) {
                                vertices.push(cc.p(center.x, center.y));
                            }
                            var element = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
                            element.verts = vertices;
                            element.lineWidth = lineWidth;
                            element.lineColor = color;
                            element.isClosePolygon = true;
                            element.isStroke = true;
                            this._buffer.push(element);
                        },
                        drawQuadBezier: function(origin, control, destination, segments, lineWidth, color) {
                            lineWidth = lineWidth || this._lineWidth;
                            color = color || this.getDrawColor();
                            if (null == color.a) {
                                color.a = 255;
                            }
                            var vertices = [], t = 0;
                            for (var i = 0; i < segments; i++) {
                                var x = Math.pow(1 - t, 2) * origin.x + 2 * (1 - t) * t * control.x + t * t * destination.x;
                                var y = Math.pow(1 - t, 2) * origin.y + 2 * (1 - t) * t * control.y + t * t * destination.y;
                                vertices.push(cc.p(x, y));
                                t += 1 / segments;
                            }
                            vertices.push(cc.p(destination.x, destination.y));
                            var element = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
                            element.verts = vertices;
                            element.lineWidth = lineWidth;
                            element.lineColor = color;
                            element.isStroke = true;
                            element.lineCap = "round";
                            this._buffer.push(element);
                        },
                        drawCubicBezier: function(origin, control1, control2, destination, segments, lineWidth, color) {
                            lineWidth = lineWidth || this._lineWidth;
                            color = color || this.getDrawColor();
                            if (null == color.a) {
                                color.a = 255;
                            }
                            var vertices = [], t = 0;
                            for (var i = 0; i < segments; i++) {
                                var x = Math.pow(1 - t, 3) * origin.x + 3 * Math.pow(1 - t, 2) * t * control1.x + 3 * (1 - t) * t * t * control2.x + t * t * t * destination.x;
                                var y = Math.pow(1 - t, 3) * origin.y + 3 * Math.pow(1 - t, 2) * t * control1.y + 3 * (1 - t) * t * t * control2.y + t * t * t * destination.y;
                                vertices.push(cc.p(x, y));
                                t += 1 / segments;
                            }
                            vertices.push(cc.p(destination.x, destination.y));
                            var element = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
                            element.verts = vertices;
                            element.lineWidth = lineWidth;
                            element.lineColor = color;
                            element.isStroke = true;
                            element.lineCap = "round";
                            this._buffer.push(element);
                        },
                        drawCatmullRom: function(points, segments, lineWidth, color) {
                            this.drawCardinalSpline(points, .5, segments, lineWidth, color);
                        },
                        drawCardinalSpline: function(config, tension, segments, lineWidth, color) {
                            lineWidth = lineWidth || this._lineWidth;
                            color = color || this.getDrawColor();
                            if (null == color.a) {
                                color.a = 255;
                            }
                            var vertices = [], p, lt, deltaT = 1 / config.length;
                            for (var i = 0; i < segments + 1; i++) {
                                var dt = i / segments;
                                if (1 === dt) {
                                    p = config.length - 1;
                                    lt = 1;
                                } else {
                                    p = 0 | dt / deltaT;
                                    lt = (dt - deltaT * p) / deltaT;
                                }
                                var newPos = cc.cardinalSplineAt(cc.getControlPointAt(config, p - 1), cc.getControlPointAt(config, p - 0), cc.getControlPointAt(config, p + 1), cc.getControlPointAt(config, p + 2), tension, lt);
                                vertices.push(newPos);
                            }
                            var element = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
                            element.verts = vertices;
                            element.lineWidth = lineWidth;
                            element.lineColor = color;
                            element.isStroke = true;
                            element.lineCap = "round";
                            this._buffer.push(element);
                        },
                        drawDot: function(pos, radius, color) {
                            color = color || this.getDrawColor();
                            if (null == color.a) {
                                color.a = 255;
                            }
                            var element = new cc._DrawNodeElement(cc.DrawNode.TYPE_DOT);
                            element.verts = [ pos ];
                            element.lineWidth = radius;
                            element.fillColor = color;
                            this._buffer.push(element);
                        },
                        drawDots: function(points, radius, color) {
                            if (!points || 0 == points.length) {
                                return;
                            }
                            color = color || this.getDrawColor();
                            if (null == color.a) {
                                color.a = 255;
                            }
                            for (var i = 0, len = points.length; i < len; i++) {
                                this.drawDot(points[i], radius, color);
                            }
                        },
                        drawSegment: function(from, to, lineWidth, color) {
                            lineWidth = lineWidth || this._lineWidth;
                            color = color || this.getDrawColor();
                            if (null == color.a) {
                                color.a = 255;
                            }
                            var element = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
                            element.verts = [ from, to ];
                            element.lineWidth = 2 * lineWidth;
                            element.lineColor = color;
                            element.isStroke = true;
                            element.lineCap = "round";
                            this._buffer.push(element);
                        },
                        drawPoly_: function(verts, fillColor, lineWidth, color) {
                            lineWidth = null == lineWidth ? this._lineWidth : lineWidth;
                            color = color || this.getDrawColor();
                            if (null == color.a) {
                                color.a = 255;
                            }
                            var element = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
                            element.verts = verts;
                            element.fillColor = fillColor;
                            element.lineWidth = lineWidth;
                            element.lineColor = color;
                            element.isClosePolygon = true;
                            element.isStroke = true;
                            element.lineCap = "round";
                            if (fillColor) {
                                element.isFill = true;
                            }
                            this._buffer.push(element);
                        },
                        drawPoly: function(verts, fillColor, lineWidth, color) {
                            var vertsCopy = [];
                            for (var i = 0; i < verts.length; i++) {
                                vertsCopy.push(cc.p(verts[i].x, verts[i].y));
                            }
                            return this.drawPoly_(vertsCopy, fillColor, lineWidth, color);
                        },
                        clear: function() {
                            this._buffer.length = 0;
                        },
                        _createRenderCmd: function() {
                            return new cc.DrawNode.CanvasRenderCmd(this);
                        }
                    });
                } else {
                    if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
                        cc.js.mixin(cc.DrawNode.prototype, {
                            _bufferCapacity: 0,
                            _trianglesArrayBuffer: null,
                            _trianglesWebBuffer: null,
                            _trianglesReader: null,
                            _dirty: false,
                            _className: "DrawNodeWebGL",
                            ctor: function() {
                                _ccsg.Node.prototype.ctor.call(this);
                                this._buffer = [];
                                this._blendFunc = new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
                                this._drawColor = new cc.WebGLColor(255, 255, 255, 255);
                                this.init();
                            },
                            init: function() {
                                if (_ccsg.Node.prototype.init.call(this)) {
                                    this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_LENGTHTEXTURECOLOR);
                                    this._ensureCapacity(64);
                                    this._trianglesWebBuffer = cc._renderContext.createBuffer();
                                    this._dirty = true;
                                    return true;
                                }
                                return false;
                            },
                            drawRect: function(origin, destination, fillColor, lineWidth, lineColor) {
                                lineWidth = null == lineWidth ? this._lineWidth : lineWidth;
                                lineColor = lineColor || this.getDrawColor();
                                if (null == lineColor.a) {
                                    lineColor.a = 255;
                                }
                                var vertices = [ origin, cc.p(destination.x, origin.y), destination, cc.p(origin.x, destination.y) ];
                                if (null == fillColor) {
                                    this._drawSegments(vertices, lineWidth, lineColor, true);
                                } else {
                                    this.drawPoly(vertices, fillColor, lineWidth, lineColor);
                                }
                            },
                            drawCircle: function(center, radius, angle, segments, drawLineToCenter, lineWidth, color) {
                                lineWidth = lineWidth || this._lineWidth;
                                color = color || this.getDrawColor();
                                if (null == color.a) {
                                    color.a = 255;
                                }
                                var coef = 2 * Math.PI / segments, vertices = [], i, len;
                                for (i = 0; i <= segments; i++) {
                                    var rads = i * coef;
                                    var j = radius * Math.cos(rads + angle) + center.x;
                                    var k = radius * Math.sin(rads + angle) + center.y;
                                    vertices.push(cc.p(j, k));
                                }
                                if (drawLineToCenter) {
                                    vertices.push(cc.p(center.x, center.y));
                                }
                                lineWidth *= .5;
                                for (i = 0, len = vertices.length; i < len - 1; i++) {
                                    this.drawSegment(vertices[i], vertices[i + 1], lineWidth, color);
                                }
                            },
                            drawQuadBezier: function(origin, control, destination, segments, lineWidth, color) {
                                lineWidth = lineWidth || this._lineWidth;
                                color = color || this.getDrawColor();
                                if (null == color.a) {
                                    color.a = 255;
                                }
                                var vertices = [], t = 0;
                                for (var i = 0; i < segments; i++) {
                                    var x = Math.pow(1 - t, 2) * origin.x + 2 * (1 - t) * t * control.x + t * t * destination.x;
                                    var y = Math.pow(1 - t, 2) * origin.y + 2 * (1 - t) * t * control.y + t * t * destination.y;
                                    vertices.push(cc.p(x, y));
                                    t += 1 / segments;
                                }
                                vertices.push(cc.p(destination.x, destination.y));
                                this._drawSegments(vertices, lineWidth, color, false);
                            },
                            drawCubicBezier: function(origin, control1, control2, destination, segments, lineWidth, color) {
                                lineWidth = lineWidth || this._lineWidth;
                                color = color || this.getDrawColor();
                                if (null == color.a) {
                                    color.a = 255;
                                }
                                var vertices = [], t = 0;
                                for (var i = 0; i < segments; i++) {
                                    var x = Math.pow(1 - t, 3) * origin.x + 3 * Math.pow(1 - t, 2) * t * control1.x + 3 * (1 - t) * t * t * control2.x + t * t * t * destination.x;
                                    var y = Math.pow(1 - t, 3) * origin.y + 3 * Math.pow(1 - t, 2) * t * control1.y + 3 * (1 - t) * t * t * control2.y + t * t * t * destination.y;
                                    vertices.push(cc.p(x, y));
                                    t += 1 / segments;
                                }
                                vertices.push(cc.p(destination.x, destination.y));
                                this._drawSegments(vertices, lineWidth, color, false);
                            },
                            drawCatmullRom: function(points, segments, lineWidth, color) {
                                this.drawCardinalSpline(points, .5, segments, lineWidth, color);
                            },
                            drawCardinalSpline: function(config, tension, segments, lineWidth, color) {
                                lineWidth = lineWidth || this._lineWidth;
                                color = color || this.getDrawColor();
                                if (null == color.a) {
                                    color.a = 255;
                                }
                                var vertices = [], p, lt, deltaT = 1 / config.length;
                                for (var i = 0; i < segments + 1; i++) {
                                    var dt = i / segments;
                                    if (1 === dt) {
                                        p = config.length - 1;
                                        lt = 1;
                                    } else {
                                        p = 0 | dt / deltaT;
                                        lt = (dt - deltaT * p) / deltaT;
                                    }
                                    var newPos = cc.cardinalSplineAt(cc.getControlPointAt(config, p - 1), cc.getControlPointAt(config, p - 0), cc.getControlPointAt(config, p + 1), cc.getControlPointAt(config, p + 2), tension, lt);
                                    vertices.push(newPos);
                                }
                                lineWidth *= .5;
                                for (var j = 0, len = vertices.length; j < len - 1; j++) {
                                    this.drawSegment(vertices[j], vertices[j + 1], lineWidth, color);
                                }
                            },
                            _render: function() {
                                var gl = cc._renderContext;
                                cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
                                gl.bindBuffer(gl.ARRAY_BUFFER, this._trianglesWebBuffer);
                                if (this._dirty) {
                                    gl.bufferData(gl.ARRAY_BUFFER, this._trianglesArrayBuffer, gl.STREAM_DRAW);
                                    this._dirty = false;
                                }
                                var triangleSize = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
                                gl.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, gl.FLOAT, false, triangleSize, 0);
                                gl.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, gl.UNSIGNED_BYTE, true, triangleSize, 8);
                                gl.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, gl.FLOAT, false, triangleSize, 12);
                                gl.drawArrays(gl.TRIANGLES, 0, 3 * this._buffer.length);
                                cc.incrementGLDraws(1);
                            },
                            _ensureCapacity: function(count) {
                                var _t = this;
                                var locBuffer = _t._buffer;
                                if (locBuffer.length + count > _t._bufferCapacity) {
                                    var TriangleLength = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT;
                                    _t._bufferCapacity += Math.max(_t._bufferCapacity, count);
                                    if (null == locBuffer || 0 === locBuffer.length) {
                                        _t._buffer = [];
                                        _t._trianglesArrayBuffer = new ArrayBuffer(TriangleLength * _t._bufferCapacity);
                                        _t._trianglesReader = new Uint8Array(_t._trianglesArrayBuffer);
                                    } else {
                                        var newTriangles = [];
                                        var newArrayBuffer = new ArrayBuffer(TriangleLength * _t._bufferCapacity);
                                        for (var i = 0; i < locBuffer.length; i++) {
                                            newTriangles[i] = new cc.V2F_C4B_T2F_Triangle(locBuffer[i].a, locBuffer[i].b, locBuffer[i].c, newArrayBuffer, i * TriangleLength);
                                        }
                                        _t._trianglesReader = new Uint8Array(newArrayBuffer);
                                        _t._trianglesArrayBuffer = newArrayBuffer;
                                        _t._buffer = newTriangles;
                                    }
                                }
                            },
                            drawDot: function(pos, radius, color) {
                                color = color || this.getDrawColor();
                                if (null == color.a) {
                                    color.a = 255;
                                }
                                var c4bColor = {
                                    r: 0 | color.r,
                                    g: 0 | color.g,
                                    b: 0 | color.b,
                                    a: 0 | color.a
                                };
                                var a = {
                                    vertices: {
                                        x: pos.x - radius,
                                        y: pos.y - radius
                                    },
                                    colors: c4bColor,
                                    texCoords: {
                                        u: -1,
                                        v: -1
                                    }
                                };
                                var b = {
                                    vertices: {
                                        x: pos.x - radius,
                                        y: pos.y + radius
                                    },
                                    colors: c4bColor,
                                    texCoords: {
                                        u: -1,
                                        v: 1
                                    }
                                };
                                var c = {
                                    vertices: {
                                        x: pos.x + radius,
                                        y: pos.y + radius
                                    },
                                    colors: c4bColor,
                                    texCoords: {
                                        u: 1,
                                        v: 1
                                    }
                                };
                                var d = {
                                    vertices: {
                                        x: pos.x + radius,
                                        y: pos.y - radius
                                    },
                                    colors: c4bColor,
                                    texCoords: {
                                        u: 1,
                                        v: -1
                                    }
                                };
                                this._ensureCapacity(6);
                                this._buffer.push(new cc.V2F_C4B_T2F_Triangle(a, b, c, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT));
                                this._buffer.push(new cc.V2F_C4B_T2F_Triangle(a, c, d, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT));
                                this._dirty = true;
                            },
                            drawDots: function(points, radius, color) {
                                if (!points || 0 === points.length) {
                                    return;
                                }
                                color = color || this.getDrawColor();
                                if (null == color.a) {
                                    color.a = 255;
                                }
                                for (var i = 0, len = points.length; i < len; i++) {
                                    this.drawDot(points[i], radius, color);
                                }
                            },
                            drawSegment: function(from, to, radius, color) {
                                color = color || this.getDrawColor();
                                if (null == color.a) {
                                    color.a = 255;
                                }
                                radius = radius || .5 * this._lineWidth;
                                var vertexCount = 18;
                                this._ensureCapacity(vertexCount);
                                var c4bColor = {
                                    r: 0 | color.r,
                                    g: 0 | color.g,
                                    b: 0 | color.b,
                                    a: 0 | color.a
                                };
                                var a = cc.__v2f(from), b = cc.__v2f(to);
                                var n = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(b, a))), t = cc.v2fperp(n);
                                var nw = cc.v2fmult(n, radius), tw = cc.v2fmult(t, radius);
                                var v0 = cc.v2fsub(b, cc.v2fadd(nw, tw));
                                var v1 = cc.v2fadd(b, cc.v2fsub(nw, tw));
                                var v2 = cc.v2fsub(b, nw);
                                var v3 = cc.v2fadd(b, nw);
                                var v4 = cc.v2fsub(a, nw);
                                var v5 = cc.v2fadd(a, nw);
                                var v6 = cc.v2fsub(a, cc.v2fsub(nw, tw));
                                var v7 = cc.v2fadd(a, cc.v2fadd(nw, tw));
                                var TriangleLength = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT, triangleBuffer = this._trianglesArrayBuffer, locBuffer = this._buffer;
                                locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
                                    vertices: v0,
                                    colors: c4bColor,
                                    texCoords: cc.__t(cc.v2fneg(cc.v2fadd(n, t)))
                                }, {
                                    vertices: v1,
                                    colors: c4bColor,
                                    texCoords: cc.__t(cc.v2fsub(n, t))
                                }, {
                                    vertices: v2,
                                    colors: c4bColor,
                                    texCoords: cc.__t(cc.v2fneg(n))
                                }, triangleBuffer, locBuffer.length * TriangleLength));
                                locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
                                    vertices: v3,
                                    colors: c4bColor,
                                    texCoords: cc.__t(n)
                                }, {
                                    vertices: v1,
                                    colors: c4bColor,
                                    texCoords: cc.__t(cc.v2fsub(n, t))
                                }, {
                                    vertices: v2,
                                    colors: c4bColor,
                                    texCoords: cc.__t(cc.v2fneg(n))
                                }, triangleBuffer, locBuffer.length * TriangleLength));
                                locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
                                    vertices: v3,
                                    colors: c4bColor,
                                    texCoords: cc.__t(n)
                                }, {
                                    vertices: v4,
                                    colors: c4bColor,
                                    texCoords: cc.__t(cc.v2fneg(n))
                                }, {
                                    vertices: v2,
                                    colors: c4bColor,
                                    texCoords: cc.__t(cc.v2fneg(n))
                                }, triangleBuffer, locBuffer.length * TriangleLength));
                                locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
                                    vertices: v3,
                                    colors: c4bColor,
                                    texCoords: cc.__t(n)
                                }, {
                                    vertices: v4,
                                    colors: c4bColor,
                                    texCoords: cc.__t(cc.v2fneg(n))
                                }, {
                                    vertices: v5,
                                    colors: c4bColor,
                                    texCoords: cc.__t(n)
                                }, triangleBuffer, locBuffer.length * TriangleLength));
                                locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
                                    vertices: v6,
                                    colors: c4bColor,
                                    texCoords: cc.__t(cc.v2fsub(t, n))
                                }, {
                                    vertices: v4,
                                    colors: c4bColor,
                                    texCoords: cc.__t(cc.v2fneg(n))
                                }, {
                                    vertices: v5,
                                    colors: c4bColor,
                                    texCoords: cc.__t(n)
                                }, triangleBuffer, locBuffer.length * TriangleLength));
                                locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
                                    vertices: v6,
                                    colors: c4bColor,
                                    texCoords: cc.__t(cc.v2fsub(t, n))
                                }, {
                                    vertices: v7,
                                    colors: c4bColor,
                                    texCoords: cc.__t(cc.v2fadd(n, t))
                                }, {
                                    vertices: v5,
                                    colors: c4bColor,
                                    texCoords: cc.__t(n)
                                }, triangleBuffer, locBuffer.length * TriangleLength));
                                this._dirty = true;
                            },
                            drawPoly: function(verts, fillColor, borderWidth, borderColor) {
                                if (null == fillColor) {
                                    this._drawSegments(verts, borderWidth, borderColor, true);
                                    return;
                                }
                                if (null == fillColor.a) {
                                    fillColor.a = 255;
                                }
                                if (null == borderColor.a) {
                                    borderColor.a = 255;
                                }
                                borderWidth = null == borderWidth ? this._lineWidth : borderWidth;
                                borderWidth *= .5;
                                var c4bFillColor = {
                                    r: 0 | fillColor.r,
                                    g: 0 | fillColor.g,
                                    b: 0 | fillColor.b,
                                    a: 0 | fillColor.a
                                };
                                var c4bBorderColor = {
                                    r: 0 | borderColor.r,
                                    g: 0 | borderColor.g,
                                    b: 0 | borderColor.b,
                                    a: 0 | borderColor.a
                                };
                                var extrude = [], i, v0, v1, v2, count = verts.length;
                                for (i = 0; i < count; i++) {
                                    v0 = cc.__v2f(verts[(i - 1 + count) % count]);
                                    v1 = cc.__v2f(verts[i]);
                                    v2 = cc.__v2f(verts[(i + 1) % count]);
                                    var n1 = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(v1, v0)));
                                    var n2 = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(v2, v1)));
                                    var offset = cc.v2fmult(cc.v2fadd(n1, n2), 1 / (cc.v2fdot(n1, n2) + 1));
                                    extrude[i] = {
                                        offset: offset,
                                        n: n2
                                    };
                                }
                                var outline = borderWidth > 0, triangleCount = 3 * count - 2, vertexCount = 3 * triangleCount;
                                this._ensureCapacity(vertexCount);
                                var triangleBytesLen = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT, trianglesBuffer = this._trianglesArrayBuffer;
                                var locBuffer = this._buffer;
                                var inset = false == outline ? .5 : 0;
                                for (i = 0; i < count - 2; i++) {
                                    v0 = cc.v2fsub(cc.__v2f(verts[0]), cc.v2fmult(extrude[0].offset, inset));
                                    v1 = cc.v2fsub(cc.__v2f(verts[i + 1]), cc.v2fmult(extrude[i + 1].offset, inset));
                                    v2 = cc.v2fsub(cc.__v2f(verts[i + 2]), cc.v2fmult(extrude[i + 2].offset, inset));
                                    locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
                                        vertices: v0,
                                        colors: c4bFillColor,
                                        texCoords: cc.__t(cc.v2fzero())
                                    }, {
                                        vertices: v1,
                                        colors: c4bFillColor,
                                        texCoords: cc.__t(cc.v2fzero())
                                    }, {
                                        vertices: v2,
                                        colors: c4bFillColor,
                                        texCoords: cc.__t(cc.v2fzero())
                                    }, trianglesBuffer, locBuffer.length * triangleBytesLen));
                                }
                                for (i = 0; i < count; i++) {
                                    var j = (i + 1) % count;
                                    v0 = cc.__v2f(verts[i]);
                                    v1 = cc.__v2f(verts[j]);
                                    var n0 = extrude[i].n;
                                    var offset0 = extrude[i].offset;
                                    var offset1 = extrude[j].offset;
                                    var inner0 = outline ? cc.v2fsub(v0, cc.v2fmult(offset0, borderWidth)) : cc.v2fsub(v0, cc.v2fmult(offset0, .5));
                                    var inner1 = outline ? cc.v2fsub(v1, cc.v2fmult(offset1, borderWidth)) : cc.v2fsub(v1, cc.v2fmult(offset1, .5));
                                    var outer0 = outline ? cc.v2fadd(v0, cc.v2fmult(offset0, borderWidth)) : cc.v2fadd(v0, cc.v2fmult(offset0, .5));
                                    var outer1 = outline ? cc.v2fadd(v1, cc.v2fmult(offset1, borderWidth)) : cc.v2fadd(v1, cc.v2fmult(offset1, .5));
                                    if (outline) {
                                        locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
                                            vertices: inner0,
                                            colors: c4bBorderColor,
                                            texCoords: cc.__t(cc.v2fneg(n0))
                                        }, {
                                            vertices: inner1,
                                            colors: c4bBorderColor,
                                            texCoords: cc.__t(cc.v2fneg(n0))
                                        }, {
                                            vertices: outer1,
                                            colors: c4bBorderColor,
                                            texCoords: cc.__t(n0)
                                        }, trianglesBuffer, locBuffer.length * triangleBytesLen));
                                        locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
                                            vertices: inner0,
                                            colors: c4bBorderColor,
                                            texCoords: cc.__t(cc.v2fneg(n0))
                                        }, {
                                            vertices: outer0,
                                            colors: c4bBorderColor,
                                            texCoords: cc.__t(n0)
                                        }, {
                                            vertices: outer1,
                                            colors: c4bBorderColor,
                                            texCoords: cc.__t(n0)
                                        }, trianglesBuffer, locBuffer.length * triangleBytesLen));
                                    } else {
                                        locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
                                            vertices: inner0,
                                            colors: c4bFillColor,
                                            texCoords: cc.__t(cc.v2fzero())
                                        }, {
                                            vertices: inner1,
                                            colors: c4bFillColor,
                                            texCoords: cc.__t(cc.v2fzero())
                                        }, {
                                            vertices: outer1,
                                            colors: c4bFillColor,
                                            texCoords: cc.__t(n0)
                                        }, trianglesBuffer, locBuffer.length * triangleBytesLen));
                                        locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
                                            vertices: inner0,
                                            colors: c4bFillColor,
                                            texCoords: cc.__t(cc.v2fzero())
                                        }, {
                                            vertices: outer0,
                                            colors: c4bFillColor,
                                            texCoords: cc.__t(n0)
                                        }, {
                                            vertices: outer1,
                                            colors: c4bFillColor,
                                            texCoords: cc.__t(n0)
                                        }, trianglesBuffer, locBuffer.length * triangleBytesLen));
                                    }
                                }
                                extrude = null;
                                this._dirty = true;
                            },
                            _drawSegments: function(verts, borderWidth, borderColor, closePoly) {
                                borderWidth = null == borderWidth ? this._lineWidth : borderWidth;
                                borderColor = borderColor || this._drawColor;
                                if (null == borderColor.a) {
                                    borderColor.a = 255;
                                }
                                borderWidth *= .5;
                                if (borderWidth <= 0) {
                                    return;
                                }
                                var c4bBorderColor = {
                                    r: 0 | borderColor.r,
                                    g: 0 | borderColor.g,
                                    b: 0 | borderColor.b,
                                    a: 0 | borderColor.a
                                };
                                var extrude = [], i, v0, v1, v2, count = verts.length;
                                for (i = 0; i < count; i++) {
                                    v0 = cc.__v2f(verts[(i - 1 + count) % count]);
                                    v1 = cc.__v2f(verts[i]);
                                    v2 = cc.__v2f(verts[(i + 1) % count]);
                                    var n1 = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(v1, v0)));
                                    var n2 = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(v2, v1)));
                                    var offset = cc.v2fmult(cc.v2fadd(n1, n2), 1 / (cc.v2fdot(n1, n2) + 1));
                                    extrude[i] = {
                                        offset: offset,
                                        n: n2
                                    };
                                }
                                var triangleCount = 3 * count - 2, vertexCount = 3 * triangleCount;
                                this._ensureCapacity(vertexCount);
                                var triangleBytesLen = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT, trianglesBuffer = this._trianglesArrayBuffer;
                                var locBuffer = this._buffer;
                                var len = closePoly ? count : count - 1;
                                for (i = 0; i < len; i++) {
                                    var j = (i + 1) % count;
                                    v0 = cc.__v2f(verts[i]);
                                    v1 = cc.__v2f(verts[j]);
                                    var n0 = extrude[i].n;
                                    var offset0 = extrude[i].offset;
                                    var offset1 = extrude[j].offset;
                                    var inner0 = cc.v2fsub(v0, cc.v2fmult(offset0, borderWidth));
                                    var inner1 = cc.v2fsub(v1, cc.v2fmult(offset1, borderWidth));
                                    var outer0 = cc.v2fadd(v0, cc.v2fmult(offset0, borderWidth));
                                    var outer1 = cc.v2fadd(v1, cc.v2fmult(offset1, borderWidth));
                                    locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
                                        vertices: inner0,
                                        colors: c4bBorderColor,
                                        texCoords: cc.__t(cc.v2fneg(n0))
                                    }, {
                                        vertices: inner1,
                                        colors: c4bBorderColor,
                                        texCoords: cc.__t(cc.v2fneg(n0))
                                    }, {
                                        vertices: outer1,
                                        colors: c4bBorderColor,
                                        texCoords: cc.__t(n0)
                                    }, trianglesBuffer, locBuffer.length * triangleBytesLen));
                                    locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
                                        vertices: inner0,
                                        colors: c4bBorderColor,
                                        texCoords: cc.__t(cc.v2fneg(n0))
                                    }, {
                                        vertices: outer0,
                                        colors: c4bBorderColor,
                                        texCoords: cc.__t(n0)
                                    }, {
                                        vertices: outer1,
                                        colors: c4bBorderColor,
                                        texCoords: cc.__t(n0)
                                    }, trianglesBuffer, locBuffer.length * triangleBytesLen));
                                }
                                extrude = null;
                                this._dirty = true;
                            },
                            clear: function() {
                                this._buffer.length = 0;
                                this._dirty = true;
                            },
                            _createRenderCmd: function() {
                                return new cc.DrawNode.WebGLRenderCmd(this);
                            }
                        });
                    }
                }
            });
            !function() {
                cc.DrawNode.CanvasRenderCmd = function(renderableObject) {
                    _ccsg.Node.CanvasRenderCmd.call(this, renderableObject);
                    this._needDraw = true;
                    this._buffer = null;
                    this._drawColor = null;
                    this._blendFunc = null;
                };
                cc.DrawNode.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
                cc.DrawNode.CanvasRenderCmd.prototype.constructor = cc.DrawNode.CanvasRenderCmd;
                cc.js.mixin(cc.DrawNode.CanvasRenderCmd.prototype, {
                    rendering: function(ctx, scaleX, scaleY) {
                        var wrapper = ctx || cc._renderContext, context = wrapper.getContext(), node = this._node;
                        var alpha = node._displayedOpacity / 255;
                        if (0 === alpha) {
                            return;
                        }
                        wrapper.setTransform(this._worldTransform, scaleX, scaleY);
                        wrapper.setGlobalAlpha(alpha);
                        if (this._blendFunc && this._blendFunc.src === cc.SRC_ALPHA && this._blendFunc.dst === cc.ONE) {
                            wrapper.setCompositeOperation("lighter");
                        }
                        var locBuffer = this._buffer;
                        for (var i = 0, len = locBuffer.length; i < len; i++) {
                            var element = locBuffer[i];
                            switch (element.type) {
                              case cc.DrawNode.TYPE_DOT:
                                this._drawDot(wrapper, element, scaleX, scaleY);
                                break;

                              case cc.DrawNode.TYPE_SEGMENT:
                                this._drawSegment(wrapper, element, scaleX, scaleY);
                                break;

                              case cc.DrawNode.TYPE_POLY:
                                this._drawPoly(wrapper, element, scaleX, scaleY);
                            }
                        }
                    },
                    _drawDot: function(wrapper, element, scaleX, scaleY) {
                        var locColor = element.fillColor, locPos = element.verts[0], locRadius = element.lineWidth;
                        var ctx = wrapper.getContext();
                        wrapper.setFillStyle("rgba(" + (0 | locColor.r) + "," + (0 | locColor.g) + "," + (0 | locColor.b) + "," + locColor.a / 255 + ")");
                        ctx.beginPath();
                        ctx.arc(locPos.x * scaleX, -locPos.y * scaleY, locRadius * scaleX, 0, 2 * Math.PI, false);
                        ctx.closePath();
                        ctx.fill();
                    },
                    _drawSegment: function(wrapper, element, scaleX, scaleY) {
                        var locColor = element.lineColor;
                        var locFrom = element.verts[0], locTo = element.verts[1];
                        var locLineWidth = element.lineWidth, locLineCap = element.lineCap;
                        var ctx = wrapper.getContext();
                        wrapper.setStrokeStyle("rgba(" + (0 | locColor.r) + "," + (0 | locColor.g) + "," + (0 | locColor.b) + "," + locColor.a / 255 + ")");
                        ctx.lineWidth = locLineWidth * scaleX;
                        ctx.beginPath();
                        ctx.lineCap = locLineCap;
                        ctx.moveTo(locFrom.x * scaleX, -locFrom.y * scaleY);
                        ctx.lineTo(locTo.x * scaleX, -locTo.y * scaleY);
                        ctx.stroke();
                    },
                    _drawPoly: function(wrapper, element, scaleX, scaleY) {
                        var locVertices = element.verts, locLineCap = element.lineCap;
                        if (null == locVertices) {
                            return;
                        }
                        var locFillColor = element.fillColor, locLineWidth = element.lineWidth;
                        var locLineColor = element.lineColor, locIsClosePolygon = element.isClosePolygon;
                        var locIsFill = element.isFill, locIsStroke = element.isStroke;
                        var ctx = wrapper.getContext();
                        var firstPoint = locVertices[0];
                        ctx.lineCap = locLineCap;
                        if (locFillColor) {
                            wrapper.setFillStyle("rgba(" + (0 | locFillColor.r) + "," + (0 | locFillColor.g) + "," + (0 | locFillColor.b) + "," + locFillColor.a / 255 + ")");
                        }
                        if (locLineWidth) {
                            ctx.lineWidth = locLineWidth * scaleX;
                        }
                        if (locLineColor) {
                            wrapper.setStrokeStyle("rgba(" + (0 | locLineColor.r) + "," + (0 | locLineColor.g) + "," + (0 | locLineColor.b) + "," + locLineColor.a / 255 + ")");
                        }
                        ctx.beginPath();
                        ctx.moveTo(firstPoint.x * scaleX, -firstPoint.y * scaleY);
                        for (var i = 1, len = locVertices.length; i < len; i++) {
                            ctx.lineTo(locVertices[i].x * scaleX, -locVertices[i].y * scaleY);
                        }
                        if (locIsClosePolygon) {
                            ctx.closePath();
                        }
                        if (locIsFill) {
                            ctx.fill();
                        }
                        if (locIsStroke) {
                            ctx.stroke();
                        }
                    }
                });
            }();
            !function() {
                cc.DrawNode.WebGLRenderCmd = function(renderableObject) {
                    _ccsg.Node.WebGLRenderCmd.call(this, renderableObject);
                    this._needDraw = true;
                };
                cc.DrawNode.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
                cc.DrawNode.WebGLRenderCmd.prototype.constructor = cc.DrawNode.WebGLRenderCmd;
                cc.DrawNode.WebGLRenderCmd.prototype.rendering = function(ctx) {
                    var node = this._node;
                    cc.glBlendFunc(node._blendFunc.src, node._blendFunc.dst);
                    this._shaderProgram.use();
                    this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
                    node._render();
                };
            }();
            cc.stencilBits = -1;
            cc.ClippingNode = _ccsg.Node.extend({
                alphaThreshold: 0,
                inverted: false,
                _stencil: null,
                _className: "ClippingNode",
                ctor: function(stencil) {
                    stencil = stencil || null;
                    _ccsg.Node.prototype.ctor.call(this);
                    this._stencil = stencil;
                    this.alphaThreshold = 1;
                    this.inverted = false;
                    this._renderCmd.initStencilBits();
                },
                init: function(stencil) {
                    this._stencil = stencil;
                    this.alphaThreshold = 1;
                    this.inverted = false;
                    this._renderCmd.initStencilBits();
                    return true;
                },
                onEnter: function() {
                    _ccsg.Node.prototype.onEnter.call(this);
                    this._stencil.onEnter();
                },
                onEnterTransitionDidFinish: function() {
                    _ccsg.Node.prototype.onEnterTransitionDidFinish.call(this);
                    this._stencil.onEnterTransitionDidFinish();
                },
                onExitTransitionDidStart: function() {
                    this._stencil.onExitTransitionDidStart();
                    _ccsg.Node.prototype.onExitTransitionDidStart.call(this);
                },
                onExit: function() {
                    this._stencil.onExit();
                    _ccsg.Node.prototype.onExit.call(this);
                },
                getAlphaThreshold: function() {
                    return this.alphaThreshold;
                },
                setAlphaThreshold: function(alphaThreshold) {
                    this.alphaThreshold = alphaThreshold;
                },
                isInverted: function() {
                    return this.inverted;
                },
                setInverted: function(inverted) {
                    this.inverted = inverted;
                },
                getStencil: function() {
                    return this._stencil;
                },
                setStencil: function(stencil) {
                    if (this._stencil === stencil) {
                        return;
                    }
                    this._renderCmd.setStencil(stencil);
                },
                _createRenderCmd: function() {
                    if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                        return new cc.ClippingNode.CanvasRenderCmd(this);
                    } else {
                        return new cc.ClippingNode.WebGLRenderCmd(this);
                    }
                }
            });
            var _p = cc.ClippingNode.prototype;
            cc.defineGetterSetter(_p, "stencil", _p.getStencil, _p.setStencil);
            _p.stencil;
            cc.ClippingNode.create = function(stencil) {
                return new cc.ClippingNode(stencil);
            };
            !function() {
                cc.ClippingNode.CanvasRenderCmd = function(renderable) {
                    _ccsg.Node.CanvasRenderCmd.call(this, renderable);
                    this._needDraw = false;
                    this._godhelpme = false;
                    this._clipElemType = false;
                    this._rendererSaveCmd = new cc.CustomRenderCmd(this, this._saveCmdCallback);
                    this._rendererClipCmd = new cc.CustomRenderCmd(this, this._clipCmdCallback);
                    this._rendererRestoreCmd = new cc.CustomRenderCmd(this, this._restoreCmdCallback);
                };
                var proto = cc.ClippingNode.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
                proto.constructor = cc.ClippingNode.CanvasRenderCmd;
                proto.initStencilBits = function() {};
                proto.setStencil = function(stencil) {
                    if (null == stencil) {
                        return;
                    }
                    this._node._stencil = stencil;
                    if (stencil instanceof cc.DrawNode) {
                        if (stencil._buffer) {
                            for (var i = 0; i < stencil._buffer.length; i++) {
                                stencil._buffer[i].isFill = false;
                                stencil._buffer[i].isStroke = false;
                            }
                        }
                        stencil._renderCmd.rendering = function(ctx, scaleX, scaleY) {
                            scaleX = scaleX || cc.view.getScaleX();
                            scaleY = scaleY || cc.view.getScaleY();
                            var wrapper = ctx || cc._renderContext, context = wrapper.getContext();
                            var t = this._transform;
                            context.transform(t.a, t.b, t.c, t.d, t.tx * scaleX, -t.ty * scaleY);
                            for (var i = 0; i < stencil._buffer.length; i++) {
                                var vertices = stencil._buffer[i].verts;
                                var firstPoint = vertices[0];
                                context.moveTo(firstPoint.x * scaleX, -firstPoint.y * scaleY);
                                for (var j = vertices.length - 1; j > 0; j--) {
                                    context.lineTo(vertices[j].x * scaleX, -vertices[j].y * scaleY);
                                }
                            }
                        };
                    } else {
                        stencil._parent = this._node;
                    }
                };
                proto._saveCmdCallback = function(ctx, scaleX, scaleY) {
                    var wrapper = ctx || cc._renderContext, context = wrapper.getContext();
                    if (this._clipElemType) {
                        context.save();
                        context.globalAlpha = this._displayedOpacity / 255;
                        var locCache = cc.ClippingNode.CanvasRenderCmd._getSharedCache();
                        var canvas = context.canvas;
                        if (locCache.width !== canvas.width) {
                            locCache.width = canvas.width;
                        }
                        if (locCache.height !== canvas.height) {
                            locCache.height = canvas.height;
                        }
                        var locCacheCtx = locCache.getContext("2d");
                        locCacheCtx.drawImage(canvas, 0, 0);
                    } else {
                        wrapper.save();
                        context.beginPath();
                        wrapper.setTransform(this._worldTransform, scaleX, scaleY);
                        if (this._node.inverted) {
                            context.rect(0, 0, context.canvas.width, -context.canvas.height);
                            context.clip();
                        }
                    }
                };
                proto._setStencilCompositionOperation = function(stencil) {
                    if (!stencil) {
                        return;
                    }
                    var node = this._node;
                    if (stencil._renderCmd && stencil._renderCmd._blendFuncStr) {
                        stencil._renderCmd._blendFuncStr = node.inverted ? "destination-out" : "destination-in";
                    }
                    if (!stencil._children) {
                        return;
                    }
                    var children = stencil._children;
                    for (var i = 0, len = children.length; i < len; i++) {
                        this._setStencilCompositionOperation(children[i]);
                    }
                };
                proto._clipCmdCallback = function(ctx) {
                    var node = this._node;
                    var wrapper = ctx || cc._renderContext, context = wrapper.getContext();
                    if (this._clipElemType) {
                        this._setStencilCompositionOperation(node._stencil);
                    } else {
                        context.clip();
                    }
                };
                proto._restoreCmdCallback = function(ctx) {
                    var locCache = cc.ClippingNode.CanvasRenderCmd._getSharedCache();
                    var wrapper = ctx || cc._renderContext, context = wrapper.getContext();
                    if (this._clipElemType) {
                        context.save();
                        context.setTransform(1, 0, 0, 1, 0, 0);
                        context.globalCompositeOperation = "destination-over";
                        context.drawImage(locCache, 0, 0);
                        context.restore();
                        this._dirtyFlag = 0;
                        context.restore();
                    } else {
                        wrapper.restore();
                    }
                };
                proto.transform = function(parentCmd, recursive) {
                    _ccsg.Node.CanvasRenderCmd.prototype.transform.call(this, parentCmd, recursive);
                    var node = this._node;
                    if (node._stencil && node._stencil._renderCmd) {
                        node._stencil._renderCmd.transform(this, recursive);
                    }
                };
                proto._cangodhelpme = function(godhelpme) {
                    if (true === godhelpme || false === godhelpme) {
                        cc.ClippingNode.CanvasRenderCmd.prototype._godhelpme = godhelpme;
                    }
                    return cc.ClippingNode.CanvasRenderCmd.prototype._godhelpme;
                };
                proto.visit = function(parentCmd) {
                    var node = this._node;
                    if (!node._visible) {
                        return;
                    }
                    parentCmd = parentCmd || this.getParentRenderCmd();
                    if (parentCmd) {
                        this._curLevel = parentCmd._curLevel + 1;
                    }
                    var transformRenderCmd = this;
                    this._clipElemType = !(!this._cangodhelpme() && node._stencil instanceof cc.DrawNode);
                    if (!node._stencil || !node._stencil.visible) {
                        if (this.inverted) {
                            _ccsg.Node.CanvasRenderCmd.prototype.visit.call(this, parentCmd);
                        }
                        return;
                    }
                    this._syncStatus(parentCmd);
                    cc.renderer.pushRenderCommand(this._rendererSaveCmd);
                    if (this._clipElemType) {
                        _ccsg.Node.CanvasRenderCmd.prototype.visit.call(this, parentCmd);
                    } else {
                        node._stencil.visit(this);
                    }
                    cc.renderer.pushRenderCommand(this._rendererClipCmd);
                    if (this._clipElemType) {
                        node._stencil.visit(transformRenderCmd);
                    } else {
                        var i, children = node._children;
                        this._cangodhelpme(true);
                        var len = children.length;
                        if (len > 0) {
                            node.sortAllChildren();
                            for (i = 0; i < len; i++) {
                                children[i]._renderCmd.visit(this);
                            }
                        }
                        this._cangodhelpme(false);
                    }
                    cc.renderer.pushRenderCommand(this._rendererRestoreCmd);
                    this._dirtyFlag = 0;
                };
                cc.ClippingNode.CanvasRenderCmd._sharedCache = null;
                cc.ClippingNode.CanvasRenderCmd._getSharedCache = function() {
                    return cc.ClippingNode.CanvasRenderCmd._sharedCache || (cc.ClippingNode.CanvasRenderCmd._sharedCache = document.createElement("canvas"));
                };
            }();
            !function() {
                cc.ClippingNode.WebGLRenderCmd = function(renderable) {
                    _ccsg.Node.WebGLRenderCmd.call(this, renderable);
                    this._needDraw = false;
                    this._beforeVisitCmd = new cc.CustomRenderCmd(this, this._onBeforeVisit);
                    this._afterDrawStencilCmd = new cc.CustomRenderCmd(this, this._onAfterDrawStencil);
                    this._afterVisitCmd = new cc.CustomRenderCmd(this, this._onAfterVisit);
                    this._currentStencilFunc = null;
                    this._currentStencilRef = null;
                    this._currentStencilValueMask = null;
                    this._currentStencilFail = null;
                    this._currentStencilPassDepthFail = null;
                    this._currentStencilPassDepthPass = null;
                    this._currentStencilWriteMask = null;
                    this._currentStencilEnabled = null;
                    this._currentDepthWriteMask = null;
                    this._mask_layer_le = null;
                };
                var proto = cc.ClippingNode.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
                proto.constructor = cc.ClippingNode.WebGLRenderCmd;
                cc.ClippingNode.WebGLRenderCmd._init_once = null;
                cc.ClippingNode.WebGLRenderCmd._visit_once = null;
                cc.ClippingNode.WebGLRenderCmd._layer = -1;
                proto.initStencilBits = function() {
                    cc.ClippingNode.WebGLRenderCmd._init_once = true;
                    if (cc.ClippingNode.WebGLRenderCmd._init_once) {
                        cc.stencilBits = cc._renderContext.getParameter(cc._renderContext.STENCIL_BITS);
                        if (cc.stencilBits <= 0) {
                            cc.log("Stencil buffer is not enabled.");
                        }
                        cc.ClippingNode.WebGLRenderCmd._init_once = false;
                    }
                };
                proto.transform = function(parentCmd, recursive) {
                    var node = this._node;
                    _ccsg.Node.WebGLRenderCmd.prototype.transform.call(this, parentCmd, recursive);
                    if (node._stencil) {
                        node._stencil._renderCmd.transform(this, recursive);
                    }
                };
                proto.visit = function(parentCmd) {
                    var node = this._node;
                    if (!node._visible) {
                        return;
                    }
                    if (node._parent && node._parent._renderCmd) {
                        this._curLevel = node._parent._renderCmd._curLevel + 1;
                    }
                    if (cc.stencilBits < 1) {
                        _ccsg.Node.WebGLRenderCmd.prototype.visit.call(this, parentCmd);
                        return;
                    }
                    if (!node._stencil || !node._stencil.visible) {
                        if (node.inverted) {
                            _ccsg.Node.WebGLRenderCmd.prototype.visit.call(this, parentCmd);
                        }
                        return;
                    }
                    if (cc.ClippingNode.WebGLRenderCmd._layer + 1 === cc.stencilBits) {
                        cc.ClippingNode.WebGLRenderCmd._visit_once = true;
                        if (cc.ClippingNode.WebGLRenderCmd._visit_once) {
                            cc.log("Nesting more than " + cc.stencilBits + "stencils is not supported. Everything will be drawn without stencil for this node and its children.");
                            cc.ClippingNode.WebGLRenderCmd._visit_once = false;
                        }
                        _ccsg.Node.WebGLRenderCmd.prototype.visit.call(this, parentCmd);
                        return;
                    }
                    cc.renderer.pushRenderCommand(this._beforeVisitCmd);
                    var currentStack = cc.current_stack;
                    currentStack.stack.push(currentStack.top);
                    this._syncStatus(parentCmd);
                    currentStack.top = this._stackMatrix;
                    node._stencil._renderCmd.visit(this);
                    cc.renderer.pushRenderCommand(this._afterDrawStencilCmd);
                    var locChildren = node._children;
                    if (locChildren && locChildren.length > 0) {
                        var childLen = locChildren.length;
                        node.sortAllChildren();
                        for (var i = 0; i < childLen; i++) {
                            locChildren[i]._renderCmd.visit(this);
                        }
                    }
                    cc.renderer.pushRenderCommand(this._afterVisitCmd);
                    this._dirtyFlag = 0;
                    currentStack.top = currentStack.stack.pop();
                };
                proto.setStencil = function(stencil) {
                    var node = this._node;
                    if (node._stencil) {
                        node._stencil._parent = null;
                    }
                    node._stencil = stencil;
                    if (node._stencil) {
                        node._stencil._parent = node;
                    }
                };
                proto._drawFullScreenQuadClearStencil = function() {
                    var projStack = cc.projection_matrix_stack;
                    projStack.push();
                    projStack.top.identity();
                    var modelViewStack = cc.modelview_matrix_stack;
                    modelViewStack.push();
                    modelViewStack.top.identity();
                    cc._drawingUtil.drawSolidRect(cc.p(-1, -1), cc.p(1, 1), cc.color(255, 255, 255, 255));
                    projStack.pop();
                    modelViewStack.pop();
                };
                proto._onBeforeVisit = function(ctx) {
                    var gl = ctx || cc._renderContext, node = this._node;
                    cc.ClippingNode.WebGLRenderCmd._layer++;
                    var mask_layer = 1 << cc.ClippingNode.WebGLRenderCmd._layer;
                    var mask_layer_l = mask_layer - 1;
                    this._mask_layer_le = mask_layer | mask_layer_l;
                    this._currentStencilEnabled = gl.isEnabled(gl.STENCIL_TEST);
                    this._currentStencilWriteMask = gl.getParameter(gl.STENCIL_WRITEMASK);
                    this._currentStencilFunc = gl.getParameter(gl.STENCIL_FUNC);
                    this._currentStencilRef = gl.getParameter(gl.STENCIL_REF);
                    this._currentStencilValueMask = gl.getParameter(gl.STENCIL_VALUE_MASK);
                    this._currentStencilFail = gl.getParameter(gl.STENCIL_FAIL);
                    this._currentStencilPassDepthFail = gl.getParameter(gl.STENCIL_PASS_DEPTH_FAIL);
                    this._currentStencilPassDepthPass = gl.getParameter(gl.STENCIL_PASS_DEPTH_PASS);
                    gl.enable(gl.STENCIL_TEST);
                    gl.stencilMask(mask_layer);
                    this._currentDepthWriteMask = gl.getParameter(gl.DEPTH_WRITEMASK);
                    gl.depthMask(false);
                    gl.stencilFunc(gl.NEVER, mask_layer, mask_layer);
                    gl.stencilOp(!node.inverted ? gl.ZERO : gl.REPLACE, gl.KEEP, gl.KEEP);
                    this._drawFullScreenQuadClearStencil();
                    gl.stencilFunc(gl.NEVER, mask_layer, mask_layer);
                    gl.stencilOp(!node.inverted ? gl.REPLACE : gl.ZERO, gl.KEEP, gl.KEEP);
                    if (node.alphaThreshold < 1) {
                        var program = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST);
                        var alphaValueLocation = gl.getUniformLocation(program.getProgram(), cc.UNIFORM_ALPHA_TEST_VALUE_S);
                        cc.glUseProgram(program.getProgram());
                        program.setUniformLocationWith1f(alphaValueLocation, node.alphaThreshold);
                        cc.setProgram(node._stencil, program);
                    }
                };
                proto._onAfterDrawStencil = function(ctx) {
                    var gl = ctx || cc._renderContext;
                    gl.depthMask(this._currentDepthWriteMask);
                    gl.stencilFunc(gl.EQUAL, this._mask_layer_le, this._mask_layer_le);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
                };
                proto._onAfterVisit = function(ctx) {
                    var gl = ctx || cc._renderContext;
                    gl.stencilFunc(this._currentStencilFunc, this._currentStencilRef, this._currentStencilValueMask);
                    gl.stencilOp(this._currentStencilFail, this._currentStencilPassDepthFail, this._currentStencilPassDepthPass);
                    gl.stencilMask(this._currentStencilWriteMask);
                    if (!this._currentStencilEnabled) {
                        gl.disable(gl.STENCIL_TEST);
                    }
                    cc.ClippingNode.WebGLRenderCmd._layer--;
                };
            }();
            cc.HashElement = cc._Class.extend({
                actions: null,
                target: null,
                actionIndex: 0,
                currentAction: null,
                currentActionSalvaged: false,
                paused: false,
                hh: null,
                ctor: function() {
                    this.actions = [];
                    this.target = null;
                    this.actionIndex = 0;
                    this.currentAction = null;
                    this.currentActionSalvaged = false;
                    this.paused = false;
                    this.hh = null;
                }
            });
            cc.ActionManager = cc._Class.extend({
                _hashTargets: null,
                _arrayTargets: null,
                _currentTarget: null,
                _currentTargetSalvaged: false,
                _searchElementByTarget: function(arr, target) {
                    for (var k = 0; k < arr.length; k++) {
                        if (target === arr[k].target) {
                            return arr[k];
                        }
                    }
                    return null;
                },
                ctor: function() {
                    this._hashTargets = {};
                    this._arrayTargets = [];
                    this._currentTarget = null;
                    this._currentTargetSalvaged = false;
                },
                addAction: function(action, target, paused) {
                    if (!action) {
                        throw new Error("cc.ActionManager.addAction(): action must be non-null");
                    }
                    if (!target) {
                        throw new Error("cc.ActionManager.addAction(): action must be non-null");
                    }
                    var element = this._hashTargets[target.__instanceId];
                    if (!element) {
                        element = new cc.HashElement();
                        element.paused = paused;
                        element.target = target;
                        this._hashTargets[target.__instanceId] = element;
                        this._arrayTargets.push(element);
                    }
                    this._actionAllocWithHashElement(element);
                    element.actions.push(action);
                    action.startWithTarget(target);
                },
                removeAllActions: function() {
                    var locTargets = this._arrayTargets;
                    for (var i = 0; i < locTargets.length; i++) {
                        var element = locTargets[i];
                        if (element) {
                            this.removeAllActionsFromTarget(element.target, true);
                        }
                    }
                },
                removeAllActionsFromTarget: function(target, forceDelete) {
                    if (null == target) {
                        return;
                    }
                    var element = this._hashTargets[target.__instanceId];
                    if (element) {
                        if (-1 !== element.actions.indexOf(element.currentAction) && !element.currentActionSalvaged) {
                            element.currentActionSalvaged = true;
                        }
                        element.actions.length = 0;
                        if (this._currentTarget === element && !forceDelete) {
                            this._currentTargetSalvaged = true;
                        } else {
                            this._deleteHashElement(element);
                        }
                    }
                },
                removeAction: function(action) {
                    if (null == action) {
                        return;
                    }
                    var target = action.getOriginalTarget();
                    var element = this._hashTargets[target.__instanceId];
                    if (element) {
                        for (var i = 0; i < element.actions.length; i++) {
                            if (element.actions[i] === action) {
                                element.actions.splice(i, 1);
                                break;
                            }
                        }
                    } else {
                        cc.log(cc._LogInfos.ActionManager.removeAction);
                    }
                },
                removeActionByTag: function(tag, target) {
                    if (tag === cc.ACTION_TAG_INVALID) {
                        cc.log(cc._LogInfos.ActionManager.addAction);
                    }
                    cc.assert(target, cc._LogInfos.ActionManager.addAction);
                    var element = this._hashTargets[target.__instanceId];
                    if (element) {
                        var limit = element.actions.length;
                        for (var i = 0; i < limit; ++i) {
                            var action = element.actions[i];
                            if (action && action.getTag() === tag && action.getOriginalTarget() === target) {
                                this._removeActionAtIndex(i, element);
                                break;
                            }
                        }
                    }
                },
                getActionByTag: function(tag, target) {
                    if (tag === cc.ACTION_TAG_INVALID) {
                        cc.log(cc._LogInfos.ActionManager.getActionByTag);
                    }
                    var element = this._hashTargets[target.__instanceId];
                    if (element) {
                        if (null != element.actions) {
                            for (var i = 0; i < element.actions.length; ++i) {
                                var action = element.actions[i];
                                if (action && action.getTag() === tag) {
                                    return action;
                                }
                            }
                        }
                        cc.log(cc._LogInfos.ActionManager.getActionByTag_2, tag);
                    }
                    return null;
                },
                numberOfRunningActionsInTarget: function(target) {
                    var element = this._hashTargets[target.__instanceId];
                    if (element) {
                        return element.actions ? element.actions.length : 0;
                    }
                    return 0;
                },
                pauseTarget: function(target) {
                    var element = this._hashTargets[target.__instanceId];
                    if (element) {
                        element.paused = true;
                    }
                },
                resumeTarget: function(target) {
                    var element = this._hashTargets[target.__instanceId];
                    if (element) {
                        element.paused = false;
                    }
                },
                pauseAllRunningActions: function() {
                    var idsWithActions = [];
                    var locTargets = this._arrayTargets;
                    for (var i = 0; i < locTargets.length; i++) {
                        var element = locTargets[i];
                        if (element && !element.paused) {
                            element.paused = true;
                            idsWithActions.push(element.target);
                        }
                    }
                    return idsWithActions;
                },
                resumeTargets: function(targetsToResume) {
                    if (!targetsToResume) {
                        return;
                    }
                    for (var i = 0; i < targetsToResume.length; i++) {
                        if (targetsToResume[i]) {
                            this.resumeTarget(targetsToResume[i]);
                        }
                    }
                },
                purgeSharedManager: function() {
                    cc.director.getScheduler().unscheduleUpdate(this);
                },
                _removeActionAtIndex: function(index, element) {
                    var action = element.actions[index];
                    if (action === element.currentAction && !element.currentActionSalvaged) {
                        element.currentActionSalvaged = true;
                    }
                    element.actions.splice(index, 1);
                    if (element.actionIndex >= index) {
                        element.actionIndex--;
                    }
                    if (0 === element.actions.length) {
                        if (this._currentTarget === element) {
                            this._currentTargetSalvaged = true;
                        } else {
                            this._deleteHashElement(element);
                        }
                    }
                },
                _deleteHashElement: function(element) {
                    var ret = false;
                    if (element) {
                        if (this._hashTargets[element.target.__instanceId]) {
                            delete this._hashTargets[element.target.__instanceId];
                            cc.js.array.remove(this._arrayTargets, element);
                            ret = true;
                        }
                        element.actions = null;
                        element.target = null;
                    }
                    return ret;
                },
                _actionAllocWithHashElement: function(element) {
                    if (null == element.actions) {
                        element.actions = [];
                    }
                },
                update: function(dt) {
                    var locTargets = this._arrayTargets, locCurrTarget;
                    for (var elt = 0; elt < locTargets.length; elt++) {
                        this._currentTarget = locTargets[elt];
                        locCurrTarget = this._currentTarget;
                        if (!locCurrTarget.paused) {
                            for (locCurrTarget.actionIndex = 0; locCurrTarget.actionIndex < (locCurrTarget.actions ? locCurrTarget.actions.length : 0); locCurrTarget.actionIndex++) {
                                locCurrTarget.currentAction = locCurrTarget.actions[locCurrTarget.actionIndex];
                                if (!locCurrTarget.currentAction) {
                                    continue;
                                }
                                locCurrTarget.currentActionSalvaged = false;
                                locCurrTarget.currentAction.step(dt * (locCurrTarget.currentAction._speedMethod ? locCurrTarget.currentAction._speed : 1));
                                if (locCurrTarget.currentActionSalvaged) {
                                    locCurrTarget.currentAction = null;
                                } else {
                                    if (locCurrTarget.currentAction.isDone()) {
                                        locCurrTarget.currentAction.stop();
                                        var action = locCurrTarget.currentAction;
                                        locCurrTarget.currentAction = null;
                                        this.removeAction(action);
                                    }
                                }
                                locCurrTarget.currentAction = null;
                            }
                        }
                        if (this._currentTargetSalvaged && 0 === locCurrTarget.actions.length) {
                            this._deleteHashElement(locCurrTarget) && elt--;
                        }
                    }
                }
            });
            cc.ACTION_TAG_INVALID = -1;
            cc.Action = cc._Class.extend({
                originalTarget: null,
                target: null,
                tag: cc.ACTION_TAG_INVALID,
                ctor: function() {
                    this.originalTarget = null;
                    this.target = null;
                    this.tag = cc.ACTION_TAG_INVALID;
                },
                clone: function() {
                    var action = new cc.Action();
                    action.originalTarget = null;
                    action.target = null;
                    action.tag = this.tag;
                    return action;
                },
                isDone: function() {
                    return true;
                },
                startWithTarget: function(target) {
                    this.originalTarget = target;
                    this.target = target;
                },
                stop: function() {
                    this.target = null;
                },
                step: function(dt) {
                    cc.log("[Action step]. override me");
                },
                update: function(dt) {
                    cc.log("[Action update]. override me");
                },
                getTarget: function() {
                    return this.target;
                },
                setTarget: function(target) {
                    this.target = target;
                },
                getOriginalTarget: function() {
                    return this.originalTarget;
                },
                setOriginalTarget: function(originalTarget) {
                    this.originalTarget = originalTarget;
                },
                getTag: function() {
                    return this.tag;
                },
                setTag: function(tag) {
                    this.tag = tag;
                },
                retain: function() {},
                release: function() {}
            });
            cc.action = function() {
                return new cc.Action();
            };
            cc.Action.create = cc.action;
            cc.FiniteTimeAction = cc.Action.extend({
                _duration: 0,
                ctor: function() {
                    cc.Action.prototype.ctor.call(this);
                    this._duration = 0;
                },
                getDuration: function() {
                    return this._duration * (this._timesForRepeat || 1);
                },
                setDuration: function(duration) {
                    this._duration = duration;
                },
                reverse: function() {
                    cc.log("cocos2d: FiniteTimeAction#reverse: Implement me");
                    return null;
                },
                clone: function() {
                    return new cc.FiniteTimeAction();
                }
            });
            cc.Speed = cc.Action.extend({
                _speed: 0,
                _innerAction: null,
                ctor: function(action, speed) {
                    cc.Action.prototype.ctor.call(this);
                    this._speed = 0;
                    this._innerAction = null;
                    action && this.initWithAction(action, speed);
                },
                getSpeed: function() {
                    return this._speed;
                },
                setSpeed: function(speed) {
                    this._speed = speed;
                },
                initWithAction: function(action, speed) {
                    if (!action) {
                        throw new Error("cc.Speed.initWithAction(): action must be non nil");
                    }
                    this._innerAction = action;
                    this._speed = speed;
                    return true;
                },
                clone: function() {
                    var action = new cc.Speed();
                    action.initWithAction(this._innerAction.clone(), this._speed);
                    return action;
                },
                startWithTarget: function(target) {
                    cc.Action.prototype.startWithTarget.call(this, target);
                    this._innerAction.startWithTarget(target);
                },
                stop: function() {
                    this._innerAction.stop();
                    cc.Action.prototype.stop.call(this);
                },
                step: function(dt) {
                    this._innerAction.step(dt * this._speed);
                },
                isDone: function() {
                    return this._innerAction.isDone();
                },
                reverse: function() {
                    return new cc.Speed(this._innerAction.reverse(), this._speed);
                },
                setInnerAction: function(action) {
                    if (this._innerAction !== action) {
                        this._innerAction = action;
                    }
                },
                getInnerAction: function() {
                    return this._innerAction;
                }
            });
            cc.speed = function(action, speed) {
                return new cc.Speed(action, speed);
            };
            cc.Speed.create = cc.speed;
            cc.Follow = cc.Action.extend({
                _followedNode: null,
                _boundarySet: false,
                _boundaryFullyCovered: false,
                _halfScreenSize: null,
                _fullScreenSize: null,
                _worldRect: null,
                leftBoundary: 0,
                rightBoundary: 0,
                topBoundary: 0,
                bottomBoundary: 0,
                ctor: function(followedNode, rect) {
                    cc.Action.prototype.ctor.call(this);
                    this._followedNode = null;
                    this._boundarySet = false;
                    this._boundaryFullyCovered = false;
                    this._halfScreenSize = null;
                    this._fullScreenSize = null;
                    this.leftBoundary = 0;
                    this.rightBoundary = 0;
                    this.topBoundary = 0;
                    this.bottomBoundary = 0;
                    this._worldRect = cc.rect(0, 0, 0, 0);
                    if (followedNode) {
                        rect ? this.initWithTarget(followedNode, rect) : this.initWithTarget(followedNode);
                    }
                },
                clone: function() {
                    var action = new cc.Follow();
                    var locRect = this._worldRect;
                    var rect = new cc.Rect(locRect.x, locRect.y, locRect.width, locRect.height);
                    action.initWithTarget(this._followedNode, rect);
                    return action;
                },
                isBoundarySet: function() {
                    return this._boundarySet;
                },
                setBoudarySet: function(value) {
                    this._boundarySet = value;
                },
                initWithTarget: function(followedNode, rect) {
                    if (!followedNode) {
                        throw new Error("cc.Follow.initWithAction(): followedNode must be non nil");
                    }
                    var _this = this;
                    rect = rect || cc.rect(0, 0, 0, 0);
                    _this._followedNode = followedNode;
                    _this._worldRect = rect;
                    _this._boundarySet = !cc._rectEqualToZero(rect);
                    _this._boundaryFullyCovered = false;
                    var winSize = cc.director.getWinSize();
                    _this._fullScreenSize = cc.p(winSize.width, winSize.height);
                    _this._halfScreenSize = cc.pMult(_this._fullScreenSize, .5);
                    if (_this._boundarySet) {
                        _this.leftBoundary = -(rect.x + rect.width - _this._fullScreenSize.x);
                        _this.rightBoundary = -rect.x;
                        _this.topBoundary = -rect.y;
                        _this.bottomBoundary = -(rect.y + rect.height - _this._fullScreenSize.y);
                        if (_this.rightBoundary < _this.leftBoundary) {
                            _this.rightBoundary = _this.leftBoundary = (_this.leftBoundary + _this.rightBoundary) / 2;
                        }
                        if (_this.topBoundary < _this.bottomBoundary) {
                            _this.topBoundary = _this.bottomBoundary = (_this.topBoundary + _this.bottomBoundary) / 2;
                        }
                        if (_this.topBoundary === _this.bottomBoundary && _this.leftBoundary === _this.rightBoundary) {
                            _this._boundaryFullyCovered = true;
                        }
                    }
                    return true;
                },
                step: function(dt) {
                    var tempPosX = this._followedNode.x;
                    var tempPosY = this._followedNode.y;
                    tempPosX = this._halfScreenSize.x - tempPosX;
                    tempPosY = this._halfScreenSize.y - tempPosY;
                    this.target._renderCmd._dirtyFlag = 0;
                    if (this._boundarySet) {
                        if (this._boundaryFullyCovered) {
                            return;
                        }
                        this.target.setPosition(cc.clampf(tempPosX, this.leftBoundary, this.rightBoundary), cc.clampf(tempPosY, this.bottomBoundary, this.topBoundary));
                    } else {
                        this.target.setPosition(tempPosX, tempPosY);
                    }
                },
                isDone: function() {
                    return !this._followedNode.running;
                },
                stop: function() {
                    this.target = null;
                    cc.Action.prototype.stop.call(this);
                }
            });
            cc.follow = function(followedNode, rect) {
                return new cc.Follow(followedNode, rect);
            };
            cc.Follow.create = cc.follow;
            cc.ActionInterval = cc.FiniteTimeAction.extend({
                _elapsed: 0,
                _firstTick: false,
                _easeList: null,
                _timesForRepeat: 1,
                _repeatForever: false,
                _repeatMethod: false,
                _speed: 1,
                _speedMethod: false,
                ctor: function(d) {
                    this._speed = 1;
                    this._timesForRepeat = 1;
                    this._repeatForever = false;
                    this.MAX_VALUE = 2;
                    this._repeatMethod = false;
                    this._speedMethod = false;
                    cc.FiniteTimeAction.prototype.ctor.call(this);
                    void 0 !== d && this.initWithDuration(d);
                },
                getElapsed: function() {
                    return this._elapsed;
                },
                initWithDuration: function(d) {
                    this._duration = 0 === d ? cc.FLT_EPSILON : d;
                    this._elapsed = 0;
                    this._firstTick = true;
                    return true;
                },
                isDone: function() {
                    return this._elapsed >= this._duration;
                },
                _cloneDecoration: function(action) {
                    action._repeatForever = this._repeatForever;
                    action._speed = this._speed;
                    action._timesForRepeat = this._timesForRepeat;
                    action._easeList = this._easeList;
                    action._speedMethod = this._speedMethod;
                    action._repeatMethod = this._repeatMethod;
                },
                _reverseEaseList: function(action) {
                    if (this._easeList) {
                        action._easeList = [];
                        for (var i = 0; i < this._easeList.length; i++) {
                            action._easeList.push(this._easeList[i].reverse());
                        }
                    }
                },
                clone: function() {
                    var action = new cc.ActionInterval(this._duration);
                    this._cloneDecoration(action);
                    return action;
                },
                easing: function(easeObj) {
                    if (this._easeList) {
                        this._easeList.length = 0;
                    } else {
                        this._easeList = [];
                    }
                    for (var i = 0; i < arguments.length; i++) {
                        this._easeList.push(arguments[i]);
                    }
                    return this;
                },
                _computeEaseTime: function(dt) {
                    var locList = this._easeList;
                    if (!locList || 0 === locList.length) {
                        return dt;
                    }
                    for (var i = 0, n = locList.length; i < n; i++) {
                        dt = locList[i].easing(dt);
                    }
                    return dt;
                },
                step: function(dt) {
                    if (this._firstTick) {
                        this._firstTick = false;
                        this._elapsed = 0;
                    } else {
                        this._elapsed += dt;
                    }
                    var t = this._elapsed / (this._duration > 1.192092896e-7 ? this._duration : 1.192092896e-7);
                    t = 1 > t ? t : 1;
                    this.update(t > 0 ? t : 0);
                    if (this._repeatMethod && this._timesForRepeat > 1 && this.isDone()) {
                        if (!this._repeatForever) {
                            this._timesForRepeat--;
                        }
                        this.startWithTarget(this.target);
                        this.step(this._elapsed - this._duration);
                    }
                },
                startWithTarget: function(target) {
                    cc.Action.prototype.startWithTarget.call(this, target);
                    this._elapsed = 0;
                    this._firstTick = true;
                },
                reverse: function() {
                    cc.log("cc.IntervalAction: reverse not implemented.");
                    return null;
                },
                setAmplitudeRate: function(amp) {
                    cc.log("cc.ActionInterval.setAmplitudeRate(): it should be overridden in subclass.");
                },
                getAmplitudeRate: function() {
                    cc.log("cc.ActionInterval.getAmplitudeRate(): it should be overridden in subclass.");
                    return 0;
                },
                speed: function(speed) {
                    if (speed <= 0) {
                        cc.log("The speed parameter error");
                        return this;
                    }
                    this._speedMethod = true;
                    this._speed *= speed;
                    return this;
                },
                getSpeed: function() {
                    return this._speed;
                },
                setSpeed: function(speed) {
                    this._speed = speed;
                    return this;
                },
                repeat: function(times) {
                    times = Math.round(times);
                    if (isNaN(times) || times < 1) {
                        cc.log("The repeat parameter error");
                        return this;
                    }
                    this._repeatMethod = true;
                    this._timesForRepeat *= times;
                    return this;
                },
                repeatForever: function() {
                    this._repeatMethod = true;
                    this._timesForRepeat = this.MAX_VALUE;
                    this._repeatForever = true;
                    return this;
                }
            });
            cc.actionInterval = function(d) {
                return new cc.ActionInterval(d);
            };
            cc.ActionInterval.create = cc.actionInterval;
            cc.Sequence = cc.ActionInterval.extend({
                _actions: null,
                _split: null,
                _last: 0,
                ctor: function(tempArray) {
                    cc.ActionInterval.prototype.ctor.call(this);
                    this._actions = [];
                    var paramArray = tempArray instanceof Array ? tempArray : arguments;
                    var last = paramArray.length - 1;
                    if (last >= 0 && null == paramArray[last]) {
                        cc.log("parameters should not be ending with null in Javascript");
                    }
                    if (last >= 0) {
                        var prev = paramArray[0], action1;
                        for (var i = 1; i < last; i++) {
                            if (paramArray[i]) {
                                action1 = prev;
                                prev = cc.Sequence._actionOneTwo(action1, paramArray[i]);
                            }
                        }
                        this.initWithTwoActions(prev, paramArray[last]);
                    }
                },
                initWithTwoActions: function(actionOne, actionTwo) {
                    if (!actionOne || !actionTwo) {
                        throw new Error("cc.Sequence.initWithTwoActions(): arguments must all be non nil");
                    }
                    var d = actionOne._duration + actionTwo._duration;
                    this.initWithDuration(d);
                    this._actions[0] = actionOne;
                    this._actions[1] = actionTwo;
                    return true;
                },
                clone: function() {
                    var action = new cc.Sequence();
                    this._cloneDecoration(action);
                    action.initWithTwoActions(this._actions[0].clone(), this._actions[1].clone());
                    return action;
                },
                startWithTarget: function(target) {
                    cc.ActionInterval.prototype.startWithTarget.call(this, target);
                    this._split = this._actions[0]._duration / this._duration;
                    this._last = -1;
                },
                stop: function() {
                    if (-1 !== this._last) {
                        this._actions[this._last].stop();
                    }
                    cc.Action.prototype.stop.call(this);
                },
                update: function(dt) {
                    var new_t, found = 0;
                    var locSplit = this._split, locActions = this._actions, locLast = this._last, actionFound;
                    dt = this._computeEaseTime(dt);
                    if (dt < locSplit) {
                        new_t = 0 !== locSplit ? dt / locSplit : 1;
                        if (0 === found && 1 === locLast) {
                            locActions[1].update(0);
                            locActions[1].stop();
                        }
                    } else {
                        found = 1;
                        new_t = 1 === locSplit ? 1 : (dt - locSplit) / (1 - locSplit);
                        if (-1 === locLast) {
                            locActions[0].startWithTarget(this.target);
                            locActions[0].update(1);
                            locActions[0].stop();
                        }
                        if (!locLast) {
                            locActions[0].update(1);
                            locActions[0].stop();
                        }
                    }
                    actionFound = locActions[found];
                    if (locLast === found && actionFound.isDone()) {
                        return;
                    }
                    if (locLast !== found) {
                        actionFound.startWithTarget(this.target);
                    }
                    new_t *= actionFound._timesForRepeat;
                    actionFound.update(new_t > 1 ? new_t % 1 : new_t);
                    this._last = found;
                },
                reverse: function() {
                    var action = cc.Sequence._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());
                    this._cloneDecoration(action);
                    this._reverseEaseList(action);
                    return action;
                }
            });
            cc.sequence = function(tempArray) {
                var paramArray = tempArray instanceof Array ? tempArray : arguments;
                if (paramArray.length > 0 && null == paramArray[paramArray.length - 1]) {
                    cc.log("parameters should not be ending with null in Javascript");
                }
                var result, current, i, repeat;
                while (paramArray && paramArray.length > 0) {
                    current = Array.prototype.shift.call(paramArray);
                    repeat = current._timesForRepeat || 1;
                    current._repeatMethod = false;
                    current._timesForRepeat = 1;
                    i = 0;
                    if (!result) {
                        result = current;
                        i = 1;
                    }
                    for (i; i < repeat; i++) {
                        result = cc.Sequence._actionOneTwo(result, current);
                    }
                }
                return result;
            };
            cc.Sequence.create = cc.sequence;
            cc.Sequence._actionOneTwo = function(actionOne, actionTwo) {
                var sequence = new cc.Sequence();
                sequence.initWithTwoActions(actionOne, actionTwo);
                return sequence;
            };
            cc.Repeat = cc.ActionInterval.extend({
                _times: 0,
                _total: 0,
                _nextDt: 0,
                _actionInstant: false,
                _innerAction: null,
                ctor: function(action, times) {
                    cc.ActionInterval.prototype.ctor.call(this);
                    void 0 !== times && this.initWithAction(action, times);
                },
                initWithAction: function(action, times) {
                    var duration = action._duration * times;
                    if (this.initWithDuration(duration)) {
                        this._times = times;
                        this._innerAction = action;
                        if (action instanceof cc.ActionInstant) {
                            this._actionInstant = true;
                            this._times -= 1;
                        }
                        this._total = 0;
                        return true;
                    }
                    return false;
                },
                clone: function() {
                    var action = new cc.Repeat();
                    this._cloneDecoration(action);
                    action.initWithAction(this._innerAction.clone(), this._times);
                    return action;
                },
                startWithTarget: function(target) {
                    this._total = 0;
                    this._nextDt = this._innerAction._duration / this._duration;
                    cc.ActionInterval.prototype.startWithTarget.call(this, target);
                    this._innerAction.startWithTarget(target);
                },
                stop: function() {
                    this._innerAction.stop();
                    cc.Action.prototype.stop.call(this);
                },
                update: function(dt) {
                    dt = this._computeEaseTime(dt);
                    var locInnerAction = this._innerAction;
                    var locDuration = this._duration;
                    var locTimes = this._times;
                    var locNextDt = this._nextDt;
                    if (dt >= locNextDt) {
                        while (dt > locNextDt && this._total < locTimes) {
                            locInnerAction.update(1);
                            this._total++;
                            locInnerAction.stop();
                            locInnerAction.startWithTarget(this.target);
                            locNextDt += locInnerAction._duration / locDuration;
                            this._nextDt = locNextDt;
                        }
                        if (dt >= 1 && this._total < locTimes) {
                            this._total++;
                        }
                        if (!this._actionInstant) {
                            if (this._total === locTimes) {
                                locInnerAction.update(1);
                                locInnerAction.stop();
                            } else {
                                locInnerAction.update(dt - (locNextDt - locInnerAction._duration / locDuration));
                            }
                        }
                    } else {
                        locInnerAction.update(dt * locTimes % 1);
                    }
                },
                isDone: function() {
                    return this._total === this._times;
                },
                reverse: function() {
                    var action = new cc.Repeat(this._innerAction.reverse(), this._times);
                    this._cloneDecoration(action);
                    this._reverseEaseList(action);
                    return action;
                },
                setInnerAction: function(action) {
                    if (this._innerAction !== action) {
                        this._innerAction = action;
                    }
                },
                getInnerAction: function() {
                    return this._innerAction;
                }
            });
            cc.repeat = function(action, times) {
                return new cc.Repeat(action, times);
            };
            cc.Repeat.create = cc.repeat;
            cc.RepeatForever = cc.ActionInterval.extend({
                _innerAction: null,
                ctor: function(action) {
                    cc.ActionInterval.prototype.ctor.call(this);
                    this._innerAction = null;
                    action && this.initWithAction(action);
                },
                initWithAction: function(action) {
                    if (!action) {
                        throw new Error("cc.RepeatForever.initWithAction(): action must be non null");
                    }
                    this._innerAction = action;
                    return true;
                },
                clone: function() {
                    var action = new cc.RepeatForever();
                    this._cloneDecoration(action);
                    action.initWithAction(this._innerAction.clone());
                    return action;
                },
                startWithTarget: function(target) {
                    cc.ActionInterval.prototype.startWithTarget.call(this, target);
                    this._innerAction.startWithTarget(target);
                },
                step: function(dt) {
                    var locInnerAction = this._innerAction;
                    locInnerAction.step(dt);
                    if (locInnerAction.isDone()) {
                        locInnerAction.startWithTarget(this.target);
                        locInnerAction.step(locInnerAction.getElapsed() - locInnerAction._duration);
                    }
                },
                isDone: function() {
                    return false;
                },
                reverse: function() {
                    var action = new cc.RepeatForever(this._innerAction.reverse());
                    this._cloneDecoration(action);
                    this._reverseEaseList(action);
                    return action;
                },
                setInnerAction: function(action) {
                    if (this._innerAction !== action) {
                        this._innerAction = action;
                    }
                },
                getInnerAction: function() {
                    return this._innerAction;
                }
            });
            cc.repeatForever = function(action) {
                return new cc.RepeatForever(action);
            };
            cc.RepeatForever.create = cc.repeatForever;
            cc.Spawn = cc.ActionInterval.extend({
                _one: null,
                _two: null,
                ctor: function(tempArray) {
                    cc.ActionInterval.prototype.ctor.call(this);
                    this._one = null;
                    this._two = null;
                    var paramArray = tempArray instanceof Array ? tempArray : arguments;
                    var last = paramArray.length - 1;
                    if (last >= 0 && null == paramArray[last]) {
                        cc.log("parameters should not be ending with null in Javascript");
                    }
                    if (last >= 0) {
                        var prev = paramArray[0], action1;
                        for (var i = 1; i < last; i++) {
                            if (paramArray[i]) {
                                action1 = prev;
                                prev = cc.Spawn._actionOneTwo(action1, paramArray[i]);
                            }
                        }
                        this.initWithTwoActions(prev, paramArray[last]);
                    }
                },
                initWithTwoActions: function(action1, action2) {
                    if (!action1 || !action2) {
                        throw new Error("cc.Spawn.initWithTwoActions(): arguments must all be non null");
                    }
                    var ret = false;
                    var d1 = action1._duration;
                    var d2 = action2._duration;
                    if (this.initWithDuration(Math.max(d1, d2))) {
                        this._one = action1;
                        this._two = action2;
                        if (d1 > d2) {
                            this._two = cc.Sequence._actionOneTwo(action2, cc.delayTime(d1 - d2));
                        } else {
                            if (d1 < d2) {
                                this._one = cc.Sequence._actionOneTwo(action1, cc.delayTime(d2 - d1));
                            }
                        }
                        ret = true;
                    }
                    return ret;
                },
                clone: function() {
                    var action = new cc.Spawn();
                    this._cloneDecoration(action);
                    action.initWithTwoActions(this._one.clone(), this._two.clone());
                    return action;
                },
                startWithTarget: function(target) {
                    cc.ActionInterval.prototype.startWithTarget.call(this, target);
                    this._one.startWithTarget(target);
                    this._two.startWithTarget(target);
                },
                stop: function() {
                    this._one.stop();
                    this._two.stop();
                    cc.Action.prototype.stop.call(this);
                },
                update: function(dt) {
                    dt = this._computeEaseTime(dt);
                    if (this._one) {
                        this._one.update(dt);
                    }
                    if (this._two) {
                        this._two.update(dt);
                    }
                },
                reverse: function() {
                    var action = cc.Spawn._actionOneTwo(this._one.reverse(), this._two.reverse());
                    this._cloneDecoration(action);
                    this._reverseEaseList(action);
                    return action;
                }
            });
            cc.spawn = function(tempArray) {
                var paramArray = tempArray instanceof Array ? tempArray : arguments;
                if (paramArray.length > 0 && null == paramArray[paramArray.length - 1]) {
                    cc.log("parameters should not be ending with null in Javascript");
                }
                var prev = paramArray[0];
                for (var i = 1; i < paramArray.length; i++) {
                    if (null != paramArray[i]) {
                        prev = cc.Spawn._actionOneTwo(prev, paramArray[i]);
                    }
                }
                return prev;
            };
            cc.Spawn.create = cc.spawn;
            cc.Spawn._actionOneTwo = function(action1, action2) {
                var pSpawn = new cc.Spawn();
                pSpawn.initWithTwoActions(action1, action2);
                return pSpawn;
            };
            cc.RotateTo = cc.ActionInterval.extend({
                _dstAngleX: 0,
                _startAngleX: 0,
                _diffAngleX: 0,
                _dstAngleY: 0,
                _startAngleY: 0,
                _diffAngleY: 0,
                ctor: function(duration, deltaAngleX, deltaAngleY) {
                    cc.ActionInterval.prototype.ctor.call(this);
                    void 0 !== deltaAngleX && this.initWithDuration(duration, deltaAngleX, deltaAngleY);
                },
                initWithDuration: function(duration, deltaAngleX, deltaAngleY) {
                    if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
                        this._dstAngleX = deltaAngleX || 0;
                        this._dstAngleY = deltaAngleY || this._dstAngleX;
                        return true;
                    }
                    return false;
                },
                clone: function() {
                    var action = new cc.RotateTo();
                    this._cloneDecoration(action);
                    action.initWithDuration(this._duration, this._dstAngleX, this._dstAngleY);
                    return action;
                },
                startWithTarget: function(target) {
                    cc.ActionInterval.prototype.startWithTarget.call(this, target);
                    var locStartAngleX = target.rotationX % 360;
                    var locDiffAngleX = this._dstAngleX - locStartAngleX;
                    if (locDiffAngleX > 180) {
                        locDiffAngleX -= 360;
                    }
                    if (locDiffAngleX < -180) {
                        locDiffAngleX += 360;
                    }
                    this._startAngleX = locStartAngleX;
                    this._diffAngleX = locDiffAngleX;
                    this._startAngleY = target.rotationY % 360;
                    var locDiffAngleY = this._dstAngleY - this._startAngleY;
                    if (locDiffAngleY > 180) {
                        locDiffAngleY -= 360;
                    }
                    if (locDiffAngleY < -180) {
                        locDiffAngleY += 360;
                    }
                    this._diffAngleY = locDiffAngleY;
                },
                reverse: function() {
                    cc.log("cc.RotateTo.reverse(): it should be overridden in subclass.");
                },
                update: function(dt) {
                    dt = this._computeEaseTime(dt);
                    if (this.target) {
                        this.target.rotationX = this._startAngleX + this._diffAngleX * dt;
                        this.target.rotationY = this._startAngleY + this._diffAngleY * dt;
                    }
                }
            });
            cc.rotateTo = function(duration, deltaAngleX, deltaAngleY) {
                return new cc.RotateTo(duration, deltaAngleX, deltaAngleY);
            };
            cc.RotateTo.create = cc.rotateTo;
            cc.RotateBy = cc.ActionInterval.extend({
                _angleX: 0,
                _startAngleX: 0,
                _angleY: 0,
                _startAngleY: 0,
                ctor: function(duration, deltaAngleX, deltaAngleY) {
                    cc.ActionInterval.prototype.ctor.call(this);
                    void 0 !== deltaAngleX && this.initWithDuration(duration, deltaAngleX, deltaAngleY);
                },
                initWithDuration: function(duration, deltaAngleX, deltaAngleY) {
                    if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
                        this._angleX = deltaAngleX || 0;
                        this._angleY = deltaAngleY || this._angleX;
                        return true;
                    }
                    return false;
                },
                clone: function() {
                    var action = new cc.RotateBy();
                    this._cloneDecoration(action);
                    action.initWithDuration(this._duration, this._angleX, this._angleY);
                    return action;
                },
                startWithTarget: function(target) {
                    cc.ActionInterval.prototype.startWithTarget.call(this, target);
                    this._startAngleX = target.rotationX;
                    this._startAngleY = target.rotationY;
                },
                update: function(dt) {
                    dt = this._computeEaseTime(dt);
                    if (this.target) {
                        this.target.rotationX = this._startAngleX + this._angleX * dt;
                        this.target.rotationY = this._startAngleY + this._angleY * dt;
                    }
                },
                reverse: function() {
                    var action = new cc.RotateBy(this._duration, -this._angleX, -this._angleY);
                    this._cloneDecoration(action);
                    this._reverseEaseList(action);
                    return action;
                }
            });
            cc.rotateBy = function(duration, deltaAngleX, deltaAngleY) {
                return new cc.RotateBy(duration, deltaAngleX, deltaAngleY);
            };
            cc.RotateBy.create = cc.rotateBy;
            cc.MoveBy = cc.ActionInterval.extend({
                _positionDelta: null,
                _startPosition: null,
                _previousPosition: null,
                ctor: function(duration, deltaPos, deltaY) {
                    cc.ActionInterval.prototype.ctor.call(this);
                    this._positionDelta = cc.p(0, 0);
                    this._startPosition = cc.p(0, 0);
                    this._previousPosition = cc.p(0, 0);
                    void 0 !== deltaPos && this.initWithDuration(duration, deltaPos, deltaY);
                },
                initWithDuration: function(duration, position, y) {
                    if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
                        if (void 0 !== position.x) {
                            y = position.y;
                            position = position.x;
                        }
                        this._positionDelta.x = position;
                        this._positionDelta.y = y;
                        return true;
                    }
                    return false;
                },
                clone: function() {
                    var action = new cc.MoveBy();
                    this._cloneDecoration(action);
                    action.initWithDuration(this._duration, this._positionDelta);
                    return action;
                },
                startWithTarget: function(target) {
                    cc.ActionInterval.prototype.startWithTarget.call(this, target);
                    var locPosX = target.getPositionX();
                    var locPosY = target.getPositionY();
                    this._previousPosition.x = locPosX;
                    this._previousPosition.y = locPosY;
                    this._startPosition.x = locPosX;
                    this._startPosition.y = locPosY;
                },
                update: function(dt) {
                    dt = this._computeEaseTime(dt);
                    if (this.target) {
                        var x = this._positionDelta.x * dt;
                        var y = this._positionDelta.y * dt;
                        var locStartPosition = this._startPosition;
                        if (cc.ENABLE_STACKABLE_ACTIONS) {
                            var targetX = this.target.getPositionX();
                            var targetY = this.target.getPositionY();
                            var locPreviousPosition = this._previousPosition;
                            locStartPosition.x = locStartPosition.x + targetX - locPreviousPosition.x;
                            locStartPosition.y = locStartPosition.y + targetY - locPreviousPosition.y;
                            x += locStartPosition.x;
                            y += locStartPosition.y;
                            locPreviousPosition.x = x;
                            locPreviousPosition.y = y;
                            this.target.setPosition(x, y);
                        } else {
                            this.target.setPosition(locStartPosition.x + x, locStartPosition.y + y);
                        }
                    }
                },
                reverse: function() {
                    var action = new cc.MoveBy(this._duration, cc.p(-this._positionDelta.x, -this._positionDelta.y));
                    this._cloneDecoration(action);
                    this._reverseEaseList(action);
                    return action;
                }
            });
            cc.moveBy = function(duration, deltaPos, deltaY) {
                return new cc.MoveBy(duration, deltaPos, deltaY);
            };
            cc.MoveBy.create = cc.moveBy;
            cc.MoveTo = cc.MoveBy.extend({
                _endPosition: null,
                ctor: function(duration, position, y) {
                    cc.MoveBy.prototype.ctor.call(this);
                    this._endPosition = cc.p(0, 0);
                    void 0 !== position && this.initWithDuration(duration, position, y);
                },
                initWithDuration: function(duration, position, y) {
                    if (cc.MoveBy.prototype.initWithDuration.call(this, duration, position, y)) {
                        if (void 0 !== position.x) {
                            y = position.y;
                            position = position.x;
                        }
                        this._endPosition.x = position;
                        this._endPosition.y = y;
                        return true;
                    }
                    return false;
                },
                clone: function() {
                    var action = new cc.MoveTo();
                    this._cloneDecoration(action);
                    action.initWithDuration(this._duration, this._endPosition);
                    return action;
                },
                startWithTarget: function(target) {
                    cc.MoveBy.prototype.startWithTarget.call(this, target);
                    this._positionDelta.x = this._endPosition.x - target.getPositionX();
                    this._positionDelta.y = this._endPosition.y - target.getPositionY();
                }
            });
            cc.moveTo = function(duration, position, y) {
                return new cc.MoveTo(duration, position, y);
            };
            cc.MoveTo.create = cc.moveTo;
            cc.SkewTo = cc.ActionInterval.extend({
                _skewX: 0,
                _skewY: 0,
                _startSkewX: 0,
                _startSkewY: 0,
                _endSkewX: 0,
                _endSkewY: 0,
                _deltaX: 0,
                _deltaY: 0,
                ctor: function(t, sx, sy) {
                    cc.ActionInterval.prototype.ctor.call(this);
                    void 0 !== sy && this.initWithDuration(t, sx, sy);
                },
                initWithDuration: function(t, sx, sy) {
                    var ret = false;
                    if (cc.ActionInterval.prototype.initWithDuration.call(this, t)) {
                        this._endSkewX = sx;
                        this._endSkewY = sy;
                        ret = true;
                    }
                    return ret;
                },
                clone: function() {
                    var action = new cc.SkewTo();
                    this._cloneDecoration(action);
                    action.initWithDuration(this._duration, this._endSkewX, this._endSkewY);
                    return action;
                },
                startWithTarget: function(target) {
                    cc.ActionInterval.prototype.startWithTarget.call(this, target);
                    this._startSkewX = target.skewX % 180;
                    this._deltaX = this._endSkewX - this._startSkewX;
                    if (this._deltaX > 180) {
                        this._deltaX -= 360;
                    }
                    if (this._deltaX < -180) {
                        this._deltaX += 360;
                    }
                    this._startSkewY = target.skewY % 360;
                    this._deltaY = this._endSkewY - this._startSkewY;
                    if (this._deltaY > 180) {
                        this._deltaY -= 360;
                    }
                    if (this._deltaY < -180) {
                        this._deltaY += 360;
                    }
                },
                update: function(dt) {
                    dt = this._computeEaseTime(dt);
                    this.target.skewX = this._startSkewX + this._deltaX * dt;
                    this.target.skewY = this._startSkewY + this._deltaY * dt;
                }
            });
            cc.skewTo = function(t, sx, sy) {
                return new cc.SkewTo(t, sx, sy);
            };
            cc.SkewTo.create = cc.skewTo;
            cc.SkewBy = cc.SkewTo.extend({
                ctor: function(t, sx, sy) {
                    cc.SkewTo.prototype.ctor.call(this);
                    void 0 !== sy && this.initWithDuration(t, sx, sy);
                },
                initWithDuration: function(t, deltaSkewX, deltaSkewY) {
                    var ret = false;
                    if (cc.SkewTo.prototype.initWithDuration.call(this, t, deltaSkewX, deltaSkewY)) {
                        this._skewX = deltaSkewX;
                        this._skewY = deltaSkewY;
                        ret = true;
                    }
                    return ret;
                },
                clone: function() {
                    var action = new cc.SkewBy();
                    this._cloneDecoration(action);
                    action.initWithDuration(this._duration, this._skewX, this._skewY);
                    return action;
                },
                startWithTarget: function(target) {
                    cc.SkewTo.prototype.startWithTarget.call(this, target);
                    this._deltaX = this._skewX;
                    this._deltaY = this._skewY;
                    this._endSkewX = this._startSkewX + this._deltaX;
                    this._endSkewY = this._startSkewY + this._deltaY;
                },
                reverse: function() {
                    var action = new cc.SkewBy(this._duration, -this._skewX, -this._skewY);
                    this._cloneDecoration(action);
                    this._reverseEaseList(action);
                    return action;
                }
            });
            cc.skewBy = function(t, sx, sy) {
                return new cc.SkewBy(t, sx, sy);
            };
            cc.SkewBy.create = cc.skewBy;
            cc.JumpBy = cc.ActionInterval.extend({
                _startPosition: null,
                _delta: null,
                _height: 0,
                _jumps: 0,
                _previousPosition: null,
                ctor: function(duration, position, y, height, jumps) {
                    cc.ActionInterval.prototype.ctor.call(this);
                    this._startPosition = cc.p(0, 0);
                    this._previousPosition = cc.p(0, 0);
                    this._delta = cc.p(0, 0);
                    void 0 !== height && this.initWithDuration(duration, position, y, height, jumps);
                },
                initWithDuration: function(duration, position, y, height, jumps) {
                    if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
                        if (void 0 === jumps) {
                            jumps = height;
                            height = y;
                            y = position.y;
                            position = position.x;
                        }
                        this._delta.x = position;
                        this._delta.y = y;
                        this._height = height;
                        this._jumps = jumps;
                        return true;
                    }
                    return false;
                },
                clone: function() {
                    var action = new cc.JumpBy();
                    this._cloneDecoration(action);
                    action.initWithDuration(this._duration, this._delta, this._height, this._jumps);
                    return action;
                },
                startWithTarget: function(target) {
                    cc.ActionInterval.prototype.startWithTarget.call(this, target);
                    var locPosX = target.getPositionX();
                    var locPosY = target.getPositionY();
                    this._previousPosition.x = locPosX;
                    this._previousPosition.y = locPosY;
                    this._startPosition.x = locPosX;
                    this._startPosition.y = locPosY;
                },
                update: function(dt) {
                    dt = this._computeEaseTime(dt);
                    if (this.target) {
                        var frac = dt * this._jumps % 1;
                        var y = 4 * this._height * frac * (1 - frac);
                        y += this._delta.y * dt;
                        var x = this._delta.x * dt;
                        var locStartPosition = this._startPosition;
                        if (cc.ENABLE_STACKABLE_ACTIONS) {
                            var targetX = this.target.getPositionX();
                            var targetY = this.target.getPositionY();
                            var locPreviousPosition = this._previousPosition;
                            locStartPosition.x = locStartPosition.x + targetX - locPreviousPosition.x;
                            locStartPosition.y = locStartPosition.y + targetY - locPreviousPosition.y;
                            x += locStartPosition.x;
                            y += locStartPosition.y;
                            locPreviousPosition.x = x;
                            locPreviousPosition.y = y;
                            this.target.setPosition(x, y);
                        } else {
                            this.target.setPosition(locStartPosition.x + x, locStartPosition.y + y);
                        }
                    }
                },
                reverse: function() {
                    var action = new cc.JumpBy(this._duration, cc.p(-this._delta.x, -this._delta.y), this._height, this._jumps);
                    this._cloneDecoration(action);
                    this._reverseEaseList(action);
                    return action;
                }
            });
            cc.jumpBy = function(duration, position, y, height, jumps) {
                return new cc.JumpBy(duration, position, y, height, jumps);
            };
            cc.JumpBy.create = cc.jumpBy;
            cc.JumpTo = cc.JumpBy.extend({
                _endPosition: null,
                ctor: function(duration, position, y, height, jumps) {
                    cc.JumpBy.prototype.ctor.call(this);
                    this._endPosition = cc.p(0, 0);
                    void 0 !== height && this.initWithDuration(duration, position, y, height, jumps);
                },
                initWithDuration: function(duration, position, y, height, jumps) {
                    if (cc.JumpBy.prototype.initWithDuration.call(this, duration, position, y, height, jumps)) {
                        if (void 0 === jumps) {
                            y = position.y;
                            position = position.x;
                        }
                        this._endPosition.x = position;
                        this._endPosition.y = y;
                        return true;
                    }
                    return false;
                },
                startWithTarget: function(target) {
                    cc.JumpBy.prototype.startWithTarget.call(this, target);
                    this._delta.x = this._endPosition.x - this._startPosition.x;
                    this._delta.y = this._endPosition.y - this._startPosition.y;
                },
                clone: function() {
                    var action = new cc.JumpTo();
                    this._cloneDecoration(action);
                    action.initWithDuration(this._duration, this._endPosition, this._height, this._jumps);
                    return action;
                }
            });
            cc.jumpTo = function(duration, position, y, height, jumps) {
                return new cc.JumpTo(duration, position, y, height, jumps);
            };
            cc.JumpTo.create = cc.jumpTo;
            cc.bezierAt = function(a, b, c, d, t) {
                return Math.pow(1 - t, 3) * a + 3 * t * Math.pow(1 - t, 2) * b + 3 * Math.pow(t, 2) * (1 - t) * c + Math.pow(t, 3) * d;
            };
            cc.BezierBy = cc.ActionInterval.extend({
                _config: null,
                _startPosition: null,
                _previousPosition: null,
                ctor: function(t, c) {
                    cc.ActionInterval.prototype.ctor.call(this);
                    this._config = [];
                    this._startPosition = cc.p(0, 0);
                    this._previousPosition = cc.p(0, 0);
                    c && this.initWithDuration(t, c);
                },
                initWithDuration: function(t, c) {
                    if (cc.ActionInterval.prototype.initWithDuration.call(this, t)) {
                        this._config = c;
                        return true;
                    }
                    return false;
                },
                clone: function() {
                    var action = new cc.BezierBy();
                    this._cloneDecoration(action);
                    var newConfigs = [];
                    for (var i = 0; i < this._config.length; i++) {
                        var selConf = this._config[i];
                        newConfigs.push(cc.p(selConf.x, selConf.y));
                    }
                    action.initWithDuration(this._duration, newConfigs);
                    return action;
                },
                startWithTarget: function(target) {
                    cc.ActionInterval.prototype.startWithTarget.call(this, target);
                    var locPosX = target.getPositionX();
                    var locPosY = target.getPositionY();
                    this._previousPosition.x = locPosX;
                    this._previousPosition.y = locPosY;
                    this._startPosition.x = locPosX;
                    this._startPosition.y = locPosY;
                },
                update: function(dt) {
                    dt = this._computeEaseTime(dt);
                    if (this.target) {
                        var locConfig = this._config;
                        var xa = 0;
                        var xb = locConfig[0].x;
                        var xc = locConfig[1].x;
                        var xd = locConfig[2].x;
                        var ya = 0;
                        var yb = locConfig[0].y;
                        var yc = locConfig[1].y;
                        var yd = locConfig[2].y;
                        var x = cc.bezierAt(xa, xb, xc, xd, dt);
                        var y = cc.bezierAt(ya, yb, yc, yd, dt);
                        var locStartPosition = this._startPosition;
                        if (cc.ENABLE_STACKABLE_ACTIONS) {
                            var targetX = this.target.getPositionX();
                            var targetY = this.target.getPositionY();
                            var locPreviousPosition = this._previousPosition;
                            locStartPosition.x = locStartPosition.x + targetX - locPreviousPosition.x;
                            locStartPosition.y = locStartPosition.y + targetY - locPreviousPosition.y;
                            x += locStartPosition.x;
                            y += locStartPosition.y;
                            locPreviousPosition.x = x;
                            locPreviousPosition.y = y;
                            this.target.setPosition(x, y);
                        } else {
                            this.target.setPosition(locStartPosition.x + x, locStartPosition.y + y);
                        }
                    }
                },
                reverse: function() {
                    var locConfig = this._config;
                    var r = [ cc.pAdd(locConfig[1], cc.pNeg(locConfig[2])), cc.pAdd(locConfig[0], cc.pNeg(locConfig[2])), cc.pNeg(locConfig[2]) ];
                    var action = new cc.BezierBy(this._duration, r);
                    this._cloneDecoration(action);
                    this._reverseEaseList(action);
                    return action;
                }
            });
            cc.bezierBy = function(t, c) {
                return new cc.BezierBy(t, c);
            };
            cc.BezierBy.create = cc.bezierBy;
            cc.BezierTo = cc.BezierBy.extend({
                _toConfig: null,
                ctor: function(t, c) {
                    cc.BezierBy.prototype.ctor.call(this);
                    this._toConfig = [];
                    c && this.initWithDuration(t, c);
                },
                initWithDuration: function(t, c) {
                    if (cc.ActionInterval.prototype.initWithDuration.call(this, t)) {
                        this._toConfig = c;
                        return true;
                    }
                    return false;
                },
                clone: function() {
                    var action = new cc.BezierTo();
                    this._cloneDecoration(action);
                    action.initWithDuration(this._duration, this._toConfig);
                    return action;
                },
                startWithTarget: function(target) {
                    cc.BezierBy.prototype.startWithTarget.call(this, target);
                    var locStartPos = this._startPosition;
                    var locToConfig = this._toConfig;
                    var locConfig = this._config;
                    locConfig[0] = cc.pSub(locToConfig[0], locStartPos);
                    locConfig[1] = cc.pSub(locToConfig[1], locStartPos);
                    locConfig[2] = cc.pSub(locToConfig[2], locStartPos);
                }
            });
            cc.bezierTo = function(t, c) {
                return new cc.BezierTo(t, c);
            };
            cc.BezierTo.create = cc.bezierTo;
            cc.ScaleTo = cc.ActionInterval.extend({
                _scaleX: 1,
                _scaleY: 1,
                _startScaleX: 1,
                _startScaleY: 1,
                _endScaleX: 0,
                _endScaleY: 0,
                _deltaX: 0,
                _deltaY: 0,
                ctor: function(duration, sx, sy) {
                    cc.ActionInterval.prototype.ctor.call(this);
                    void 0 !== sx && this.initWithDuration(duration, sx, sy);
                },
                initWithDuration: function(duration, sx, sy) {
                    if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
                        this._endScaleX = sx;
                        this._endScaleY = null != sy ? sy : sx;
                        return true;
                    }
                    return false;
                },
                clone: function() {
                    var action = new cc.ScaleTo();
                    this._cloneDecoration(action);
                    action.initWithDuration(this._duration, this._endScaleX, this._endScaleY);
                    return action;
                },
                startWithTarget: function(target) {
                    cc.ActionInterval.prototype.startWithTarget.call(this, target);
                    this._startScaleX = target.scaleX;
                    this._startScaleY = target.scaleY;
                    this._deltaX = this._endScaleX - this._startScaleX;
                    this._deltaY = this._endScaleY - this._startScaleY;
                },
                update: function(dt) {
                    dt = this._computeEaseTime(dt);
                    if (this.target) {
                        this.target.scaleX = this._startScaleX + this._deltaX * dt;
                        this.target.scaleY = this._startScaleY + this._deltaY * dt;
                    }
                }
            });
            cc.scaleTo = function(duration, sx, sy) {
                return new cc.ScaleTo(duration, sx, sy);
            };
            cc.ScaleTo.create = cc.scaleTo;
            cc.ScaleBy = cc.ScaleTo.extend({
                startWithTarget: function(target) {
                    cc.ScaleTo.prototype.startWithTarget.call(this, target);
                    this._deltaX = this._startScaleX * this._endScaleX - this._startScaleX;
                    this._deltaY = this._startScaleY * this._endScaleY - this._startScaleY;
                },
                reverse: function() {
                    var action = new cc.ScaleBy(this._duration, 1 / this._endScaleX, 1 / this._endScaleY);
                    this._cloneDecoration(action);
                    this._reverseEaseList(action);
                    return action;
                },
                clone: function() {
                    var action = new cc.ScaleBy();
                    this._cloneDecoration(action);
                    action.initWithDuration(this._duration, this._endScaleX, this._endScaleY);
                    return action;
                }
            });
            cc.scaleBy = function(duration, sx, sy) {
                return new cc.ScaleBy(duration, sx, sy);
            };
            cc.ScaleBy.create = cc.scaleBy;
            cc.Blink = cc.ActionInterval.extend({
                _times: 0,
                _originalState: false,
                ctor: function(duration, blinks) {
                    cc.ActionInterval.prototype.ctor.call(this);
                    void 0 !== blinks && this.initWithDuration(duration, blinks);
                },
                initWithDuration: function(duration, blinks) {
                    if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
                        this._times = blinks;
                        return true;
                    }
                    return false;
                },
                clone: function() {
                    var action = new cc.Blink();
                    this._cloneDecoration(action);
                    action.initWithDuration(this._duration, this._times);
                    return action;
                },
                update: function(dt) {
                    dt = this._computeEaseTime(dt);
                    if (this.target && !this.isDone()) {
                        var slice = 1 / this._times;
                        var m = dt % slice;
                        this.target.visible = m > slice / 2;
                    }
                },
                startWithTarget: function(target) {
                    cc.ActionInterval.prototype.startWithTarget.call(this, target);
                    this._originalState = target.visible;
                },
                stop: function() {
                    this.target.visible = this._originalState;
                    cc.ActionInterval.prototype.stop.call(this);
                },
                reverse: function() {
                    var action = new cc.Blink(this._duration, this._times);
                    this._cloneDecoration(action);
                    this._reverseEaseList(action);
                    return action;
                }
            });
            cc.blink = function(duration, blinks) {
                return new cc.Blink(duration, blinks);
            };
            cc.Blink.create = cc.blink;
            cc.FadeTo = cc.ActionInterval.extend({
                _toOpacity: 0,
                _fromOpacity: 0,
                ctor: function(duration, opacity) {
                    cc.ActionInterval.prototype.ctor.call(this);
                    void 0 !== opacity && this.initWithDuration(duration, opacity);
                },
                initWithDuration: function(duration, opacity) {
                    if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
                        this._toOpacity = opacity;
                        return true;
                    }
                    return false;
                },
                clone: function() {
                    var action = new cc.FadeTo();
                    this._cloneDecoration(action);
                    action.initWithDuration(this._duration, this._toOpacity);
                    return action;
                },
                update: function(time) {
                    time = this._computeEaseTime(time);
                    var fromOpacity = void 0 !== this._fromOpacity ? this._fromOpacity : 255;
                    this.target.opacity = fromOpacity + (this._toOpacity - fromOpacity) * time;
                },
                startWithTarget: function(target) {
                    cc.ActionInterval.prototype.startWithTarget.call(this, target);
                    this._fromOpacity = target.opacity;
                }
            });
            cc.fadeTo = function(duration, opacity) {
                return new cc.FadeTo(duration, opacity);
            };
            cc.FadeTo.create = cc.fadeTo;
            cc.FadeIn = cc.FadeTo.extend({
                _reverseAction: null,
                ctor: function(duration) {
                    cc.FadeTo.prototype.ctor.call(this);
                    if (null == duration) {
                        duration = 0;
                    }
                    this.initWithDuration(duration, 255);
                },
                reverse: function() {
                    var action = new cc.FadeOut();
                    action.initWithDuration(this._duration, 0);
                    this._cloneDecoration(action);
                    this._reverseEaseList(action);
                    return action;
                },
                clone: function() {
                    var action = new cc.FadeIn();
                    this._cloneDecoration(action);
                    action.initWithDuration(this._duration, this._toOpacity);
                    return action;
                },
                startWithTarget: function(target) {
                    if (this._reverseAction) {
                        this._toOpacity = this._reverseAction._fromOpacity;
                    }
                    cc.FadeTo.prototype.startWithTarget.call(this, target);
                }
            });
            cc.fadeIn = function(duration) {
                return new cc.FadeIn(duration);
            };
            cc.FadeIn.create = cc.fadeIn;
            cc.FadeOut = cc.FadeTo.extend({
                ctor: function(duration) {
                    cc.FadeTo.prototype.ctor.call(this);
                    if (null == duration) {
                        duration = 0;
                    }
                    this.initWithDuration(duration, 0);
                },
                reverse: function() {
                    var action = new cc.FadeIn();
                    action._reverseAction = this;
                    action.initWithDuration(this._duration, 255);
                    this._cloneDecoration(action);
                    this._reverseEaseList(action);
                    return action;
                },
                clone: function() {
                    var action = new cc.FadeOut();
                    this._cloneDecoration(action);
                    action.initWithDuration(this._duration, this._toOpacity);
                    return action;
                }
            });
            cc.fadeOut = function(d) {
                return new cc.FadeOut(d);
            };
            cc.FadeOut.create = cc.fadeOut;
            cc.TintTo = cc.ActionInterval.extend({
                _to: null,
                _from: null,
                ctor: function(duration, red, green, blue) {
                    cc.ActionInterval.prototype.ctor.call(this);
                    this._to = cc.color(0, 0, 0);
                    this._from = cc.color(0, 0, 0);
                    void 0 !== blue && this.initWithDuration(duration, red, green, blue);
                },
                initWithDuration: function(duration, red, green, blue) {
                    if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
                        this._to = cc.color(red, green, blue);
                        return true;
                    }
                    return false;
                },
                clone: function() {
                    var action = new cc.TintTo();
                    this._cloneDecoration(action);
                    var locTo = this._to;
                    action.initWithDuration(this._duration, locTo.r, locTo.g, locTo.b);
                    return action;
                },
                startWithTarget: function(target) {
                    cc.ActionInterval.prototype.startWithTarget.call(this, target);
                    this._from = this.target.color;
                },
                update: function(dt) {
                    dt = this._computeEaseTime(dt);
                    var locFrom = this._from, locTo = this._to;
                    if (locFrom) {
                        this.target.setColor(cc.color(locFrom.r + (locTo.r - locFrom.r) * dt, locFrom.g + (locTo.g - locFrom.g) * dt, locFrom.b + (locTo.b - locFrom.b) * dt));
                    }
                }
            });
            cc.tintTo = function(duration, red, green, blue) {
                return new cc.TintTo(duration, red, green, blue);
            };
            cc.TintTo.create = cc.tintTo;
            cc.TintBy = cc.ActionInterval.extend({
                _deltaR: 0,
                _deltaG: 0,
                _deltaB: 0,
                _fromR: 0,
                _fromG: 0,
                _fromB: 0,
                ctor: function(duration, deltaRed, deltaGreen, deltaBlue) {
                    cc.ActionInterval.prototype.ctor.call(this);
                    void 0 !== deltaBlue && this.initWithDuration(duration, deltaRed, deltaGreen, deltaBlue);
                },
                initWithDuration: function(duration, deltaRed, deltaGreen, deltaBlue) {
                    if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
                        this._deltaR = deltaRed;
                        this._deltaG = deltaGreen;
                        this._deltaB = deltaBlue;
                        return true;
                    }
                    return false;
                },
                clone: function() {
                    var action = new cc.TintBy();
                    this._cloneDecoration(action);
                    action.initWithDuration(this._duration, this._deltaR, this._deltaG, this._deltaB);
                    return action;
                },
                startWithTarget: function(target) {
                    cc.ActionInterval.prototype.startWithTarget.call(this, target);
                    var color = target.color;
                    this._fromR = color.r;
                    this._fromG = color.g;
                    this._fromB = color.b;
                },
                update: function(dt) {
                    dt = this._computeEaseTime(dt);
                    this.target.color = cc.color(this._fromR + this._deltaR * dt, this._fromG + this._deltaG * dt, this._fromB + this._deltaB * dt);
                },
                reverse: function() {
                    var action = new cc.TintBy(this._duration, -this._deltaR, -this._deltaG, -this._deltaB);
                    this._cloneDecoration(action);
                    this._reverseEaseList(action);
                    return action;
                }
            });
            cc.tintBy = function(duration, deltaRed, deltaGreen, deltaBlue) {
                return new cc.TintBy(duration, deltaRed, deltaGreen, deltaBlue);
            };
            cc.TintBy.create = cc.tintBy;
            cc.DelayTime = cc.ActionInterval.extend({
                update: function(dt) {},
                reverse: function() {
                    var action = new cc.DelayTime(this._duration);
                    this._cloneDecoration(action);
                    this._reverseEaseList(action);
                    return action;
                },
                clone: function() {
                    var action = new cc.DelayTime();
                    this._cloneDecoration(action);
                    action.initWithDuration(this._duration);
                    return action;
                }
            });
            cc.delayTime = function(d) {
                return new cc.DelayTime(d);
            };
            cc.DelayTime.create = cc.delayTime;
            cc.ReverseTime = cc.ActionInterval.extend({
                _other: null,
                ctor: function(action) {
                    cc.ActionInterval.prototype.ctor.call(this);
                    this._other = null;
                    action && this.initWithAction(action);
                },
                initWithAction: function(action) {
                    if (!action) {
                        throw new Error("cc.ReverseTime.initWithAction(): action must be non null");
                    }
                    if (action === this._other) {
                        throw new Error("cc.ReverseTime.initWithAction(): the action was already passed in.");
                    }
                    if (cc.ActionInterval.prototype.initWithDuration.call(this, action._duration)) {
                        this._other = action;
                        return true;
                    }
                    return false;
                },
                clone: function() {
                    var action = new cc.ReverseTime();
                    this._cloneDecoration(action);
                    action.initWithAction(this._other.clone());
                    return action;
                },
                startWithTarget: function(target) {
                    cc.ActionInterval.prototype.startWithTarget.call(this, target);
                    this._other.startWithTarget(target);
                },
                update: function(dt) {
                    dt = this._computeEaseTime(dt);
                    if (this._other) {
                        this._other.update(1 - dt);
                    }
                },
                reverse: function() {
                    return this._other.clone();
                },
                stop: function() {
                    this._other.stop();
                    cc.Action.prototype.stop.call(this);
                }
            });
            cc.reverseTime = function(action) {
                return new cc.ReverseTime(action);
            };
            cc.ReverseTime.create = cc.reverseTime;
            cc.Animate = cc.ActionInterval.extend({
                _animation: null,
                _nextFrame: 0,
                _origFrame: null,
                _executedLoops: 0,
                _splitTimes: null,
                _currFrameIndex: 0,
                ctor: function(animation) {
                    cc.ActionInterval.prototype.ctor.call(this);
                    this._splitTimes = [];
                    animation && this.initWithAnimation(animation);
                },
                getAnimation: function() {
                    return this._animation;
                },
                setAnimation: function(animation) {
                    this._animation = animation;
                },
                getCurrentFrameIndex: function() {
                    return this._currFrameIndex;
                },
                initWithAnimation: function(animation) {
                    if (!animation) {
                        throw new Error("cc.Animate.initWithAnimation(): animation must be non-NULL");
                    }
                    var singleDuration = animation.getDuration();
                    if (this.initWithDuration(singleDuration * animation.getLoops())) {
                        this._nextFrame = 0;
                        this.setAnimation(animation);
                        this._origFrame = null;
                        this._executedLoops = 0;
                        var locTimes = this._splitTimes;
                        locTimes.length = 0;
                        var accumUnitsOfTime = 0;
                        var newUnitOfTimeValue = singleDuration / animation.getTotalDelayUnits();
                        var frames = animation.getFrames();
                        cc.js.array.verifyType(frames, cc.AnimationFrame);
                        for (var i = 0; i < frames.length; i++) {
                            var frame = frames[i];
                            var value = accumUnitsOfTime * newUnitOfTimeValue / singleDuration;
                            accumUnitsOfTime += frame.getDelayUnits();
                            locTimes.push(value);
                        }
                        return true;
                    }
                    return false;
                },
                clone: function() {
                    var action = new cc.Animate();
                    this._cloneDecoration(action);
                    action.initWithAnimation(this._animation.clone());
                    return action;
                },
                startWithTarget: function(target) {
                    cc.ActionInterval.prototype.startWithTarget.call(this, target);
                    if (this._animation.getRestoreOriginalFrame()) {
                        this._origFrame = target.displayFrame();
                    }
                    this._nextFrame = 0;
                    this._executedLoops = 0;
                },
                update: function(dt) {
                    dt = this._computeEaseTime(dt);
                    if (dt < 1) {
                        dt *= this._animation.getLoops();
                        var loopNumber = 0 | dt;
                        if (loopNumber > this._executedLoops) {
                            this._nextFrame = 0;
                            this._executedLoops++;
                        }
                        dt %= 1;
                    }
                    var frames = this._animation.getFrames();
                    var numberOfFrames = frames.length, locSplitTimes = this._splitTimes;
                    for (var i = this._nextFrame; i < numberOfFrames; i++) {
                        if (locSplitTimes[i] <= dt) {
                            _currFrameIndex = i;
                            this.target.setSpriteFrame(frames[_currFrameIndex].getSpriteFrame());
                            this._nextFrame = i + 1;
                        } else {
                            break;
                        }
                    }
                },
                reverse: function() {
                    var locAnimation = this._animation;
                    var oldArray = locAnimation.getFrames();
                    var newArray = [];
                    cc.js.array.verifyType(oldArray, cc.AnimationFrame);
                    if (oldArray.length > 0) {
                        for (var i = oldArray.length - 1; i >= 0; i--) {
                            var element = oldArray[i];
                            if (!element) {
                                break;
                            }
                            newArray.push(element.clone());
                        }
                    }
                    var newAnim = new cc.SpriteFrameAnimation(newArray, locAnimation.getDelayPerUnit(), locAnimation.getLoops());
                    newAnim.setRestoreOriginalFrame(locAnimation.getRestoreOriginalFrame());
                    var action = new cc.Animate(newAnim);
                    this._cloneDecoration(action);
                    this._reverseEaseList(action);
                    return action;
                },
                stop: function() {
                    if (this._animation.getRestoreOriginalFrame() && this.target) {
                        this.target.setSpriteFrame(this._origFrame);
                    }
                    cc.Action.prototype.stop.call(this);
                }
            });
            cc.animate = function(animation) {
                return new cc.Animate(animation);
            };
            cc.Animate.create = cc.animate;
            cc.TargetedAction = cc.ActionInterval.extend({
                _action: null,
                _forcedTarget: null,
                ctor: function(target, action) {
                    cc.ActionInterval.prototype.ctor.call(this);
                    action && this.initWithTarget(target, action);
                },
                initWithTarget: function(target, action) {
                    if (this.initWithDuration(action._duration)) {
                        this._forcedTarget = target;
                        this._action = action;
                        return true;
                    }
                    return false;
                },
                clone: function() {
                    var action = new cc.TargetedAction();
                    this._cloneDecoration(action);
                    action.initWithTarget(this._forcedTarget, this._action.clone());
                    return action;
                },
                startWithTarget: function(target) {
                    cc.ActionInterval.prototype.startWithTarget.call(this, target);
                    this._action.startWithTarget(this._forcedTarget);
                },
                stop: function() {
                    this._action.stop();
                },
                update: function(dt) {
                    dt = this._computeEaseTime(dt);
                    this._action.update(dt);
                },
                getForcedTarget: function() {
                    return this._forcedTarget;
                },
                setForcedTarget: function(forcedTarget) {
                    if (this._forcedTarget !== forcedTarget) {
                        this._forcedTarget = forcedTarget;
                    }
                }
            });
            cc.targetedAction = function(target, action) {
                return new cc.TargetedAction(target, action);
            };
            cc.TargetedAction.create = cc.targetedAction;
            cc.ActionInstant = cc.FiniteTimeAction.extend({
                isDone: function() {
                    return true;
                },
                step: function(dt) {
                    this.update(1);
                },
                update: function(dt) {},
                reverse: function() {
                    return this.clone();
                },
                clone: function() {
                    return new cc.ActionInstant();
                }
            });
            cc.Show = cc.ActionInstant.extend({
                update: function(dt) {
                    this.target.visible = true;
                },
                reverse: function() {
                    return new cc.Hide();
                },
                clone: function() {
                    return new cc.Show();
                }
            });
            cc.show = function() {
                return new cc.Show();
            };
            cc.Show.create = cc.show;
            cc.Hide = cc.ActionInstant.extend({
                update: function(dt) {
                    this.target.visible = false;
                },
                reverse: function() {
                    return new cc.Show();
                },
                clone: function() {
                    return new cc.Hide();
                }
            });
            cc.hide = function() {
                return new cc.Hide();
            };
            cc.Hide.create = cc.hide;
            cc.ToggleVisibility = cc.ActionInstant.extend({
                update: function(dt) {
                    this.target.visible = !this.target.visible;
                },
                reverse: function() {
                    return new cc.ToggleVisibility();
                },
                clone: function() {
                    return new cc.ToggleVisibility();
                }
            });
            cc.toggleVisibility = function() {
                return new cc.ToggleVisibility();
            };
            cc.ToggleVisibility.create = cc.toggleVisibility;
            cc.RemoveSelf = cc.ActionInstant.extend({
                _isNeedCleanUp: true,
                ctor: function(isNeedCleanUp) {
                    cc.FiniteTimeAction.prototype.ctor.call(this);
                    void 0 !== isNeedCleanUp && this.init(isNeedCleanUp);
                },
                update: function(dt) {
                    this.target.removeFromParent(this._isNeedCleanUp);
                },
                init: function(isNeedCleanUp) {
                    this._isNeedCleanUp = isNeedCleanUp;
                    return true;
                },
                reverse: function() {
                    return new cc.RemoveSelf(this._isNeedCleanUp);
                },
                clone: function() {
                    return new cc.RemoveSelf(this._isNeedCleanUp);
                }
            });
            cc.removeSelf = function(isNeedCleanUp) {
                return new cc.RemoveSelf(isNeedCleanUp);
            };
            cc.RemoveSelf.create = cc.removeSelf;
            cc.FlipX = cc.ActionInstant.extend({
                _flippedX: false,
                ctor: function(flip) {
                    cc.FiniteTimeAction.prototype.ctor.call(this);
                    this._flippedX = false;
                    void 0 !== flip && this.initWithFlipX(flip);
                },
                initWithFlipX: function(flip) {
                    this._flippedX = flip;
                    return true;
                },
                update: function(dt) {
                    this.target.flippedX = this._flippedX;
                },
                reverse: function() {
                    return new cc.FlipX(!this._flippedX);
                },
                clone: function() {
                    var action = new cc.FlipX();
                    action.initWithFlipX(this._flippedX);
                    return action;
                }
            });
            cc.flipX = function(flip) {
                return new cc.FlipX(flip);
            };
            cc.FlipX.create = cc.flipX;
            cc.FlipY = cc.ActionInstant.extend({
                _flippedY: false,
                ctor: function(flip) {
                    cc.FiniteTimeAction.prototype.ctor.call(this);
                    this._flippedY = false;
                    void 0 !== flip && this.initWithFlipY(flip);
                },
                initWithFlipY: function(flip) {
                    this._flippedY = flip;
                    return true;
                },
                update: function(dt) {
                    this.target.flippedY = this._flippedY;
                },
                reverse: function() {
                    return new cc.FlipY(!this._flippedY);
                },
                clone: function() {
                    var action = new cc.FlipY();
                    action.initWithFlipY(this._flippedY);
                    return action;
                }
            });
            cc.flipY = function(flip) {
                return new cc.FlipY(flip);
            };
            cc.FlipY.create = cc.flipY;
            cc.Place = cc.ActionInstant.extend({
                _x: 0,
                _y: 0,
                ctor: function(pos, y) {
                    cc.FiniteTimeAction.prototype.ctor.call(this);
                    this._x = 0;
                    this._y = 0;
                    if (void 0 !== pos) {
                        if (void 0 !== pos.x) {
                            y = pos.y;
                            pos = pos.x;
                        }
                        this.initWithPosition(pos, y);
                    }
                },
                initWithPosition: function(x, y) {
                    this._x = x;
                    this._y = y;
                    return true;
                },
                update: function(dt) {
                    this.target.setPosition(this._x, this._y);
                },
                clone: function() {
                    var action = new cc.Place();
                    action.initWithPosition(this._x, this._y);
                    return action;
                }
            });
            cc.place = function(pos, y) {
                return new cc.Place(pos, y);
            };
            cc.Place.create = cc.place;
            cc.CallFunc = cc.ActionInstant.extend({
                _selectorTarget: null,
                _function: null,
                _data: null,
                ctor: function(selector, selectorTarget, data) {
                    cc.FiniteTimeAction.prototype.ctor.call(this);
                    this.initWithFunction(selector, selectorTarget, data);
                },
                initWithFunction: function(selector, selectorTarget, data) {
                    if (selector) {
                        this._function = selector;
                    }
                    if (selectorTarget) {
                        this._selectorTarget = selectorTarget;
                    }
                    if (data) {
                        this._data = data;
                    }
                    return true;
                },
                execute: function() {
                    if (this._function) {
                        this._function.call(this._selectorTarget, this.target, this._data);
                    }
                },
                update: function(dt) {
                    this.execute();
                },
                getTargetCallback: function() {
                    return this._selectorTarget;
                },
                setTargetCallback: function(sel) {
                    if (sel !== this._selectorTarget) {
                        if (this._selectorTarget) {
                            this._selectorTarget = null;
                        }
                        this._selectorTarget = sel;
                    }
                },
                clone: function() {
                    var action = new cc.CallFunc();
                    action.initWithFunction(this._function, this._selectorTarget, this._data);
                    return action;
                }
            });
            cc.callFunc = function(selector, selectorTarget, data) {
                return new cc.CallFunc(selector, selectorTarget, data);
            };
            cc.CallFunc.create = cc.callFunc;
            cc.ActionEase = cc.ActionInterval.extend({
                _inner: null,
                ctor: function(action) {
                    cc.ActionInterval.prototype.ctor.call(this);
                    action && this.initWithAction(action);
                },
                initWithAction: function(action) {
                    if (!action) {
                        throw new Error("cc.ActionEase.initWithAction(): action must be non nil");
                    }
                    if (this.initWithDuration(action.getDuration())) {
                        this._inner = action;
                        return true;
                    }
                    return false;
                },
                clone: function() {
                    var action = new cc.ActionEase();
                    action.initWithAction(this._inner.clone());
                    return action;
                },
                startWithTarget: function(target) {
                    cc.ActionInterval.prototype.startWithTarget.call(this, target);
                    this._inner.startWithTarget(this.target);
                },
                stop: function() {
                    this._inner.stop();
                    cc.ActionInterval.prototype.stop.call(this);
                },
                update: function(dt) {
                    this._inner.update(dt);
                },
                reverse: function() {
                    return new cc.ActionEase(this._inner.reverse());
                },
                getInnerAction: function() {
                    return this._inner;
                }
            });
            cc.actionEase = function(action) {
                return new cc.ActionEase(action);
            };
            cc.ActionEase.create = cc.actionEase;
            cc.EaseRateAction = cc.ActionEase.extend({
                _rate: 0,
                ctor: function(action, rate) {
                    cc.ActionEase.prototype.ctor.call(this);
                    void 0 !== rate && this.initWithAction(action, rate);
                },
                setRate: function(rate) {
                    this._rate = rate;
                },
                getRate: function() {
                    return this._rate;
                },
                initWithAction: function(action, rate) {
                    if (cc.ActionEase.prototype.initWithAction.call(this, action)) {
                        this._rate = rate;
                        return true;
                    }
                    return false;
                },
                clone: function() {
                    var action = new cc.EaseRateAction();
                    action.initWithAction(this._inner.clone(), this._rate);
                    return action;
                },
                reverse: function() {
                    return new cc.EaseRateAction(this._inner.reverse(), 1 / this._rate);
                }
            });
            cc.easeRateAction = function(action, rate) {
                return new cc.EaseRateAction(action, rate);
            };
            cc.EaseRateAction.create = cc.easeRateAction;
            cc.EaseIn = cc.EaseRateAction.extend({
                update: function(dt) {
                    this._inner.update(Math.pow(dt, this._rate));
                },
                reverse: function() {
                    return new cc.EaseIn(this._inner.reverse(), 1 / this._rate);
                },
                clone: function() {
                    var action = new cc.EaseIn();
                    action.initWithAction(this._inner.clone(), this._rate);
                    return action;
                }
            });
            cc.EaseIn.create = function(action, rate) {
                return new cc.EaseIn(action, rate);
            };
            cc.easeIn = function(rate) {
                return {
                    _rate: rate,
                    easing: function(dt) {
                        return Math.pow(dt, this._rate);
                    },
                    reverse: function() {
                        return cc.easeIn(1 / this._rate);
                    }
                };
            };
            cc.EaseOut = cc.EaseRateAction.extend({
                update: function(dt) {
                    this._inner.update(Math.pow(dt, 1 / this._rate));
                },
                reverse: function() {
                    return new cc.EaseOut(this._inner.reverse(), 1 / this._rate);
                },
                clone: function() {
                    var action = new cc.EaseOut();
                    action.initWithAction(this._inner.clone(), this._rate);
                    return action;
                }
            });
            cc.EaseOut.create = function(action, rate) {
                return new cc.EaseOut(action, rate);
            };
            cc.easeOut = function(rate) {
                return {
                    _rate: rate,
                    easing: function(dt) {
                        return Math.pow(dt, 1 / this._rate);
                    },
                    reverse: function() {
                        return cc.easeOut(1 / this._rate);
                    }
                };
            };
            cc.EaseInOut = cc.EaseRateAction.extend({
                update: function(dt) {
                    dt *= 2;
                    if (dt < 1) {
                        this._inner.update(.5 * Math.pow(dt, this._rate));
                    } else {
                        this._inner.update(1 - .5 * Math.pow(2 - dt, this._rate));
                    }
                },
                clone: function() {
                    var action = new cc.EaseInOut();
                    action.initWithAction(this._inner.clone(), this._rate);
                    return action;
                },
                reverse: function() {
                    return new cc.EaseInOut(this._inner.reverse(), this._rate);
                }
            });
            cc.EaseInOut.create = function(action, rate) {
                return new cc.EaseInOut(action, rate);
            };
            cc.easeInOut = function(rate) {
                return {
                    _rate: rate,
                    easing: function(dt) {
                        dt *= 2;
                        if (dt < 1) {
                            return .5 * Math.pow(dt, this._rate);
                        } else {
                            return 1 - .5 * Math.pow(2 - dt, this._rate);
                        }
                    },
                    reverse: function() {
                        return cc.easeInOut(this._rate);
                    }
                };
            };
            cc.EaseExponentialIn = cc.ActionEase.extend({
                update: function(dt) {
                    this._inner.update(0 === dt ? 0 : Math.pow(2, 10 * (dt - 1)));
                },
                reverse: function() {
                    return new cc.EaseExponentialOut(this._inner.reverse());
                },
                clone: function() {
                    var action = new cc.EaseExponentialIn();
                    action.initWithAction(this._inner.clone());
                    return action;
                }
            });
            cc.EaseExponentialIn.create = function(action) {
                return new cc.EaseExponentialIn(action);
            };
            cc._easeExponentialInObj = {
                easing: function(dt) {
                    return 0 === dt ? 0 : Math.pow(2, 10 * (dt - 1));
                },
                reverse: function() {
                    return cc._easeExponentialOutObj;
                }
            };
            cc.easeExponentialIn = function() {
                return cc._easeExponentialInObj;
            };
            cc.EaseExponentialOut = cc.ActionEase.extend({
                update: function(dt) {
                    this._inner.update(1 === dt ? 1 : -Math.pow(2, -10 * dt) + 1);
                },
                reverse: function() {
                    return new cc.EaseExponentialIn(this._inner.reverse());
                },
                clone: function() {
                    var action = new cc.EaseExponentialOut();
                    action.initWithAction(this._inner.clone());
                    return action;
                }
            });
            cc.EaseExponentialOut.create = function(action) {
                return new cc.EaseExponentialOut(action);
            };
            cc._easeExponentialOutObj = {
                easing: function(dt) {
                    return 1 === dt ? 1 : -Math.pow(2, -10 * dt) + 1;
                },
                reverse: function() {
                    return cc._easeExponentialInObj;
                }
            };
            cc.easeExponentialOut = function() {
                return cc._easeExponentialOutObj;
            };
            cc.EaseExponentialInOut = cc.ActionEase.extend({
                update: function(dt) {
                    if (1 !== dt && 0 !== dt) {
                        dt *= 2;
                        if (dt < 1) {
                            dt = .5 * Math.pow(2, 10 * (dt - 1));
                        } else {
                            dt = .5 * (-Math.pow(2, -10 * (dt - 1)) + 2);
                        }
                    }
                    this._inner.update(dt);
                },
                reverse: function() {
                    return new cc.EaseExponentialInOut(this._inner.reverse());
                },
                clone: function() {
                    var action = new cc.EaseExponentialInOut();
                    action.initWithAction(this._inner.clone());
                    return action;
                }
            });
            cc.EaseExponentialInOut.create = function(action) {
                return new cc.EaseExponentialInOut(action);
            };
            cc._easeExponentialInOutObj = {
                easing: function(dt) {
                    if (1 !== dt && 0 !== dt) {
                        dt *= 2;
                        if (dt < 1) {
                            return .5 * Math.pow(2, 10 * (dt - 1));
                        } else {
                            return .5 * (-Math.pow(2, -10 * (dt - 1)) + 2);
                        }
                    }
                    return dt;
                },
                reverse: function() {
                    return cc._easeExponentialInOutObj;
                }
            };
            cc.easeExponentialInOut = function() {
                return cc._easeExponentialInOutObj;
            };
            cc.EaseSineIn = cc.ActionEase.extend({
                update: function(dt) {
                    dt = 0 === dt || 1 === dt ? dt : -1 * Math.cos(dt * Math.PI / 2) + 1;
                    this._inner.update(dt);
                },
                reverse: function() {
                    return new cc.EaseSineOut(this._inner.reverse());
                },
                clone: function() {
                    var action = new cc.EaseSineIn();
                    action.initWithAction(this._inner.clone());
                    return action;
                }
            });
            cc.EaseSineIn.create = function(action) {
                return new cc.EaseSineIn(action);
            };
            cc._easeSineInObj = {
                easing: function(dt) {
                    return 0 === dt || 1 === dt ? dt : -1 * Math.cos(dt * Math.PI / 2) + 1;
                },
                reverse: function() {
                    return cc._easeSineOutObj;
                }
            };
            cc.easeSineIn = function() {
                return cc._easeSineInObj;
            };
            cc.EaseSineOut = cc.ActionEase.extend({
                update: function(dt) {
                    dt = 0 === dt || 1 === dt ? dt : Math.sin(dt * Math.PI / 2);
                    this._inner.update(dt);
                },
                reverse: function() {
                    return new cc.EaseSineIn(this._inner.reverse());
                },
                clone: function() {
                    var action = new cc.EaseSineOut();
                    action.initWithAction(this._inner.clone());
                    return action;
                }
            });
            cc.EaseSineOut.create = function(action) {
                return new cc.EaseSineOut(action);
            };
            cc._easeSineOutObj = {
                easing: function(dt) {
                    return 0 === dt || 1 === dt ? dt : Math.sin(dt * Math.PI / 2);
                },
                reverse: function() {
                    return cc._easeSineInObj;
                }
            };
            cc.easeSineOut = function() {
                return cc._easeSineOutObj;
            };
            cc.EaseSineInOut = cc.ActionEase.extend({
                update: function(dt) {
                    dt = 0 === dt || 1 === dt ? dt : -.5 * (Math.cos(Math.PI * dt) - 1);
                    this._inner.update(dt);
                },
                clone: function() {
                    var action = new cc.EaseSineInOut();
                    action.initWithAction(this._inner.clone());
                    return action;
                },
                reverse: function() {
                    return new cc.EaseSineInOut(this._inner.reverse());
                }
            });
            cc.EaseSineInOut.create = function(action) {
                return new cc.EaseSineInOut(action);
            };
            cc._easeSineInOutObj = {
                easing: function(dt) {
                    return 0 === dt || 1 === dt ? dt : -.5 * (Math.cos(Math.PI * dt) - 1);
                },
                reverse: function() {
                    return cc._easeSineInOutObj;
                }
            };
            cc.easeSineInOut = function() {
                return cc._easeSineInOutObj;
            };
            cc.EaseElastic = cc.ActionEase.extend({
                _period: .3,
                ctor: function(action, period) {
                    cc.ActionEase.prototype.ctor.call(this);
                    action && this.initWithAction(action, period);
                },
                getPeriod: function() {
                    return this._period;
                },
                setPeriod: function(period) {
                    this._period = period;
                },
                initWithAction: function(action, period) {
                    cc.ActionEase.prototype.initWithAction.call(this, action);
                    this._period = null == period ? .3 : period;
                    return true;
                },
                reverse: function() {
                    cc.log("cc.EaseElastic.reverse(): it should be overridden in subclass.");
                    return null;
                },
                clone: function() {
                    var action = new cc.EaseElastic();
                    action.initWithAction(this._inner.clone(), this._period);
                    return action;
                }
            });
            cc.EaseElastic.create = function(action, period) {
                return new cc.EaseElastic(action, period);
            };
            cc.EaseElasticIn = cc.EaseElastic.extend({
                update: function(dt) {
                    var newT = 0;
                    if (0 === dt || 1 === dt) {
                        newT = dt;
                    } else {
                        var s = this._period / 4;
                        dt -= 1;
                        newT = -Math.pow(2, 10 * dt) * Math.sin((dt - s) * Math.PI * 2 / this._period);
                    }
                    this._inner.update(newT);
                },
                reverse: function() {
                    return new cc.EaseElasticOut(this._inner.reverse(), this._period);
                },
                clone: function() {
                    var action = new cc.EaseElasticIn();
                    action.initWithAction(this._inner.clone(), this._period);
                    return action;
                }
            });
            cc.EaseElasticIn.create = function(action, period) {
                return new cc.EaseElasticIn(action, period);
            };
            cc._easeElasticInObj = {
                easing: function(dt) {
                    if (0 === dt || 1 === dt) {
                        return dt;
                    }
                    dt -= 1;
                    return -Math.pow(2, 10 * dt) * Math.sin((dt - .075) * Math.PI * 2 / .3);
                },
                reverse: function() {
                    return cc._easeElasticOutObj;
                }
            };
            cc.easeElasticIn = function(period) {
                if (period && .3 !== period) {
                    return {
                        _period: period,
                        easing: function(dt) {
                            if (0 === dt || 1 === dt) {
                                return dt;
                            }
                            dt -= 1;
                            return -Math.pow(2, 10 * dt) * Math.sin((dt - this._period / 4) * Math.PI * 2 / this._period);
                        },
                        reverse: function() {
                            return cc.easeElasticOut(this._period);
                        }
                    };
                }
                return cc._easeElasticInObj;
            };
            cc.EaseElasticOut = cc.EaseElastic.extend({
                update: function(dt) {
                    var newT = 0;
                    if (0 === dt || 1 === dt) {
                        newT = dt;
                    } else {
                        var s = this._period / 4;
                        newT = Math.pow(2, -10 * dt) * Math.sin((dt - s) * Math.PI * 2 / this._period) + 1;
                    }
                    this._inner.update(newT);
                },
                reverse: function() {
                    return new cc.EaseElasticIn(this._inner.reverse(), this._period);
                },
                clone: function() {
                    var action = new cc.EaseElasticOut();
                    action.initWithAction(this._inner.clone(), this._period);
                    return action;
                }
            });
            cc.EaseElasticOut.create = function(action, period) {
                return new cc.EaseElasticOut(action, period);
            };
            cc._easeElasticOutObj = {
                easing: function(dt) {
                    return 0 === dt || 1 === dt ? dt : Math.pow(2, -10 * dt) * Math.sin((dt - .075) * Math.PI * 2 / .3) + 1;
                },
                reverse: function() {
                    return cc._easeElasticInObj;
                }
            };
            cc.easeElasticOut = function(period) {
                if (period && .3 !== period) {
                    return {
                        _period: period,
                        easing: function(dt) {
                            return 0 === dt || 1 === dt ? dt : Math.pow(2, -10 * dt) * Math.sin((dt - this._period / 4) * Math.PI * 2 / this._period) + 1;
                        },
                        reverse: function() {
                            return cc.easeElasticIn(this._period);
                        }
                    };
                }
                return cc._easeElasticOutObj;
            };
            cc.EaseElasticInOut = cc.EaseElastic.extend({
                update: function(dt) {
                    var newT = 0;
                    var locPeriod = this._period;
                    if (0 === dt || 1 === dt) {
                        newT = dt;
                    } else {
                        dt = 2 * dt;
                        if (!locPeriod) {
                            locPeriod = this._period = .3 * 1.5;
                        }
                        var s = locPeriod / 4;
                        dt -= 1;
                        if (dt < 0) {
                            newT = -.5 * Math.pow(2, 10 * dt) * Math.sin((dt - s) * Math.PI * 2 / locPeriod);
                        } else {
                            newT = Math.pow(2, -10 * dt) * Math.sin((dt - s) * Math.PI * 2 / locPeriod) * .5 + 1;
                        }
                    }
                    this._inner.update(newT);
                },
                reverse: function() {
                    return new cc.EaseElasticInOut(this._inner.reverse(), this._period);
                },
                clone: function() {
                    var action = new cc.EaseElasticInOut();
                    action.initWithAction(this._inner.clone(), this._period);
                    return action;
                }
            });
            cc.EaseElasticInOut.create = function(action, period) {
                return new cc.EaseElasticInOut(action, period);
            };
            cc.easeElasticInOut = function(period) {
                period = period || .3;
                return {
                    _period: period,
                    easing: function(dt) {
                        var newT = 0;
                        var locPeriod = this._period;
                        if (0 === dt || 1 === dt) {
                            newT = dt;
                        } else {
                            dt = 2 * dt;
                            if (!locPeriod) {
                                locPeriod = this._period = .3 * 1.5;
                            }
                            var s = locPeriod / 4;
                            dt -= 1;
                            if (dt < 0) {
                                newT = -.5 * Math.pow(2, 10 * dt) * Math.sin((dt - s) * Math.PI * 2 / locPeriod);
                            } else {
                                newT = Math.pow(2, -10 * dt) * Math.sin((dt - s) * Math.PI * 2 / locPeriod) * .5 + 1;
                            }
                        }
                        return newT;
                    },
                    reverse: function() {
                        return cc.easeElasticInOut(this._period);
                    }
                };
            };
            cc.EaseBounce = cc.ActionEase.extend({
                bounceTime: function(time1) {
                    if (time1 < 1 / 2.75) {
                        return 7.5625 * time1 * time1;
                    } else {
                        if (time1 < 2 / 2.75) {
                            time1 -= 1.5 / 2.75;
                            return 7.5625 * time1 * time1 + .75;
                        } else {
                            if (time1 < 2.5 / 2.75) {
                                time1 -= 2.25 / 2.75;
                                return 7.5625 * time1 * time1 + .9375;
                            }
                        }
                    }
                    time1 -= 2.625 / 2.75;
                    return 7.5625 * time1 * time1 + .984375;
                },
                clone: function() {
                    var action = new cc.EaseBounce();
                    action.initWithAction(this._inner.clone());
                    return action;
                },
                reverse: function() {
                    return new cc.EaseBounce(this._inner.reverse());
                }
            });
            cc.EaseBounce.create = function(action) {
                return new cc.EaseBounce(action);
            };
            cc.EaseBounceIn = cc.EaseBounce.extend({
                update: function(dt) {
                    var newT = 1 - this.bounceTime(1 - dt);
                    this._inner.update(newT);
                },
                reverse: function() {
                    return new cc.EaseBounceOut(this._inner.reverse());
                },
                clone: function() {
                    var action = new cc.EaseBounceIn();
                    action.initWithAction(this._inner.clone());
                    return action;
                }
            });
            cc.EaseBounceIn.create = function(action) {
                return new cc.EaseBounceIn(action);
            };
            cc._bounceTime = function(time1) {
                if (time1 < 1 / 2.75) {
                    return 7.5625 * time1 * time1;
                } else {
                    if (time1 < 2 / 2.75) {
                        time1 -= 1.5 / 2.75;
                        return 7.5625 * time1 * time1 + .75;
                    } else {
                        if (time1 < 2.5 / 2.75) {
                            time1 -= 2.25 / 2.75;
                            return 7.5625 * time1 * time1 + .9375;
                        }
                    }
                }
                time1 -= 2.625 / 2.75;
                return 7.5625 * time1 * time1 + .984375;
            };
            cc._easeBounceInObj = {
                easing: function(dt) {
                    return 1 - cc._bounceTime(1 - dt);
                },
                reverse: function() {
                    return cc._easeBounceOutObj;
                }
            };
            cc.easeBounceIn = function() {
                return cc._easeBounceInObj;
            };
            cc.EaseBounceOut = cc.EaseBounce.extend({
                update: function(dt) {
                    var newT = this.bounceTime(dt);
                    this._inner.update(newT);
                },
                reverse: function() {
                    return new cc.EaseBounceIn(this._inner.reverse());
                },
                clone: function() {
                    var action = new cc.EaseBounceOut();
                    action.initWithAction(this._inner.clone());
                    return action;
                }
            });
            cc.EaseBounceOut.create = function(action) {
                return new cc.EaseBounceOut(action);
            };
            cc._easeBounceOutObj = {
                easing: function(dt) {
                    return cc._bounceTime(dt);
                },
                reverse: function() {
                    return cc._easeBounceInObj;
                }
            };
            cc.easeBounceOut = function() {
                return cc._easeBounceOutObj;
            };
            cc.EaseBounceInOut = cc.EaseBounce.extend({
                update: function(dt) {
                    var newT = 0;
                    if (dt < .5) {
                        dt = 2 * dt;
                        newT = .5 * (1 - this.bounceTime(1 - dt));
                    } else {
                        newT = .5 * this.bounceTime(2 * dt - 1) + .5;
                    }
                    this._inner.update(newT);
                },
                clone: function() {
                    var action = new cc.EaseBounceInOut();
                    action.initWithAction(this._inner.clone());
                    return action;
                },
                reverse: function() {
                    return new cc.EaseBounceInOut(this._inner.reverse());
                }
            });
            cc.EaseBounceInOut.create = function(action) {
                return new cc.EaseBounceInOut(action);
            };
            cc._easeBounceInOutObj = {
                easing: function(time1) {
                    var newT;
                    if (time1 < .5) {
                        time1 = 2 * time1;
                        newT = .5 * (1 - cc._bounceTime(1 - time1));
                    } else {
                        newT = .5 * cc._bounceTime(2 * time1 - 1) + .5;
                    }
                    return newT;
                },
                reverse: function() {
                    return cc._easeBounceInOutObj;
                }
            };
            cc.easeBounceInOut = function() {
                return cc._easeBounceInOutObj;
            };
            cc.EaseBackIn = cc.ActionEase.extend({
                update: function(dt) {
                    var overshoot = 1.70158;
                    dt = 0 === dt || 1 === dt ? dt : dt * dt * ((overshoot + 1) * dt - overshoot);
                    this._inner.update(dt);
                },
                reverse: function() {
                    return new cc.EaseBackOut(this._inner.reverse());
                },
                clone: function() {
                    var action = new cc.EaseBackIn();
                    action.initWithAction(this._inner.clone());
                    return action;
                }
            });
            cc.EaseBackIn.create = function(action) {
                return new cc.EaseBackIn(action);
            };
            cc._easeBackInObj = {
                easing: function(time1) {
                    var overshoot = 1.70158;
                    return 0 === time1 || 1 === time1 ? time1 : time1 * time1 * ((overshoot + 1) * time1 - overshoot);
                },
                reverse: function() {
                    return cc._easeBackOutObj;
                }
            };
            cc.easeBackIn = function() {
                return cc._easeBackInObj;
            };
            cc.EaseBackOut = cc.ActionEase.extend({
                update: function(dt) {
                    var overshoot = 1.70158;
                    dt -= 1;
                    this._inner.update(dt * dt * ((overshoot + 1) * dt + overshoot) + 1);
                },
                reverse: function() {
                    return new cc.EaseBackIn(this._inner.reverse());
                },
                clone: function() {
                    var action = new cc.EaseBackOut();
                    action.initWithAction(this._inner.clone());
                    return action;
                }
            });
            cc.EaseBackOut.create = function(action) {
                return new cc.EaseBackOut(action);
            };
            cc._easeBackOutObj = {
                easing: function(time1) {
                    var overshoot = 1.70158;
                    time1 -= 1;
                    return time1 * time1 * ((overshoot + 1) * time1 + overshoot) + 1;
                },
                reverse: function() {
                    return cc._easeBackInObj;
                }
            };
            cc.easeBackOut = function() {
                return cc._easeBackOutObj;
            };
            cc.EaseBackInOut = cc.ActionEase.extend({
                update: function(dt) {
                    var overshoot = 2.5949095;
                    dt = 2 * dt;
                    if (dt < 1) {
                        this._inner.update(dt * dt * ((overshoot + 1) * dt - overshoot) / 2);
                    } else {
                        dt -= 2;
                        this._inner.update(dt * dt * ((overshoot + 1) * dt + overshoot) / 2 + 1);
                    }
                },
                clone: function() {
                    var action = new cc.EaseBackInOut();
                    action.initWithAction(this._inner.clone());
                    return action;
                },
                reverse: function() {
                    return new cc.EaseBackInOut(this._inner.reverse());
                }
            });
            cc.EaseBackInOut.create = function(action) {
                return new cc.EaseBackInOut(action);
            };
            cc._easeBackInOutObj = {
                easing: function(time1) {
                    var overshoot = 2.5949095;
                    time1 = 2 * time1;
                    if (time1 < 1) {
                        return time1 * time1 * ((overshoot + 1) * time1 - overshoot) / 2;
                    } else {
                        time1 -= 2;
                        return time1 * time1 * ((overshoot + 1) * time1 + overshoot) / 2 + 1;
                    }
                },
                reverse: function() {
                    return cc._easeBackInOutObj;
                }
            };
            cc.easeBackInOut = function() {
                return cc._easeBackInOutObj;
            };
            cc.EaseBezierAction = cc.ActionEase.extend({
                _p0: null,
                _p1: null,
                _p2: null,
                _p3: null,
                ctor: function(action) {
                    cc.ActionEase.prototype.ctor.call(this, action);
                },
                _updateTime: function(a, b, c, d, t) {
                    return Math.pow(1 - t, 3) * a + 3 * t * Math.pow(1 - t, 2) * b + 3 * Math.pow(t, 2) * (1 - t) * c + Math.pow(t, 3) * d;
                },
                update: function(dt) {
                    var t = this._updateTime(this._p0, this._p1, this._p2, this._p3, dt);
                    this._inner.update(t);
                },
                clone: function() {
                    var action = new cc.EaseBezierAction();
                    action.initWithAction(this._inner.clone());
                    action.setBezierParamer(this._p0, this._p1, this._p2, this._p3);
                    return action;
                },
                reverse: function() {
                    var action = new cc.EaseBezierAction(this._inner.reverse());
                    action.setBezierParamer(this._p3, this._p2, this._p1, this._p0);
                    return action;
                },
                setBezierParamer: function(p0, p1, p2, p3) {
                    this._p0 = p0 || 0;
                    this._p1 = p1 || 0;
                    this._p2 = p2 || 0;
                    this._p3 = p3 || 0;
                }
            });
            cc.EaseBezierAction.create = function(action) {
                return new cc.EaseBezierAction(action);
            };
            cc.easeBezierAction = function(p0, p1, p2, p3) {
                return {
                    easing: function(time) {
                        return cc.EaseBezierAction.prototype._updateTime(p0, p1, p2, p3, time);
                    },
                    reverse: function() {
                        return cc.easeBezierAction(p3, p2, p1, p0);
                    }
                };
            };
            cc.EaseQuadraticActionIn = cc.ActionEase.extend({
                _updateTime: function(time) {
                    return Math.pow(time, 2);
                },
                update: function(dt) {
                    this._inner.update(this._updateTime(dt));
                },
                clone: function() {
                    var action = new cc.EaseQuadraticActionIn();
                    action.initWithAction(this._inner.clone());
                    return action;
                },
                reverse: function() {
                    return new cc.EaseQuadraticActionIn(this._inner.reverse());
                }
            });
            cc.EaseQuadraticActionIn.create = function(action) {
                return new cc.EaseQuadraticActionIn(action);
            };
            cc._easeQuadraticActionIn = {
                easing: cc.EaseQuadraticActionIn.prototype._updateTime,
                reverse: function() {
                    return cc._easeQuadraticActionIn;
                }
            };
            cc.easeQuadraticActionIn = function() {
                return cc._easeQuadraticActionIn;
            };
            cc.EaseQuadraticActionOut = cc.ActionEase.extend({
                _updateTime: function(time) {
                    return -time * (time - 2);
                },
                update: function(dt) {
                    this._inner.update(this._updateTime(dt));
                },
                clone: function() {
                    var action = new cc.EaseQuadraticActionOut();
                    action.initWithAction();
                    return action;
                },
                reverse: function() {
                    return new cc.EaseQuadraticActionOut(this._inner.reverse());
                }
            });
            cc.EaseQuadraticActionOut.create = function(action) {
                return new cc.EaseQuadraticActionOut(action);
            };
            cc._easeQuadraticActionOut = {
                easing: cc.EaseQuadraticActionOut.prototype._updateTime,
                reverse: function() {
                    return cc._easeQuadraticActionOut;
                }
            };
            cc.easeQuadraticActionOut = function() {
                return cc._easeQuadraticActionOut;
            };
            cc.EaseQuadraticActionInOut = cc.ActionEase.extend({
                _updateTime: function(time) {
                    var resultTime = time;
                    time *= 2;
                    if (time < 1) {
                        resultTime = time * time * .5;
                    } else {
                        --time;
                        resultTime = -.5 * (time * (time - 2) - 1);
                    }
                    return resultTime;
                },
                update: function(dt) {
                    this._inner.update(this._updateTime(dt));
                },
                clone: function() {
                    var action = new cc.EaseQuadraticActionInOut();
                    action.initWithAction(this._inner.clone());
                    return action;
                },
                reverse: function() {
                    return new cc.EaseQuadraticActionInOut(this._inner.reverse());
                }
            });
            cc.EaseQuadraticActionInOut.create = function(action) {
                return new cc.EaseQuadraticActionInOut(action);
            };
            cc._easeQuadraticActionInOut = {
                easing: cc.EaseQuadraticActionInOut.prototype._updateTime,
                reverse: function() {
                    return cc._easeQuadraticActionInOut;
                }
            };
            cc.easeQuadraticActionInOut = function() {
                return cc._easeQuadraticActionInOut;
            };
            cc.EaseQuarticActionIn = cc.ActionEase.extend({
                _updateTime: function(time) {
                    return time * time * time * time;
                },
                update: function(dt) {
                    this._inner.update(this._updateTime(dt));
                },
                clone: function() {
                    var action = new cc.EaseQuarticActionIn();
                    action.initWithAction(this._inner.clone());
                    return action;
                },
                reverse: function() {
                    return new cc.EaseQuarticActionIn(this._inner.reverse());
                }
            });
            cc.EaseQuarticActionIn.create = function(action) {
                return new cc.EaseQuarticActionIn(action);
            };
            cc._easeQuarticActionIn = {
                easing: cc.EaseQuarticActionIn.prototype._updateTime,
                reverse: function() {
                    return cc._easeQuarticActionIn;
                }
            };
            cc.easeQuarticActionIn = function() {
                return cc._easeQuarticActionIn;
            };
            cc.EaseQuarticActionOut = cc.ActionEase.extend({
                _updateTime: function(time) {
                    time -= 1;
                    return -(time * time * time * time - 1);
                },
                update: function(dt) {
                    this._inner.update(this._updateTime(dt));
                },
                clone: function() {
                    var action = new cc.EaseQuarticActionOut();
                    action.initWithAction(this._inner.clone());
                    return action;
                },
                reverse: function() {
                    return new cc.EaseQuarticActionOut(this._inner.reverse());
                }
            });
            cc.EaseQuarticActionOut.create = function(action) {
                return new cc.EaseQuarticActionOut(action);
            };
            cc._easeQuarticActionOut = {
                easing: cc.EaseQuarticActionOut.prototype._updateTime,
                reverse: function() {
                    return cc._easeQuarticActionOut;
                }
            };
            cc.easeQuarticActionOut = function() {
                return cc._easeQuarticActionOut;
            };
            cc.EaseQuarticActionInOut = cc.ActionEase.extend({
                _updateTime: function(time) {
                    time = 2 * time;
                    if (time < 1) {
                        return .5 * time * time * time * time;
                    }
                    time -= 2;
                    return -.5 * (time * time * time * time - 2);
                },
                update: function(dt) {
                    this._inner.update(this._updateTime(dt));
                },
                clone: function() {
                    var action = new cc.EaseQuarticActionInOut();
                    action.initWithAction(this._inner.clone());
                    return action;
                },
                reverse: function() {
                    return new cc.EaseQuarticActionInOut(this._inner.reverse());
                }
            });
            cc.EaseQuarticActionInOut.create = function(action) {
                return new cc.EaseQuarticActionInOut(action);
            };
            cc._easeQuarticActionInOut = {
                easing: cc.EaseQuarticActionInOut.prototype._updateTime,
                reverse: function() {
                    return cc._easeQuarticActionInOut;
                }
            };
            cc.easeQuarticActionInOut = function() {
                return cc._easeQuarticActionInOut;
            };
            cc.EaseQuinticActionIn = cc.ActionEase.extend({
                _updateTime: function(time) {
                    return time * time * time * time * time;
                },
                update: function(dt) {
                    this._inner.update(this._updateTime(dt));
                },
                clone: function() {
                    var action = new cc.EaseQuinticActionIn();
                    action.initWithAction(this._inner.clone());
                    return action;
                },
                reverse: function() {
                    return new cc.EaseQuinticActionIn(this._inner.reverse());
                }
            });
            cc.EaseQuinticActionIn.create = function(action) {
                return new cc.EaseQuinticActionIn(action);
            };
            cc._easeQuinticActionIn = {
                easing: cc.EaseQuinticActionIn.prototype._updateTime,
                reverse: function() {
                    return cc._easeQuinticActionIn;
                }
            };
            cc.easeQuinticActionIn = function() {
                return cc._easeQuinticActionIn;
            };
            cc.EaseQuinticActionOut = cc.ActionEase.extend({
                _updateTime: function(time) {
                    time -= 1;
                    return time * time * time * time * time + 1;
                },
                update: function(dt) {
                    this._inner.update(this._updateTime(dt));
                },
                clone: function() {
                    var action = new cc.EaseQuinticActionOut();
                    action.initWithAction(this._inner.clone());
                    return action;
                },
                reverse: function() {
                    return new cc.EaseQuinticActionOut(this._inner.reverse());
                }
            });
            cc.EaseQuinticActionOut.create = function(action) {
                return new cc.EaseQuinticActionOut(action);
            };
            cc._easeQuinticActionOut = {
                easing: cc.EaseQuinticActionOut.prototype._updateTime,
                reverse: function() {
                    return cc._easeQuinticActionOut;
                }
            };
            cc.easeQuinticActionOut = function() {
                return cc._easeQuinticActionOut;
            };
            cc.EaseQuinticActionInOut = cc.ActionEase.extend({
                _updateTime: function(time) {
                    time = 2 * time;
                    if (time < 1) {
                        return .5 * time * time * time * time * time;
                    }
                    time -= 2;
                    return .5 * (time * time * time * time * time + 2);
                },
                update: function(dt) {
                    this._inner.update(this._updateTime(dt));
                },
                clone: function() {
                    var action = new cc.EaseQuinticActionInOut();
                    action.initWithAction(this._inner.clone());
                    return action;
                },
                reverse: function() {
                    return new cc.EaseQuinticActionInOut(this._inner.reverse());
                }
            });
            cc.EaseQuinticActionInOut.create = function(action) {
                return new cc.EaseQuinticActionInOut(action);
            };
            cc._easeQuinticActionInOut = {
                easing: cc.EaseQuinticActionInOut.prototype._updateTime,
                reverse: function() {
                    return cc._easeQuinticActionInOut;
                }
            };
            cc.easeQuinticActionInOut = function() {
                return cc._easeQuinticActionInOut;
            };
            cc.EaseCircleActionIn = cc.ActionEase.extend({
                _updateTime: function(time) {
                    return -1 * (Math.sqrt(1 - time * time) - 1);
                },
                update: function(dt) {
                    this._inner.update(this._updateTime(dt));
                },
                clone: function() {
                    var action = new cc.EaseCircleActionIn();
                    action.initWithAction(this._inner.clone());
                    return action;
                },
                reverse: function() {
                    return new cc.EaseCircleActionIn(this._inner.reverse());
                }
            });
            cc.EaseCircleActionIn.create = function(action) {
                return new cc.EaseCircleActionIn(action);
            };
            cc._easeCircleActionIn = {
                easing: cc.EaseCircleActionIn.prototype._updateTime,
                reverse: function() {
                    return cc._easeCircleActionIn;
                }
            };
            cc.easeCircleActionIn = function() {
                return cc._easeCircleActionIn;
            };
            cc.EaseCircleActionOut = cc.ActionEase.extend({
                _updateTime: function(time) {
                    time -= 1;
                    return Math.sqrt(1 - time * time);
                },
                update: function(dt) {
                    this._inner.update(this._updateTime(dt));
                },
                clone: function() {
                    var action = new cc.EaseCircleActionOut();
                    action.initWithAction(this._inner.clone());
                    return action;
                },
                reverse: function() {
                    return new cc.EaseCircleActionOut(this._inner.reverse());
                }
            });
            cc.EaseCircleActionOut.create = function(action) {
                return new cc.EaseCircleActionOut(action);
            };
            cc._easeCircleActionOut = {
                easing: cc.EaseCircleActionOut.prototype._updateTime,
                reverse: function() {
                    return cc._easeCircleActionOut;
                }
            };
            cc.easeCircleActionOut = function() {
                return cc._easeCircleActionOut;
            };
            cc.EaseCircleActionInOut = cc.ActionEase.extend({
                _updateTime: function(time) {
                    time = 2 * time;
                    if (time < 1) {
                        return -.5 * (Math.sqrt(1 - time * time) - 1);
                    }
                    time -= 2;
                    return .5 * (Math.sqrt(1 - time * time) + 1);
                },
                update: function(dt) {
                    this._inner.update(this._updateTime(dt));
                },
                clone: function() {
                    var action = new cc.EaseCircleActionInOut();
                    action.initWithAction(this._inner.clone());
                    return action;
                },
                reverse: function() {
                    return new cc.EaseCircleActionInOut(this._inner.reverse());
                }
            });
            cc.EaseCircleActionInOut.create = function(action) {
                return new cc.EaseCircleActionInOut(action);
            };
            cc._easeCircleActionInOut = {
                easing: cc.EaseCircleActionInOut.prototype._updateTime,
                reverse: function() {
                    return cc._easeCircleActionInOut;
                }
            };
            cc.easeCircleActionInOut = function() {
                return cc._easeCircleActionInOut;
            };
            cc.EaseCubicActionIn = cc.ActionEase.extend({
                _updateTime: function(time) {
                    return time * time * time;
                },
                update: function(dt) {
                    this._inner.update(this._updateTime(dt));
                },
                clone: function() {
                    var action = new cc.EaseCubicActionIn();
                    action.initWithAction(this._inner.clone());
                    return action;
                },
                reverse: function() {
                    return new cc.EaseCubicActionIn(this._inner.reverse());
                }
            });
            cc.EaseCubicActionIn.create = function(action) {
                return new cc.EaseCubicActionIn(action);
            };
            cc._easeCubicActionIn = {
                easing: cc.EaseCubicActionIn.prototype._updateTime,
                reverse: function() {
                    return cc._easeCubicActionIn;
                }
            };
            cc.easeCubicActionIn = function() {
                return cc._easeCubicActionIn;
            };
            cc.EaseCubicActionOut = cc.ActionEase.extend({
                _updateTime: function(time) {
                    time -= 1;
                    return time * time * time + 1;
                },
                update: function(dt) {
                    this._inner.update(this._updateTime(dt));
                },
                clone: function() {
                    var action = new cc.EaseCubicActionOut();
                    action.initWithAction(this._inner.clone());
                    return action;
                },
                reverse: function() {
                    return new cc.EaseCubicActionOut(this._inner.reverse());
                }
            });
            cc.EaseCubicActionOut.create = function(action) {
                return new cc.EaseCubicActionOut(action);
            };
            cc._easeCubicActionOut = {
                easing: cc.EaseCubicActionOut.prototype._updateTime,
                reverse: function() {
                    return cc._easeCubicActionOut;
                }
            };
            cc.easeCubicActionOut = function() {
                return cc._easeCubicActionOut;
            };
            cc.EaseCubicActionInOut = cc.ActionEase.extend({
                _updateTime: function(time) {
                    time = 2 * time;
                    if (time < 1) {
                        return .5 * time * time * time;
                    }
                    time -= 2;
                    return .5 * (time * time * time + 2);
                },
                update: function(dt) {
                    this._inner.update(this._updateTime(dt));
                },
                clone: function() {
                    var action = new cc.EaseCubicActionInOut();
                    action.initWithAction(this._inner.clone());
                    return action;
                },
                reverse: function() {
                    return new cc.EaseCubicActionInOut(this._inner.reverse());
                }
            });
            cc.EaseCubicActionInOut.create = function(action) {
                return new cc.EaseCubicActionInOut(action);
            };
            cc._easeCubicActionInOut = {
                easing: cc.EaseCubicActionInOut.prototype._updateTime,
                reverse: function() {
                    return cc._easeCubicActionInOut;
                }
            };
            cc.easeCubicActionInOut = function() {
                return cc._easeCubicActionInOut;
            };
            cc.cardinalSplineAt = function(p0, p1, p2, p3, tension, t) {
                var t2 = t * t;
                var t3 = t2 * t;
                var s = (1 - tension) / 2;
                var b1 = s * (-t3 + 2 * t2 - t);
                var b2 = s * (-t3 + t2) + (2 * t3 - 3 * t2 + 1);
                var b3 = s * (t3 - 2 * t2 + t) + (-2 * t3 + 3 * t2);
                var b4 = s * (t3 - t2);
                var x = p0.x * b1 + p1.x * b2 + p2.x * b3 + p3.x * b4;
                var y = p0.y * b1 + p1.y * b2 + p2.y * b3 + p3.y * b4;
                return cc.p(x, y);
            };
            cc.reverseControlPoints = function(controlPoints) {
                var newArray = [];
                for (var i = controlPoints.length - 1; i >= 0; i--) {
                    newArray.push(cc.p(controlPoints[i].x, controlPoints[i].y));
                }
                return newArray;
            };
            cc.cloneControlPoints = function(controlPoints) {
                var newArray = [];
                for (var i = 0; i < controlPoints.length; i++) {
                    newArray.push(cc.p(controlPoints[i].x, controlPoints[i].y));
                }
                return newArray;
            };
            cc.copyControlPoints = cc.cloneControlPoints;
            cc.getControlPointAt = function(controlPoints, pos) {
                var p = Math.min(controlPoints.length - 1, Math.max(pos, 0));
                return controlPoints[p];
            };
            cc.reverseControlPointsInline = function(controlPoints) {
                var len = controlPoints.length;
                var mid = 0 | len / 2;
                for (var i = 0; i < mid; ++i) {
                    var temp = controlPoints[i];
                    controlPoints[i] = controlPoints[len - i - 1];
                    controlPoints[len - i - 1] = temp;
                }
            };
            cc.CardinalSplineTo = cc.ActionInterval.extend({
                _points: null,
                _deltaT: 0,
                _tension: 0,
                _previousPosition: null,
                _accumulatedDiff: null,
                ctor: function(duration, points, tension) {
                    cc.ActionInterval.prototype.ctor.call(this);
                    this._points = [];
                    void 0 !== tension && this.initWithDuration(duration, points, tension);
                },
                initWithDuration: function(duration, points, tension) {
                    if (!points || 0 === points.length) {
                        throw new Error("Invalid configuration. It must at least have one control point");
                    }
                    if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
                        this.setPoints(points);
                        this._tension = tension;
                        return true;
                    }
                    return false;
                },
                clone: function() {
                    var action = new cc.CardinalSplineTo();
                    action.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension);
                    return action;
                },
                startWithTarget: function(target) {
                    cc.ActionInterval.prototype.startWithTarget.call(this, target);
                    this._deltaT = 1 / (this._points.length - 1);
                    this._previousPosition = cc.p(this.target.getPositionX(), this.target.getPositionY());
                    this._accumulatedDiff = cc.p(0, 0);
                },
                update: function(dt) {
                    dt = this._computeEaseTime(dt);
                    var p, lt;
                    var ps = this._points;
                    if (1 === dt) {
                        p = ps.length - 1;
                        lt = 1;
                    } else {
                        var locDT = this._deltaT;
                        p = 0 | dt / locDT;
                        lt = (dt - locDT * p) / locDT;
                    }
                    var newPos = cc.cardinalSplineAt(cc.getControlPointAt(ps, p - 1), cc.getControlPointAt(ps, p - 0), cc.getControlPointAt(ps, p + 1), cc.getControlPointAt(ps, p + 2), this._tension, lt);
                    if (cc.ENABLE_STACKABLE_ACTIONS) {
                        var tempX, tempY;
                        tempX = this.target.getPositionX() - this._previousPosition.x;
                        tempY = this.target.getPositionY() - this._previousPosition.y;
                        if (0 !== tempX || 0 !== tempY) {
                            var locAccDiff = this._accumulatedDiff;
                            tempX = locAccDiff.x + tempX;
                            tempY = locAccDiff.y + tempY;
                            locAccDiff.x = tempX;
                            locAccDiff.y = tempY;
                            newPos.x += tempX;
                            newPos.y += tempY;
                        }
                    }
                    this.updatePosition(newPos);
                },
                reverse: function() {
                    var reversePoints = cc.reverseControlPoints(this._points);
                    return cc.cardinalSplineTo(this._duration, reversePoints, this._tension);
                },
                updatePosition: function(newPos) {
                    this.target.setPosition(newPos);
                    this._previousPosition = newPos;
                },
                getPoints: function() {
                    return this._points;
                },
                setPoints: function(points) {
                    this._points = points;
                }
            });
            cc.cardinalSplineTo = function(duration, points, tension) {
                return new cc.CardinalSplineTo(duration, points, tension);
            };
            cc.CardinalSplineTo.create = cc.cardinalSplineTo;
            cc.CardinalSplineBy = cc.CardinalSplineTo.extend({
                _startPosition: null,
                ctor: function(duration, points, tension) {
                    cc.CardinalSplineTo.prototype.ctor.call(this);
                    this._startPosition = cc.p(0, 0);
                    void 0 !== tension && this.initWithDuration(duration, points, tension);
                },
                startWithTarget: function(target) {
                    cc.CardinalSplineTo.prototype.startWithTarget.call(this, target);
                    this._startPosition.x = target.getPositionX();
                    this._startPosition.y = target.getPositionY();
                },
                reverse: function() {
                    var copyConfig = this._points.slice();
                    var current;
                    var p = copyConfig[0];
                    for (var i = 1; i < copyConfig.length; ++i) {
                        current = copyConfig[i];
                        copyConfig[i] = cc.pSub(current, p);
                        p = current;
                    }
                    var reverseArray = cc.reverseControlPoints(copyConfig);
                    p = reverseArray[reverseArray.length - 1];
                    reverseArray.pop();
                    p.x = -p.x;
                    p.y = -p.y;
                    reverseArray.unshift(p);
                    for (var i = 1; i < reverseArray.length; ++i) {
                        current = reverseArray[i];
                        current.x = -current.x;
                        current.y = -current.y;
                        current.x += p.x;
                        current.y += p.y;
                        reverseArray[i] = current;
                        p = current;
                    }
                    return cc.cardinalSplineBy(this._duration, reverseArray, this._tension);
                },
                updatePosition: function(newPos) {
                    var pos = this._startPosition;
                    var posX = newPos.x + pos.x;
                    var posY = newPos.y + pos.y;
                    this._previousPosition.x = posX;
                    this._previousPosition.y = posY;
                    this.target.setPosition(posX, posY);
                },
                clone: function() {
                    var a = new cc.CardinalSplineBy();
                    a.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension);
                    return a;
                }
            });
            cc.cardinalSplineBy = function(duration, points, tension) {
                return new cc.CardinalSplineBy(duration, points, tension);
            };
            cc.CardinalSplineBy.create = cc.cardinalSplineBy;
            cc.CatmullRomTo = cc.CardinalSplineTo.extend({
                ctor: function(dt, points) {
                    points && this.initWithDuration(dt, points);
                },
                initWithDuration: function(dt, points) {
                    return cc.CardinalSplineTo.prototype.initWithDuration.call(this, dt, points, .5);
                },
                clone: function() {
                    var action = new cc.CatmullRomTo();
                    action.initWithDuration(this._duration, cc.copyControlPoints(this._points));
                    return action;
                }
            });
            cc.catmullRomTo = function(dt, points) {
                return new cc.CatmullRomTo(dt, points);
            };
            cc.CatmullRomTo.create = cc.catmullRomTo;
            cc.CatmullRomBy = cc.CardinalSplineBy.extend({
                ctor: function(dt, points) {
                    cc.CardinalSplineBy.prototype.ctor.call(this);
                    points && this.initWithDuration(dt, points);
                },
                initWithDuration: function(dt, points) {
                    return cc.CardinalSplineTo.prototype.initWithDuration.call(this, dt, points, .5);
                },
                clone: function() {
                    var action = new cc.CatmullRomBy();
                    action.initWithDuration(this._duration, cc.copyControlPoints(this._points));
                    return action;
                }
            });
            cc.catmullRomBy = function(dt, points) {
                return new cc.CatmullRomBy(dt, points);
            };
            cc.CatmullRomBy.create = cc.catmullRomBy;
            cc.ProgressTimer = _ccsg.Node.extend({
                _type: null,
                _percentage: 0,
                _sprite: null,
                _midPoint: null,
                _barChangeRate: null,
                _reverseDirection: false,
                _className: "ProgressTimer",
                ctor: function(sprite) {
                    _ccsg.Node.prototype.ctor.call(this);
                    this._type = cc.ProgressTimer.Type.RADIAL;
                    this._percentage = 0;
                    this._midPoint = cc.p(0, 0);
                    this._barChangeRate = cc.p(0, 0);
                    this._reverseDirection = false;
                    this._sprite = null;
                    sprite && this.initWithSprite(sprite);
                },
                getMidpoint: function() {
                    return cc.p(this._midPoint.x, this._midPoint.y);
                },
                setMidpoint: function(mpoint) {
                    this._midPoint = cc.pClamp(mpoint, cc.p(0, 0), cc.p(1, 1));
                },
                getBarChangeRate: function() {
                    return cc.p(this._barChangeRate.x, this._barChangeRate.y);
                },
                setBarChangeRate: function(barChangeRate) {
                    this._barChangeRate = cc.pClamp(barChangeRate, cc.p(0, 0), cc.p(1, 1));
                },
                getType: function() {
                    return this._type;
                },
                getPercentage: function() {
                    return this._percentage;
                },
                getSprite: function() {
                    return this._sprite;
                },
                setPercentage: function(percentage) {
                    if (this._percentage !== percentage) {
                        this._percentage = cc.clampf(percentage, 0, 100);
                        this._renderCmd._updateProgress();
                    }
                },
                setOpacityModifyRGB: function(bValue) {},
                isOpacityModifyRGB: function() {
                    return false;
                },
                isReverseDirection: function() {
                    return this._reverseDirection;
                },
                setColor: function(color) {
                    this._sprite.color = color;
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.colorDirty);
                },
                setOpacity: function(opacity) {
                    this._sprite.opacity = opacity;
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.opacityDirty);
                },
                getColor: function() {
                    return this._sprite.color;
                },
                getOpacity: function() {
                    return this._sprite.opacity;
                },
                setReverseProgress: function(reverse) {
                    if (this._reverseDirection !== reverse) {
                        this._reverseDirection = reverse;
                        this._renderCmd.releaseData();
                    }
                },
                setSprite: function(sprite) {
                    if (this._sprite !== sprite) {
                        this._sprite = sprite;
                        if (sprite) {
                            this.setContentSize(sprite.width, sprite.height);
                        } else {
                            this.setContentSize(0, 0);
                        }
                        this._renderCmd.releaseData();
                    }
                },
                setType: function(type) {
                    if (type !== this._type) {
                        this._type = type;
                        this._renderCmd.releaseData();
                    }
                },
                setReverseDirection: function(reverse) {
                    if (this._reverseDirection !== reverse) {
                        this._reverseDirection = reverse;
                        this._renderCmd.releaseData();
                    }
                },
                initWithSprite: function(sprite) {
                    this.percentage = 0;
                    this.setAnchorPoint(.5, .5);
                    this._type = cc.ProgressTimer.Type.RADIAL;
                    this._reverseDirection = false;
                    this.midPoint = cc.p(.5, .5);
                    this.barChangeRate = cc.p(1, 1);
                    this.setSprite(sprite);
                    this._renderCmd.initCmd();
                    return true;
                },
                _createRenderCmd: function() {
                    if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                        return new cc.ProgressTimer.CanvasRenderCmd(this);
                    } else {
                        return new cc.ProgressTimer.WebGLRenderCmd(this);
                    }
                }
            });
            var _p = cc.ProgressTimer.prototype;
            _p.midPoint;
            cc.defineGetterSetter(_p, "midPoint", _p.getMidpoint, _p.setMidpoint);
            _p.barChangeRate;
            cc.defineGetterSetter(_p, "barChangeRate", _p.getBarChangeRate, _p.setBarChangeRate);
            _p.type;
            cc.defineGetterSetter(_p, "type", _p.getType, _p.setType);
            _p.percentage;
            cc.defineGetterSetter(_p, "percentage", _p.getPercentage, _p.setPercentage);
            _p.sprite;
            cc.defineGetterSetter(_p, "sprite", _p.getSprite, _p.setSprite);
            _p.reverseDir;
            cc.defineGetterSetter(_p, "reverseDir", _p.isReverseDirection, _p.setReverseDirection);
            cc.ProgressTimer.create = function(sprite) {
                return new cc.ProgressTimer(sprite);
            };
            cc.ProgressTimer.TEXTURE_COORDS_COUNT = 4;
            cc.ProgressTimer.TEXTURE_COORDS = 75;
            cc.ProgressTimer.Type = cc.Enum({
                RADIAL: 0,
                BAR: 1
            });
            !function() {
                cc.ProgressTimer.CanvasRenderCmd = function(renderableObject) {
                    _ccsg.Node.CanvasRenderCmd.call(this, renderableObject);
                    this._needDraw = true;
                    this._PI180 = Math.PI / 180;
                    this._barRect = cc.rect(0, 0, 0, 0);
                    this._origin = cc.p(0, 0);
                    this._radius = 0;
                    this._startAngle = 270;
                    this._endAngle = 270;
                    this._counterClockWise = false;
                };
                var proto = cc.ProgressTimer.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
                proto.constructor = cc.ProgressTimer.CanvasRenderCmd;
                proto.rendering = function(ctx, scaleX, scaleY) {
                    var wrapper = ctx || cc._renderContext, context = wrapper.getContext(), node = this._node, locSprite = node._sprite;
                    var locTextureCoord = locSprite._renderCmd._textureCoord, alpha = locSprite._renderCmd._displayedOpacity / 255;
                    if (0 === locTextureCoord.width || 0 === locTextureCoord.height) {
                        return;
                    }
                    if (!locSprite._texture || !locTextureCoord.validRect || 0 === alpha) {
                        return;
                    }
                    wrapper.setTransform(this._worldTransform, scaleX, scaleY);
                    wrapper.setCompositeOperation(locSprite._blendFuncStr);
                    wrapper.setGlobalAlpha(alpha);
                    var locRect = locSprite._rect, locOffsetPosition = locSprite._offsetPosition;
                    var locX = locOffsetPosition.x, locY = -locOffsetPosition.y - locRect.height, locWidth = locRect.width, locHeight = locRect.height;
                    wrapper.save();
                    if (locSprite._flippedX) {
                        locX = -locX - locWidth;
                        context.scale(-1, 1);
                    }
                    if (locSprite._flippedY) {
                        locY = locOffsetPosition.y;
                        context.scale(1, -1);
                    }
                    if (node._type === cc.ProgressTimer.Type.BAR) {
                        var locBarRect = this._barRect;
                        context.beginPath();
                        context.rect(locBarRect.x * scaleX, locBarRect.y * scaleY, locBarRect.width * scaleX, locBarRect.height * scaleY);
                        context.clip();
                        context.closePath();
                    } else {
                        if (node._type === cc.ProgressTimer.Type.RADIAL) {
                            var locOriginX = this._origin.x * scaleX;
                            var locOriginY = this._origin.y * scaleY;
                            context.beginPath();
                            context.arc(locOriginX, locOriginY, this._radius * scaleY, this._PI180 * this._startAngle, this._PI180 * this._endAngle, this._counterClockWise);
                            context.lineTo(locOriginX, locOriginY);
                            context.clip();
                            context.closePath();
                        }
                    }
                    var image = locSprite._texture.getHtmlElementObj();
                    if (locSprite._renderCmd._colorized) {
                        context.drawImage(image, 0, 0, locTextureCoord.width, locTextureCoord.height, locX * scaleX, locY * scaleY, locWidth * scaleX, locHeight * scaleY);
                    } else {
                        context.drawImage(image, locTextureCoord.renderX, locTextureCoord.renderY, locTextureCoord.width, locTextureCoord.height, locX * scaleX, locY * scaleY, locWidth * scaleX, locHeight * scaleY);
                    }
                    wrapper.restore();
                    cc.g_NumberOfDraws++;
                };
                proto.releaseData = function() {};
                proto.initCmd = function() {};
                proto._updateProgress = function() {
                    var node = this._node;
                    var locSprite = node._sprite;
                    var sw = locSprite.width, sh = locSprite.height;
                    var locMidPoint = node._midPoint;
                    if (node._type === cc.ProgressTimer.Type.RADIAL) {
                        this._radius = Math.round(Math.sqrt(sw * sw + sh * sh));
                        var locStartAngle, locEndAngle, locCounterClockWise = false, locOrigin = this._origin;
                        locOrigin.x = sw * locMidPoint.x;
                        locOrigin.y = -sh * locMidPoint.y;
                        if (node._reverseDirection) {
                            locEndAngle = 270;
                            locStartAngle = 270 - 3.6 * node._percentage;
                        } else {
                            locStartAngle = -90;
                            locEndAngle = -90 + 3.6 * node._percentage;
                        }
                        if (locSprite._flippedX) {
                            locOrigin.x -= 2 * sw * node._midPoint.x;
                            locStartAngle = -locStartAngle;
                            locEndAngle = -locEndAngle;
                            locStartAngle -= 180;
                            locEndAngle -= 180;
                            locCounterClockWise = !locCounterClockWise;
                        }
                        if (locSprite._flippedY) {
                            locOrigin.y += 2 * sh * node._midPoint.y;
                            locCounterClockWise = !locCounterClockWise;
                            locStartAngle = -locStartAngle;
                            locEndAngle = -locEndAngle;
                        }
                        this._startAngle = locStartAngle;
                        this._endAngle = locEndAngle;
                        this._counterClockWise = locCounterClockWise;
                    } else {
                        var locBarChangeRate = node._barChangeRate;
                        var percentageF = node._percentage / 100;
                        var locBarRect = this._barRect;
                        var drewSize = cc.size(sw * (1 - locBarChangeRate.x), sh * (1 - locBarChangeRate.y));
                        var drawingSize = cc.size((sw - drewSize.width) * percentageF, (sh - drewSize.height) * percentageF);
                        var currentDrawSize = cc.size(drewSize.width + drawingSize.width, drewSize.height + drawingSize.height);
                        var startPoint = cc.p(sw * locMidPoint.x, sh * locMidPoint.y);
                        var needToLeft = startPoint.x - currentDrawSize.width / 2;
                        if (locMidPoint.x > .5 && currentDrawSize.width / 2 >= sw - startPoint.x) {
                            needToLeft = sw - currentDrawSize.width;
                        }
                        var needToTop = startPoint.y - currentDrawSize.height / 2;
                        if (locMidPoint.y > .5 && currentDrawSize.height / 2 >= sh - startPoint.y) {
                            needToTop = sh - currentDrawSize.height;
                        }
                        locBarRect.x = 0;
                        var flipXNeed = 1;
                        if (locSprite._flippedX) {
                            locBarRect.x -= currentDrawSize.width;
                            flipXNeed = -1;
                        }
                        if (needToLeft > 0) {
                            locBarRect.x += needToLeft * flipXNeed;
                        }
                        locBarRect.y = 0;
                        var flipYNeed = 1;
                        if (locSprite._flippedY) {
                            locBarRect.y += currentDrawSize.height;
                            flipYNeed = -1;
                        }
                        if (needToTop > 0) {
                            locBarRect.y -= needToTop * flipYNeed;
                        }
                        locBarRect.width = currentDrawSize.width;
                        locBarRect.height = -currentDrawSize.height;
                    }
                };
                proto._updateColor = function() {};
                proto._syncStatus = function(parentCmd) {
                    var node = this._node;
                    if (!node._sprite) {
                        return;
                    }
                    var flags = _ccsg.Node._dirtyFlags, locFlag = this._dirtyFlag;
                    var parentNode = parentCmd ? parentCmd._node : null;
                    if (parentNode && parentNode._cascadeColorEnabled && parentCmd._dirtyFlag & flags.colorDirty) {
                        locFlag |= flags.colorDirty;
                    }
                    if (parentNode && parentNode._cascadeOpacityEnabled && parentCmd._dirtyFlag & flags.opacityDirty) {
                        locFlag |= flags.opacityDirty;
                    }
                    if (parentCmd && parentCmd._dirtyFlag & flags.transformDirty) {
                        locFlag |= flags.transformDirty;
                    }
                    this._dirtyFlag = locFlag;
                    var spriteCmd = node._sprite._renderCmd;
                    var spriteFlag = spriteCmd._dirtyFlag;
                    var colorDirty = spriteFlag & flags.colorDirty, opacityDirty = spriteFlag & flags.opacityDirty;
                    if (colorDirty) {
                        spriteCmd._syncDisplayColor();
                    }
                    if (opacityDirty) {
                        spriteCmd._syncDisplayOpacity();
                    }
                    if (colorDirty || opacityDirty) {
                        spriteCmd._updateColor();
                    }
                    if (locFlag & flags.transformDirty) {
                        this.transform(parentCmd);
                    }
                };
                proto.updateStatus = function() {
                    var node = this._node;
                    if (!node._sprite) {
                        return;
                    }
                    var flags = _ccsg.Node._dirtyFlags, locFlag = this._dirtyFlag;
                    var spriteCmd = node._sprite._renderCmd;
                    var spriteFlag = spriteCmd._dirtyFlag;
                    var colorDirty = spriteFlag & flags.colorDirty, opacityDirty = spriteFlag & flags.opacityDirty;
                    if (colorDirty) {
                        spriteCmd._updateDisplayColor();
                    }
                    if (opacityDirty) {
                        spriteCmd._updateDisplayOpacity();
                    }
                    if (colorDirty || opacityDirty) {
                        spriteCmd._updateColor();
                    }
                    if (locFlag & flags.transformDirty) {
                        this.transform(this.getParentRenderCmd(), true);
                    }
                    this._dirtyFlag = 0;
                };
            }();
            !function() {
                cc.ProgressTimer.WebGLRenderCmd = function(renderableObject) {
                    _ccsg.Node.WebGLRenderCmd.call(this, renderableObject);
                    this._needDraw = true;
                    this._vertexWebGLBuffer = cc._renderContext.createBuffer();
                    this._vertexDataCount = 0;
                    this._vertexData = null;
                    this._vertexArrayBuffer = null;
                    this._vertexDataDirty = false;
                };
                var proto = cc.ProgressTimer.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
                proto.constructor = cc.ProgressTimer.WebGLRenderCmd;
                proto.rendering = function(ctx) {
                    var node = this._node;
                    var context = ctx || cc._renderContext;
                    if (!this._vertexData || !node._sprite) {
                        return;
                    }
                    this._shaderProgram.use();
                    this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
                    var blendFunc = node._sprite._blendFunc;
                    cc.glBlendFunc(blendFunc.src, blendFunc.dst);
                    cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
                    cc.glBindTexture2D(node._sprite.texture);
                    context.bindBuffer(context.ARRAY_BUFFER, this._vertexWebGLBuffer);
                    if (this._vertexDataDirty) {
                        context.bufferData(context.ARRAY_BUFFER, this._vertexArrayBuffer, context.DYNAMIC_DRAW);
                        this._vertexDataDirty = false;
                    }
                    var locVertexDataLen = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
                    context.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, context.FLOAT, false, locVertexDataLen, 0);
                    context.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, context.UNSIGNED_BYTE, true, locVertexDataLen, 8);
                    context.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, context.FLOAT, false, locVertexDataLen, 12);
                    if (node._type === cc.ProgressTimer.Type.RADIAL) {
                        context.drawArrays(context.TRIANGLE_FAN, 0, this._vertexDataCount);
                    } else {
                        if (node._type === cc.ProgressTimer.Type.BAR) {
                            if (!node._reverseDirection) {
                                context.drawArrays(context.TRIANGLE_STRIP, 0, this._vertexDataCount);
                            } else {
                                context.drawArrays(context.TRIANGLE_STRIP, 0, this._vertexDataCount / 2);
                                context.drawArrays(context.TRIANGLE_STRIP, 4, this._vertexDataCount / 2);
                                cc.g_NumberOfDraws++;
                            }
                        }
                    }
                    cc.g_NumberOfDraws++;
                };
                proto._syncStatus = function(parentCmd) {
                    var node = this._node;
                    if (!node._sprite) {
                        return;
                    }
                    var flags = _ccsg.Node._dirtyFlags, locFlag = this._dirtyFlag;
                    var parentNode = parentCmd ? parentCmd._node : null;
                    if (parentNode && parentNode._cascadeColorEnabled && parentCmd._dirtyFlag & flags.colorDirty) {
                        locFlag |= flags.colorDirty;
                    }
                    if (parentNode && parentNode._cascadeOpacityEnabled && parentCmd._dirtyFlag & flags.opacityDirty) {
                        locFlag |= flags.opacityDirty;
                    }
                    if (parentCmd && parentCmd._dirtyFlag & flags.transformDirty) {
                        locFlag |= flags.transformDirty;
                    }
                    this._dirtyFlag = locFlag;
                    var spriteCmd = node._sprite._renderCmd;
                    var spriteFlag = spriteCmd._dirtyFlag;
                    var colorDirty = spriteFlag & flags.colorDirty, opacityDirty = spriteFlag & flags.opacityDirty;
                    if (colorDirty) {
                        spriteCmd._syncDisplayColor();
                    }
                    if (opacityDirty) {
                        spriteCmd._syncDisplayOpacity();
                    }
                    if (colorDirty || opacityDirty) {
                        spriteCmd._updateColor();
                        this._updateColor();
                    }
                    this.transform(parentCmd);
                    spriteCmd._dirtyFlag = 0;
                };
                proto.updateStatus = function() {
                    var node = this._node;
                    if (!node._sprite) {
                        return;
                    }
                    var flags = _ccsg.Node._dirtyFlags, locFlag = this._dirtyFlag;
                    var spriteCmd = node._sprite._renderCmd;
                    var spriteFlag = spriteCmd._dirtyFlag;
                    var colorDirty = spriteFlag & flags.colorDirty, opacityDirty = spriteFlag & flags.opacityDirty;
                    if (colorDirty) {
                        spriteCmd._updateDisplayColor();
                        this._dirtyFlag = this._dirtyFlag & flags.colorDirty ^ this._dirtyFlag;
                    }
                    if (opacityDirty) {
                        spriteCmd._updateDisplayOpacity();
                        this._dirtyFlag = this._dirtyFlag & flags.opacityDirty ^ this._dirtyFlag;
                    }
                    if (colorDirty || opacityDirty) {
                        spriteCmd._updateColor();
                        this._updateColor();
                    }
                    if (locFlag & flags.transformDirty) {
                        this.transform(this.getParentRenderCmd(), true);
                    }
                };
                proto.releaseData = function() {
                    if (this._vertexData) {
                        this._vertexData = null;
                        this._vertexArrayBuffer = null;
                        this._vertexDataCount = 0;
                    }
                };
                proto.initCmd = function() {
                    this._vertexData = null;
                    this._vertexArrayBuffer = null;
                    this._vertexDataCount = 0;
                    this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
                };
                proto._updateProgress = function() {
                    var node = this._node;
                    var locType = node._type;
                    if (locType === cc.ProgressTimer.Type.RADIAL) {
                        this._updateRadial();
                    } else {
                        if (locType === cc.ProgressTimer.Type.BAR) {
                            this._updateBar();
                        }
                    }
                    this._vertexDataDirty = true;
                };
                proto._updateBar = function() {
                    var node = this._node;
                    if (!node._sprite) {
                        return;
                    }
                    var i, alpha = node._percentage / 100;
                    var locBarChangeRate = node._barChangeRate;
                    var alphaOffset = cc.pMult(cc.p(1 - locBarChangeRate.x + alpha * locBarChangeRate.x, 1 - locBarChangeRate.y + alpha * locBarChangeRate.y), .5);
                    var min = cc.pSub(node._midPoint, alphaOffset), max = cc.pAdd(node._midPoint, alphaOffset);
                    if (min.x < 0) {
                        max.x += -min.x;
                        min.x = 0;
                    }
                    if (max.x > 1) {
                        min.x -= max.x - 1;
                        max.x = 1;
                    }
                    if (min.y < 0) {
                        max.y += -min.y;
                        min.y = 0;
                    }
                    if (max.y > 1) {
                        min.y -= max.y - 1;
                        max.y = 1;
                    }
                    var locVertexData;
                    if (!this._reverseDirection) {
                        if (!this._vertexData) {
                            this._vertexDataCount = 4;
                            var vertexDataLen = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT, locCount = 4;
                            this._vertexArrayBuffer = new ArrayBuffer(locCount * vertexDataLen);
                            this._vertexData = [];
                            for (i = 0; i < locCount; i++) {
                                this._vertexData[i] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer, i * vertexDataLen);
                            }
                        }
                        locVertexData = this._vertexData;
                        locVertexData[0].texCoords = this._textureCoordFromAlphaPoint(cc.p(min.x, max.y));
                        locVertexData[0].vertices = this._vertexFromAlphaPoint(cc.p(min.x, max.y));
                        locVertexData[1].texCoords = this._textureCoordFromAlphaPoint(cc.p(min.x, min.y));
                        locVertexData[1].vertices = this._vertexFromAlphaPoint(cc.p(min.x, min.y));
                        locVertexData[2].texCoords = this._textureCoordFromAlphaPoint(cc.p(max.x, max.y));
                        locVertexData[2].vertices = this._vertexFromAlphaPoint(cc.p(max.x, max.y));
                        locVertexData[3].texCoords = this._textureCoordFromAlphaPoint(cc.p(max.x, min.y));
                        locVertexData[3].vertices = this._vertexFromAlphaPoint(cc.p(max.x, min.y));
                    } else {
                        if (!this._vertexData) {
                            this._vertexDataCount = 8;
                            var rVertexDataLen = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT, rLocCount = 8;
                            this._vertexArrayBuffer = new ArrayBuffer(rLocCount * rVertexDataLen);
                            var rTempData = [];
                            for (i = 0; i < rLocCount; i++) {
                                rTempData[i] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer, i * rVertexDataLen);
                            }
                            rTempData[0].texCoords = this._textureCoordFromAlphaPoint(cc.p(0, 1));
                            rTempData[0].vertices = this._vertexFromAlphaPoint(cc.p(0, 1));
                            rTempData[1].texCoords = this._textureCoordFromAlphaPoint(cc.p(0, 0));
                            rTempData[1].vertices = this._vertexFromAlphaPoint(cc.p(0, 0));
                            rTempData[6].texCoords = this._textureCoordFromAlphaPoint(cc.p(1, 1));
                            rTempData[6].vertices = this._vertexFromAlphaPoint(cc.p(1, 1));
                            rTempData[7].texCoords = this._textureCoordFromAlphaPoint(cc.p(1, 0));
                            rTempData[7].vertices = this._vertexFromAlphaPoint(cc.p(1, 0));
                            this._vertexData = rTempData;
                        }
                        locVertexData = this._vertexData;
                        locVertexData[2].texCoords = this._textureCoordFromAlphaPoint(cc.p(min.x, max.y));
                        locVertexData[2].vertices = this._vertexFromAlphaPoint(cc.p(min.x, max.y));
                        locVertexData[3].texCoords = this._textureCoordFromAlphaPoint(cc.p(min.x, min.y));
                        locVertexData[3].vertices = this._vertexFromAlphaPoint(cc.p(min.x, min.y));
                        locVertexData[4].texCoords = this._textureCoordFromAlphaPoint(cc.p(max.x, max.y));
                        locVertexData[4].vertices = this._vertexFromAlphaPoint(cc.p(max.x, max.y));
                        locVertexData[5].texCoords = this._textureCoordFromAlphaPoint(cc.p(max.x, min.y));
                        locVertexData[5].vertices = this._vertexFromAlphaPoint(cc.p(max.x, min.y));
                    }
                    this._updateColor();
                };
                proto._updateRadial = function() {
                    var node = this._node;
                    if (!node._sprite) {
                        return;
                    }
                    var i, locMidPoint = node._midPoint;
                    var alpha = node._percentage / 100;
                    var angle = 2 * cc.PI * (node._reverseDirection ? alpha : 1 - alpha);
                    var topMid = cc.p(locMidPoint.x, 1);
                    var percentagePt = cc.pRotateByAngle(topMid, locMidPoint, angle);
                    var index = 0;
                    var hit;
                    if (0 === alpha) {
                        hit = topMid;
                        index = 0;
                    } else {
                        if (1 === alpha) {
                            hit = topMid;
                            index = 4;
                        } else {
                            var min_t = cc.FLT_MAX;
                            var locProTextCoordsCount = cc.ProgressTimer.TEXTURE_COORDS_COUNT;
                            for (i = 0; i <= locProTextCoordsCount; ++i) {
                                var pIndex = (i + (locProTextCoordsCount - 1)) % locProTextCoordsCount;
                                var edgePtA = this._boundaryTexCoord(i % locProTextCoordsCount);
                                var edgePtB = this._boundaryTexCoord(pIndex);
                                if (0 === i) {
                                    edgePtB = cc.pLerp(edgePtA, edgePtB, 1 - locMidPoint.x);
                                } else {
                                    if (4 === i) {
                                        edgePtA = cc.pLerp(edgePtA, edgePtB, 1 - locMidPoint.x);
                                    }
                                }
                                var retPoint = cc.p(0, 0);
                                if (cc.pLineIntersect(edgePtA, edgePtB, locMidPoint, percentagePt, retPoint)) {
                                    if (0 === i || 4 === i) {
                                        if (!(0 <= retPoint.x && retPoint.x <= 1)) {
                                            continue;
                                        }
                                    }
                                    if (retPoint.y >= 0) {
                                        if (retPoint.y < min_t) {
                                            min_t = retPoint.y;
                                            index = i;
                                        }
                                    }
                                }
                            }
                            hit = cc.pAdd(locMidPoint, cc.pMult(cc.pSub(percentagePt, locMidPoint), min_t));
                        }
                    }
                    var sameIndexCount = true;
                    if (this._vertexDataCount !== index + 3) {
                        sameIndexCount = false;
                        this._vertexData = null;
                        this._vertexArrayBuffer = null;
                        this._vertexDataCount = 0;
                    }
                    if (!this._vertexData) {
                        this._vertexDataCount = index + 3;
                        var locCount = this._vertexDataCount, vertexDataLen = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
                        this._vertexArrayBuffer = new ArrayBuffer(locCount * vertexDataLen);
                        var locData = [];
                        for (i = 0; i < locCount; i++) {
                            locData[i] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer, i * vertexDataLen);
                        }
                        this._vertexData = locData;
                        if (!this._vertexData) {
                            cc.log("cc.ProgressTimer._updateRadial() : Not enough memory");
                            return;
                        }
                    }
                    this._updateColor();
                    var locVertexData = this._vertexData;
                    if (!sameIndexCount) {
                        locVertexData[0].texCoords = this._textureCoordFromAlphaPoint(locMidPoint);
                        locVertexData[0].vertices = this._vertexFromAlphaPoint(locMidPoint);
                        locVertexData[1].texCoords = this._textureCoordFromAlphaPoint(topMid);
                        locVertexData[1].vertices = this._vertexFromAlphaPoint(topMid);
                        for (i = 0; i < index; i++) {
                            var alphaPoint = this._boundaryTexCoord(i);
                            locVertexData[i + 2].texCoords = this._textureCoordFromAlphaPoint(alphaPoint);
                            locVertexData[i + 2].vertices = this._vertexFromAlphaPoint(alphaPoint);
                        }
                    }
                    locVertexData[this._vertexDataCount - 1].texCoords = this._textureCoordFromAlphaPoint(hit);
                    locVertexData[this._vertexDataCount - 1].vertices = this._vertexFromAlphaPoint(hit);
                };
                proto._boundaryTexCoord = function(index) {
                    if (index < cc.ProgressTimer.TEXTURE_COORDS_COUNT) {
                        var locProTextCoords = cc.ProgressTimer.TEXTURE_COORDS;
                        if (this._node._reverseDirection) {
                            return cc.p(locProTextCoords >> 7 - (index << 1) & 1, locProTextCoords >> 7 - ((index << 1) + 1) & 1);
                        } else {
                            return cc.p(locProTextCoords >> (index << 1) + 1 & 1, locProTextCoords >> (index << 1) & 1);
                        }
                    }
                    return cc.p(0, 0);
                };
                proto._textureCoordFromAlphaPoint = function(alpha) {
                    var locSprite = this._node._sprite;
                    if (!locSprite) {
                        return {
                            u: 0,
                            v: 0
                        };
                    }
                    var quad = locSprite.quad;
                    var min = cc.p(quad.bl.texCoords.u, quad.bl.texCoords.v);
                    var max = cc.p(quad.tr.texCoords.u, quad.tr.texCoords.v);
                    if (locSprite.textureRectRotated) {
                        var temp = alpha.x;
                        alpha.x = alpha.y;
                        alpha.y = temp;
                    }
                    return {
                        u: min.x * (1 - alpha.x) + max.x * alpha.x,
                        v: min.y * (1 - alpha.y) + max.y * alpha.y
                    };
                };
                proto._vertexFromAlphaPoint = function(alpha) {
                    var locSprite = this._node._sprite;
                    if (!locSprite) {
                        return {
                            x: 0,
                            y: 0
                        };
                    }
                    var quad = locSprite.quad;
                    var min = cc.p(quad.bl.vertices.x, quad.bl.vertices.y);
                    var max = cc.p(quad.tr.vertices.x, quad.tr.vertices.y);
                    return {
                        x: min.x * (1 - alpha.x) + max.x * alpha.x,
                        y: min.y * (1 - alpha.y) + max.y * alpha.y
                    };
                };
                proto._updateColor = function() {
                    var node = this._node;
                    if (!node._sprite || !this._vertexData) {
                        return;
                    }
                    var sc = node._sprite.quad.tl.colors;
                    var locVertexData = this._vertexData;
                    for (var i = 0, len = this._vertexDataCount; i < len; ++i) {
                        locVertexData[i].colors = sc;
                    }
                    this._vertexDataDirty = true;
                };
            }();
            cc.ProgressTo = cc.ActionInterval.extend({
                _to: 0,
                _from: 0,
                ctor: function(duration, percent) {
                    cc.ActionInterval.prototype.ctor.call(this);
                    this._to = 0;
                    this._from = 0;
                    void 0 !== percent && this.initWithDuration(duration, percent);
                },
                initWithDuration: function(duration, percent) {
                    if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
                        this._to = percent;
                        return true;
                    }
                    return false;
                },
                clone: function() {
                    var action = new cc.ProgressTo();
                    action.initWithDuration(this._duration, this._to);
                    return action;
                },
                reverse: function() {
                    cc.log("cc.ProgressTo.reverse(): reverse hasn't been supported.");
                    return null;
                },
                startWithTarget: function(target) {
                    cc.ActionInterval.prototype.startWithTarget.call(this, target);
                    this._from = target.percentage;
                },
                update: function(time) {
                    if (this.target instanceof cc.ProgressTimer) {
                        this.target.percentage = this._from + (this._to - this._from) * time;
                    }
                }
            });
            cc.progressTo = function(duration, percent) {
                return new cc.ProgressTo(duration, percent);
            };
            cc.ProgressTo.create = cc.progressTo;
            cc.ProgressFromTo = cc.ActionInterval.extend({
                _to: 0,
                _from: 0,
                ctor: function(duration, fromPercentage, toPercentage) {
                    cc.ActionInterval.prototype.ctor.call(this);
                    this._to = 0;
                    this._from = 0;
                    void 0 !== toPercentage && this.initWithDuration(duration, fromPercentage, toPercentage);
                },
                initWithDuration: function(duration, fromPercentage, toPercentage) {
                    if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
                        this._to = toPercentage;
                        this._from = fromPercentage;
                        return true;
                    }
                    return false;
                },
                clone: function() {
                    var action = new cc.ProgressFromTo();
                    action.initWithDuration(this._duration, this._from, this._to);
                    return action;
                },
                reverse: function() {
                    return cc.progressFromTo(this._duration, this._to, this._from);
                },
                startWithTarget: function(target) {
                    cc.ActionInterval.prototype.startWithTarget.call(this, target);
                },
                update: function(time) {
                    if (this.target instanceof cc.ProgressTimer) {
                        this.target.percentage = this._from + (this._to - this._from) * time;
                    }
                }
            });
            cc.progressFromTo = function(duration, fromPercentage, toPercentage) {
                return new cc.ProgressFromTo(duration, fromPercentage, toPercentage);
            };
            cc.ProgressFromTo.create = cc.progressFromTo;
            cc.Codec = {
                name: "Jacob__Codec"
            };
            cc.unzip = function() {
                return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, arguments);
            };
            cc.unzipBase64 = function() {
                var tmpInput = cc.Codec.Base64.decode.apply(cc.Codec.Base64, arguments);
                return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, [ tmpInput ]);
            };
            cc.unzipBase64AsArray = function(input, bytes) {
                bytes = bytes || 1;
                var dec = this.unzipBase64(input), ar = [], i, j, len;
                for (i = 0, len = dec.length / bytes; i < len; i++) {
                    ar[i] = 0;
                    for (j = bytes - 1; j >= 0; --j) {
                        ar[i] += dec.charCodeAt(i * bytes + j) << 8 * j;
                    }
                }
                return ar;
            };
            cc.unzipAsArray = function(input, bytes) {
                bytes = bytes || 1;
                var dec = this.unzip(input), ar = [], i, j, len;
                for (i = 0, len = dec.length / bytes; i < len; i++) {
                    ar[i] = 0;
                    for (j = bytes - 1; j >= 0; --j) {
                        ar[i] += dec.charCodeAt(i * bytes + j) << 8 * j;
                    }
                }
                return ar;
            };
            cc.StringToArray = function(input) {
                var tmp = input.split(","), ar = [], i;
                for (i = 0; i < tmp.length; i++) {
                    ar.push(parseInt(tmp[i]));
                }
                return ar;
            };
            cc.Codec.Base64 = {
                name: "Jacob__Codec__Base64"
            };
            cc.Codec.Base64._keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            cc.Codec.Base64.decode = function Jacob__Codec__Base64__decode(input) {
                var output = [], chr1, chr2, chr3, enc1, enc2, enc3, enc4, i = 0;
                input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
                while (i < input.length) {
                    enc1 = this._keyStr.indexOf(input.charAt(i++));
                    enc2 = this._keyStr.indexOf(input.charAt(i++));
                    enc3 = this._keyStr.indexOf(input.charAt(i++));
                    enc4 = this._keyStr.indexOf(input.charAt(i++));
                    chr1 = enc1 << 2 | enc2 >> 4;
                    chr2 = (15 & enc2) << 4 | enc3 >> 2;
                    chr3 = (3 & enc3) << 6 | enc4;
                    output.push(String.fromCharCode(chr1));
                    if (64 !== enc3) {
                        output.push(String.fromCharCode(chr2));
                    }
                    if (64 !== enc4) {
                        output.push(String.fromCharCode(chr3));
                    }
                }
                output = output.join("");
                return output;
            };
            cc.Codec.Base64.decodeAsArray = function Jacob__Codec__Base64___decodeAsArray(input, bytes) {
                var dec = this.decode(input), ar = [], i, j, len;
                for (i = 0, len = dec.length / bytes; i < len; i++) {
                    ar[i] = 0;
                    for (j = bytes - 1; j >= 0; --j) {
                        ar[i] += dec.charCodeAt(i * bytes + j) << 8 * j;
                    }
                }
                return ar;
            };
            cc.uint8ArrayToUint32Array = function(uint8Arr) {
                if (uint8Arr.length % 4 !== 0) {
                    return null;
                }
                var arrLen = uint8Arr.length / 4;
                var retArr = window.Uint32Array ? new Uint32Array(arrLen) : [];
                for (var i = 0; i < arrLen; i++) {
                    var offset = 4 * i;
                    retArr[i] = uint8Arr[offset] + 256 * uint8Arr[offset + 1] + 65536 * uint8Arr[offset + 2] + uint8Arr[offset + 3] * (1 << 24);
                }
                return retArr;
            };
            cc.Codec.GZip = function Jacob__GZip(data) {
                this.data = data;
                this.debug = false;
                this.gpflags = void 0;
                this.files = 0;
                this.unzipped = [];
                this.buf32k = new Array(32768);
                this.bIdx = 0;
                this.modeZIP = false;
                this.bytepos = 0;
                this.bb = 1;
                this.bits = 0;
                this.nameBuf = [];
                this.fileout = void 0;
                this.literalTree = new Array(cc.Codec.GZip.LITERALS);
                this.distanceTree = new Array(32);
                this.treepos = 0;
                this.Places = null;
                this.len = 0;
                this.fpos = new Array(17);
                this.fpos[0] = 0;
                this.flens = void 0;
                this.fmax = void 0;
            };
            cc.Codec.GZip.gunzip = function(string) {
                if (string.constructor === Array) {
                    ;
                } else {
                    if (string.constructor === String) {}
                }
                var gzip = new cc.Codec.GZip(string);
                return gzip.gunzip()[0][0];
            };
            cc.Codec.GZip.HufNode = function() {
                this.b0 = 0;
                this.b1 = 0;
                this.jump = null;
                this.jumppos = -1;
            };
            cc.Codec.GZip.LITERALS = 288;
            cc.Codec.GZip.NAMEMAX = 256;
            cc.Codec.GZip.bitReverse = [ 0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240, 8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244, 12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 3, 131, 67, 195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251, 7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247, 15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255 ];
            cc.Codec.GZip.cplens = [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0 ];
            cc.Codec.GZip.cplext = [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99 ];
            cc.Codec.GZip.cpdist = [ 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 ];
            cc.Codec.GZip.cpdext = [ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ];
            cc.Codec.GZip.border = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];
            cc.Codec.GZip.prototype.gunzip = function() {
                this.outputArr = [];
                this.nextFile();
                return this.unzipped;
            };
            cc.Codec.GZip.prototype.readByte = function() {
                this.bits += 8;
                if (this.bytepos < this.data.length) {
                    return this.data.charCodeAt(this.bytepos++);
                } else {
                    return -1;
                }
            };
            cc.Codec.GZip.prototype.byteAlign = function() {
                this.bb = 1;
            };
            cc.Codec.GZip.prototype.readBit = function() {
                var carry;
                this.bits++;
                carry = 1 & this.bb;
                this.bb >>= 1;
                if (0 === this.bb) {
                    this.bb = this.readByte();
                    carry = 1 & this.bb;
                    this.bb = this.bb >> 1 | 128;
                }
                return carry;
            };
            cc.Codec.GZip.prototype.readBits = function(a) {
                var res = 0, i = a;
                while (i--) {
                    res = res << 1 | this.readBit();
                }
                if (a) {
                    res = cc.Codec.GZip.bitReverse[res] >> 8 - a;
                }
                return res;
            };
            cc.Codec.GZip.prototype.flushBuffer = function() {
                this.bIdx = 0;
            };
            cc.Codec.GZip.prototype.addBuffer = function(a) {
                this.buf32k[this.bIdx++] = a;
                this.outputArr.push(String.fromCharCode(a));
                if (32768 === this.bIdx) {
                    this.bIdx = 0;
                }
            };
            cc.Codec.GZip.prototype.IsPat = function() {
                while (1) {
                    if (this.fpos[this.len] >= this.fmax) {
                        return -1;
                    }
                    if (this.flens[this.fpos[this.len]] === this.len) {
                        return this.fpos[this.len]++;
                    }
                    this.fpos[this.len]++;
                }
            };
            cc.Codec.GZip.prototype.Rec = function() {
                var curplace = this.Places[this.treepos];
                var tmp;
                if (17 === this.len) {
                    return -1;
                }
                this.treepos++;
                this.len++;
                tmp = this.IsPat();
                if (tmp >= 0) {
                    curplace.b0 = tmp;
                } else {
                    curplace.b0 = 32768;
                    if (this.Rec()) {
                        return -1;
                    }
                }
                tmp = this.IsPat();
                if (tmp >= 0) {
                    curplace.b1 = tmp;
                    curplace.jump = null;
                } else {
                    curplace.b1 = 32768;
                    curplace.jump = this.Places[this.treepos];
                    curplace.jumppos = this.treepos;
                    if (this.Rec()) {
                        return -1;
                    }
                }
                this.len--;
                return 0;
            };
            cc.Codec.GZip.prototype.CreateTree = function(currentTree, numval, lengths, show) {
                var i;
                this.Places = currentTree;
                this.treepos = 0;
                this.flens = lengths;
                this.fmax = numval;
                for (i = 0; i < 17; i++) {
                    this.fpos[i] = 0;
                }
                this.len = 0;
                if (this.Rec()) {
                    return -1;
                }
                return 0;
            };
            cc.Codec.GZip.prototype.DecodeValue = function(currentTree) {
                var len, i, xtreepos = 0, X = currentTree[xtreepos], b;
                while (1) {
                    b = this.readBit();
                    if (b) {
                        if (!(32768 & X.b1)) {
                            return X.b1;
                        }
                        X = X.jump;
                        len = currentTree.length;
                        for (i = 0; i < len; i++) {
                            if (currentTree[i] === X) {
                                xtreepos = i;
                                break;
                            }
                        }
                    } else {
                        if (!(32768 & X.b0)) {
                            return X.b0;
                        }
                        xtreepos++;
                        X = currentTree[xtreepos];
                    }
                }
                return -1;
            };
            cc.Codec.GZip.prototype.DeflateLoop = function() {
                var last, c, type, i, len;
                do {
                    last = this.readBit();
                    type = this.readBits(2);
                    if (0 === type) {
                        var blockLen, cSum;
                        this.byteAlign();
                        blockLen = this.readByte();
                        blockLen |= this.readByte() << 8;
                        cSum = this.readByte();
                        cSum |= this.readByte() << 8;
                        if (65535 & (blockLen ^ ~cSum)) {
                            document.write("BlockLen checksum mismatch\n");
                        }
                        while (blockLen--) {
                            c = this.readByte();
                            this.addBuffer(c);
                        }
                    } else {
                        if (1 === type) {
                            var j;
                            while (1) {
                                j = cc.Codec.GZip.bitReverse[this.readBits(7)] >> 1;
                                if (j > 23) {
                                    j = j << 1 | this.readBit();
                                    if (j > 199) {
                                        j -= 128;
                                        j = j << 1 | this.readBit();
                                    } else {
                                        j -= 48;
                                        if (j > 143) {
                                            j += 136;
                                        }
                                    }
                                } else {
                                    j += 256;
                                }
                                if (j < 256) {
                                    this.addBuffer(j);
                                } else {
                                    if (256 === j) {
                                        break;
                                    } else {
                                        var len, dist;
                                        j -= 257;
                                        len = this.readBits(cc.Codec.GZip.cplext[j]) + cc.Codec.GZip.cplens[j];
                                        j = cc.Codec.GZip.bitReverse[this.readBits(5)] >> 3;
                                        if (cc.Codec.GZip.cpdext[j] > 8) {
                                            dist = this.readBits(8);
                                            dist |= this.readBits(cc.Codec.GZip.cpdext[j] - 8) << 8;
                                        } else {
                                            dist = this.readBits(cc.Codec.GZip.cpdext[j]);
                                        }
                                        dist += cc.Codec.GZip.cpdist[j];
                                        for (j = 0; j < len; j++) {
                                            var c = this.buf32k[this.bIdx - dist & 32767];
                                            this.addBuffer(c);
                                        }
                                    }
                                }
                            }
                        } else {
                            if (2 === type) {
                                var j, n, literalCodes, distCodes, lenCodes;
                                var ll = new Array(320);
                                literalCodes = 257 + this.readBits(5);
                                distCodes = 1 + this.readBits(5);
                                lenCodes = 4 + this.readBits(4);
                                for (j = 0; j < 19; j++) {
                                    ll[j] = 0;
                                }
                                for (j = 0; j < lenCodes; j++) {
                                    ll[cc.Codec.GZip.border[j]] = this.readBits(3);
                                }
                                len = this.distanceTree.length;
                                for (i = 0; i < len; i++) {
                                    this.distanceTree[i] = new cc.Codec.GZip.HufNode();
                                }
                                if (this.CreateTree(this.distanceTree, 19, ll, 0)) {
                                    this.flushBuffer();
                                    return 1;
                                }
                                n = literalCodes + distCodes;
                                i = 0;
                                var z = -1;
                                while (i < n) {
                                    z++;
                                    j = this.DecodeValue(this.distanceTree);
                                    if (j < 16) {
                                        ll[i++] = j;
                                    } else {
                                        if (16 === j) {
                                            var l;
                                            j = 3 + this.readBits(2);
                                            if (i + j > n) {
                                                this.flushBuffer();
                                                return 1;
                                            }
                                            l = i ? ll[i - 1] : 0;
                                            while (j--) {
                                                ll[i++] = l;
                                            }
                                        } else {
                                            if (17 === j) {
                                                j = 3 + this.readBits(3);
                                            } else {
                                                j = 11 + this.readBits(7);
                                            }
                                            if (i + j > n) {
                                                this.flushBuffer();
                                                return 1;
                                            }
                                            while (j--) {
                                                ll[i++] = 0;
                                            }
                                        }
                                    }
                                }
                                len = this.literalTree.length;
                                for (i = 0; i < len; i++) {
                                    this.literalTree[i] = new cc.Codec.GZip.HufNode();
                                }
                                if (this.CreateTree(this.literalTree, literalCodes, ll, 0)) {
                                    this.flushBuffer();
                                    return 1;
                                }
                                len = this.literalTree.length;
                                for (i = 0; i < len; i++) {
                                    this.distanceTree[i] = new cc.Codec.GZip.HufNode();
                                }
                                var ll2 = new Array();
                                for (i = literalCodes; i < ll.length; i++) {
                                    ll2[i - literalCodes] = ll[i];
                                }
                                if (this.CreateTree(this.distanceTree, distCodes, ll2, 0)) {
                                    this.flushBuffer();
                                    return 1;
                                }
                                while (1) {
                                    j = this.DecodeValue(this.literalTree);
                                    if (j >= 256) {
                                        var len, dist;
                                        j -= 256;
                                        if (0 === j) {
                                            break;
                                        }
                                        j--;
                                        len = this.readBits(cc.Codec.GZip.cplext[j]) + cc.Codec.GZip.cplens[j];
                                        j = this.DecodeValue(this.distanceTree);
                                        if (cc.Codec.GZip.cpdext[j] > 8) {
                                            dist = this.readBits(8);
                                            dist |= this.readBits(cc.Codec.GZip.cpdext[j] - 8) << 8;
                                        } else {
                                            dist = this.readBits(cc.Codec.GZip.cpdext[j]);
                                        }
                                        dist += cc.Codec.GZip.cpdist[j];
                                        while (len--) {
                                            var c = this.buf32k[this.bIdx - dist & 32767];
                                            this.addBuffer(c);
                                        }
                                    } else {
                                        this.addBuffer(j);
                                    }
                                }
                            }
                        }
                    }
                } while (!last);
                this.flushBuffer();
                this.byteAlign();
                return 0;
            };
            cc.Codec.GZip.prototype.unzipFile = function(name) {
                var i;
                this.gunzip();
                for (i = 0; i < this.unzipped.length; i++) {
                    if (this.unzipped[i][1] === name) {
                        return this.unzipped[i][0];
                    }
                }
            };
            cc.Codec.GZip.prototype.nextFile = function() {
                this.outputArr = [];
                this.modeZIP = false;
                var tmp = [];
                tmp[0] = this.readByte();
                tmp[1] = this.readByte();
                if (120 === tmp[0] && 218 === tmp[1]) {
                    this.DeflateLoop();
                    this.unzipped[this.files] = [ this.outputArr.join(""), "geonext.gxt" ];
                    this.files++;
                }
                if (31 === tmp[0] && 139 === tmp[1]) {
                    this.skipdir();
                    this.unzipped[this.files] = [ this.outputArr.join(""), "file" ];
                    this.files++;
                }
                if (80 === tmp[0] && 75 === tmp[1]) {
                    this.modeZIP = true;
                    tmp[2] = this.readByte();
                    tmp[3] = this.readByte();
                    if (3 === tmp[2] && 4 === tmp[3]) {
                        tmp[0] = this.readByte();
                        tmp[1] = this.readByte();
                        this.gpflags = this.readByte();
                        this.gpflags |= this.readByte() << 8;
                        var method = this.readByte();
                        method |= this.readByte() << 8;
                        this.readByte();
                        this.readByte();
                        this.readByte();
                        this.readByte();
                        var compSize = this.readByte();
                        compSize |= this.readByte() << 8;
                        compSize |= this.readByte() << 16;
                        compSize |= this.readByte() << 24;
                        var size = this.readByte();
                        size |= this.readByte() << 8;
                        size |= this.readByte() << 16;
                        size |= this.readByte() << 24;
                        var filelen = this.readByte();
                        filelen |= this.readByte() << 8;
                        var extralen = this.readByte();
                        extralen |= this.readByte() << 8;
                        i = 0;
                        this.nameBuf = [];
                        while (filelen--) {
                            var c = this.readByte();
                            if ("/" === c | ":" === c) {
                                i = 0;
                            } else {
                                if (i < cc.Codec.GZip.NAMEMAX - 1) {
                                    this.nameBuf[i++] = String.fromCharCode(c);
                                }
                            }
                        }
                        if (!this.fileout) {
                            this.fileout = this.nameBuf;
                        }
                        var i = 0;
                        while (i < extralen) {
                            c = this.readByte();
                            i++;
                        }
                        if (8 === method) {
                            this.DeflateLoop();
                            this.unzipped[this.files] = [ this.outputArr.join(""), this.nameBuf.join("") ];
                            this.files++;
                        }
                        this.skipdir();
                    }
                }
            };
            cc.Codec.GZip.prototype.skipdir = function() {
                var tmp = [];
                var compSize, size, os, i, c;
                if (8 & this.gpflags) {
                    tmp[0] = this.readByte();
                    tmp[1] = this.readByte();
                    tmp[2] = this.readByte();
                    tmp[3] = this.readByte();
                    compSize = this.readByte();
                    compSize |= this.readByte() << 8;
                    compSize |= this.readByte() << 16;
                    compSize |= this.readByte() << 24;
                    size = this.readByte();
                    size |= this.readByte() << 8;
                    size |= this.readByte() << 16;
                    size |= this.readByte() << 24;
                }
                if (this.modeZIP) {
                    this.nextFile();
                }
                tmp[0] = this.readByte();
                if (8 !== tmp[0]) {
                    return 0;
                }
                this.gpflags = this.readByte();
                this.readByte();
                this.readByte();
                this.readByte();
                this.readByte();
                this.readByte();
                os = this.readByte();
                if (4 & this.gpflags) {
                    tmp[0] = this.readByte();
                    tmp[2] = this.readByte();
                    this.len = tmp[0] + 256 * tmp[1];
                    for (i = 0; i < this.len; i++) {
                        this.readByte();
                    }
                }
                if (8 & this.gpflags) {
                    i = 0;
                    this.nameBuf = [];
                    while (c = this.readByte()) {
                        if ("7" === c || ":" === c) {
                            i = 0;
                        }
                        if (i < cc.Codec.GZip.NAMEMAX - 1) {
                            this.nameBuf[i++] = c;
                        }
                    }
                }
                if (16 & this.gpflags) {
                    while (c = this.readByte()) {}
                }
                if (2 & this.gpflags) {
                    this.readByte();
                    this.readByte();
                }
                this.DeflateLoop();
                size = this.readByte();
                size |= this.readByte() << 8;
                size |= this.readByte() << 16;
                size |= this.readByte() << 24;
                if (this.modeZIP) {
                    this.nextFile();
                }
            };
            (function() {
                "use strict";
                function i(a) {
                    throw a;
                }
                var r = void 0, v = !0, aa = this;
                function y(a, c) {
                    var b = a.split("."), e = aa;
                    !(b[0] in e) && e.execScript && e.execScript("var " + b[0]);
                    for (var f; b.length && (f = b.shift()); ) {
                        !b.length && c !== r ? e[f] = c : e = e[f] ? e[f] : e[f] = {};
                    }
                }
                var H = "undefined" !== typeof Uint8Array && "undefined" !== typeof Uint16Array && "undefined" !== typeof Uint32Array;
                function ba(a) {
                    if ("string" === typeof a) {
                        var c = a.split(""), b, e;
                        b = 0;
                        for (e = c.length; b < e; b++) {
                            c[b] = (255 & c[b].charCodeAt(0)) >>> 0;
                        }
                        a = c;
                    }
                    for (var f = 1, d = 0, g = a.length, h, m = 0; 0 < g; ) {
                        h = 1024 < g ? 1024 : g;
                        g -= h;
                        do {
                            f += a[m++], d += f;
                        } while (--h);
                        f %= 65521;
                        d %= 65521;
                    }
                    return (d << 16 | f) >>> 0;
                }
                function J(a, c) {
                    this.index = "number" === typeof c ? c : 0;
                    this.i = 0;
                    this.buffer = a instanceof (H ? Uint8Array : Array) ? a : new (H ? Uint8Array : Array)(32768);
                    2 * this.buffer.length <= this.index && i(Error("invalid index"));
                    this.buffer.length <= this.index && this.f();
                }
                J.prototype.f = function() {
                    var a = this.buffer, c, b = a.length, e = new (H ? Uint8Array : Array)(b << 1);
                    if (H) {
                        e.set(a);
                    } else {
                        for (c = 0; c < b; ++c) {
                            e[c] = a[c];
                        }
                    }
                    return this.buffer = e;
                };
                J.prototype.d = function(a, c, b) {
                    var e = this.buffer, f = this.index, d = this.i, g = e[f], h;
                    b && 1 < c && (a = 8 < c ? (N[255 & a] << 24 | N[a >>> 8 & 255] << 16 | N[a >>> 16 & 255] << 8 | N[a >>> 24 & 255]) >> 32 - c : N[a] >> 8 - c);
                    if (8 > c + d) {
                        g = g << c | a, d += c;
                    } else {
                        for (h = 0; h < c; ++h) {
                            g = g << 1 | a >> c - h - 1 & 1, 8 === ++d && (d = 0, e[f++] = N[g], g = 0, f === e.length && (e = this.f()));
                        }
                    }
                    e[f] = g;
                    this.buffer = e;
                    this.i = d;
                    this.index = f;
                };
                J.prototype.finish = function() {
                    var a = this.buffer, c = this.index, b;
                    0 < this.i && (a[c] <<= 8 - this.i, a[c] = N[a[c]], c++);
                    H ? b = a.subarray(0, c) : (a.length = c, b = a);
                    return b;
                };
                var ca = new (H ? Uint8Array : Array)(256), ha;
                for (ha = 0; 256 > ha; ++ha) {
                    for (var R = ha, ia = R, ja = 7, R = R >>> 1; R; R >>>= 1) {
                        ia <<= 1, ia |= 1 & R, --ja;
                    }
                    ca[ha] = (ia << ja & 255) >>> 0;
                }
                var N = ca;
                var ka = [ 0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117 ];
                H && new Uint32Array(ka);
                function la(a) {
                    this.buffer = new (H ? Uint16Array : Array)(2 * a);
                    this.length = 0;
                }
                la.prototype.getParent = function(a) {
                    return 2 * ((a - 2) / 4 | 0);
                };
                la.prototype.push = function(a, c) {
                    var b, e, f = this.buffer, d;
                    b = this.length;
                    f[this.length++] = c;
                    for (f[this.length++] = a; 0 < b; ) {
                        if (e = this.getParent(b), f[b] > f[e]) {
                            d = f[b], f[b] = f[e], f[e] = d, d = f[b + 1], f[b + 1] = f[e + 1], f[e + 1] = d, 
                            b = e;
                        } else {
                            break;
                        }
                    }
                    return this.length;
                };
                la.prototype.pop = function() {
                    var a, c, b = this.buffer, e, f, d;
                    c = b[0];
                    a = b[1];
                    this.length -= 2;
                    b[0] = b[this.length];
                    b[1] = b[this.length + 1];
                    for (d = 0; ;) {
                        f = 2 * d + 2;
                        if (f >= this.length) {
                            break;
                        }
                        f + 2 < this.length && b[f + 2] > b[f] && (f += 2);
                        if (b[f] > b[d]) {
                            e = b[d], b[d] = b[f], b[f] = e, e = b[d + 1], b[d + 1] = b[f + 1], b[f + 1] = e;
                        } else {
                            break;
                        }
                        d = f;
                    }
                    return {
                        index: a,
                        value: c,
                        length: this.length
                    };
                };
                function S(a) {
                    var c = a.length, b = 0, e = Number.POSITIVE_INFINITY, f, d, g, h, m, j, s, n, l;
                    for (n = 0; n < c; ++n) {
                        a[n] > b && (b = a[n]), a[n] < e && (e = a[n]);
                    }
                    f = 1 << b;
                    d = new (H ? Uint32Array : Array)(f);
                    g = 1;
                    h = 0;
                    for (m = 2; g <= b; ) {
                        for (n = 0; n < c; ++n) {
                            if (a[n] === g) {
                                j = 0;
                                s = h;
                                for (l = 0; l < g; ++l) {
                                    j = j << 1 | 1 & s, s >>= 1;
                                }
                                for (l = j; l < f; l += m) {
                                    d[l] = g << 16 | n;
                                }
                                ++h;
                            }
                        }
                        ++g;
                        h <<= 1;
                        m <<= 1;
                    }
                    return [ d, b, e ];
                }
                function ma(a, c) {
                    this.h = pa;
                    this.w = 0;
                    this.input = a;
                    this.b = 0;
                    c && (c.lazy && (this.w = c.lazy), "number" === typeof c.compressionType && (this.h = c.compressionType), 
                    c.outputBuffer && (this.a = H && c.outputBuffer instanceof Array ? new Uint8Array(c.outputBuffer) : c.outputBuffer), 
                    "number" === typeof c.outputIndex && (this.b = c.outputIndex));
                    this.a || (this.a = new (H ? Uint8Array : Array)(32768));
                }
                var pa = 2, qa = {
                    NONE: 0,
                    r: 1,
                    j: pa,
                    N: 3
                }, ra = [], T;
                for (T = 0; 288 > T; T++) {
                    switch (v) {
                      case 143 >= T:
                        ra.push([ T + 48, 8 ]);
                        break;

                      case 255 >= T:
                        ra.push([ T - 144 + 400, 9 ]);
                        break;

                      case 279 >= T:
                        ra.push([ T - 256 + 0, 7 ]);
                        break;

                      case 287 >= T:
                        ra.push([ T - 280 + 192, 8 ]);
                        break;

                      default:
                        i("invalid literal: " + T);
                    }
                }
                ma.prototype.n = function() {
                    var a, c, b, e, f = this.input;
                    switch (this.h) {
                      case 0:
                        b = 0;
                        for (e = f.length; b < e; ) {
                            c = H ? f.subarray(b, b + 65535) : f.slice(b, b + 65535);
                            b += c.length;
                            var d = c, g = b === e, h = r, m = r, j = r, s = r, n = r, l = this.a, q = this.b;
                            if (H) {
                                for (l = new Uint8Array(this.a.buffer); l.length <= q + d.length + 5; ) {
                                    l = new Uint8Array(l.length << 1);
                                }
                                l.set(this.a);
                            }
                            h = g ? 1 : 0;
                            l[q++] = 0 | h;
                            m = d.length;
                            j = ~m + 65536 & 65535;
                            l[q++] = 255 & m;
                            l[q++] = m >>> 8 & 255;
                            l[q++] = 255 & j;
                            l[q++] = j >>> 8 & 255;
                            if (H) {
                                l.set(d, q), q += d.length, l = l.subarray(0, q);
                            } else {
                                s = 0;
                                for (n = d.length; s < n; ++s) {
                                    l[q++] = d[s];
                                }
                                l.length = q;
                            }
                            this.b = q;
                            this.a = l;
                        }
                        break;

                      case 1:
                        var E = new J(new Uint8Array(this.a.buffer), this.b);
                        E.d(1, 1, v);
                        E.d(1, 2, v);
                        var t = sa(this, f), z, K, A;
                        z = 0;
                        for (K = t.length; z < K; z++) {
                            if (A = t[z], J.prototype.d.apply(E, ra[A]), 256 < A) {
                                E.d(t[++z], t[++z], v), E.d(t[++z], 5), E.d(t[++z], t[++z], v);
                            } else {
                                if (256 === A) {
                                    break;
                                }
                            }
                        }
                        this.a = E.finish();
                        this.b = this.a.length;
                        break;

                      case pa:
                        var x = new J(new Uint8Array(this.a), this.b), B, k, p, D, C, da = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ], W, Ma, ea, Na, na, va = Array(19), Oa, $, oa, F, Pa;
                        B = pa;
                        x.d(1, 1, v);
                        x.d(B, 2, v);
                        k = sa(this, f);
                        W = ta(this.L, 15);
                        Ma = ua(W);
                        ea = ta(this.K, 7);
                        Na = ua(ea);
                        for (p = 286; 257 < p && 0 === W[p - 1]; p--) {}
                        for (D = 30; 1 < D && 0 === ea[D - 1]; D--) {}
                        var Qa = p, Ra = D, M = new (H ? Uint32Array : Array)(Qa + Ra), u, O, w, fa, L = new (H ? Uint32Array : Array)(316), I, G, P = new (H ? Uint8Array : Array)(19);
                        for (u = O = 0; u < Qa; u++) {
                            M[O++] = W[u];
                        }
                        for (u = 0; u < Ra; u++) {
                            M[O++] = ea[u];
                        }
                        if (!H) {
                            u = 0;
                            for (fa = P.length; u < fa; ++u) {
                                P[u] = 0;
                            }
                        }
                        u = I = 0;
                        for (fa = M.length; u < fa; u += O) {
                            for (O = 1; u + O < fa && M[u + O] === M[u]; ++O) {}
                            w = O;
                            if (0 === M[u]) {
                                if (3 > w) {
                                    for (;0 < w--; ) {
                                        L[I++] = 0, P[0]++;
                                    }
                                } else {
                                    for (;0 < w; ) {
                                        G = 138 > w ? w : 138, G > w - 3 && G < w && (G = w - 3), 10 >= G ? (L[I++] = 17, 
                                        L[I++] = G - 3, P[17]++) : (L[I++] = 18, L[I++] = G - 11, P[18]++), w -= G;
                                    }
                                }
                            } else {
                                if (L[I++] = M[u], P[M[u]]++, w--, 3 > w) {
                                    for (;0 < w--; ) {
                                        L[I++] = M[u], P[M[u]]++;
                                    }
                                } else {
                                    for (;0 < w; ) {
                                        G = 6 > w ? w : 6, G > w - 3 && G < w && (G = w - 3), L[I++] = 16, L[I++] = G - 3, 
                                        P[16]++, w -= G;
                                    }
                                }
                            }
                        }
                        a = H ? L.subarray(0, I) : L.slice(0, I);
                        na = ta(P, 7);
                        for (F = 0; 19 > F; F++) {
                            va[F] = na[da[F]];
                        }
                        for (C = 19; 4 < C && 0 === va[C - 1]; C--) {}
                        Oa = ua(na);
                        x.d(p - 257, 5, v);
                        x.d(D - 1, 5, v);
                        x.d(C - 4, 4, v);
                        for (F = 0; F < C; F++) {
                            x.d(va[F], 3, v);
                        }
                        F = 0;
                        for (Pa = a.length; F < Pa; F++) {
                            if ($ = a[F], x.d(Oa[$], na[$], v), 16 <= $) {
                                F++;
                                switch ($) {
                                  case 16:
                                    oa = 2;
                                    break;

                                  case 17:
                                    oa = 3;
                                    break;

                                  case 18:
                                    oa = 7;
                                    break;

                                  default:
                                    i("invalid code: " + $);
                                }
                                x.d(a[F], oa, v);
                            }
                        }
                        var Sa = [ Ma, W ], Ta = [ Na, ea ], Q, Ua, ga, ya, Va, Wa, Xa, Ya;
                        Va = Sa[0];
                        Wa = Sa[1];
                        Xa = Ta[0];
                        Ya = Ta[1];
                        Q = 0;
                        for (Ua = k.length; Q < Ua; ++Q) {
                            if (ga = k[Q], x.d(Va[ga], Wa[ga], v), 256 < ga) {
                                x.d(k[++Q], k[++Q], v), ya = k[++Q], x.d(Xa[ya], Ya[ya], v), x.d(k[++Q], k[++Q], v);
                            } else {
                                if (256 === ga) {
                                    break;
                                }
                            }
                        }
                        this.a = x.finish();
                        this.b = this.a.length;
                        break;

                      default:
                        i("invalid compression type");
                    }
                    return this.a;
                };
                function wa(a, c) {
                    this.length = a;
                    this.G = c;
                }
                function xa() {
                    var a = za;
                    switch (v) {
                      case 3 === a:
                        return [ 257, a - 3, 0 ];

                      case 4 === a:
                        return [ 258, a - 4, 0 ];

                      case 5 === a:
                        return [ 259, a - 5, 0 ];

                      case 6 === a:
                        return [ 260, a - 6, 0 ];

                      case 7 === a:
                        return [ 261, a - 7, 0 ];

                      case 8 === a:
                        return [ 262, a - 8, 0 ];

                      case 9 === a:
                        return [ 263, a - 9, 0 ];

                      case 10 === a:
                        return [ 264, a - 10, 0 ];

                      case 12 >= a:
                        return [ 265, a - 11, 1 ];

                      case 14 >= a:
                        return [ 266, a - 13, 1 ];

                      case 16 >= a:
                        return [ 267, a - 15, 1 ];

                      case 18 >= a:
                        return [ 268, a - 17, 1 ];

                      case 22 >= a:
                        return [ 269, a - 19, 2 ];

                      case 26 >= a:
                        return [ 270, a - 23, 2 ];

                      case 30 >= a:
                        return [ 271, a - 27, 2 ];

                      case 34 >= a:
                        return [ 272, a - 31, 2 ];

                      case 42 >= a:
                        return [ 273, a - 35, 3 ];

                      case 50 >= a:
                        return [ 274, a - 43, 3 ];

                      case 58 >= a:
                        return [ 275, a - 51, 3 ];

                      case 66 >= a:
                        return [ 276, a - 59, 3 ];

                      case 82 >= a:
                        return [ 277, a - 67, 4 ];

                      case 98 >= a:
                        return [ 278, a - 83, 4 ];

                      case 114 >= a:
                        return [ 279, a - 99, 4 ];

                      case 130 >= a:
                        return [ 280, a - 115, 4 ];

                      case 162 >= a:
                        return [ 281, a - 131, 5 ];

                      case 194 >= a:
                        return [ 282, a - 163, 5 ];

                      case 226 >= a:
                        return [ 283, a - 195, 5 ];

                      case 257 >= a:
                        return [ 284, a - 227, 5 ];

                      case 258 === a:
                        return [ 285, a - 258, 0 ];

                      default:
                        i("invalid length: " + a);
                    }
                }
                var Aa = [], za, Ba;
                for (za = 3; 258 >= za; za++) {
                    Ba = xa(), Aa[za] = Ba[2] << 24 | Ba[1] << 16 | Ba[0];
                }
                var Ca = H ? new Uint32Array(Aa) : Aa;
                function sa(a, c) {
                    function b(a, c) {
                        var b = a.G, d = [], e = 0, f;
                        f = Ca[a.length];
                        d[e++] = 65535 & f;
                        d[e++] = f >> 16 & 255;
                        d[e++] = f >> 24;
                        var g;
                        switch (v) {
                          case 1 === b:
                            g = [ 0, b - 1, 0 ];
                            break;

                          case 2 === b:
                            g = [ 1, b - 2, 0 ];
                            break;

                          case 3 === b:
                            g = [ 2, b - 3, 0 ];
                            break;

                          case 4 === b:
                            g = [ 3, b - 4, 0 ];
                            break;

                          case 6 >= b:
                            g = [ 4, b - 5, 1 ];
                            break;

                          case 8 >= b:
                            g = [ 5, b - 7, 1 ];
                            break;

                          case 12 >= b:
                            g = [ 6, b - 9, 2 ];
                            break;

                          case 16 >= b:
                            g = [ 7, b - 13, 2 ];
                            break;

                          case 24 >= b:
                            g = [ 8, b - 17, 3 ];
                            break;

                          case 32 >= b:
                            g = [ 9, b - 25, 3 ];
                            break;

                          case 48 >= b:
                            g = [ 10, b - 33, 4 ];
                            break;

                          case 64 >= b:
                            g = [ 11, b - 49, 4 ];
                            break;

                          case 96 >= b:
                            g = [ 12, b - 65, 5 ];
                            break;

                          case 128 >= b:
                            g = [ 13, b - 97, 5 ];
                            break;

                          case 192 >= b:
                            g = [ 14, b - 129, 6 ];
                            break;

                          case 256 >= b:
                            g = [ 15, b - 193, 6 ];
                            break;

                          case 384 >= b:
                            g = [ 16, b - 257, 7 ];
                            break;

                          case 512 >= b:
                            g = [ 17, b - 385, 7 ];
                            break;

                          case 768 >= b:
                            g = [ 18, b - 513, 8 ];
                            break;

                          case 1024 >= b:
                            g = [ 19, b - 769, 8 ];
                            break;

                          case 1536 >= b:
                            g = [ 20, b - 1025, 9 ];
                            break;

                          case 2048 >= b:
                            g = [ 21, b - 1537, 9 ];
                            break;

                          case 3072 >= b:
                            g = [ 22, b - 2049, 10 ];
                            break;

                          case 4096 >= b:
                            g = [ 23, b - 3073, 10 ];
                            break;

                          case 6144 >= b:
                            g = [ 24, b - 4097, 11 ];
                            break;

                          case 8192 >= b:
                            g = [ 25, b - 6145, 11 ];
                            break;

                          case 12288 >= b:
                            g = [ 26, b - 8193, 12 ];
                            break;

                          case 16384 >= b:
                            g = [ 27, b - 12289, 12 ];
                            break;

                          case 24576 >= b:
                            g = [ 28, b - 16385, 13 ];
                            break;

                          case 32768 >= b:
                            g = [ 29, b - 24577, 13 ];
                            break;

                          default:
                            i("invalid distance");
                        }
                        f = g;
                        d[e++] = f[0];
                        d[e++] = f[1];
                        d[e++] = f[2];
                        var h, j;
                        h = 0;
                        for (j = d.length; h < j; ++h) {
                            l[q++] = d[h];
                        }
                        t[d[0]]++;
                        z[d[3]]++;
                        E = a.length + c - 1;
                        n = null;
                    }
                    var e, f, d, g, h, m = {}, j, s, n, l = H ? new Uint16Array(2 * c.length) : [], q = 0, E = 0, t = new (H ? Uint32Array : Array)(286), z = new (H ? Uint32Array : Array)(30), K = a.w, A;
                    if (!H) {
                        for (d = 0; 285 >= d; ) {
                            t[d++] = 0;
                        }
                        for (d = 0; 29 >= d; ) {
                            z[d++] = 0;
                        }
                    }
                    t[256] = 1;
                    e = 0;
                    for (f = c.length; e < f; ++e) {
                        d = h = 0;
                        for (g = 3; d < g && e + d !== f; ++d) {
                            h = h << 8 | c[e + d];
                        }
                        m[h] === r && (m[h] = []);
                        j = m[h];
                        if (!(0 < E--)) {
                            for (;0 < j.length && 32768 < e - j[0]; ) {
                                j.shift();
                            }
                            if (e + 3 >= f) {
                                n && b(n, -1);
                                d = 0;
                                for (g = f - e; d < g; ++d) {
                                    A = c[e + d], l[q++] = A, ++t[A];
                                }
                                break;
                            }
                            if (0 < j.length) {
                                var x = r, B = r, k = 0, p = r, D = r, C = r, da = r, W = c.length, D = 0, da = j.length;
                                a: for (;D < da; D++) {
                                    x = j[da - D - 1];
                                    p = 3;
                                    if (3 < k) {
                                        for (C = k; 3 < C; C--) {
                                            if (c[x + C - 1] !== c[e + C - 1]) {
                                                continue a;
                                            }
                                        }
                                        p = k;
                                    }
                                    for (;258 > p && e + p < W && c[x + p] === c[e + p]; ) {
                                        ++p;
                                    }
                                    p > k && (B = x, k = p);
                                    if (258 === p) {
                                        break;
                                    }
                                }
                                s = new wa(k, e - B);
                                n ? n.length < s.length ? (A = c[e - 1], l[q++] = A, ++t[A], b(s, 0)) : b(n, -1) : s.length < K ? n = s : b(s, 0);
                            } else {
                                n ? b(n, -1) : (A = c[e], l[q++] = A, ++t[A]);
                            }
                        }
                        j.push(e);
                    }
                    l[q++] = 256;
                    t[256]++;
                    a.L = t;
                    a.K = z;
                    return H ? l.subarray(0, q) : l;
                }
                function ta(a, c) {
                    function b(a) {
                        var c = z[a][K[a]];
                        c === n ? (b(a + 1), b(a + 1)) : --E[c];
                        ++K[a];
                    }
                    var e = a.length, f = new la(572), d = new (H ? Uint8Array : Array)(e), g, h, m, j, s;
                    if (!H) {
                        for (j = 0; j < e; j++) {
                            d[j] = 0;
                        }
                    }
                    for (j = 0; j < e; ++j) {
                        0 < a[j] && f.push(j, a[j]);
                    }
                    g = Array(f.length / 2);
                    h = new (H ? Uint32Array : Array)(f.length / 2);
                    if (1 === g.length) {
                        return d[f.pop().index] = 1, d;
                    }
                    j = 0;
                    for (s = f.length / 2; j < s; ++j) {
                        g[j] = f.pop(), h[j] = g[j].value;
                    }
                    var n = h.length, l = new (H ? Uint16Array : Array)(c), q = new (H ? Uint8Array : Array)(c), E = new (H ? Uint8Array : Array)(n), t = Array(c), z = Array(c), K = Array(c), A = (1 << c) - n, x = 1 << c - 1, B, k, p, D, C;
                    l[c - 1] = n;
                    for (k = 0; k < c; ++k) {
                        A < x ? q[k] = 0 : (q[k] = 1, A -= x), A <<= 1, l[c - 2 - k] = (l[c - 1 - k] / 2 | 0) + n;
                    }
                    l[0] = q[0];
                    t[0] = Array(l[0]);
                    z[0] = Array(l[0]);
                    for (k = 1; k < c; ++k) {
                        l[k] > 2 * l[k - 1] + q[k] && (l[k] = 2 * l[k - 1] + q[k]), t[k] = Array(l[k]), 
                        z[k] = Array(l[k]);
                    }
                    for (B = 0; B < n; ++B) {
                        E[B] = c;
                    }
                    for (p = 0; p < l[c - 1]; ++p) {
                        t[c - 1][p] = h[p], z[c - 1][p] = p;
                    }
                    for (B = 0; B < c; ++B) {
                        K[B] = 0;
                    }
                    1 === q[c - 1] && (--E[0], ++K[c - 1]);
                    for (k = c - 2; 0 <= k; --k) {
                        D = B = 0;
                        C = K[k + 1];
                        for (p = 0; p < l[k]; p++) {
                            D = t[k + 1][C] + t[k + 1][C + 1], D > h[B] ? (t[k][p] = D, z[k][p] = n, C += 2) : (t[k][p] = h[B], 
                            z[k][p] = B, ++B);
                        }
                        K[k] = 0;
                        1 === q[k] && b(k);
                    }
                    m = E;
                    j = 0;
                    for (s = g.length; j < s; ++j) {
                        d[g[j].index] = m[j];
                    }
                    return d;
                }
                function ua(a) {
                    var c = new (H ? Uint16Array : Array)(a.length), b = [], e = [], f = 0, d, g, h, m;
                    d = 0;
                    for (g = a.length; d < g; d++) {
                        b[a[d]] = (0 | b[a[d]]) + 1;
                    }
                    d = 1;
                    for (g = 16; d <= g; d++) {
                        e[d] = f, f += 0 | b[d], f > 1 << d && i("overcommitted"), f <<= 1;
                    }
                    65536 > f && i("undercommitted");
                    d = 0;
                    for (g = a.length; d < g; d++) {
                        f = e[a[d]];
                        e[a[d]] += 1;
                        h = c[d] = 0;
                        for (m = a[d]; h < m; h++) {
                            c[d] = c[d] << 1 | 1 & f, f >>>= 1;
                        }
                    }
                    return c;
                }
                function Da(a, c) {
                    this.input = a;
                    this.a = new (H ? Uint8Array : Array)(32768);
                    this.h = U.j;
                    var b = {}, e;
                    if ((c || !(c = {})) && "number" === typeof c.compressionType) {
                        this.h = c.compressionType;
                    }
                    for (e in c) {
                        b[e] = c[e];
                    }
                    b.outputBuffer = this.a;
                    this.z = new ma(this.input, b);
                }
                var U = qa;
                Da.prototype.n = function() {
                    var a, c, b, e, f, d, g, h = 0;
                    g = this.a;
                    a = Ea;
                    switch (a) {
                      case Ea:
                        c = Math.LOG2E * Math.log(32768) - 8;
                        break;

                      default:
                        i(Error("invalid compression method"));
                    }
                    b = c << 4 | a;
                    g[h++] = b;
                    switch (a) {
                      case Ea:
                        switch (this.h) {
                          case U.NONE:
                            f = 0;
                            break;

                          case U.r:
                            f = 1;
                            break;

                          case U.j:
                            f = 2;
                            break;

                          default:
                            i(Error("unsupported compression type"));
                        }
                        break;

                      default:
                        i(Error("invalid compression method"));
                    }
                    e = f << 6 | 0;
                    g[h++] = e | 31 - (256 * b + e) % 31;
                    d = ba(this.input);
                    this.z.b = h;
                    g = this.z.n();
                    h = g.length;
                    H && (g = new Uint8Array(g.buffer), g.length <= h + 4 && (this.a = new Uint8Array(g.length + 4), 
                    this.a.set(g), g = this.a), g = g.subarray(0, h + 4));
                    g[h++] = d >> 24 & 255;
                    g[h++] = d >> 16 & 255;
                    g[h++] = d >> 8 & 255;
                    g[h++] = 255 & d;
                    return g;
                };
                y("Zlib.Deflate", Da);
                y("Zlib.Deflate.compress", function(a, c) {
                    return new Da(a, c).n();
                });
                y("Zlib.Deflate.CompressionType", U);
                y("Zlib.Deflate.CompressionType.NONE", U.NONE);
                y("Zlib.Deflate.CompressionType.FIXED", U.r);
                y("Zlib.Deflate.CompressionType.DYNAMIC", U.j);
                function V(a, c) {
                    this.k = [];
                    this.l = 32768;
                    this.e = this.g = this.c = this.q = 0;
                    this.input = H ? new Uint8Array(a) : a;
                    this.s = !1;
                    this.m = Fa;
                    this.B = !1;
                    if (c || !(c = {})) {
                        c.index && (this.c = c.index), c.bufferSize && (this.l = c.bufferSize), c.bufferType && (this.m = c.bufferType), 
                        c.resize && (this.B = c.resize);
                    }
                    switch (this.m) {
                      case Ga:
                        this.b = 32768;
                        this.a = new (H ? Uint8Array : Array)(32768 + this.l + 258);
                        break;

                      case Fa:
                        this.b = 0;
                        this.a = new (H ? Uint8Array : Array)(this.l);
                        this.f = this.J;
                        this.t = this.H;
                        this.o = this.I;
                        break;

                      default:
                        i(Error("invalid inflate mode"));
                    }
                }
                var Ga = 0, Fa = 1, Ha = {
                    D: Ga,
                    C: Fa
                };
                V.prototype.p = function() {
                    for (;!this.s; ) {
                        var a = X(this, 3);
                        1 & a && (this.s = v);
                        a >>>= 1;
                        switch (a) {
                          case 0:
                            var c = this.input, b = this.c, e = this.a, f = this.b, d = r, g = r, h = r, m = e.length, j = r;
                            this.e = this.g = 0;
                            d = c[b++];
                            d === r && i(Error("invalid uncompressed block header: LEN (first byte)"));
                            g = d;
                            d = c[b++];
                            d === r && i(Error("invalid uncompressed block header: LEN (second byte)"));
                            g |= d << 8;
                            d = c[b++];
                            d === r && i(Error("invalid uncompressed block header: NLEN (first byte)"));
                            h = d;
                            d = c[b++];
                            d === r && i(Error("invalid uncompressed block header: NLEN (second byte)"));
                            h |= d << 8;
                            g === ~h && i(Error("invalid uncompressed block header: length verify"));
                            b + g > c.length && i(Error("input buffer is broken"));
                            switch (this.m) {
                              case Ga:
                                for (;f + g > e.length; ) {
                                    j = m - f;
                                    g -= j;
                                    if (H) {
                                        e.set(c.subarray(b, b + j), f), f += j, b += j;
                                    } else {
                                        for (;j--; ) {
                                            e[f++] = c[b++];
                                        }
                                    }
                                    this.b = f;
                                    e = this.f();
                                    f = this.b;
                                }
                                break;

                              case Fa:
                                for (;f + g > e.length; ) {
                                    e = this.f({
                                        v: 2
                                    });
                                }
                                break;

                              default:
                                i(Error("invalid inflate mode"));
                            }
                            if (H) {
                                e.set(c.subarray(b, b + g), f), f += g, b += g;
                            } else {
                                for (;g--; ) {
                                    e[f++] = c[b++];
                                }
                            }
                            this.c = b;
                            this.b = f;
                            this.a = e;
                            break;

                          case 1:
                            this.o(Ia, Ja);
                            break;

                          case 2:
                            Ka(this);
                            break;

                          default:
                            i(Error("unknown BTYPE: " + a));
                        }
                    }
                    return this.t();
                };
                var La = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ], Za = H ? new Uint16Array(La) : La, $a = [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258 ], ab = H ? new Uint16Array($a) : $a, bb = [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0 ], cb = H ? new Uint8Array(bb) : bb, db = [ 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 ], eb = H ? new Uint16Array(db) : db, fb = [ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ], gb = H ? new Uint8Array(fb) : fb, hb = new (H ? Uint8Array : Array)(288), Y, ib;
                Y = 0;
                for (ib = hb.length; Y < ib; ++Y) {
                    hb[Y] = 143 >= Y ? 8 : 255 >= Y ? 9 : 279 >= Y ? 7 : 8;
                }
                var Ia = S(hb), jb = new (H ? Uint8Array : Array)(30), kb, lb;
                kb = 0;
                for (lb = jb.length; kb < lb; ++kb) {
                    jb[kb] = 5;
                }
                var Ja = S(jb);
                function X(a, c) {
                    for (var b = a.g, e = a.e, f = a.input, d = a.c, g; e < c; ) {
                        g = f[d++], g === r && i(Error("input buffer is broken")), b |= g << e, e += 8;
                    }
                    g = b & (1 << c) - 1;
                    a.g = b >>> c;
                    a.e = e - c;
                    a.c = d;
                    return g;
                }
                function mb(a, c) {
                    for (var b = a.g, e = a.e, f = a.input, d = a.c, g = c[0], h = c[1], m, j, s; e < h; ) {
                        m = f[d++], m === r && i(Error("input buffer is broken")), b |= m << e, e += 8;
                    }
                    j = g[b & (1 << h) - 1];
                    s = j >>> 16;
                    a.g = b >> s;
                    a.e = e - s;
                    a.c = d;
                    return 65535 & j;
                }
                function Ka(a) {
                    function c(a, b, c) {
                        var d, e, f, g;
                        for (g = 0; g < a; ) {
                            switch (d = mb(this, b), d) {
                              case 16:
                                for (f = 3 + X(this, 2); f--; ) {
                                    c[g++] = e;
                                }
                                break;

                              case 17:
                                for (f = 3 + X(this, 3); f--; ) {
                                    c[g++] = 0;
                                }
                                e = 0;
                                break;

                              case 18:
                                for (f = 11 + X(this, 7); f--; ) {
                                    c[g++] = 0;
                                }
                                e = 0;
                                break;

                              default:
                                e = c[g++] = d;
                            }
                        }
                        return c;
                    }
                    var b = X(a, 5) + 257, e = X(a, 5) + 1, f = X(a, 4) + 4, d = new (H ? Uint8Array : Array)(Za.length), g, h, m, j;
                    for (j = 0; j < f; ++j) {
                        d[Za[j]] = X(a, 3);
                    }
                    g = S(d);
                    h = new (H ? Uint8Array : Array)(b);
                    m = new (H ? Uint8Array : Array)(e);
                    a.o(S(c.call(a, b, g, h)), S(c.call(a, e, g, m)));
                }
                V.prototype.o = function(a, c) {
                    var b = this.a, e = this.b;
                    this.u = a;
                    for (var f = b.length - 258, d, g, h, m; 256 !== (d = mb(this, a)); ) {
                        if (256 > d) {
                            e >= f && (this.b = e, b = this.f(), e = this.b), b[e++] = d;
                        } else {
                            g = d - 257;
                            m = ab[g];
                            0 < cb[g] && (m += X(this, cb[g]));
                            d = mb(this, c);
                            h = eb[d];
                            0 < gb[d] && (h += X(this, gb[d]));
                            e >= f && (this.b = e, b = this.f(), e = this.b);
                            for (;m--; ) {
                                b[e] = b[e++ - h];
                            }
                        }
                    }
                    for (;8 <= this.e; ) {
                        this.e -= 8, this.c--;
                    }
                    this.b = e;
                };
                V.prototype.I = function(a, c) {
                    var b = this.a, e = this.b;
                    this.u = a;
                    for (var f = b.length, d, g, h, m; 256 !== (d = mb(this, a)); ) {
                        if (256 > d) {
                            e >= f && (b = this.f(), f = b.length), b[e++] = d;
                        } else {
                            g = d - 257;
                            m = ab[g];
                            0 < cb[g] && (m += X(this, cb[g]));
                            d = mb(this, c);
                            h = eb[d];
                            0 < gb[d] && (h += X(this, gb[d]));
                            e + m > f && (b = this.f(), f = b.length);
                            for (;m--; ) {
                                b[e] = b[e++ - h];
                            }
                        }
                    }
                    for (;8 <= this.e; ) {
                        this.e -= 8, this.c--;
                    }
                    this.b = e;
                };
                V.prototype.f = function() {
                    var a = new (H ? Uint8Array : Array)(this.b - 32768), c = this.b - 32768, b, e, f = this.a;
                    if (H) {
                        a.set(f.subarray(32768, a.length));
                    } else {
                        b = 0;
                        for (e = a.length; b < e; ++b) {
                            a[b] = f[b + 32768];
                        }
                    }
                    this.k.push(a);
                    this.q += a.length;
                    if (H) {
                        f.set(f.subarray(c, c + 32768));
                    } else {
                        for (b = 0; 32768 > b; ++b) {
                            f[b] = f[c + b];
                        }
                    }
                    this.b = 32768;
                    return f;
                };
                V.prototype.J = function(a) {
                    var c, b = this.input.length / this.c + 1 | 0, e, f, d, g = this.input, h = this.a;
                    a && ("number" === typeof a.v && (b = a.v), "number" === typeof a.F && (b += a.F));
                    2 > b ? (e = (g.length - this.c) / this.u[2], d = 258 * (e / 2) | 0, f = d < h.length ? h.length + d : h.length << 1) : f = h.length * b;
                    H ? (c = new Uint8Array(f), c.set(h)) : c = h;
                    return this.a = c;
                };
                V.prototype.t = function() {
                    var a = 0, c = this.a, b = this.k, e, f = new (H ? Uint8Array : Array)(this.q + (this.b - 32768)), d, g, h, m;
                    if (0 === b.length) {
                        return H ? this.a.subarray(32768, this.b) : this.a.slice(32768, this.b);
                    }
                    d = 0;
                    for (g = b.length; d < g; ++d) {
                        e = b[d];
                        h = 0;
                        for (m = e.length; h < m; ++h) {
                            f[a++] = e[h];
                        }
                    }
                    d = 32768;
                    for (g = this.b; d < g; ++d) {
                        f[a++] = c[d];
                    }
                    this.k = [];
                    return this.buffer = f;
                };
                V.prototype.H = function() {
                    var a, c = this.b;
                    H ? this.B ? (a = new Uint8Array(c), a.set(this.a.subarray(0, c))) : a = this.a.subarray(0, c) : (this.a.length > c && (this.a.length = c), 
                    a = this.a);
                    return this.buffer = a;
                };
                function nb(a, c) {
                    var b, e;
                    this.input = a;
                    this.c = 0;
                    if (c || !(c = {})) {
                        c.index && (this.c = c.index), c.verify && (this.M = c.verify);
                    }
                    b = a[this.c++];
                    e = a[this.c++];
                    switch (15 & b) {
                      case Ea:
                        this.method = Ea;
                        break;

                      default:
                        i(Error("unsupported compression method"));
                    }
                    0 !== ((b << 8) + e) % 31 && i(Error("invalid fcheck flag:" + ((b << 8) + e) % 31));
                    32 & e && i(Error("fdict flag is not supported"));
                    this.A = new V(a, {
                        index: this.c,
                        bufferSize: c.bufferSize,
                        bufferType: c.bufferType,
                        resize: c.resize
                    });
                }
                nb.prototype.p = function() {
                    var a = this.input, c, b;
                    c = this.A.p();
                    this.c = this.A.c;
                    this.M && (b = (a[this.c++] << 24 | a[this.c++] << 16 | a[this.c++] << 8 | a[this.c++]) >>> 0, 
                    b !== ba(c) && i(Error("invalid adler-32 checksum")));
                    return c;
                };
                y("Zlib.Inflate", nb);
                y("Zlib.Inflate.BufferType", Ha);
                Ha.ADAPTIVE = Ha.C;
                Ha.BLOCK = Ha.D;
                y("Zlib.Inflate.prototype.decompress", nb.prototype.p);
                var ob = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];
                H && new Uint16Array(ob);
                var pb = [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258 ];
                H && new Uint16Array(pb);
                var qb = [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0 ];
                H && new Uint8Array(qb);
                var rb = [ 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 ];
                H && new Uint16Array(rb);
                var sb = [ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ];
                H && new Uint8Array(sb);
                var tb = new (H ? Uint8Array : Array)(288), Z, ub;
                Z = 0;
                for (ub = tb.length; Z < ub; ++Z) {
                    tb[Z] = 143 >= Z ? 8 : 255 >= Z ? 9 : 279 >= Z ? 7 : 8;
                }
                S(tb);
                var vb = new (H ? Uint8Array : Array)(30), wb, xb;
                wb = 0;
                for (xb = vb.length; wb < xb; ++wb) {
                    vb[wb] = 5;
                }
                S(vb);
                var Ea = 8;
            }).call(this);
            var _p = window;
            _p = _p.Zlib = _p["Zlib"];
            _p.Deflate = _p["Deflate"];
            _p.Deflate.compress = _p.Deflate["compress"];
            _p.Inflate = _p["Inflate"];
            _p.Inflate.BufferType = _p.Inflate["BufferType"];
            _p.Inflate.prototype.decompress = _p.Inflate.prototype["decompress"];
            cc.PNGReader = cc._Class.extend({
                ctor: function(data) {
                    var chunkSize, colors, delayDen, delayNum, frame, i, index, key, section, ccshort, text, _i, _j, _ref;
                    this.data = data;
                    this.pos = 8;
                    this.palette = [];
                    this.imgData = [];
                    this.transparency = {};
                    this.animation = null;
                    this.text = {};
                    frame = null;
                    while (true) {
                        chunkSize = this.readUInt32();
                        section = function() {
                            var _i, _results;
                            _results = [];
                            for (i = _i = 0; _i < 4; i = ++_i) {
                                _results.push(String.fromCharCode(this.data[this.pos++]));
                            }
                            return _results;
                        }.call(this).join("");
                        switch (section) {
                          case "IHDR":
                            this.width = this.readUInt32();
                            this.height = this.readUInt32();
                            this.bits = this.data[this.pos++];
                            this.colorType = this.data[this.pos++];
                            this.compressionMethod = this.data[this.pos++];
                            this.filterMethod = this.data[this.pos++];
                            this.interlaceMethod = this.data[this.pos++];
                            break;

                          case "acTL":
                            this.animation = {
                                numFrames: this.readUInt32(),
                                numPlays: this.readUInt32() || 1 / 0,
                                frames: []
                            };
                            break;

                          case "PLTE":
                            this.palette = this.read(chunkSize);
                            break;

                          case "fcTL":
                            if (frame) {
                                this.animation.frames.push(frame);
                            }
                            this.pos += 4;
                            frame = {
                                width: this.readUInt32(),
                                height: this.readUInt32(),
                                xOffset: this.readUInt32(),
                                yOffset: this.readUInt32()
                            };
                            delayNum = this.readUInt16();
                            delayDen = this.readUInt16() || 100;
                            frame.delay = 1e3 * delayNum / delayDen;
                            frame.disposeOp = this.data[this.pos++];
                            frame.blendOp = this.data[this.pos++];
                            frame.data = [];
                            break;

                          case "IDAT":
                          case "fdAT":
                            if ("fdAT" === section) {
                                this.pos += 4;
                                chunkSize -= 4;
                            }
                            data = (null != frame ? frame.data : void 0) || this.imgData;
                            for (i = _i = 0; 0 <= chunkSize ? _i < chunkSize : _i > chunkSize; i = 0 <= chunkSize ? ++_i : --_i) {
                                data.push(this.data[this.pos++]);
                            }
                            break;

                          case "tRNS":
                            this.transparency = {};
                            switch (this.colorType) {
                              case 3:
                                this.transparency.indexed = this.read(chunkSize);
                                ccshort = 255 - this.transparency.indexed.length;
                                if (ccshort > 0) {
                                    for (i = _j = 0; 0 <= ccshort ? _j < ccshort : _j > ccshort; i = 0 <= ccshort ? ++_j : --_j) {
                                        this.transparency.indexed.push(255);
                                    }
                                }
                                break;

                              case 0:
                                this.transparency.grayscale = this.read(chunkSize)[0];
                                break;

                              case 2:
                                this.transparency.rgb = this.read(chunkSize);
                            }
                            break;

                          case "tEXt":
                            text = this.read(chunkSize);
                            index = text.indexOf(0);
                            key = String.fromCharCode.apply(String, text.slice(0, index));
                            this.text[key] = String.fromCharCode.apply(String, text.slice(index + 1));
                            break;

                          case "IEND":
                            if (frame) {
                                this.animation.frames.push(frame);
                            }
                            this.colors = function() {
                                switch (this.colorType) {
                                  case 0:
                                  case 3:
                                  case 4:
                                    return 1;

                                  case 2:
                                  case 6:
                                    return 3;
                                }
                            }.call(this);
                            this.hasAlphaChannel = 4 === (_ref = this.colorType) || 6 === _ref;
                            colors = this.colors + (this.hasAlphaChannel ? 1 : 0);
                            this.pixelBitlength = this.bits * colors;
                            this.colorSpace = function() {
                                switch (this.colors) {
                                  case 1:
                                    return "DeviceGray";

                                  case 3:
                                    return "DeviceRGB";
                                }
                            }.call(this);
                            if (Uint8Array != Array) {
                                this.imgData = new Uint8Array(this.imgData);
                            }
                            return;

                          default:
                            this.pos += chunkSize;
                        }
                        this.pos += 4;
                        if (this.pos > this.data.length) {
                            throw new Error("Incomplete or corrupt PNG file");
                        }
                    }
                },
                read: function(bytes) {
                    var i, _i, _results;
                    _results = [];
                    for (i = _i = 0; 0 <= bytes ? _i < bytes : _i > bytes; i = 0 <= bytes ? ++_i : --_i) {
                        _results.push(this.data[this.pos++]);
                    }
                    return _results;
                },
                readUInt32: function() {
                    var b1, b2, b3, b4;
                    b1 = this.data[this.pos++] << 24;
                    b2 = this.data[this.pos++] << 16;
                    b3 = this.data[this.pos++] << 8;
                    b4 = this.data[this.pos++];
                    return b1 | b2 | b3 | b4;
                },
                readUInt16: function() {
                    var b1, b2;
                    b1 = this.data[this.pos++] << 8;
                    b2 = this.data[this.pos++];
                    return b1 | b2;
                },
                decodePixels: function(data) {
                    var ccbyte, c, col, i, left, length, p, pa, paeth, pb, pc, pixelBytes, pixels, pos, row, scanlineLength, upper, upperLeft, _i, _j, _k, _l, _m;
                    if (null == data) {
                        data = this.imgData;
                    }
                    if (0 === data.length) {
                        return new Uint8Array(0);
                    }
                    var inflate = new Zlib.Inflate(data, {
                        index: 0,
                        verify: false
                    });
                    data = inflate.decompress();
                    pixelBytes = this.pixelBitlength / 8;
                    scanlineLength = pixelBytes * this.width;
                    pixels = new Uint8Array(scanlineLength * this.height);
                    length = data.length;
                    row = 0;
                    pos = 0;
                    c = 0;
                    while (pos < length) {
                        switch (data[pos++]) {
                          case 0:
                            for (i = _i = 0; _i < scanlineLength; i = _i += 1) {
                                pixels[c++] = data[pos++];
                            }
                            break;

                          case 1:
                            for (i = _j = 0; _j < scanlineLength; i = _j += 1) {
                                ccbyte = data[pos++];
                                left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
                                pixels[c++] = (ccbyte + left) % 256;
                            }
                            break;

                          case 2:
                            for (i = _k = 0; _k < scanlineLength; i = _k += 1) {
                                ccbyte = data[pos++];
                                col = (i - i % pixelBytes) / pixelBytes;
                                upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                                pixels[c++] = (upper + ccbyte) % 256;
                            }
                            break;

                          case 3:
                            for (i = _l = 0; _l < scanlineLength; i = _l += 1) {
                                ccbyte = data[pos++];
                                col = (i - i % pixelBytes) / pixelBytes;
                                left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
                                upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                                pixels[c++] = (ccbyte + Math.floor((left + upper) / 2)) % 256;
                            }
                            break;

                          case 4:
                            for (i = _m = 0; _m < scanlineLength; i = _m += 1) {
                                ccbyte = data[pos++];
                                col = (i - i % pixelBytes) / pixelBytes;
                                left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
                                if (0 === row) {
                                    upper = upperLeft = 0;
                                } else {
                                    upper = pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                                    upperLeft = col && pixels[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i % pixelBytes];
                                }
                                p = left + upper - upperLeft;
                                pa = Math.abs(p - left);
                                pb = Math.abs(p - upper);
                                pc = Math.abs(p - upperLeft);
                                if (pa <= pb && pa <= pc) {
                                    paeth = left;
                                } else {
                                    if (pb <= pc) {
                                        paeth = upper;
                                    } else {
                                        paeth = upperLeft;
                                    }
                                }
                                pixels[c++] = (ccbyte + paeth) % 256;
                            }
                            break;

                          default:
                            throw new Error("Invalid filter algorithm: " + data[pos - 1]);
                        }
                        row++;
                    }
                    return pixels;
                },
                copyToImageData: function(imageData, pixels) {
                    var alpha, colors, data, i, input, j, k, length, palette, v, _ref;
                    colors = this.colors;
                    palette = null;
                    alpha = this.hasAlphaChannel;
                    if (this.palette.length) {
                        palette = null != (_ref = this._decodedPalette) ? _ref : this._decodedPalette = this.decodePalette();
                        colors = 4;
                        alpha = true;
                    }
                    data = imageData.data || imageData;
                    length = data.length;
                    input = palette || pixels;
                    i = j = 0;
                    if (1 === colors) {
                        while (i < length) {
                            k = palette ? 4 * pixels[i / 4] : j;
                            v = input[k++];
                            data[i++] = v;
                            data[i++] = v;
                            data[i++] = v;
                            data[i++] = alpha ? input[k++] : 255;
                            j = k;
                        }
                    } else {
                        while (i < length) {
                            k = palette ? 4 * pixels[i / 4] : j;
                            data[i++] = input[k++];
                            data[i++] = input[k++];
                            data[i++] = input[k++];
                            data[i++] = alpha ? input[k++] : 255;
                            j = k;
                        }
                    }
                },
                decodePalette: function() {
                    var c, i, palette, pos, ret, transparency, _i, _ref, _ref1;
                    palette = this.palette;
                    transparency = this.transparency.indexed || [];
                    ret = new Uint8Array((transparency.length || 0) + palette.length);
                    pos = 0;
                    c = 0;
                    for (i = _i = 0, _ref = palette.length; _i < _ref; i = _i += 3) {
                        ret[pos++] = palette[i];
                        ret[pos++] = palette[i + 1];
                        ret[pos++] = palette[i + 2];
                        ret[pos++] = null != (_ref1 = transparency[c++]) ? _ref1 : 255;
                    }
                    return ret;
                },
                render: function(canvas) {
                    var ctx, data;
                    canvas.width = this.width;
                    canvas.height = this.height;
                    ctx = canvas.getContext("2d");
                    data = ctx.createImageData(this.width, this.height);
                    this.copyToImageData(data, this.decodePixels());
                    return ctx.putImageData(data, 0, 0);
                }
            });
            cc.tiffReader = {
                _littleEndian: false,
                _tiffData: null,
                _fileDirectories: [],
                getUint8: function(offset) {
                    return this._tiffData[offset];
                },
                getUint16: function(offset) {
                    if (this._littleEndian) {
                        return this._tiffData[offset + 1] << 8 | this._tiffData[offset];
                    } else {
                        return this._tiffData[offset] << 8 | this._tiffData[offset + 1];
                    }
                },
                getUint32: function(offset) {
                    var a = this._tiffData;
                    if (this._littleEndian) {
                        return a[offset + 3] << 24 | a[offset + 2] << 16 | a[offset + 1] << 8 | a[offset];
                    } else {
                        return a[offset] << 24 | a[offset + 1] << 16 | a[offset + 2] << 8 | a[offset + 3];
                    }
                },
                checkLittleEndian: function() {
                    var BOM = this.getUint16(0);
                    if (18761 === BOM) {
                        this.littleEndian = true;
                    } else {
                        if (19789 === BOM) {
                            this.littleEndian = false;
                        } else {
                            console.log(BOM);
                            throw TypeError("Invalid byte order value.");
                        }
                    }
                    return this.littleEndian;
                },
                hasTowel: function() {
                    if (42 !== this.getUint16(2)) {
                        throw RangeError("You forgot your towel!");
                    }
                    return true;
                },
                getFieldTypeName: function(fieldType) {
                    var typeNames = this.fieldTypeNames;
                    if (fieldType in typeNames) {
                        return typeNames[fieldType];
                    }
                    return null;
                },
                getFieldTagName: function(fieldTag) {
                    var tagNames = this.fieldTagNames;
                    if (fieldTag in tagNames) {
                        return tagNames[fieldTag];
                    } else {
                        console.log("Unknown Field Tag:", fieldTag);
                        return "Tag" + fieldTag;
                    }
                },
                getFieldTypeLength: function(fieldTypeName) {
                    if (-1 !== [ "BYTE", "ASCII", "SBYTE", "UNDEFINED" ].indexOf(fieldTypeName)) {
                        return 1;
                    } else {
                        if (-1 !== [ "SHORT", "SSHORT" ].indexOf(fieldTypeName)) {
                            return 2;
                        } else {
                            if (-1 !== [ "LONG", "SLONG", "FLOAT" ].indexOf(fieldTypeName)) {
                                return 4;
                            } else {
                                if (-1 !== [ "RATIONAL", "SRATIONAL", "DOUBLE" ].indexOf(fieldTypeName)) {
                                    return 8;
                                }
                            }
                        }
                    }
                    return null;
                },
                getFieldValues: function(fieldTagName, fieldTypeName, typeCount, valueOffset) {
                    var fieldValues = [];
                    var fieldTypeLength = this.getFieldTypeLength(fieldTypeName);
                    var fieldValueSize = fieldTypeLength * typeCount;
                    if (fieldValueSize <= 4) {
                        if (false === this.littleEndian) {
                            fieldValues.push(valueOffset >>> 8 * (4 - fieldTypeLength));
                        } else {
                            fieldValues.push(valueOffset);
                        }
                    } else {
                        for (var i = 0; i < typeCount; i++) {
                            var indexOffset = fieldTypeLength * i;
                            if (fieldTypeLength >= 8) {
                                if (-1 !== [ "RATIONAL", "SRATIONAL" ].indexOf(fieldTypeName)) {
                                    fieldValues.push(this.getUint32(valueOffset + indexOffset));
                                    fieldValues.push(this.getUint32(valueOffset + indexOffset + 4));
                                } else {
                                    cc.log("Can't handle this field type or size");
                                }
                            } else {
                                fieldValues.push(this.getBytes(fieldTypeLength, valueOffset + indexOffset));
                            }
                        }
                    }
                    if ("ASCII" === fieldTypeName) {
                        fieldValues.forEach(function(e, i, a) {
                            a[i] = String.fromCharCode(e);
                        });
                    }
                    return fieldValues;
                },
                getBytes: function(numBytes, offset) {
                    if (numBytes <= 0) {
                        cc.log("No bytes requested");
                    } else {
                        if (numBytes <= 1) {
                            return this.getUint8(offset);
                        } else {
                            if (numBytes <= 2) {
                                return this.getUint16(offset);
                            } else {
                                if (numBytes <= 3) {
                                    return this.getUint32(offset) >>> 8;
                                } else {
                                    if (numBytes <= 4) {
                                        return this.getUint32(offset);
                                    } else {
                                        cc.log("Too many bytes requested");
                                    }
                                }
                            }
                        }
                    }
                },
                getBits: function(numBits, byteOffset, bitOffset) {
                    bitOffset = bitOffset || 0;
                    var extraBytes = Math.floor(bitOffset / 8);
                    var newByteOffset = byteOffset + extraBytes;
                    var totalBits = bitOffset + numBits;
                    var shiftRight = 32 - numBits;
                    var shiftLeft, rawBits;
                    if (totalBits <= 0) {
                        console.log("No bits requested");
                    } else {
                        if (totalBits <= 8) {
                            shiftLeft = 24 + bitOffset;
                            rawBits = this.getUint8(newByteOffset);
                        } else {
                            if (totalBits <= 16) {
                                shiftLeft = 16 + bitOffset;
                                rawBits = this.getUint16(newByteOffset);
                            } else {
                                if (totalBits <= 32) {
                                    shiftLeft = bitOffset;
                                    rawBits = this.getUint32(newByteOffset);
                                } else {
                                    console.log("Too many bits requested");
                                }
                            }
                        }
                    }
                    return {
                        bits: rawBits << shiftLeft >>> shiftRight,
                        byteOffset: newByteOffset + Math.floor(totalBits / 8),
                        bitOffset: totalBits % 8
                    };
                },
                parseFileDirectory: function(byteOffset) {
                    var numDirEntries = this.getUint16(byteOffset);
                    var tiffFields = [];
                    for (var i = byteOffset + 2, entryCount = 0; entryCount < numDirEntries; i += 12, 
                    entryCount++) {
                        var fieldTag = this.getUint16(i);
                        var fieldType = this.getUint16(i + 2);
                        var typeCount = this.getUint32(i + 4);
                        var valueOffset = this.getUint32(i + 8);
                        var fieldTagName = this.getFieldTagName(fieldTag);
                        var fieldTypeName = this.getFieldTypeName(fieldType);
                        var fieldValues = this.getFieldValues(fieldTagName, fieldTypeName, typeCount, valueOffset);
                        tiffFields[fieldTagName] = {
                            type: fieldTypeName,
                            values: fieldValues
                        };
                    }
                    this._fileDirectories.push(tiffFields);
                    var nextIFDByteOffset = this.getUint32(i);
                    if (0 !== nextIFDByteOffset) {
                        this.parseFileDirectory(nextIFDByteOffset);
                    }
                },
                clampColorSample: function(colorSample, bitsPerSample) {
                    var multiplier = Math.pow(2, 8 - bitsPerSample);
                    return Math.floor(colorSample * multiplier + (multiplier - 1));
                },
                parseTIFF: function(tiffData, canvas) {
                    canvas = canvas || document.createElement("canvas");
                    this._tiffData = tiffData;
                    this.canvas = canvas;
                    this.checkLittleEndian();
                    if (!this.hasTowel()) {
                        return;
                    }
                    var firstIFDByteOffset = this.getUint32(4);
                    this._fileDirectories.length = 0;
                    this.parseFileDirectory(firstIFDByteOffset);
                    var fileDirectory = this._fileDirectories[0];
                    var imageWidth = fileDirectory["ImageWidth"].values[0];
                    var imageLength = fileDirectory["ImageLength"].values[0];
                    this.canvas.width = imageWidth;
                    this.canvas.height = imageLength;
                    var strips = [];
                    var compression = fileDirectory["Compression"] ? fileDirectory["Compression"].values[0] : 1;
                    var samplesPerPixel = fileDirectory["SamplesPerPixel"].values[0];
                    var sampleProperties = [];
                    var bitsPerPixel = 0;
                    var hasBytesPerPixel = false;
                    fileDirectory["BitsPerSample"].values.forEach(function(bitsPerSample, i, bitsPerSampleValues) {
                        sampleProperties[i] = {
                            bitsPerSample: bitsPerSample,
                            hasBytesPerSample: false,
                            bytesPerSample: void 0
                        };
                        if (bitsPerSample % 8 === 0) {
                            sampleProperties[i].hasBytesPerSample = true;
                            sampleProperties[i].bytesPerSample = bitsPerSample / 8;
                        }
                        bitsPerPixel += bitsPerSample;
                    }, this);
                    if (bitsPerPixel % 8 === 0) {
                        hasBytesPerPixel = true;
                        var bytesPerPixel = bitsPerPixel / 8;
                    }
                    var stripOffsetValues = fileDirectory["StripOffsets"].values;
                    var numStripOffsetValues = stripOffsetValues.length;
                    if (fileDirectory["StripByteCounts"]) {
                        var stripByteCountValues = fileDirectory["StripByteCounts"].values;
                    } else {
                        cc.log("Missing StripByteCounts!");
                        if (1 === numStripOffsetValues) {
                            var stripByteCountValues = [ Math.ceil(imageWidth * imageLength * bitsPerPixel / 8) ];
                        } else {
                            throw Error("Cannot recover from missing StripByteCounts");
                        }
                    }
                    for (var i = 0; i < numStripOffsetValues; i++) {
                        var stripOffset = stripOffsetValues[i];
                        strips[i] = [];
                        var stripByteCount = stripByteCountValues[i];
                        for (var byteOffset = 0, bitOffset = 0, jIncrement = 1, getHeader = true, pixel = [], numBytes = 0, sample = 0, currentSample = 0; byteOffset < stripByteCount; byteOffset += jIncrement) {
                            switch (compression) {
                              case 1:
                                for (var m = 0, pixel = []; m < samplesPerPixel; m++) {
                                    if (sampleProperties[m].hasBytesPerSample) {
                                        var sampleOffset = sampleProperties[m].bytesPerSample * m;
                                        pixel.push(this.getBytes(sampleProperties[m].bytesPerSample, stripOffset + byteOffset + sampleOffset));
                                    } else {
                                        var sampleInfo = this.getBits(sampleProperties[m].bitsPerSample, stripOffset + byteOffset, bitOffset);
                                        pixel.push(sampleInfo.bits);
                                        byteOffset = sampleInfo.byteOffset - stripOffset;
                                        bitOffset = sampleInfo.bitOffset;
                                        throw RangeError("Cannot handle sub-byte bits per sample");
                                    }
                                }
                                strips[i].push(pixel);
                                if (hasBytesPerPixel) {
                                    jIncrement = bytesPerPixel;
                                } else {
                                    jIncrement = 0;
                                    throw RangeError("Cannot handle sub-byte bits per pixel");
                                }
                                break;

                              case 2:
                                break;

                              case 3:
                                break;

                              case 4:
                                break;

                              case 5:
                                break;

                              case 6:
                                break;

                              case 7:
                                break;

                              case 32773:
                                if (getHeader) {
                                    getHeader = false;
                                    var blockLength = 1;
                                    var iterations = 1;
                                    var header = this.getInt8(stripOffset + byteOffset);
                                    if (header >= 0 && header <= 127) {
                                        blockLength = header + 1;
                                    } else {
                                        if (header >= -127 && header <= -1) {
                                            iterations = -header + 1;
                                        } else {
                                            getHeader = true;
                                        }
                                    }
                                } else {
                                    var currentByte = this.getUint8(stripOffset + byteOffset);
                                    for (var m = 0; m < iterations; m++) {
                                        if (sampleProperties[sample].hasBytesPerSample) {
                                            currentSample = currentSample << 8 * numBytes | currentByte;
                                            numBytes++;
                                            if (numBytes === sampleProperties[sample].bytesPerSample) {
                                                pixel.push(currentSample);
                                                currentSample = numBytes = 0;
                                                sample++;
                                            }
                                        } else {
                                            throw RangeError("Cannot handle sub-byte bits per sample");
                                        }
                                        if (sample === samplesPerPixel) {
                                            strips[i].push(pixel);
                                            pixel = [];
                                            sample = 0;
                                        }
                                    }
                                    blockLength--;
                                    if (0 === blockLength) {
                                        getHeader = true;
                                    }
                                }
                                jIncrement = 1;
                            }
                        }
                    }
                    if (canvas.getContext) {
                        var ctx = this.canvas.getContext("2d");
                        ctx.fillStyle = "rgba(255, 255, 255, 0)";
                        var rowsPerStrip = fileDirectory["RowsPerStrip"] ? fileDirectory["RowsPerStrip"].values[0] : imageLength;
                        var numStrips = strips.length;
                        var imageLengthModRowsPerStrip = imageLength % rowsPerStrip;
                        var rowsInLastStrip = 0 === imageLengthModRowsPerStrip ? rowsPerStrip : imageLengthModRowsPerStrip;
                        var numRowsInStrip = rowsPerStrip;
                        var numRowsInPreviousStrip = 0;
                        var photometricInterpretation = fileDirectory["PhotometricInterpretation"].values[0];
                        var extraSamplesValues = [];
                        var numExtraSamples = 0;
                        if (fileDirectory["ExtraSamples"]) {
                            extraSamplesValues = fileDirectory["ExtraSamples"].values;
                            numExtraSamples = extraSamplesValues.length;
                        }
                        if (fileDirectory["ColorMap"]) {
                            var colorMapValues = fileDirectory["ColorMap"].values;
                            var colorMapSampleSize = Math.pow(2, sampleProperties[0].bitsPerSample);
                        }
                        for (var i = 0; i < numStrips; i++) {
                            if (i + 1 === numStrips) {
                                numRowsInStrip = rowsInLastStrip;
                            }
                            var numPixels = strips[i].length;
                            var yPadding = numRowsInPreviousStrip * i;
                            for (var y = 0, j = 0; y < numRowsInStrip, j < numPixels; y++) {
                                for (var x = 0; x < imageWidth; x++, j++) {
                                    var pixelSamples = strips[i][j];
                                    var red = 0;
                                    var green = 0;
                                    var blue = 0;
                                    var opacity = 1;
                                    if (numExtraSamples > 0) {
                                        for (var k = 0; k < numExtraSamples; k++) {
                                            if (1 === extraSamplesValues[k] || 2 === extraSamplesValues[k]) {
                                                opacity = pixelSamples[3 + k] / 256;
                                                break;
                                            }
                                        }
                                    }
                                    switch (photometricInterpretation) {
                                      case 0:
                                        if (sampleProperties[0].hasBytesPerSample) {
                                            var invertValue = Math.pow(16, 2 * sampleProperties[0].bytesPerSample);
                                        }
                                        pixelSamples.forEach(function(sample, index, samples) {
                                            samples[index] = invertValue - sample;
                                        });

                                      case 1:
                                        red = green = blue = this.clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);
                                        break;

                                      case 2:
                                        red = this.clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);
                                        green = this.clampColorSample(pixelSamples[1], sampleProperties[1].bitsPerSample);
                                        blue = this.clampColorSample(pixelSamples[2], sampleProperties[2].bitsPerSample);
                                        break;

                                      case 3:
                                        if (void 0 === colorMapValues) {
                                            throw Error("Palette image missing color map");
                                        }
                                        var colorMapIndex = pixelSamples[0];
                                        red = this.clampColorSample(colorMapValues[colorMapIndex], 16);
                                        green = this.clampColorSample(colorMapValues[colorMapSampleSize + colorMapIndex], 16);
                                        blue = this.clampColorSample(colorMapValues[2 * colorMapSampleSize + colorMapIndex], 16);
                                        break;

                                      default:
                                        throw RangeError("Unknown Photometric Interpretation:", photometricInterpretation);
                                    }
                                    ctx.fillStyle = "rgba(" + red + ", " + green + ", " + blue + ", " + opacity + ")";
                                    ctx.fillRect(x, yPadding + y, 1, 1);
                                }
                            }
                            numRowsInPreviousStrip = numRowsInStrip;
                        }
                    }
                    return this.canvas;
                },
                fieldTagNames: {
                    315: "Artist",
                    258: "BitsPerSample",
                    265: "CellLength",
                    264: "CellWidth",
                    320: "ColorMap",
                    259: "Compression",
                    33432: "Copyright",
                    306: "DateTime",
                    338: "ExtraSamples",
                    266: "FillOrder",
                    289: "FreeByteCounts",
                    288: "FreeOffsets",
                    291: "GrayResponseCurve",
                    290: "GrayResponseUnit",
                    316: "HostComputer",
                    270: "ImageDescription",
                    257: "ImageLength",
                    256: "ImageWidth",
                    271: "Make",
                    281: "MaxSampleValue",
                    280: "MinSampleValue",
                    272: "Model",
                    254: "NewSubfileType",
                    274: "Orientation",
                    262: "PhotometricInterpretation",
                    284: "PlanarConfiguration",
                    296: "ResolutionUnit",
                    278: "RowsPerStrip",
                    277: "SamplesPerPixel",
                    305: "Software",
                    279: "StripByteCounts",
                    273: "StripOffsets",
                    255: "SubfileType",
                    263: "Threshholding",
                    282: "XResolution",
                    283: "YResolution",
                    326: "BadFaxLines",
                    327: "CleanFaxData",
                    343: "ClipPath",
                    328: "ConsecutiveBadFaxLines",
                    433: "Decode",
                    434: "DefaultImageColor",
                    269: "DocumentName",
                    336: "DotRange",
                    321: "HalftoneHints",
                    346: "Indexed",
                    347: "JPEGTables",
                    285: "PageName",
                    297: "PageNumber",
                    317: "Predictor",
                    319: "PrimaryChromaticities",
                    532: "ReferenceBlackWhite",
                    339: "SampleFormat",
                    559: "StripRowCounts",
                    330: "SubIFDs",
                    292: "T4Options",
                    293: "T6Options",
                    325: "TileByteCounts",
                    323: "TileLength",
                    324: "TileOffsets",
                    322: "TileWidth",
                    301: "TransferFunction",
                    318: "WhitePoint",
                    344: "XClipPathUnits",
                    286: "XPosition",
                    529: "YCbCrCoefficients",
                    531: "YCbCrPositioning",
                    530: "YCbCrSubSampling",
                    345: "YClipPathUnits",
                    287: "YPosition",
                    37378: "ApertureValue",
                    40961: "ColorSpace",
                    36868: "DateTimeDigitized",
                    36867: "DateTimeOriginal",
                    34665: "Exif IFD",
                    36864: "ExifVersion",
                    33434: "ExposureTime",
                    41728: "FileSource",
                    37385: "Flash",
                    40960: "FlashpixVersion",
                    33437: "FNumber",
                    42016: "ImageUniqueID",
                    37384: "LightSource",
                    37500: "MakerNote",
                    37377: "ShutterSpeedValue",
                    37510: "UserComment",
                    33723: "IPTC",
                    34675: "ICC Profile",
                    700: "XMP",
                    42112: "GDAL_METADATA",
                    42113: "GDAL_NODATA",
                    34377: "Photoshop"
                },
                fieldTypeNames: {
                    1: "BYTE",
                    2: "ASCII",
                    3: "SHORT",
                    4: "LONG",
                    5: "RATIONAL",
                    6: "SBYTE",
                    7: "UNDEFINED",
                    8: "SSHORT",
                    9: "SLONG",
                    10: "SRATIONAL",
                    11: "FLOAT",
                    12: "DOUBLE"
                }
            };
            cc.Particle = function(pos, startPos, color, deltaColor, size, deltaSize, rotation, deltaRotation, timeToLive, atlasIndex, modeA, modeB) {
                this.pos = pos ? pos : cc.p(0, 0);
                this.startPos = startPos ? startPos : cc.p(0, 0);
                this.color = color ? color : {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 255
                };
                this.deltaColor = deltaColor ? deltaColor : {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 255
                };
                this.size = size || 0;
                this.deltaSize = deltaSize || 0;
                this.rotation = rotation || 0;
                this.deltaRotation = deltaRotation || 0;
                this.timeToLive = timeToLive || 0;
                this.atlasIndex = atlasIndex || 0;
                this.modeA = modeA ? modeA : new cc.Particle.ModeA();
                this.modeB = modeB ? modeB : new cc.Particle.ModeB();
                this.isChangeColor = false;
                this.drawPos = cc.p(0, 0);
            };
            cc.Particle.ModeA = function(dir, radialAccel, tangentialAccel) {
                this.dir = dir ? dir : cc.p(0, 0);
                this.radialAccel = radialAccel || 0;
                this.tangentialAccel = tangentialAccel || 0;
            };
            cc.Particle.ModeB = function(angle, degreesPerSecond, radius, deltaRadius) {
                this.angle = angle || 0;
                this.degreesPerSecond = degreesPerSecond || 0;
                this.radius = radius || 0;
                this.deltaRadius = deltaRadius || 0;
            };
            cc.Particle.TemporaryPoints = [ cc.p(), cc.p(), cc.p(), cc.p() ];
            _ccsg.ParticleSystem = _ccsg.Node.extend({
                _className: "ParticleSystem",
                _plistFile: "",
                _elapsed: 0,
                _dontTint: false,
                modeA: null,
                modeB: null,
                _pointZeroForParticle: cc.p(0, 0),
                _particles: null,
                _emitCounter: 0,
                _particleIdx: 0,
                _batchNode: null,
                atlasIndex: 0,
                _transformSystemDirty: false,
                _allocatedParticles: 0,
                _isActive: false,
                particleCount: 0,
                duration: 0,
                _sourcePosition: null,
                _posVar: null,
                life: 0,
                lifeVar: 0,
                angle: 0,
                angleVar: 0,
                startSize: 0,
                startSizeVar: 0,
                endSize: 0,
                endSizeVar: 0,
                _startColor: null,
                _startColorVar: null,
                _endColor: null,
                _endColorVar: null,
                startSpin: 0,
                startSpinVar: 0,
                endSpin: 0,
                endSpinVar: 0,
                emissionRate: 0,
                _totalParticles: 0,
                _texture: null,
                _blendFunc: null,
                _opacityModifyRGB: false,
                positionType: null,
                autoRemoveOnFinish: false,
                emitterMode: 0,
                _textureLoaded: null,
                ctor: function(plistFile) {
                    _ccsg.Node.prototype.ctor.call(this);
                    this.emitterMode = _ccsg.ParticleSystem.Mode.GRAVITY;
                    this.modeA = new _ccsg.ParticleSystem.ModeA();
                    this.modeB = new _ccsg.ParticleSystem.ModeB();
                    this._blendFunc = {
                        src: cc.BLEND_SRC,
                        dst: cc.BLEND_DST
                    };
                    this._particles = [];
                    this._sourcePosition = cc.p(0, 0);
                    this._posVar = cc.p(0, 0);
                    this._startColor = cc.color(255, 255, 255, 255);
                    this._startColorVar = cc.color(255, 255, 255, 255);
                    this._endColor = cc.color(255, 255, 255, 255);
                    this._endColorVar = cc.color(255, 255, 255, 255);
                    this._plistFile = "";
                    this._elapsed = 0;
                    this._dontTint = false;
                    this._pointZeroForParticle = cc.p(0, 0);
                    this._emitCounter = 0;
                    this._particleIdx = 0;
                    this._batchNode = null;
                    this.atlasIndex = 0;
                    this._transformSystemDirty = false;
                    this._allocatedParticles = 0;
                    this._isActive = false;
                    this.particleCount = 0;
                    this.duration = 0;
                    this.life = 0;
                    this.lifeVar = 0;
                    this.angle = 0;
                    this.angleVar = 0;
                    this.startSize = 0;
                    this.startSizeVar = 0;
                    this.endSize = 0;
                    this.endSizeVar = 0;
                    this.startSpin = 0;
                    this.startSpinVar = 0;
                    this.endSpin = 0;
                    this.endSpinVar = 0;
                    this.emissionRate = 0;
                    this._totalParticles = 0;
                    this._texture = null;
                    this._opacityModifyRGB = false;
                    this.positionType = _ccsg.ParticleSystem.Type.FREE;
                    this.autoRemoveOnFinish = false;
                    this._textureLoaded = true;
                    if (!plistFile || cc.js.isNumber(plistFile)) {
                        var ton = plistFile || 100;
                        this.setDrawMode(_ccsg.ParticleSystem.TEXTURE_MODE);
                        this.initWithTotalParticles(ton);
                    } else {
                        if (cc.js.isString(plistFile)) {
                            this.initWithFile(plistFile);
                        } else {
                            if (cc.js.isObject(plistFile)) {
                                this.initWithDictionary(plistFile, "");
                            }
                        }
                    }
                },
                _createRenderCmd: function() {
                    if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                        return new _ccsg.ParticleSystem.CanvasRenderCmd(this);
                    } else {
                        return new _ccsg.ParticleSystem.WebGLRenderCmd(this);
                    }
                },
                ignoreColor: function(ignore) {
                    this._dontTint = ignore;
                },
                initTexCoordsWithRect: function(pointRect) {
                    this._renderCmd.initTexCoordsWithRect(pointRect);
                },
                getBatchNode: function() {
                    return this._batchNode;
                },
                setBatchNode: function(batchNode) {
                    this._renderCmd.setBatchNode(batchNode);
                },
                getAtlasIndex: function() {
                    return this.atlasIndex;
                },
                setAtlasIndex: function(atlasIndex) {
                    this.atlasIndex = atlasIndex;
                },
                getDrawMode: function() {
                    return this._renderCmd.getDrawMode();
                },
                setDrawMode: function(drawMode) {
                    this._renderCmd.setDrawMode(drawMode);
                },
                getShapeType: function() {
                    return this._renderCmd.getShapeType();
                },
                setShapeType: function(shapeType) {
                    this._renderCmd.setShapeType(shapeType);
                },
                isActive: function() {
                    return this._isActive;
                },
                getParticleCount: function() {
                    return this.particleCount;
                },
                setParticleCount: function(particleCount) {
                    this.particleCount = particleCount;
                },
                getDuration: function() {
                    return this.duration;
                },
                setDuration: function(duration) {
                    this.duration = duration;
                },
                getSourcePosition: function() {
                    return {
                        x: this._sourcePosition.x,
                        y: this._sourcePosition.y
                    };
                },
                setSourcePosition: function(sourcePosition) {
                    this._sourcePosition = sourcePosition;
                },
                getPosVar: function() {
                    return {
                        x: this._posVar.x,
                        y: this._posVar.y
                    };
                },
                setPosVar: function(posVar) {
                    this._posVar = posVar;
                },
                getLife: function() {
                    return this.life;
                },
                setLife: function(life) {
                    this.life = life;
                },
                getLifeVar: function() {
                    return this.lifeVar;
                },
                setLifeVar: function(lifeVar) {
                    this.lifeVar = lifeVar;
                },
                getAngle: function() {
                    return this.angle;
                },
                setAngle: function(angle) {
                    this.angle = angle;
                },
                getAngleVar: function() {
                    return this.angleVar;
                },
                setAngleVar: function(angleVar) {
                    this.angleVar = angleVar;
                },
                getGravity: function() {
                    var locGravity = this.modeA.gravity;
                    return cc.p(locGravity.x, locGravity.y);
                },
                setGravity: function(gravity) {
                    this.modeA.gravity = gravity;
                },
                getSpeed: function() {
                    return this.modeA.speed;
                },
                setSpeed: function(speed) {
                    this.modeA.speed = speed;
                },
                getSpeedVar: function() {
                    return this.modeA.speedVar;
                },
                setSpeedVar: function(speedVar) {
                    this.modeA.speedVar = speedVar;
                },
                getTangentialAccel: function() {
                    return this.modeA.tangentialAccel;
                },
                setTangentialAccel: function(tangentialAccel) {
                    this.modeA.tangentialAccel = tangentialAccel;
                },
                getTangentialAccelVar: function() {
                    return this.modeA.tangentialAccelVar;
                },
                setTangentialAccelVar: function(tangentialAccelVar) {
                    this.modeA.tangentialAccelVar = tangentialAccelVar;
                },
                getRadialAccel: function() {
                    return this.modeA.radialAccel;
                },
                setRadialAccel: function(radialAccel) {
                    this.modeA.radialAccel = radialAccel;
                },
                getRadialAccelVar: function() {
                    return this.modeA.radialAccelVar;
                },
                setRadialAccelVar: function(radialAccelVar) {
                    this.modeA.radialAccelVar = radialAccelVar;
                },
                getRotationIsDir: function() {
                    return this.modeA.rotationIsDir;
                },
                setRotationIsDir: function(t) {
                    this.modeA.rotationIsDir = t;
                },
                getStartRadius: function() {
                    return this.modeB.startRadius;
                },
                setStartRadius: function(startRadius) {
                    this.modeB.startRadius = startRadius;
                },
                getStartRadiusVar: function() {
                    return this.modeB.startRadiusVar;
                },
                setStartRadiusVar: function(startRadiusVar) {
                    this.modeB.startRadiusVar = startRadiusVar;
                },
                getEndRadius: function() {
                    return this.modeB.endRadius;
                },
                setEndRadius: function(endRadius) {
                    this.modeB.endRadius = endRadius;
                },
                getEndRadiusVar: function() {
                    return this.modeB.endRadiusVar;
                },
                setEndRadiusVar: function(endRadiusVar) {
                    this.modeB.endRadiusVar = endRadiusVar;
                },
                getRotatePerSecond: function() {
                    return this.modeB.rotatePerSecond;
                },
                setRotatePerSecond: function(degrees) {
                    this.modeB.rotatePerSecond = degrees;
                },
                getRotatePerSecondVar: function() {
                    return this.modeB.rotatePerSecondVar;
                },
                setRotatePerSecondVar: function(degrees) {
                    this.modeB.rotatePerSecondVar = degrees;
                },
                setScale: function(scale, scaleY) {
                    this._transformSystemDirty = true;
                    _ccsg.Node.prototype.setScale.call(this, scale, scaleY);
                },
                setRotation: function(newRotation) {
                    this._transformSystemDirty = true;
                    _ccsg.Node.prototype.setRotation.call(this, newRotation);
                },
                setScaleX: function(newScaleX) {
                    this._transformSystemDirty = true;
                    _ccsg.Node.prototype.setScaleX.call(this, newScaleX);
                },
                setScaleY: function(newScaleY) {
                    this._transformSystemDirty = true;
                    _ccsg.Node.prototype.setScaleY.call(this, newScaleY);
                },
                getStartSize: function() {
                    return this.startSize;
                },
                setStartSize: function(startSize) {
                    this.startSize = startSize;
                },
                getStartSizeVar: function() {
                    return this.startSizeVar;
                },
                setStartSizeVar: function(startSizeVar) {
                    this.startSizeVar = startSizeVar;
                },
                getEndSize: function() {
                    return this.endSize;
                },
                setEndSize: function(endSize) {
                    this.endSize = endSize;
                },
                getEndSizeVar: function() {
                    return this.endSizeVar;
                },
                setEndSizeVar: function(endSizeVar) {
                    this.endSizeVar = endSizeVar;
                },
                getStartColor: function() {
                    return cc.color(this._startColor.r, this._startColor.g, this._startColor.b, this._startColor.a);
                },
                setStartColor: function(startColor) {
                    this._startColor = cc.color(startColor);
                },
                getStartColorVar: function() {
                    return cc.color(this._startColorVar.r, this._startColorVar.g, this._startColorVar.b, this._startColorVar.a);
                },
                setStartColorVar: function(startColorVar) {
                    this._startColorVar = cc.color(startColorVar);
                },
                getEndColor: function() {
                    return cc.color(this._endColor.r, this._endColor.g, this._endColor.b, this._endColor.a);
                },
                setEndColor: function(endColor) {
                    this._endColor = cc.color(endColor);
                },
                getEndColorVar: function() {
                    return cc.color(this._endColorVar.r, this._endColorVar.g, this._endColorVar.b, this._endColorVar.a);
                },
                setEndColorVar: function(endColorVar) {
                    this._endColorVar = cc.color(endColorVar);
                },
                getStartSpin: function() {
                    return this.startSpin;
                },
                setStartSpin: function(startSpin) {
                    this.startSpin = startSpin;
                },
                getStartSpinVar: function() {
                    return this.startSpinVar;
                },
                setStartSpinVar: function(startSpinVar) {
                    this.startSpinVar = startSpinVar;
                },
                getEndSpin: function() {
                    return this.endSpin;
                },
                setEndSpin: function(endSpin) {
                    this.endSpin = endSpin;
                },
                getEndSpinVar: function() {
                    return this.endSpinVar;
                },
                setEndSpinVar: function(endSpinVar) {
                    this.endSpinVar = endSpinVar;
                },
                getEmissionRate: function() {
                    return this.emissionRate;
                },
                setEmissionRate: function(emissionRate) {
                    this.emissionRate = emissionRate;
                },
                getTotalParticles: function() {
                    return this._totalParticles;
                },
                setTotalParticles: function(tp) {
                    this._renderCmd.setTotalParticles(tp);
                },
                getTexture: function() {
                    return this._texture;
                },
                setTexture: function(texture) {
                    if (!texture) {
                        return;
                    }
                    if (texture.isLoaded()) {
                        this.setTextureWithRect(texture, cc.rect(0, 0, texture.width, texture.height));
                    } else {
                        this._textureLoaded = false;
                        texture.once("load", function(event) {
                            this._textureLoaded = true;
                            this.setTextureWithRect(texture, cc.rect(0, 0, texture.width, texture.height));
                        }, this);
                    }
                },
                getBlendFunc: function() {
                    return this._blendFunc;
                },
                setBlendFunc: function(src, dst) {
                    if (void 0 === dst) {
                        if (this._blendFunc !== src) {
                            this._blendFunc = src;
                            this._updateBlendFunc();
                        }
                    } else {
                        if (this._blendFunc.src !== src || this._blendFunc.dst !== dst) {
                            this._blendFunc = {
                                src: src,
                                dst: dst
                            };
                            this._updateBlendFunc();
                        }
                    }
                },
                isOpacityModifyRGB: function() {
                    return this._opacityModifyRGB;
                },
                setOpacityModifyRGB: function(newValue) {
                    this._opacityModifyRGB = newValue;
                },
                isBlendAdditive: function() {
                    return this._blendFunc.src === cc.SRC_ALPHA && this._blendFunc.dst === cc.ONE || this._blendFunc.src === cc.ONE && this._blendFunc.dst === cc.ONE;
                },
                setBlendAdditive: function(isBlendAdditive) {
                    var locBlendFunc = this._blendFunc;
                    if (isBlendAdditive) {
                        locBlendFunc.src = cc.SRC_ALPHA;
                        locBlendFunc.dst = cc.ONE;
                    } else {
                        this._renderCmd._setBlendAdditive();
                    }
                },
                getPositionType: function() {
                    return this.positionType;
                },
                setPositionType: function(positionType) {
                    this.positionType = positionType;
                },
                isAutoRemoveOnFinish: function() {
                    return this.autoRemoveOnFinish;
                },
                setAutoRemoveOnFinish: function(isAutoRemoveOnFinish) {
                    this.autoRemoveOnFinish = isAutoRemoveOnFinish;
                },
                getEmitterMode: function() {
                    return this.emitterMode;
                },
                setEmitterMode: function(emitterMode) {
                    this.emitterMode = emitterMode;
                },
                init: function() {
                    return this.initWithTotalParticles(150);
                },
                initWithFile: function(plistFile) {
                    this._plistFile = plistFile;
                    var dict = cc.loader.getRes(plistFile);
                    if (!dict) {
                        cc.log("_ccsg.ParticleSystem.initWithFile(): Particles: file not found");
                        return false;
                    }
                    return this.initWithDictionary(dict, "");
                },
                getBoundingBoxToWorld: function() {
                    return cc.rect(0, 0, cc._canvas.width, cc._canvas.height);
                },
                initWithDictionary: function(dictionary, dirname) {
                    var ret = false;
                    var buffer = null;
                    var image = null;
                    var locValueForKey = this._valueForKey;
                    var maxParticles = parseInt(locValueForKey("maxParticles", dictionary));
                    if (this.initWithTotalParticles(maxParticles)) {
                        this.angle = parseFloat(locValueForKey("angle", dictionary));
                        this.angleVar = parseFloat(locValueForKey("angleVariance", dictionary));
                        this.duration = parseFloat(locValueForKey("duration", dictionary));
                        this._blendFunc.src = parseInt(locValueForKey("blendFuncSource", dictionary));
                        this._blendFunc.dst = parseInt(locValueForKey("blendFuncDestination", dictionary));
                        var locStartColor = this._startColor;
                        locStartColor.r = 255 * parseFloat(locValueForKey("startColorRed", dictionary));
                        locStartColor.g = 255 * parseFloat(locValueForKey("startColorGreen", dictionary));
                        locStartColor.b = 255 * parseFloat(locValueForKey("startColorBlue", dictionary));
                        locStartColor.a = 255 * parseFloat(locValueForKey("startColorAlpha", dictionary));
                        var locStartColorVar = this._startColorVar;
                        locStartColorVar.r = 255 * parseFloat(locValueForKey("startColorVarianceRed", dictionary));
                        locStartColorVar.g = 255 * parseFloat(locValueForKey("startColorVarianceGreen", dictionary));
                        locStartColorVar.b = 255 * parseFloat(locValueForKey("startColorVarianceBlue", dictionary));
                        locStartColorVar.a = 255 * parseFloat(locValueForKey("startColorVarianceAlpha", dictionary));
                        var locEndColor = this._endColor;
                        locEndColor.r = 255 * parseFloat(locValueForKey("finishColorRed", dictionary));
                        locEndColor.g = 255 * parseFloat(locValueForKey("finishColorGreen", dictionary));
                        locEndColor.b = 255 * parseFloat(locValueForKey("finishColorBlue", dictionary));
                        locEndColor.a = 255 * parseFloat(locValueForKey("finishColorAlpha", dictionary));
                        var locEndColorVar = this._endColorVar;
                        locEndColorVar.r = 255 * parseFloat(locValueForKey("finishColorVarianceRed", dictionary));
                        locEndColorVar.g = 255 * parseFloat(locValueForKey("finishColorVarianceGreen", dictionary));
                        locEndColorVar.b = 255 * parseFloat(locValueForKey("finishColorVarianceBlue", dictionary));
                        locEndColorVar.a = 255 * parseFloat(locValueForKey("finishColorVarianceAlpha", dictionary));
                        this.startSize = parseFloat(locValueForKey("startParticleSize", dictionary));
                        this.startSizeVar = parseFloat(locValueForKey("startParticleSizeVariance", dictionary));
                        this.endSize = parseFloat(locValueForKey("finishParticleSize", dictionary));
                        this.endSizeVar = parseFloat(locValueForKey("finishParticleSizeVariance", dictionary));
                        this.setPosition(parseFloat(locValueForKey("sourcePositionx", dictionary)), parseFloat(locValueForKey("sourcePositiony", dictionary)));
                        this._posVar.x = parseFloat(locValueForKey("sourcePositionVariancex", dictionary));
                        this._posVar.y = parseFloat(locValueForKey("sourcePositionVariancey", dictionary));
                        this.startSpin = parseFloat(locValueForKey("rotationStart", dictionary));
                        this.startSpinVar = parseFloat(locValueForKey("rotationStartVariance", dictionary));
                        this.endSpin = parseFloat(locValueForKey("rotationEnd", dictionary));
                        this.endSpinVar = parseFloat(locValueForKey("rotationEndVariance", dictionary));
                        this.emitterMode = parseInt(locValueForKey("emitterType", dictionary));
                        if (this.emitterMode === _ccsg.ParticleSystem.Mode.GRAVITY) {
                            var locModeA = this.modeA;
                            locModeA.gravity.x = parseFloat(locValueForKey("gravityx", dictionary));
                            locModeA.gravity.y = parseFloat(locValueForKey("gravityy", dictionary));
                            locModeA.speed = parseFloat(locValueForKey("speed", dictionary));
                            locModeA.speedVar = parseFloat(locValueForKey("speedVariance", dictionary));
                            var pszTmp = locValueForKey("radialAcceleration", dictionary);
                            locModeA.radialAccel = pszTmp ? parseFloat(pszTmp) : 0;
                            pszTmp = locValueForKey("radialAccelVariance", dictionary);
                            locModeA.radialAccelVar = pszTmp ? parseFloat(pszTmp) : 0;
                            pszTmp = locValueForKey("tangentialAcceleration", dictionary);
                            locModeA.tangentialAccel = pszTmp ? parseFloat(pszTmp) : 0;
                            pszTmp = locValueForKey("tangentialAccelVariance", dictionary);
                            locModeA.tangentialAccelVar = pszTmp ? parseFloat(pszTmp) : 0;
                            var locRotationIsDir = locValueForKey("rotationIsDir", dictionary).toLowerCase();
                            locModeA.rotationIsDir = null != locRotationIsDir && ("true" === locRotationIsDir || "1" === locRotationIsDir);
                        } else {
                            if (this.emitterMode === _ccsg.ParticleSystem.Mode.RADIUS) {
                                var locModeB = this.modeB;
                                locModeB.startRadius = parseFloat(locValueForKey("maxRadius", dictionary));
                                locModeB.startRadiusVar = parseFloat(locValueForKey("maxRadiusVariance", dictionary));
                                locModeB.endRadius = parseFloat(locValueForKey("minRadius", dictionary));
                                locModeB.endRadiusVar = 0;
                                locModeB.rotatePerSecond = parseFloat(locValueForKey("rotatePerSecond", dictionary));
                                locModeB.rotatePerSecondVar = parseFloat(locValueForKey("rotatePerSecondVariance", dictionary));
                            } else {
                                cc.log("_ccsg.ParticleSystem.initWithDictionary(): Invalid emitterType in config file");
                                return false;
                            }
                        }
                        this.life = parseFloat(locValueForKey("particleLifespan", dictionary));
                        this.lifeVar = parseFloat(locValueForKey("particleLifespanVariance", dictionary));
                        this.emissionRate = this._totalParticles / this.life;
                        if (!this._batchNode) {
                            this._opacityModifyRGB = false;
                            var textureName = locValueForKey("textureFileName", dictionary);
                            var imgPath = cc.path.changeBasename(this._plistFile, textureName);
                            var tex = cc.textureCache.getTextureForKey(imgPath);
                            if (tex) {
                                this.setTexture(tex);
                            } else {
                                var textureData = locValueForKey("textureImageData", dictionary);
                                if (!textureData || 0 === textureData.length) {
                                    tex = cc.textureCache.addImage(imgPath);
                                    if (!tex) {
                                        return false;
                                    }
                                    this.setTexture(tex);
                                } else {
                                    buffer = cc.unzipBase64AsArray(textureData, 1);
                                    if (!buffer) {
                                        cc.log("_ccsg.ParticleSystem: error decoding or ungzipping textureImageData");
                                        return false;
                                    }
                                    var imageFormat = cc.getImageFormatByData(buffer);
                                    if (imageFormat !== cc.FMT_TIFF && imageFormat !== cc.FMT_PNG) {
                                        cc.log("_ccsg.ParticleSystem: unknown image format with Data");
                                        return false;
                                    }
                                    var canvasObj = document.createElement("canvas");
                                    if (imageFormat === cc.FMT_PNG) {
                                        var myPngObj = new cc.PNGReader(buffer);
                                        myPngObj.render(canvasObj);
                                    } else {
                                        var myTIFFObj = cc.tiffReader;
                                        myTIFFObj.parseTIFF(buffer, canvasObj);
                                    }
                                    cc.textureCache.cacheImage(imgPath, canvasObj);
                                    var addTexture = cc.textureCache.getTextureForKey(imgPath);
                                    if (!addTexture) {
                                        cc.log("_ccsg.ParticleSystem.initWithDictionary() : error loading the texture");
                                    }
                                    this.setTexture(addTexture);
                                }
                            }
                        }
                        ret = true;
                    }
                    return ret;
                },
                initWithTotalParticles: function(numberOfParticles) {
                    this._totalParticles = numberOfParticles;
                    var i, locParticles = this._particles;
                    locParticles.length = 0;
                    for (i = 0; i < numberOfParticles; i++) {
                        locParticles[i] = new cc.Particle();
                    }
                    if (!locParticles) {
                        cc.log("Particle system: not enough memory");
                        return false;
                    }
                    this._allocatedParticles = numberOfParticles;
                    if (this._batchNode) {
                        for (i = 0; i < this._totalParticles; i++) {
                            locParticles[i].atlasIndex = i;
                        }
                    }
                    this._isActive = true;
                    this._blendFunc.src = cc.BLEND_SRC;
                    this._blendFunc.dst = cc.BLEND_DST;
                    this.positionType = _ccsg.ParticleSystem.Type.FREE;
                    this.emitterMode = _ccsg.ParticleSystem.Mode.GRAVITY;
                    this.autoRemoveOnFinish = false;
                    this._transformSystemDirty = false;
                    this.scheduleUpdateWithPriority(1);
                    this._renderCmd._initWithTotalParticles(numberOfParticles);
                    return true;
                },
                destroyParticleSystem: function() {
                    this.unscheduleUpdate();
                },
                addParticle: function() {
                    if (this.isFull()) {
                        return false;
                    }
                    var particle = this._renderCmd.addParticle();
                    this.initParticle(particle);
                    ++this.particleCount;
                    return true;
                },
                initParticle: function(particle) {
                    var locRandomMinus11 = cc.randomMinus1To1;
                    particle.timeToLive = this.life + this.lifeVar * locRandomMinus11();
                    particle.timeToLive = Math.max(0, particle.timeToLive);
                    particle.pos.x = this._sourcePosition.x + this._posVar.x * locRandomMinus11();
                    particle.pos.y = this._sourcePosition.y + this._posVar.y * locRandomMinus11();
                    var start, end;
                    var locStartColor = this._startColor, locStartColorVar = this._startColorVar;
                    var locEndColor = this._endColor, locEndColorVar = this._endColorVar;
                    start = {
                        r: cc.clampf(locStartColor.r + locStartColorVar.r * locRandomMinus11(), 0, 255),
                        g: cc.clampf(locStartColor.g + locStartColorVar.g * locRandomMinus11(), 0, 255),
                        b: cc.clampf(locStartColor.b + locStartColorVar.b * locRandomMinus11(), 0, 255),
                        a: cc.clampf(locStartColor.a + locStartColorVar.a * locRandomMinus11(), 0, 255)
                    };
                    end = {
                        r: cc.clampf(locEndColor.r + locEndColorVar.r * locRandomMinus11(), 0, 255),
                        g: cc.clampf(locEndColor.g + locEndColorVar.g * locRandomMinus11(), 0, 255),
                        b: cc.clampf(locEndColor.b + locEndColorVar.b * locRandomMinus11(), 0, 255),
                        a: cc.clampf(locEndColor.a + locEndColorVar.a * locRandomMinus11(), 0, 255)
                    };
                    particle.color = start;
                    var locParticleDeltaColor = particle.deltaColor, locParticleTimeToLive = particle.timeToLive;
                    locParticleDeltaColor.r = (end.r - start.r) / locParticleTimeToLive;
                    locParticleDeltaColor.g = (end.g - start.g) / locParticleTimeToLive;
                    locParticleDeltaColor.b = (end.b - start.b) / locParticleTimeToLive;
                    locParticleDeltaColor.a = (end.a - start.a) / locParticleTimeToLive;
                    var startS = this.startSize + this.startSizeVar * locRandomMinus11();
                    startS = Math.max(0, startS);
                    particle.size = startS;
                    if (this.endSize === _ccsg.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE) {
                        particle.deltaSize = 0;
                    } else {
                        var endS = this.endSize + this.endSizeVar * locRandomMinus11();
                        endS = Math.max(0, endS);
                        particle.deltaSize = (endS - startS) / locParticleTimeToLive;
                    }
                    var startA = this.startSpin + this.startSpinVar * locRandomMinus11();
                    var endA = this.endSpin + this.endSpinVar * locRandomMinus11();
                    particle.rotation = startA;
                    particle.deltaRotation = (endA - startA) / locParticleTimeToLive;
                    if (this.positionType === _ccsg.ParticleSystem.Type.FREE) {
                        particle.startPos = this.convertToWorldSpace(this._pointZeroForParticle);
                    } else {
                        if (this.positionType === _ccsg.ParticleSystem.Type.RELATIVE) {
                            particle.startPos.x = this._position.x;
                            particle.startPos.y = this._position.y;
                        }
                    }
                    var a = cc.degreesToRadians(this.angle + this.angleVar * locRandomMinus11());
                    if (this.emitterMode === _ccsg.ParticleSystem.Mode.GRAVITY) {
                        var locModeA = this.modeA, locParticleModeA = particle.modeA;
                        var s = locModeA.speed + locModeA.speedVar * locRandomMinus11();
                        locParticleModeA.dir.x = Math.cos(a);
                        locParticleModeA.dir.y = Math.sin(a);
                        cc.pMultIn(locParticleModeA.dir, s);
                        locParticleModeA.radialAccel = locModeA.radialAccel + locModeA.radialAccelVar * locRandomMinus11();
                        locParticleModeA.tangentialAccel = locModeA.tangentialAccel + locModeA.tangentialAccelVar * locRandomMinus11();
                        if (locModeA.rotationIsDir) {
                            particle.rotation = -cc.radiansToDegrees(cc.pToAngle(locParticleModeA.dir));
                        }
                    } else {
                        var locModeB = this.modeB, locParitlceModeB = particle.modeB;
                        var startRadius = locModeB.startRadius + locModeB.startRadiusVar * locRandomMinus11();
                        var endRadius = locModeB.endRadius + locModeB.endRadiusVar * locRandomMinus11();
                        locParitlceModeB.radius = startRadius;
                        locParitlceModeB.deltaRadius = locModeB.endRadius === _ccsg.ParticleSystem.START_RADIUS_EQUAL_TO_END_RADIUS ? 0 : (endRadius - startRadius) / locParticleTimeToLive;
                        locParitlceModeB.angle = a;
                        locParitlceModeB.degreesPerSecond = cc.degreesToRadians(locModeB.rotatePerSecond + locModeB.rotatePerSecondVar * locRandomMinus11());
                    }
                },
                stopSystem: function() {
                    this._isActive = false;
                    this._elapsed = this.duration;
                    this._emitCounter = 0;
                },
                resetSystem: function() {
                    this._isActive = true;
                    this._elapsed = 0;
                    var locParticles = this._particles;
                    for (this._particleIdx = 0; this._particleIdx < this.particleCount; ++this._particleIdx) {
                        locParticles[this._particleIdx].timeToLive = 0;
                    }
                },
                isFull: function() {
                    return this.particleCount >= this._totalParticles;
                },
                updateQuadWithParticle: function(particle, newPosition) {
                    this._renderCmd.updateQuadWithParticle(particle, newPosition);
                },
                postStep: function() {
                    this._renderCmd.postStep();
                },
                update: function(dt) {
                    if (this._isActive && this.emissionRate) {
                        var rate = 1 / this.emissionRate;
                        if (this.particleCount < this._totalParticles) {
                            this._emitCounter += dt;
                        }
                        while (this.particleCount < this._totalParticles && this._emitCounter > rate) {
                            this.addParticle();
                            this._emitCounter -= rate;
                        }
                        this._elapsed += dt;
                        if (-1 !== this.duration && this.duration < this._elapsed) {
                            this.stopSystem();
                        }
                    }
                    this._particleIdx = 0;
                    var currentPosition = cc.Particle.TemporaryPoints[0];
                    if (this.positionType === _ccsg.ParticleSystem.Type.FREE) {
                        cc.pIn(currentPosition, this.convertToWorldSpace(this._pointZeroForParticle));
                    } else {
                        if (this.positionType === _ccsg.ParticleSystem.Type.RELATIVE) {
                            currentPosition.x = this._position.x;
                            currentPosition.y = this._position.y;
                        }
                    }
                    if (this._visible) {
                        var tpa = cc.Particle.TemporaryPoints[1], tpb = cc.Particle.TemporaryPoints[2], tpc = cc.Particle.TemporaryPoints[3];
                        var locParticles = this._particles;
                        while (this._particleIdx < this.particleCount) {
                            cc.pZeroIn(tpa);
                            cc.pZeroIn(tpb);
                            cc.pZeroIn(tpc);
                            var selParticle = locParticles[this._particleIdx];
                            selParticle.timeToLive -= dt;
                            if (selParticle.timeToLive > 0) {
                                if (this.emitterMode === _ccsg.ParticleSystem.Mode.GRAVITY) {
                                    var tmp = tpc, radial = tpa, tangential = tpb;
                                    if (selParticle.pos.x || selParticle.pos.y) {
                                        cc.pIn(radial, selParticle.pos);
                                        cc.pNormalizeIn(radial);
                                    } else {
                                        cc.pZeroIn(radial);
                                    }
                                    cc.pIn(tangential, radial);
                                    cc.pMultIn(radial, selParticle.modeA.radialAccel);
                                    var newy = tangential.x;
                                    tangential.x = -tangential.y;
                                    tangential.y = newy;
                                    cc.pMultIn(tangential, selParticle.modeA.tangentialAccel);
                                    cc.pIn(tmp, radial);
                                    cc.pAddIn(tmp, tangential);
                                    cc.pAddIn(tmp, this.modeA.gravity);
                                    cc.pMultIn(tmp, dt);
                                    cc.pAddIn(selParticle.modeA.dir, tmp);
                                    cc.pIn(tmp, selParticle.modeA.dir);
                                    cc.pMultIn(tmp, dt);
                                    cc.pAddIn(selParticle.pos, tmp);
                                } else {
                                    var selModeB = selParticle.modeB;
                                    selModeB.angle += selModeB.degreesPerSecond * dt;
                                    selModeB.radius += selModeB.deltaRadius * dt;
                                    selParticle.pos.x = -Math.cos(selModeB.angle) * selModeB.radius;
                                    selParticle.pos.y = -Math.sin(selModeB.angle) * selModeB.radius;
                                }
                                this._renderCmd._updateDeltaColor(selParticle, dt);
                                selParticle.size += selParticle.deltaSize * dt;
                                selParticle.size = Math.max(0, selParticle.size);
                                selParticle.rotation += selParticle.deltaRotation * dt;
                                var newPos = tpa;
                                if (this.positionType === _ccsg.ParticleSystem.Type.FREE || this.positionType === _ccsg.ParticleSystem.Type.RELATIVE) {
                                    var diff = tpb;
                                    cc.pIn(diff, currentPosition);
                                    cc.pSubIn(diff, selParticle.startPos);
                                    cc.pIn(newPos, selParticle.pos);
                                    cc.pSubIn(newPos, diff);
                                } else {
                                    cc.pIn(newPos, selParticle.pos);
                                }
                                if (this._batchNode) {
                                    newPos.x += this._position.x;
                                    newPos.y += this._position.y;
                                }
                                this._renderCmd.updateParticlePosition(selParticle, newPos);
                                ++this._particleIdx;
                            } else {
                                var currentIndex = selParticle.atlasIndex;
                                if (this._particleIdx !== this.particleCount - 1) {
                                    var deadParticle = locParticles[this._particleIdx];
                                    locParticles[this._particleIdx] = locParticles[this.particleCount - 1];
                                    locParticles[this.particleCount - 1] = deadParticle;
                                }
                                if (this._batchNode) {
                                    this._batchNode.disableParticle(this.atlasIndex + currentIndex);
                                    locParticles[this.particleCount - 1].atlasIndex = currentIndex;
                                }
                                --this.particleCount;
                                if (0 === this.particleCount && this.autoRemoveOnFinish) {
                                    this.unscheduleUpdate();
                                    this._parent.removeChild(this, true);
                                    return;
                                }
                            }
                        }
                        this._transformSystemDirty = false;
                    }
                    if (!this._batchNode) {
                        this.postStep();
                    }
                },
                updateWithNoTime: function() {
                    this.update(0);
                },
                _valueForKey: function(key, dict) {
                    if (dict) {
                        var pString = dict[key];
                        return null != pString ? pString : "";
                    }
                    return "";
                },
                _updateBlendFunc: function() {
                    if (this._batchNode) {
                        cc.log("Can't change blending functions when the particle is being batched");
                        return;
                    }
                    var locTexture = this._texture;
                    if (locTexture && locTexture instanceof cc.Texture2D) {
                        this._opacityModifyRGB = false;
                        var locBlendFunc = this._blendFunc;
                        if (locBlendFunc.src === cc.BLEND_SRC && locBlendFunc.dst === cc.BLEND_DST) {
                            if (locTexture.hasPremultipliedAlpha()) {
                                this._opacityModifyRGB = true;
                            } else {
                                locBlendFunc.src = cc.SRC_ALPHA;
                                locBlendFunc.dst = cc.ONE_MINUS_SRC_ALPHA;
                            }
                        }
                    }
                },
                clone: function() {
                    var retParticle = new _ccsg.ParticleSystem();
                    if (retParticle.initWithTotalParticles(this.getTotalParticles())) {
                        retParticle.setAngle(this.getAngle());
                        retParticle.setAngleVar(this.getAngleVar());
                        retParticle.setDuration(this.getDuration());
                        var blend = this.getBlendFunc();
                        retParticle.setBlendFunc(blend.src, blend.dst);
                        retParticle.setStartColor(this.getStartColor());
                        retParticle.setStartColorVar(this.getStartColorVar());
                        retParticle.setEndColor(this.getEndColor());
                        retParticle.setEndColorVar(this.getEndColorVar());
                        retParticle.setStartSize(this.getStartSize());
                        retParticle.setStartSizeVar(this.getStartSizeVar());
                        retParticle.setEndSize(this.getEndSize());
                        retParticle.setEndSizeVar(this.getEndSizeVar());
                        retParticle.setPosition(cc.p(this.x, this.y));
                        retParticle.setPosVar(cc.p(this.getPosVar().x, this.getPosVar().y));
                        retParticle.setPositionType(this.getPositionType());
                        retParticle.setStartSpin(this.getStartSpin() || 0);
                        retParticle.setStartSpinVar(this.getStartSpinVar() || 0);
                        retParticle.setEndSpin(this.getEndSpin() || 0);
                        retParticle.setEndSpinVar(this.getEndSpinVar() || 0);
                        retParticle.setEmitterMode(this.getEmitterMode());
                        if (this.getEmitterMode() === _ccsg.ParticleSystem.Mode.GRAVITY) {
                            var gra = this.getGravity();
                            retParticle.setGravity(cc.p(gra.x, gra.y));
                            retParticle.setSpeed(this.getSpeed());
                            retParticle.setSpeedVar(this.getSpeedVar());
                            retParticle.setRadialAccel(this.getRadialAccel());
                            retParticle.setRadialAccelVar(this.getRadialAccelVar());
                            retParticle.setTangentialAccel(this.getTangentialAccel());
                            retParticle.setTangentialAccelVar(this.getTangentialAccelVar());
                        } else {
                            if (this.getEmitterMode() === _ccsg.ParticleSystem.Mode.RADIUS) {
                                retParticle.setStartRadius(this.getStartRadius());
                                retParticle.setStartRadiusVar(this.getStartRadiusVar());
                                retParticle.setEndRadius(this.getEndRadius());
                                retParticle.setEndRadiusVar(this.getEndRadiusVar());
                                retParticle.setRotatePerSecond(this.getRotatePerSecond());
                                retParticle.setRotatePerSecondVar(this.getRotatePerSecondVar());
                            }
                        }
                        retParticle.setLife(this.getLife());
                        retParticle.setLifeVar(this.getLifeVar());
                        retParticle.setEmissionRate(this.getEmissionRate());
                        if (!this.getBatchNode()) {
                            retParticle.setOpacityModifyRGB(this.isOpacityModifyRGB());
                            var texture = this.getTexture();
                            if (texture) {
                                var size = texture.getContentSize();
                                retParticle.setTextureWithRect(texture, cc.rect(0, 0, size.width, size.height));
                            }
                        }
                    }
                    return retParticle;
                },
                setDisplayFrame: function(spriteFrame) {
                    if (!spriteFrame) {
                        return;
                    }
                    var locOffset = spriteFrame.getOffsetInPixels();
                    if (0 !== locOffset.x || 0 !== locOffset.y) {
                        cc.log("_ccsg.ParticleSystem.setDisplayFrame(): QuadParticle only supports SpriteFrames with no offsets");
                    }
                    var texture = spriteFrame.getTexture(), locTexture = this._texture;
                    if (locTexture !== texture) {
                        this.setTexture(texture);
                    }
                },
                setTextureWithRect: function(texture, rect) {
                    var locTexture = this._texture;
                    if (locTexture !== texture) {
                        this._texture = texture;
                        this._updateBlendFunc();
                    }
                    this.initTexCoordsWithRect(rect);
                },
                listenBackToForeground: function(obj) {}
            });
            var _p = _ccsg.ParticleSystem.prototype;
            _p.opacityModifyRGB;
            cc.defineGetterSetter(_p, "opacityModifyRGB", _p.isOpacityModifyRGB, _p.setOpacityModifyRGB);
            _p.batchNode;
            cc.defineGetterSetter(_p, "batchNode", _p.getBatchNode, _p.setBatchNode);
            _p.drawMode;
            cc.defineGetterSetter(_p, "drawMode", _p.getDrawMode, _p.setDrawMode);
            _p.shapeType;
            cc.defineGetterSetter(_p, "shapeType", _p.getShapeType, _p.setShapeType);
            _p.active;
            cc.defineGetterSetter(_p, "active", _p.isActive);
            _p.sourcePos;
            cc.defineGetterSetter(_p, "sourcePos", _p.getSourcePosition, _p.setSourcePosition);
            _p.posVar;
            cc.defineGetterSetter(_p, "posVar", _p.getPosVar, _p.setPosVar);
            _p.gravity;
            cc.defineGetterSetter(_p, "gravity", _p.getGravity, _p.setGravity);
            _p.speed;
            cc.defineGetterSetter(_p, "speed", _p.getSpeed, _p.setSpeed);
            _p.speedVar;
            cc.defineGetterSetter(_p, "speedVar", _p.getSpeedVar, _p.setSpeedVar);
            _p.tangentialAccel;
            cc.defineGetterSetter(_p, "tangentialAccel", _p.getTangentialAccel, _p.setTangentialAccel);
            _p.tangentialAccelVar;
            cc.defineGetterSetter(_p, "tangentialAccelVar", _p.getTangentialAccelVar, _p.setTangentialAccelVar);
            _p.radialAccel;
            cc.defineGetterSetter(_p, "radialAccel", _p.getRadialAccel, _p.setRadialAccel);
            _p.radialAccelVar;
            cc.defineGetterSetter(_p, "radialAccelVar", _p.getRadialAccelVar, _p.setRadialAccelVar);
            _p.rotationIsDir;
            cc.defineGetterSetter(_p, "rotationIsDir", _p.getRotationIsDir, _p.setRotationIsDir);
            _p.startRadius;
            cc.defineGetterSetter(_p, "startRadius", _p.getStartRadius, _p.setStartRadius);
            _p.startRadiusVar;
            cc.defineGetterSetter(_p, "startRadiusVar", _p.getStartRadiusVar, _p.setStartRadiusVar);
            _p.endRadius;
            cc.defineGetterSetter(_p, "endRadius", _p.getEndRadius, _p.setEndRadius);
            _p.endRadiusVar;
            cc.defineGetterSetter(_p, "endRadiusVar", _p.getEndRadiusVar, _p.setEndRadiusVar);
            _p.rotatePerS;
            cc.defineGetterSetter(_p, "rotatePerS", _p.getRotatePerSecond, _p.setRotatePerSecond);
            _p.rotatePerSVar;
            cc.defineGetterSetter(_p, "rotatePerSVar", _p.getRotatePerSecondVar, _p.setRotatePerSecondVar);
            _p.startColor;
            cc.defineGetterSetter(_p, "startColor", _p.getStartColor, _p.setStartColor);
            _p.startColorVar;
            cc.defineGetterSetter(_p, "startColorVar", _p.getStartColorVar, _p.setStartColorVar);
            _p.endColor;
            cc.defineGetterSetter(_p, "endColor", _p.getEndColor, _p.setEndColor);
            _p.endColorVar;
            cc.defineGetterSetter(_p, "endColorVar", _p.getEndColorVar, _p.setEndColorVar);
            _p.totalParticles;
            cc.defineGetterSetter(_p, "totalParticles", _p.getTotalParticles, _p.setTotalParticles);
            _p.texture;
            cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
            _ccsg.ParticleSystem.create = function(plistFile) {
                return new _ccsg.ParticleSystem(plistFile);
            };
            _ccsg.ParticleSystem.createWithTotalParticles = _ccsg.ParticleSystem.create;
            _ccsg.ParticleSystem.ModeA = function(gravity, speed, speedVar, tangentialAccel, tangentialAccelVar, radialAccel, radialAccelVar, rotationIsDir) {
                this.gravity = gravity ? gravity : cc.p(0, 0);
                this.speed = speed || 0;
                this.speedVar = speedVar || 0;
                this.tangentialAccel = tangentialAccel || 0;
                this.tangentialAccelVar = tangentialAccelVar || 0;
                this.radialAccel = radialAccel || 0;
                this.radialAccelVar = radialAccelVar || 0;
                this.rotationIsDir = rotationIsDir || false;
            };
            _ccsg.ParticleSystem.ModeB = function(startRadius, startRadiusVar, endRadius, endRadiusVar, rotatePerSecond, rotatePerSecondVar) {
                this.startRadius = startRadius || 0;
                this.startRadiusVar = startRadiusVar || 0;
                this.endRadius = endRadius || 0;
                this.endRadiusVar = endRadiusVar || 0;
                this.rotatePerSecond = rotatePerSecond || 0;
                this.rotatePerSecondVar = rotatePerSecondVar || 0;
            };
            _ccsg.ParticleSystem.SHAPE_MODE = 0;
            _ccsg.ParticleSystem.TEXTURE_MODE = 1;
            _ccsg.ParticleSystem.STAR_SHAPE = 0;
            _ccsg.ParticleSystem.BALL_SHAPE = 1;
            _ccsg.ParticleSystem.DURATION_INFINITY = -1;
            _ccsg.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE = -1;
            _ccsg.ParticleSystem.START_RADIUS_EQUAL_TO_END_RADIUS = -1;
            _ccsg.ParticleSystem.Mode = cc.Enum({
                GRAVITY: 0,
                RADIUS: 1
            });
            _ccsg.ParticleSystem.Type = cc.Enum({
                FREE: 0,
                RELATIVE: 1,
                GROUPED: 2
            });
            !function() {
                _ccsg.ParticleSystem.CanvasRenderCmd = function(renderable) {
                    _ccsg.Node.CanvasRenderCmd.call(this, renderable);
                    this._needDraw = true;
                    this._drawMode = _ccsg.ParticleSystem.TEXTURE_MODE;
                    this._shapeType = _ccsg.ParticleSystem.BALL_SHAPE;
                    this._pointRect = cc.rect(0, 0, 0, 0);
                    this._tintCache = document.createElement("canvas");
                };
                var proto = _ccsg.ParticleSystem.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
                proto.constructor = _ccsg.ParticleSystem.CanvasRenderCmd;
                proto.getDrawMode = function() {
                    return this._drawMode;
                };
                proto.setDrawMode = function(drawMode) {
                    this._drawMode = drawMode;
                };
                proto.getShapeType = function() {
                    return this._shapeType;
                };
                proto.setShapeType = function(shapeType) {
                    this._shapeType = shapeType;
                };
                proto.setBatchNode = function(batchNode) {
                    if (this._batchNode !== batchNode) {
                        this._node._batchNode = batchNode;
                    }
                };
                proto.updateQuadWithParticle = function(particle, newPosition) {};
                proto.updateParticlePosition = function(particle, position) {
                    cc.pIn(particle.drawPos, position);
                };
                proto.rendering = function(ctx, scaleX, scaleY) {
                    var wrapper = ctx || cc._renderContext, context = wrapper.getContext(), node = this._node, pointRect = this._pointRect;
                    wrapper.setTransform(this._worldTransform, scaleX, scaleY);
                    wrapper.save();
                    if (node.isBlendAdditive()) {
                        context.globalCompositeOperation = "lighter";
                    } else {
                        context.globalCompositeOperation = "source-over";
                    }
                    var i, particle, lpx, alpha;
                    var particleCount = this._node.particleCount, particles = this._node._particles;
                    if (node.drawMode !== _ccsg.ParticleSystem.SHAPE_MODE && node._texture) {
                        if (!node._texture._textureLoaded) {
                            wrapper.restore();
                            return;
                        }
                        var element = node._texture.getHtmlElementObj();
                        if (!element.width || !element.height) {
                            wrapper.restore();
                            return;
                        }
                        var drawElement = element;
                        for (i = 0; i < particleCount; i++) {
                            particle = particles[i];
                            lpx = 0 | .5 * particle.size;
                            alpha = particle.color.a / 255;
                            if (0 === alpha) {
                                continue;
                            }
                            context.globalAlpha = alpha;
                            context.save();
                            context.translate(0 | particle.drawPos.x, -(0 | particle.drawPos.y));
                            var size = 4 * Math.floor(particle.size / 4);
                            var w = pointRect.width;
                            var h = pointRect.height;
                            context.scale(Math.max(1 / w * size, 1e-6), Math.max(1 / h * size, 1e-6));
                            if (particle.rotation) {
                                context.rotate(cc.degreesToRadians(particle.rotation));
                            }
                            drawElement = particle.isChangeColor ? this._changeTextureColor(node._texture, particle.color, this._pointRect) : element;
                            context.drawImage(drawElement, -(0 | w / 2), -(0 | h / 2));
                            context.restore();
                        }
                    } else {
                        var drawTool = cc._drawingUtil;
                        for (i = 0; i < particleCount; i++) {
                            particle = particles[i];
                            lpx = 0 | .5 * particle.size;
                            alpha = particle.color.a / 255;
                            if (0 === alpha) {
                                continue;
                            }
                            context.globalAlpha = alpha;
                            context.save();
                            context.translate(0 | particle.drawPos.x, -(0 | particle.drawPos.y));
                            if (node.shapeType === _ccsg.ParticleSystem.STAR_SHAPE) {
                                if (particle.rotation) {
                                    context.rotate(cc.degreesToRadians(particle.rotation));
                                }
                                drawTool.drawStar(wrapper, lpx, particle.color);
                            } else {
                                drawTool.drawColorBall(wrapper, lpx, particle.color);
                            }
                            context.restore();
                        }
                    }
                    wrapper.restore();
                    cc.g_NumberOfDraws++;
                };
                proto._changeTextureColor = function(texture, color, rect) {
                    var tintCache = this._tintCache;
                    var textureContentSize = texture.getContentSize();
                    tintCache.width = textureContentSize.width;
                    tintCache.height = textureContentSize.height;
                    return texture._generateColorTexture(color.r, color.g, color.b, rect, tintCache);
                };
                proto.initTexCoordsWithRect = function(pointRect) {
                    this._pointRect = pointRect;
                };
                proto.setTotalParticles = function(tp) {
                    this._node._totalParticles = tp < 200 ? tp : 200;
                };
                proto.addParticle = function() {
                    var node = this._node, particles = node._particles, particle;
                    if (node.particleCount < particles.length) {
                        particle = particles[node.particleCount];
                    } else {
                        particle = new cc.Particle();
                        particles.push(particle);
                    }
                    return particle;
                };
                proto._setupVBO = function() {};
                proto._allocMemory = function() {
                    return true;
                };
                proto.postStep = function() {};
                proto._setBlendAdditive = function() {
                    var locBlendFunc = this._node._blendFunc;
                    locBlendFunc.src = cc.BLEND_SRC;
                    locBlendFunc.dst = cc.BLEND_DST;
                };
                proto._initWithTotalParticles = function(totalParticles) {};
                proto._updateDeltaColor = function(selParticle, dt) {
                    if (!this._node._dontTint) {
                        selParticle.color.r += selParticle.deltaColor.r * dt;
                        selParticle.color.g += selParticle.deltaColor.g * dt;
                        selParticle.color.b += selParticle.deltaColor.b * dt;
                        selParticle.color.a += selParticle.deltaColor.a * dt;
                        selParticle.isChangeColor = true;
                    }
                };
            }();
            !function() {
                _ccsg.ParticleSystem.WebGLRenderCmd = function(renderable) {
                    _ccsg.Node.WebGLRenderCmd.call(this, renderable);
                    this._needDraw = true;
                    this._buffersVBO = [ 0, 0 ];
                    this._quads = [];
                    this._indices = [];
                    this._quadsArrayBuffer = null;
                };
                var proto = _ccsg.ParticleSystem.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
                proto.constructor = _ccsg.ParticleSystem.WebGLRenderCmd;
                proto.getDrawMode = function() {};
                proto.setDrawMode = function(drawMode) {};
                proto.getShapeType = function() {};
                proto.setShapeType = function(shapeType) {};
                proto.setBatchNode = function(batchNode) {
                    var node = this._node;
                    if (node._batchNode !== batchNode) {
                        var oldBatch = node._batchNode;
                        node._batchNode = batchNode;
                        if (batchNode) {
                            var locParticles = node._particles;
                            for (var i = 0; i < node._totalParticles; i++) {
                                locParticles[i].atlasIndex = i;
                            }
                        }
                        if (!batchNode) {
                            this._allocMemory();
                            this.initIndices(node._totalParticles);
                            node.setTexture(oldBatch.getTexture());
                            this._setupVBO();
                        } else {
                            if (!oldBatch) {
                                node._batchNode.textureAtlas._copyQuadsToTextureAtlas(this._quads, node.atlasIndex);
                                cc._renderContext.deleteBuffer(this._buffersVBO[1]);
                            }
                        }
                    }
                };
                proto.initIndices = function(totalParticles) {
                    var locIndices = this._indices;
                    for (var i = 0, len = totalParticles; i < len; ++i) {
                        var i6 = 6 * i;
                        var i4 = 4 * i;
                        locIndices[i6 + 0] = i4 + 0;
                        locIndices[i6 + 1] = i4 + 1;
                        locIndices[i6 + 2] = i4 + 2;
                        locIndices[i6 + 5] = i4 + 1;
                        locIndices[i6 + 4] = i4 + 2;
                        locIndices[i6 + 3] = i4 + 3;
                    }
                };
                proto.isDifferentTexture = function(texture1, texture2) {
                    return texture1 === texture2;
                };
                proto.updateParticlePosition = function(particle, position) {
                    this.updateQuadWithParticle(particle, position);
                };
                proto.updateQuadWithParticle = function(particle, newPosition) {
                    var quad = null, node = this._node;
                    if (node._batchNode) {
                        var batchQuads = node._batchNode.textureAtlas.quads;
                        quad = batchQuads[node.atlasIndex + particle.atlasIndex];
                        node._batchNode.textureAtlas.dirty = true;
                    } else {
                        quad = this._quads[node._particleIdx];
                    }
                    var r, g, b, a;
                    if (node._opacityModifyRGB) {
                        r = 0 | particle.color.r * particle.color.a / 255;
                        g = 0 | particle.color.g * particle.color.a / 255;
                        b = 0 | particle.color.b * particle.color.a / 255;
                    } else {
                        r = 0 | particle.color.r;
                        g = 0 | particle.color.g;
                        b = 0 | particle.color.b;
                    }
                    a = 0 | particle.color.a;
                    var blColors = quad.bl.colors, brColors = quad.br.colors, tlColors = quad.tl.colors, trColors = quad.tr.colors;
                    blColors.r = brColors.r = tlColors.r = trColors.r = r;
                    blColors.g = brColors.g = tlColors.g = trColors.g = g;
                    blColors.b = brColors.b = tlColors.b = trColors.b = b;
                    blColors.a = brColors.a = tlColors.a = trColors.a = a;
                    var size_2 = particle.size / 2;
                    if (particle.rotation) {
                        var x1 = -size_2, y1 = -size_2;
                        var x2 = size_2, y2 = size_2;
                        var x = newPosition.x, y = newPosition.y;
                        var rad = -cc.degreesToRadians(particle.rotation);
                        var cr = Math.cos(rad), sr = Math.sin(rad);
                        var ax = x1 * cr - y1 * sr + x;
                        var ay = x1 * sr + y1 * cr + y;
                        var bx = x2 * cr - y1 * sr + x;
                        var by = x2 * sr + y1 * cr + y;
                        var cx = x2 * cr - y2 * sr + x;
                        var cy = x2 * sr + y2 * cr + y;
                        var dx = x1 * cr - y2 * sr + x;
                        var dy = x1 * sr + y2 * cr + y;
                        quad.bl.vertices.x = ax;
                        quad.bl.vertices.y = ay;
                        quad.br.vertices.x = bx;
                        quad.br.vertices.y = by;
                        quad.tl.vertices.x = dx;
                        quad.tl.vertices.y = dy;
                        quad.tr.vertices.x = cx;
                        quad.tr.vertices.y = cy;
                    } else {
                        quad.bl.vertices.x = newPosition.x - size_2;
                        quad.bl.vertices.y = newPosition.y - size_2;
                        quad.br.vertices.x = newPosition.x + size_2;
                        quad.br.vertices.y = newPosition.y - size_2;
                        quad.tl.vertices.x = newPosition.x - size_2;
                        quad.tl.vertices.y = newPosition.y + size_2;
                        quad.tr.vertices.x = newPosition.x + size_2;
                        quad.tr.vertices.y = newPosition.y + size_2;
                    }
                };
                proto.rendering = function(ctx) {
                    var node = this._node;
                    if (!node._texture) {
                        return;
                    }
                    var gl = ctx || cc._renderContext;
                    this._shaderProgram.use();
                    this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
                    cc.glBindTexture2D(node._texture);
                    cc.glBlendFuncForParticle(node._blendFunc.src, node._blendFunc.dst);
                    cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
                    gl.bindBuffer(gl.ARRAY_BUFFER, this._buffersVBO[0]);
                    gl.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, gl.FLOAT, false, 24, 0);
                    gl.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, gl.UNSIGNED_BYTE, true, 24, 12);
                    gl.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, gl.FLOAT, false, 24, 16);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
                    gl.drawElements(gl.TRIANGLES, 6 * node._particleIdx, gl.UNSIGNED_SHORT, 0);
                };
                proto.initTexCoordsWithRect = function(pointRect) {
                    var node = this._node;
                    var texture = node.texture;
                    var scaleFactor = cc.contentScaleFactor();
                    var rect = cc.rect(pointRect.x * scaleFactor, pointRect.y * scaleFactor, pointRect.width * scaleFactor, pointRect.height * scaleFactor);
                    var wide = pointRect.width;
                    var high = pointRect.height;
                    if (texture) {
                        wide = texture.getPixelWidth();
                        high = texture.getPixelHeight();
                    }
                    var left, bottom, right, top;
                    if (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL) {
                        left = (2 * rect.x + 1) / (2 * wide);
                        bottom = (2 * rect.y + 1) / (2 * high);
                        right = left + (2 * rect.width - 2) / (2 * wide);
                        top = bottom + (2 * rect.height - 2) / (2 * high);
                    } else {
                        left = rect.x / wide;
                        bottom = rect.y / high;
                        right = left + rect.width / wide;
                        top = bottom + rect.height / high;
                    }
                    var temp = top;
                    top = bottom;
                    bottom = temp;
                    var quads;
                    var start = 0, end = 0;
                    if (node._batchNode) {
                        quads = node._batchNode.textureAtlas.quads;
                        start = node.atlasIndex;
                        end = node.atlasIndex + node._totalParticles;
                    } else {
                        quads = this._quads;
                        start = 0;
                        end = node._totalParticles;
                    }
                    for (var i = start; i < end; i++) {
                        if (!quads[i]) {
                            quads[i] = cc.V3F_C4B_T2F_QuadZero();
                        }
                        var selQuad = quads[i];
                        selQuad.bl.texCoords.u = left;
                        selQuad.bl.texCoords.v = bottom;
                        selQuad.br.texCoords.u = right;
                        selQuad.br.texCoords.v = bottom;
                        selQuad.tl.texCoords.u = left;
                        selQuad.tl.texCoords.v = top;
                        selQuad.tr.texCoords.u = right;
                        selQuad.tr.texCoords.v = top;
                    }
                };
                proto.setTotalParticles = function(tp) {
                    var node = this._node;
                    if (tp > node._allocatedParticles) {
                        var quadSize = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
                        this._indices = new Uint16Array(6 * tp);
                        var locQuadsArrayBuffer = new ArrayBuffer(tp * quadSize);
                        var locParticles = node._particles;
                        locParticles.length = 0;
                        var locQuads = this._quads;
                        locQuads.length = 0;
                        for (var j = 0; j < tp; j++) {
                            locParticles[j] = new cc.Particle();
                            locQuads[j] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, locQuadsArrayBuffer, j * quadSize);
                        }
                        node._allocatedParticles = tp;
                        node._totalParticles = tp;
                        if (node._batchNode) {
                            for (var i = 0; i < tp; i++) {
                                locParticles[i].atlasIndex = i;
                            }
                        }
                        this._quadsArrayBuffer = locQuadsArrayBuffer;
                        this.initIndices(tp);
                        this._setupVBO();
                        if (node._texture) {
                            this.initTexCoordsWithRect(cc.rect(0, 0, node._texture.width, node._texture.height));
                        }
                    } else {
                        node._totalParticles = tp;
                    }
                    node.resetSystem();
                };
                proto.addParticle = function() {
                    var node = this._node, particles = node._particles;
                    return particles[node.particleCount];
                };
                proto._setupVBO = function() {
                    var node = this;
                    var gl = cc._renderContext;
                    this._buffersVBO[0] = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, this._buffersVBO[0]);
                    gl.bufferData(gl.ARRAY_BUFFER, this._quadsArrayBuffer, gl.DYNAMIC_DRAW);
                    this._buffersVBO[1] = gl.createBuffer();
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._indices, gl.STATIC_DRAW);
                };
                proto._allocMemory = function() {
                    var node = this._node;
                    if (node._batchNode) {
                        cc.log("_ccsg.ParticleSystem._allocMemory(): Memory should not be allocated when not using batchNode");
                        return false;
                    }
                    var quadSize = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
                    var totalParticles = node._totalParticles;
                    var locQuads = this._quads;
                    locQuads.length = 0;
                    this._indices = new Uint16Array(6 * totalParticles);
                    var locQuadsArrayBuffer = new ArrayBuffer(quadSize * totalParticles);
                    for (var i = 0; i < totalParticles; i++) {
                        locQuads[i] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, locQuadsArrayBuffer, i * quadSize);
                    }
                    if (!locQuads || !this._indices) {
                        cc.log("cocos2d: Particle system: not enough memory");
                        return false;
                    }
                    this._quadsArrayBuffer = locQuadsArrayBuffer;
                    return true;
                };
                proto.postStep = function() {
                    var gl = cc._renderContext;
                    gl.bindBuffer(gl.ARRAY_BUFFER, this._buffersVBO[0]);
                    gl.bufferData(gl.ARRAY_BUFFER, this._quadsArrayBuffer, gl.DYNAMIC_DRAW);
                };
                proto._setBlendAdditive = function() {
                    var locBlendFunc = this._node._blendFunc;
                    if (this._texture && !this._texture.hasPremultipliedAlpha()) {
                        locBlendFunc.src = cc.SRC_ALPHA;
                        locBlendFunc.dst = cc.ONE_MINUS_SRC_ALPHA;
                    } else {
                        locBlendFunc.src = cc.BLEND_SRC;
                        locBlendFunc.dst = cc.BLEND_DST;
                    }
                };
                proto._initWithTotalParticles = function(totalParticles) {
                    if (!this._allocMemory()) {
                        return false;
                    }
                    this.initIndices(totalParticles);
                    this._setupVBO();
                    this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
                };
                proto._updateDeltaColor = function(selParticle, dt) {
                    selParticle.color.r += selParticle.deltaColor.r * dt;
                    selParticle.color.g += selParticle.deltaColor.g * dt;
                    selParticle.color.b += selParticle.deltaColor.b * dt;
                    selParticle.color.a += selParticle.deltaColor.a * dt;
                    selParticle.isChangeColor = true;
                };
            }();
            cc.ParticleFire = _ccsg.ParticleSystem.extend({
                ctor: function() {
                    _ccsg.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 300 : 150);
                },
                initWithTotalParticles: function(numberOfParticles) {
                    if (_ccsg.ParticleSystem.prototype.initWithTotalParticles.call(this, numberOfParticles)) {
                        this.setDuration(_ccsg.ParticleSystem.DURATION_INFINITY);
                        this.setEmitterMode(_ccsg.ParticleSystem.Mode.GRAVITY);
                        this.setGravity(cc.p(0, 0));
                        this.setRadialAccel(0);
                        this.setRadialAccelVar(0);
                        this.setSpeed(60);
                        this.setSpeedVar(20);
                        this.setAngle(90);
                        this.setAngleVar(10);
                        var winSize = cc.director.getWinSize();
                        this.setPosition(winSize.width / 2, 60);
                        this.setPosVar(cc.p(40, 20));
                        this.setLife(3);
                        this.setLifeVar(.25);
                        this.setStartSize(54);
                        this.setStartSizeVar(10);
                        this.setEndSize(_ccsg.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE);
                        this.setEmissionRate(this.getTotalParticles() / this.getLife());
                        this.setStartColor(cc.color(194, 64, 31, 255));
                        this.setStartColorVar(cc.color(0, 0, 0, 0));
                        this.setEndColor(cc.color(0, 0, 0, 255));
                        this.setEndColorVar(cc.color(0, 0, 0, 0));
                        this.setBlendAdditive(true);
                        return true;
                    }
                    return false;
                }
            });
            cc.ParticleFire.create = function() {
                return new cc.ParticleFire();
            };
            cc.ParticleFireworks = _ccsg.ParticleSystem.extend({
                ctor: function() {
                    _ccsg.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 1500 : 150);
                },
                initWithTotalParticles: function(numberOfParticles) {
                    if (_ccsg.ParticleSystem.prototype.initWithTotalParticles.call(this, numberOfParticles)) {
                        this.setDuration(_ccsg.ParticleSystem.DURATION_INFINITY);
                        this.setEmitterMode(_ccsg.ParticleSystem.Mode.GRAVITY);
                        this.setGravity(cc.p(0, -90));
                        this.setRadialAccel(0);
                        this.setRadialAccelVar(0);
                        this.setSpeed(180);
                        this.setSpeedVar(50);
                        var winSize = cc.director.getWinSize();
                        this.setPosition(winSize.width / 2, winSize.height / 2);
                        this.setAngle(90);
                        this.setAngleVar(20);
                        this.setLife(3.5);
                        this.setLifeVar(1);
                        this.setEmissionRate(this.getTotalParticles() / this.getLife());
                        this.setStartColor(cc.color(128, 128, 128, 255));
                        this.setStartColorVar(cc.color(128, 128, 128, 255));
                        this.setEndColor(cc.color(26, 26, 26, 51));
                        this.setEndColorVar(cc.color(26, 26, 26, 51));
                        this.setStartSize(8);
                        this.setStartSizeVar(2);
                        this.setEndSize(_ccsg.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE);
                        this.setBlendAdditive(false);
                        return true;
                    }
                    return false;
                }
            });
            cc.ParticleFireworks.create = function() {
                return new cc.ParticleFireworks();
            };
            cc.ParticleSun = _ccsg.ParticleSystem.extend({
                ctor: function() {
                    _ccsg.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 350 : 150);
                },
                initWithTotalParticles: function(numberOfParticles) {
                    if (_ccsg.ParticleSystem.prototype.initWithTotalParticles.call(this, numberOfParticles)) {
                        this.setBlendAdditive(true);
                        this.setDuration(_ccsg.ParticleSystem.DURATION_INFINITY);
                        this.setEmitterMode(_ccsg.ParticleSystem.Mode.GRAVITY);
                        this.setGravity(cc.p(0, 0));
                        this.setRadialAccel(0);
                        this.setRadialAccelVar(0);
                        this.setSpeed(20);
                        this.setSpeedVar(5);
                        this.setAngle(90);
                        this.setAngleVar(360);
                        var winSize = cc.director.getWinSize();
                        this.setPosition(winSize.width / 2, winSize.height / 2);
                        this.setPosVar(cc.p(0, 0));
                        this.setLife(1);
                        this.setLifeVar(.5);
                        this.setStartSize(30);
                        this.setStartSizeVar(10);
                        this.setEndSize(_ccsg.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE);
                        this.setEmissionRate(this.getTotalParticles() / this.getLife());
                        this.setStartColor(cc.color(194, 64, 31, 255));
                        this.setStartColorVar(cc.color(0, 0, 0, 0));
                        this.setEndColor(cc.color(0, 0, 0, 255));
                        this.setEndColorVar(cc.color(0, 0, 0, 0));
                        return true;
                    }
                    return false;
                }
            });
            cc.ParticleSun.create = function() {
                return new cc.ParticleSun();
            };
            cc.ParticleGalaxy = _ccsg.ParticleSystem.extend({
                ctor: function() {
                    _ccsg.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 200 : 100);
                },
                initWithTotalParticles: function(numberOfParticles) {
                    if (_ccsg.ParticleSystem.prototype.initWithTotalParticles.call(this, numberOfParticles)) {
                        this.setDuration(_ccsg.ParticleSystem.DURATION_INFINITY);
                        this.setEmitterMode(_ccsg.ParticleSystem.Mode.GRAVITY);
                        this.setGravity(cc.p(0, 0));
                        this.setSpeed(60);
                        this.setSpeedVar(10);
                        this.setRadialAccel(-80);
                        this.setRadialAccelVar(0);
                        this.setTangentialAccel(80);
                        this.setTangentialAccelVar(0);
                        this.setAngle(90);
                        this.setAngleVar(360);
                        var winSize = cc.director.getWinSize();
                        this.setPosition(winSize.width / 2, winSize.height / 2);
                        this.setPosVar(cc.p(0, 0));
                        this.setLife(4);
                        this.setLifeVar(1);
                        this.setStartSize(37);
                        this.setStartSizeVar(10);
                        this.setEndSize(_ccsg.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE);
                        this.setEmissionRate(this.getTotalParticles() / this.getLife());
                        this.setStartColor(cc.color(31, 64, 194, 255));
                        this.setStartColorVar(cc.color(0, 0, 0, 0));
                        this.setEndColor(cc.color(0, 0, 0, 255));
                        this.setEndColorVar(cc.color(0, 0, 0, 0));
                        this.setBlendAdditive(true);
                        return true;
                    }
                    return false;
                }
            });
            cc.ParticleGalaxy.create = function() {
                return new cc.ParticleGalaxy();
            };
            cc.ParticleFlower = _ccsg.ParticleSystem.extend({
                ctor: function() {
                    _ccsg.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 250 : 100);
                },
                initWithTotalParticles: function(numberOfParticles) {
                    if (_ccsg.ParticleSystem.prototype.initWithTotalParticles.call(this, numberOfParticles)) {
                        this.setDuration(_ccsg.ParticleSystem.DURATION_INFINITY);
                        this.setEmitterMode(_ccsg.ParticleSystem.Mode.GRAVITY);
                        this.setGravity(cc.p(0, 0));
                        this.setSpeed(80);
                        this.setSpeedVar(10);
                        this.setRadialAccel(-60);
                        this.setRadialAccelVar(0);
                        this.setTangentialAccel(15);
                        this.setTangentialAccelVar(0);
                        this.setAngle(90);
                        this.setAngleVar(360);
                        var winSize = cc.director.getWinSize();
                        this.setPosition(winSize.width / 2, winSize.height / 2);
                        this.setPosVar(cc.p(0, 0));
                        this.setLife(4);
                        this.setLifeVar(1);
                        this.setStartSize(30);
                        this.setStartSizeVar(10);
                        this.setEndSize(_ccsg.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE);
                        this.setEmissionRate(this.getTotalParticles() / this.getLife());
                        this.setStartColor(cc.color(128, 128, 128, 255));
                        this.setStartColorVar(cc.color(128, 128, 128, 128));
                        this.setEndColor(cc.color(0, 0, 0, 255));
                        this.setEndColorVar(cc.color(0, 0, 0, 0));
                        this.setBlendAdditive(true);
                        return true;
                    }
                    return false;
                }
            });
            cc.ParticleFlower.create = function() {
                return new cc.ParticleFlower();
            };
            cc.ParticleMeteor = _ccsg.ParticleSystem.extend({
                ctor: function() {
                    _ccsg.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 150 : 100);
                },
                initWithTotalParticles: function(numberOfParticles) {
                    if (_ccsg.ParticleSystem.prototype.initWithTotalParticles.call(this, numberOfParticles)) {
                        this.setDuration(_ccsg.ParticleSystem.DURATION_INFINITY);
                        this.setEmitterMode(_ccsg.ParticleSystem.Mode.GRAVITY);
                        this.setGravity(cc.p(-200, 200));
                        this.setSpeed(15);
                        this.setSpeedVar(5);
                        this.setRadialAccel(0);
                        this.setRadialAccelVar(0);
                        this.setTangentialAccel(0);
                        this.setTangentialAccelVar(0);
                        this.setAngle(90);
                        this.setAngleVar(360);
                        var winSize = cc.director.getWinSize();
                        this.setPosition(winSize.width / 2, winSize.height / 2);
                        this.setPosVar(cc.p(0, 0));
                        this.setLife(2);
                        this.setLifeVar(1);
                        this.setStartSize(60);
                        this.setStartSizeVar(10);
                        this.setEndSize(_ccsg.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE);
                        this.setEmissionRate(this.getTotalParticles() / this.getLife());
                        this.setStartColor(cc.color(51, 102, 179));
                        this.setStartColorVar(cc.color(0, 0, 51, 26));
                        this.setEndColor(cc.color(0, 0, 0, 255));
                        this.setEndColorVar(cc.color(0, 0, 0, 0));
                        this.setBlendAdditive(true);
                        return true;
                    }
                    return false;
                }
            });
            cc.ParticleMeteor.create = function() {
                return new cc.ParticleMeteor();
            };
            cc.ParticleSpiral = _ccsg.ParticleSystem.extend({
                ctor: function() {
                    _ccsg.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 500 : 100);
                },
                initWithTotalParticles: function(numberOfParticles) {
                    if (_ccsg.ParticleSystem.prototype.initWithTotalParticles.call(this, numberOfParticles)) {
                        this.setDuration(_ccsg.ParticleSystem.DURATION_INFINITY);
                        this.setEmitterMode(_ccsg.ParticleSystem.Mode.GRAVITY);
                        this.setGravity(cc.p(0, 0));
                        this.setSpeed(150);
                        this.setSpeedVar(0);
                        this.setRadialAccel(-380);
                        this.setRadialAccelVar(0);
                        this.setTangentialAccel(45);
                        this.setTangentialAccelVar(0);
                        this.setAngle(90);
                        this.setAngleVar(0);
                        var winSize = cc.director.getWinSize();
                        this.setPosition(winSize.width / 2, winSize.height / 2);
                        this.setPosVar(cc.p(0, 0));
                        this.setLife(12);
                        this.setLifeVar(0);
                        this.setStartSize(20);
                        this.setStartSizeVar(0);
                        this.setEndSize(_ccsg.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE);
                        this.setEmissionRate(this.getTotalParticles() / this.getLife());
                        this.setStartColor(cc.color(128, 128, 128, 255));
                        this.setStartColorVar(cc.color(128, 128, 128, 0));
                        this.setEndColor(cc.color(128, 128, 128, 255));
                        this.setEndColorVar(cc.color(128, 128, 128, 0));
                        this.setBlendAdditive(false);
                        return true;
                    }
                    return false;
                }
            });
            cc.ParticleSpiral.create = function() {
                return new cc.ParticleSpiral();
            };
            cc.ParticleExplosion = _ccsg.ParticleSystem.extend({
                ctor: function() {
                    _ccsg.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 700 : 300);
                },
                initWithTotalParticles: function(numberOfParticles) {
                    if (_ccsg.ParticleSystem.prototype.initWithTotalParticles.call(this, numberOfParticles)) {
                        this.setDuration(.1);
                        this.setEmitterMode(_ccsg.ParticleSystem.Mode.GRAVITY);
                        this.setGravity(cc.p(0, 0));
                        this.setSpeed(70);
                        this.setSpeedVar(40);
                        this.setRadialAccel(0);
                        this.setRadialAccelVar(0);
                        this.setTangentialAccel(0);
                        this.setTangentialAccelVar(0);
                        this.setAngle(90);
                        this.setAngleVar(360);
                        var winSize = cc.director.getWinSize();
                        this.setPosition(winSize.width / 2, winSize.height / 2);
                        this.setPosVar(cc.p(0, 0));
                        this.setLife(5);
                        this.setLifeVar(2);
                        this.setStartSize(15);
                        this.setStartSizeVar(10);
                        this.setEndSize(_ccsg.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE);
                        this.setEmissionRate(this.getTotalParticles() / this.getDuration());
                        this.setStartColor(cc.color(179, 26, 51, 255));
                        this.setStartColorVar(cc.color(128, 128, 128, 0));
                        this.setEndColor(cc.color(128, 128, 128, 0));
                        this.setEndColorVar(cc.color(128, 128, 128, 0));
                        this.setBlendAdditive(false);
                        return true;
                    }
                    return false;
                }
            });
            cc.ParticleExplosion.create = function() {
                return new cc.ParticleExplosion();
            };
            cc.ParticleSmoke = _ccsg.ParticleSystem.extend({
                ctor: function() {
                    _ccsg.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 200 : 100);
                },
                initWithTotalParticles: function(numberOfParticles) {
                    if (_ccsg.ParticleSystem.prototype.initWithTotalParticles.call(this, numberOfParticles)) {
                        this.setDuration(_ccsg.ParticleSystem.DURATION_INFINITY);
                        this.setEmitterMode(_ccsg.ParticleSystem.Mode.GRAVITY);
                        this.setGravity(cc.p(0, 0));
                        this.setRadialAccel(0);
                        this.setRadialAccelVar(0);
                        this.setSpeed(25);
                        this.setSpeedVar(10);
                        this.setAngle(90);
                        this.setAngleVar(5);
                        var winSize = cc.director.getWinSize();
                        this.setPosition(winSize.width / 2, 0);
                        this.setPosVar(cc.p(20, 0));
                        this.setLife(4);
                        this.setLifeVar(1);
                        this.setStartSize(60);
                        this.setStartSizeVar(10);
                        this.setEndSize(_ccsg.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE);
                        this.setEmissionRate(this.getTotalParticles() / this.getLife());
                        this.setStartColor(cc.color(204, 204, 204, 255));
                        this.setStartColorVar(cc.color(5, 5, 5, 0));
                        this.setEndColor(cc.color(0, 0, 0, 255));
                        this.setEndColorVar(cc.color(0, 0, 0, 0));
                        this.setBlendAdditive(false);
                        return true;
                    }
                    return false;
                }
            });
            cc.ParticleSmoke.create = function() {
                return new cc.ParticleSmoke();
            };
            cc.ParticleSnow = _ccsg.ParticleSystem.extend({
                ctor: function() {
                    _ccsg.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 700 : 250);
                },
                initWithTotalParticles: function(numberOfParticles) {
                    if (_ccsg.ParticleSystem.prototype.initWithTotalParticles.call(this, numberOfParticles)) {
                        this.setDuration(_ccsg.ParticleSystem.DURATION_INFINITY);
                        this.setEmitterMode(_ccsg.ParticleSystem.Mode.GRAVITY);
                        this.setGravity(cc.p(0, -1));
                        this.setSpeed(5);
                        this.setSpeedVar(1);
                        this.setRadialAccel(0);
                        this.setRadialAccelVar(1);
                        this.setTangentialAccel(0);
                        this.setTangentialAccelVar(1);
                        var winSize = cc.director.getWinSize();
                        this.setPosition(winSize.width / 2, winSize.height + 10);
                        this.setPosVar(cc.p(winSize.width / 2, 0));
                        this.setAngle(-90);
                        this.setAngleVar(5);
                        this.setLife(45);
                        this.setLifeVar(15);
                        this.setStartSize(10);
                        this.setStartSizeVar(5);
                        this.setEndSize(_ccsg.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE);
                        this.setEmissionRate(10);
                        this.setStartColor(cc.color(255, 255, 255, 255));
                        this.setStartColorVar(cc.color(0, 0, 0, 0));
                        this.setEndColor(cc.color(255, 255, 255, 0));
                        this.setEndColorVar(cc.color(0, 0, 0, 0));
                        this.setBlendAdditive(false);
                        return true;
                    }
                    return false;
                }
            });
            cc.ParticleSnow.create = function() {
                return new cc.ParticleSnow();
            };
            cc.ParticleRain = _ccsg.ParticleSystem.extend({
                ctor: function() {
                    _ccsg.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 1e3 : 300);
                },
                initWithTotalParticles: function(numberOfParticles) {
                    if (_ccsg.ParticleSystem.prototype.initWithTotalParticles.call(this, numberOfParticles)) {
                        this.setDuration(_ccsg.ParticleSystem.DURATION_INFINITY);
                        this.setEmitterMode(_ccsg.ParticleSystem.Mode.GRAVITY);
                        this.setGravity(cc.p(10, -10));
                        this.setRadialAccel(0);
                        this.setRadialAccelVar(1);
                        this.setTangentialAccel(0);
                        this.setTangentialAccelVar(1);
                        this.setSpeed(130);
                        this.setSpeedVar(30);
                        this.setAngle(-90);
                        this.setAngleVar(5);
                        var winSize = cc.director.getWinSize();
                        this.setPosition(winSize.width / 2, winSize.height);
                        this.setPosVar(cc.p(winSize.width / 2, 0));
                        this.setLife(4.5);
                        this.setLifeVar(0);
                        this.setStartSize(4);
                        this.setStartSizeVar(2);
                        this.setEndSize(_ccsg.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE);
                        this.setEmissionRate(20);
                        this.setStartColor(cc.color(179, 204, 255, 255));
                        this.setStartColorVar(cc.color(0, 0, 0, 0));
                        this.setEndColor(cc.color(179, 204, 255, 128));
                        this.setEndColorVar(cc.color(0, 0, 0, 0));
                        this.setBlendAdditive(false);
                        return true;
                    }
                    return false;
                }
            });
            cc.ParticleRain.create = function() {
                return new cc.ParticleRain();
            };
            cc.PARTICLE_DEFAULT_CAPACITY = 500;
            cc.ParticleBatchNode = _ccsg.Node.extend({
                textureAtlas: null,
                _blendFunc: null,
                _className: "ParticleBatchNode",
                ctor: function(fileImage, capacity) {
                    _ccsg.Node.prototype.ctor.call(this);
                    this._blendFunc = {
                        src: cc.BLEND_SRC,
                        dst: cc.BLEND_DST
                    };
                    if (cc.js.isString(fileImage)) {
                        this.init(fileImage, capacity);
                    } else {
                        if (fileImage instanceof cc.Texture2D) {
                            this.initWithTexture(fileImage, capacity);
                        }
                    }
                },
                _createRenderCmd: function() {
                    if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                        return new cc.ParticleBatchNode.CanvasRenderCmd(this);
                    } else {
                        return new cc.ParticleBatchNode.WebGLRenderCmd(this);
                    }
                },
                initWithTexture: function(texture, capacity) {
                    this.textureAtlas = new cc.TextureAtlas();
                    this.textureAtlas.initWithTexture(texture, capacity);
                    this._children.length = 0;
                    this._renderCmd._initWithTexture();
                    return true;
                },
                initWithFile: function(fileImage, capacity) {
                    var tex = cc.textureCache.addImage(fileImage);
                    return this.initWithTexture(tex, capacity);
                },
                init: function(fileImage, capacity) {
                    var tex = cc.textureCache.addImage(fileImage);
                    return this.initWithTexture(tex, capacity);
                },
                addChild: function(child, zOrder, tag) {
                    if (!child) {
                        throw new Error("cc.ParticleBatchNode.addChild() : child should be non-null");
                    }
                    if (!(child instanceof _ccsg.ParticleSystem)) {
                        throw new Error("cc.ParticleBatchNode.addChild() : only supports _ccsg.ParticleSystem as children");
                    }
                    zOrder = null == zOrder ? child.zIndex : zOrder;
                    tag = null == tag ? child.tag : tag;
                    if (child.getTexture() !== this.textureAtlas.texture) {
                        throw new Error("_ccsg.ParticleSystem.addChild() : the child is not using the same texture id");
                    }
                    var childBlendFunc = child.getBlendFunc();
                    if (0 === this._children.length) {
                        this.setBlendFunc(childBlendFunc);
                    } else {
                        if (childBlendFunc.src !== this._blendFunc.src || childBlendFunc.dst !== this._blendFunc.dst) {
                            cc.log("_ccsg.ParticleSystem.addChild() : Can't add a ParticleSystem that uses a different blending function");
                            return;
                        }
                    }
                    var pos = this._addChildHelper(child, zOrder, tag);
                    var atlasIndex = 0;
                    if (0 !== pos) {
                        var p = this._children[pos - 1];
                        atlasIndex = p.getAtlasIndex() + p.getTotalParticles();
                    } else {
                        atlasIndex = 0;
                    }
                    this.insertChild(child, atlasIndex);
                    child.setBatchNode(this);
                },
                insertChild: function(pSystem, index) {
                    var totalParticles = pSystem.getTotalParticles();
                    var locTextureAtlas = this.textureAtlas;
                    var totalQuads = locTextureAtlas.totalQuads;
                    pSystem.setAtlasIndex(index);
                    if (totalQuads + totalParticles > locTextureAtlas.getCapacity()) {
                        this._increaseAtlasCapacityTo(totalQuads + totalParticles);
                        locTextureAtlas.fillWithEmptyQuadsFromIndex(locTextureAtlas.getCapacity() - totalParticles, totalParticles);
                    }
                    if (pSystem.getAtlasIndex() + totalParticles !== totalQuads) {
                        locTextureAtlas.moveQuadsFromIndex(index, index + totalParticles);
                    }
                    locTextureAtlas.increaseTotalQuadsWith(totalParticles);
                    this._updateAllAtlasIndexes();
                },
                removeChild: function(child, cleanup) {
                    if (null == child) {
                        return;
                    }
                    if (!(child instanceof _ccsg.ParticleSystem)) {
                        throw new Error("cc.ParticleBatchNode.removeChild(): only supports _ccsg.ParticleSystem as children");
                    }
                    if (-1 === this._children.indexOf(child)) {
                        cc.log("cc.ParticleBatchNode.removeChild(): doesn't contain the sprite. Can't remove it");
                        return;
                    }
                    _ccsg.Node.prototype.removeChild.call(this, child, cleanup);
                    var locTextureAtlas = this.textureAtlas;
                    locTextureAtlas.removeQuadsAtIndex(child.getAtlasIndex(), child.getTotalParticles());
                    locTextureAtlas.fillWithEmptyQuadsFromIndex(locTextureAtlas.totalQuads, child.getTotalParticles());
                    child.setBatchNode(null);
                    this._updateAllAtlasIndexes();
                },
                reorderChild: function(child, zOrder) {
                    if (!child) {
                        throw new Error("cc.ParticleBatchNode.reorderChild(): child should be non-null");
                    }
                    if (!(child instanceof _ccsg.ParticleSystem)) {
                        throw new Error("cc.ParticleBatchNode.reorderChild(): only supports cc.QuadParticleSystems as children");
                    }
                    if (-1 === this._children.indexOf(child)) {
                        cc.log("cc.ParticleBatchNode.reorderChild(): Child doesn't belong to batch");
                        return;
                    }
                    if (zOrder === child.zIndex) {
                        return;
                    }
                    if (this._children.length > 1) {
                        var getIndexes = this._getCurrentIndex(child, zOrder);
                        if (getIndexes.oldIndex !== getIndexes.newIndex) {
                            this._children.splice(getIndexes.oldIndex, 1);
                            this._children.splice(getIndexes.newIndex, 0, child);
                            var oldAtlasIndex = child.getAtlasIndex();
                            this._updateAllAtlasIndexes();
                            var newAtlasIndex = 0;
                            var locChildren = this._children;
                            for (var i = 0; i < locChildren.length; i++) {
                                var pNode = locChildren[i];
                                if (pNode === child) {
                                    newAtlasIndex = child.getAtlasIndex();
                                    break;
                                }
                            }
                            this.textureAtlas.moveQuadsFromIndex(oldAtlasIndex, child.getTotalParticles(), newAtlasIndex);
                            child.updateWithNoTime();
                        }
                    }
                    child._setLocalZOrder(zOrder);
                },
                removeChildAtIndex: function(index, doCleanup) {
                    this.removeChild(this._children[i], doCleanup);
                },
                removeAllChildren: function(doCleanup) {
                    var locChildren = this._children;
                    for (var i = 0; i < locChildren.length; i++) {
                        locChildren[i].setBatchNode(null);
                    }
                    _ccsg.Node.prototype.removeAllChildren.call(this, doCleanup);
                    this.textureAtlas.removeAllQuads();
                },
                disableParticle: function(particleIndex) {
                    var quad = this.textureAtlas.quads[particleIndex];
                    quad.br.vertices.x = quad.br.vertices.y = quad.tr.vertices.x = quad.tr.vertices.y = quad.tl.vertices.x = quad.tl.vertices.y = quad.bl.vertices.x = quad.bl.vertices.y = 0;
                    this.textureAtlas._setDirty(true);
                },
                getTexture: function() {
                    return this.textureAtlas.texture;
                },
                setTexture: function(texture) {
                    this.textureAtlas.texture = texture;
                    var locBlendFunc = this._blendFunc;
                    if (texture && !texture.hasPremultipliedAlpha() && locBlendFunc.src === cc.BLEND_SRC && locBlendFunc.dst === cc.BLEND_DST) {
                        locBlendFunc.src = cc.SRC_ALPHA;
                        locBlendFunc.dst = cc.ONE_MINUS_SRC_ALPHA;
                    }
                },
                setBlendFunc: function(src, dst) {
                    if (void 0 === dst) {
                        this._blendFunc.src = src.src;
                        this._blendFunc.dst = src.dst;
                    } else {
                        this._blendFunc.src = src;
                        this._blendFunc.src = dst;
                    }
                },
                getBlendFunc: function() {
                    return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst);
                },
                _updateAllAtlasIndexes: function() {
                    var index = 0;
                    var locChildren = this._children;
                    for (var i = 0; i < locChildren.length; i++) {
                        var child = locChildren[i];
                        child.setAtlasIndex(index);
                        index += child.getTotalParticles();
                    }
                },
                _increaseAtlasCapacityTo: function(quantity) {
                    cc.log("cocos2d: cc.ParticleBatchNode: resizing TextureAtlas capacity from [" + this.textureAtlas.getCapacity() + "] to [" + quantity + "].");
                    if (!this.textureAtlas.resizeCapacity(quantity)) {
                        cc.log("cc.ParticleBatchNode._increaseAtlasCapacityTo() : WARNING: Not enough memory to resize the atlas");
                    }
                },
                _searchNewPositionInChildrenForZ: function(z) {
                    var locChildren = this._children;
                    var count = locChildren.length;
                    for (var i = 0; i < count; i++) {
                        if (locChildren[i].zIndex > z) {
                            return i;
                        }
                    }
                    return count;
                },
                _getCurrentIndex: function(child, z) {
                    var foundCurrentIdx = false;
                    var foundNewIdx = false;
                    var newIndex = 0;
                    var oldIndex = 0;
                    var minusOne = 0, locChildren = this._children;
                    var count = locChildren.length;
                    for (var i = 0; i < count; i++) {
                        var pNode = locChildren[i];
                        if (pNode.zIndex > z && !foundNewIdx) {
                            newIndex = i;
                            foundNewIdx = true;
                            if (foundCurrentIdx && foundNewIdx) {
                                break;
                            }
                        }
                        if (child === pNode) {
                            oldIndex = i;
                            foundCurrentIdx = true;
                            if (!foundNewIdx) {
                                minusOne = -1;
                            }
                            if (foundCurrentIdx && foundNewIdx) {
                                break;
                            }
                        }
                    }
                    if (!foundNewIdx) {
                        newIndex = count;
                    }
                    newIndex += minusOne;
                    return {
                        newIndex: newIndex,
                        oldIndex: oldIndex
                    };
                },
                _addChildHelper: function(child, z, aTag) {
                    if (!child) {
                        throw new Error("cc.ParticleBatchNode._addChildHelper(): child should be non-null");
                    }
                    if (child.parent) {
                        cc.log("cc.ParticleBatchNode._addChildHelper(): child already added. It can't be added again");
                        return null;
                    }
                    if (!this._children) {
                        this._children = [];
                    }
                    var pos = this._searchNewPositionInChildrenForZ(z);
                    this._children.splice(pos, 0, child);
                    child.tag = aTag;
                    child._setLocalZOrder(z);
                    child.parent = this;
                    if (this._running) {
                        child.onEnter();
                        child.onEnterTransitionDidFinish();
                    }
                    return pos;
                },
                _updateBlendFunc: function() {
                    if (!this.textureAtlas.texture.hasPremultipliedAlpha()) {
                        this._blendFunc.src = cc.SRC_ALPHA;
                        this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA;
                    }
                },
                getTextureAtlas: function() {
                    return this.textureAtlas;
                },
                setTextureAtlas: function(textureAtlas) {
                    this.textureAtlas = textureAtlas;
                }
            });
            var _p = cc.ParticleBatchNode.prototype;
            _p.texture;
            cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
            cc.ParticleBatchNode.create = function(fileImage, capacity) {
                return new cc.ParticleBatchNode(fileImage, capacity);
            };
            !function() {
                cc.ParticleBatchNode.CanvasRenderCmd = function(renderable) {
                    _ccsg.Node.CanvasRenderCmd.call(this, renderable);
                    this._needDraw = false;
                };
                var proto = cc.ParticleBatchNode.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
                proto.constructor = cc.ParticleBatchNode.CanvasRenderCmd;
                proto._initWithTexture = function() {};
            }();
            !function() {
                cc.ParticleBatchNode.WebGLRenderCmd = function(renderable) {
                    _ccsg.Node.WebGLRenderCmd.call(this, renderable);
                    this._needDraw = true;
                };
                var proto = cc.ParticleBatchNode.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
                proto.constructor = cc.ParticleBatchNode.WebGLRenderCmd;
                proto.rendering = function(ctx) {
                    var _t = this._node;
                    if (0 === _t.textureAtlas.totalQuads) {
                        return;
                    }
                    this._shaderProgram.use();
                    this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
                    cc.glBlendFuncForParticle(_t._blendFunc.src, _t._blendFunc.dst);
                    _t.textureAtlas.drawQuads();
                };
                proto._initWithTexture = function() {
                    this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
                };
                proto.visit = function(parentCmd) {
                    var node = this._node;
                    if (!node._visible) {
                        return;
                    }
                    var currentStack = cc.current_stack;
                    currentStack.stack.push(currentStack.top);
                    this._syncStatus(parentCmd);
                    currentStack.top = this._stackMatrix;
                    cc.renderer.pushRenderCommand(this);
                    this._dirtyFlag = 0;
                    cc.kmGLPopMatrix();
                };
            }();
            cc._globalFontSize = cc.ITEM_SIZE;
            cc._globalFontName = "Arial";
            cc._globalFontNameRelease = false;
            cc.MenuItem = _ccsg.Node.extend({
                _enabled: false,
                _target: null,
                _callback: null,
                _isSelected: false,
                _className: "MenuItem",
                ctor: function(callback, target) {
                    var nodeP = _ccsg.Node.prototype;
                    nodeP.ctor.call(this);
                    this._target = null;
                    this._callback = null;
                    this._isSelected = false;
                    this._enabled = false;
                    nodeP.setAnchorPoint.call(this, .5, .5);
                    this._target = target || null;
                    this._callback = callback || null;
                    if (this._callback) {
                        this._enabled = true;
                    }
                },
                isSelected: function() {
                    return this._isSelected;
                },
                setOpacityModifyRGB: function(value) {},
                isOpacityModifyRGB: function() {
                    return false;
                },
                setTarget: function(selector, rec) {
                    this._target = rec;
                    this._callback = selector;
                },
                isEnabled: function() {
                    return this._enabled;
                },
                setEnabled: function(enable) {
                    this._enabled = enable;
                },
                initWithCallback: function(callback, target) {
                    this.anchorX = .5;
                    this.anchorY = .5;
                    this._target = target;
                    this._callback = callback;
                    this._enabled = true;
                    this._isSelected = false;
                    return true;
                },
                rect: function() {
                    var locPosition = this._position, locContentSize = this._contentSize, locAnchorPoint = this._anchorPoint;
                    return cc.rect(locPosition.x - locContentSize.width * locAnchorPoint.x, locPosition.y - locContentSize.height * locAnchorPoint.y, locContentSize.width, locContentSize.height);
                },
                selected: function() {
                    this._isSelected = true;
                },
                unselected: function() {
                    this._isSelected = false;
                },
                setCallback: function(callback, target) {
                    this._target = target;
                    this._callback = callback;
                },
                activate: function() {
                    if (this._enabled) {
                        var locTarget = this._target, locCallback = this._callback;
                        if (!locCallback) {
                            return;
                        }
                        if (locTarget && cc.js.isString(locCallback)) {
                            locTarget[locCallback](this);
                        } else {
                            if (locTarget && cc.js.isFunction(locCallback)) {
                                locCallback.call(locTarget, this);
                            } else {
                                locCallback(this);
                            }
                        }
                    }
                }
            });
            var _p = cc.MenuItem.prototype;
            _p.enabled;
            cc.defineGetterSetter(_p, "enabled", _p.isEnabled, _p.setEnabled);
            cc.MenuItem.create = function(callback, target) {
                return new cc.MenuItem(callback, target);
            };
            cc.MenuItemLabel = cc.MenuItem.extend({
                _disabledColor: null,
                _label: null,
                _originalScale: 0,
                _colorBackup: null,
                ctor: function(label, selector, target) {
                    cc.MenuItem.prototype.ctor.call(this, selector, target);
                    this._disabledColor = null;
                    this._label = null;
                    this._colorBackup = null;
                    if (label) {
                        this._originalScale = 1;
                        this._colorBackup = cc.Color.WHITE;
                        this._disabledColor = cc.color(126, 126, 126);
                        this.setLabel(label);
                        this.setCascadeColorEnabled(true);
                        this.setCascadeOpacityEnabled(true);
                    }
                },
                getDisabledColor: function() {
                    return this._disabledColor;
                },
                setDisabledColor: function(color) {
                    this._disabledColor = color;
                },
                getLabel: function() {
                    return this._label;
                },
                setLabel: function(label) {
                    if (label) {
                        this.addChild(label);
                        label.anchorX = 0;
                        label.anchorY = 0;
                        this.width = label.width;
                        this.height = label.height;
                        label.setCascadeColorEnabled(true);
                    }
                    if (this._label) {
                        this.removeChild(this._label, true);
                    }
                    this._label = label;
                },
                setEnabled: function(enabled) {
                    if (this._enabled !== enabled) {
                        if (!enabled) {
                            this._colorBackup = this.color;
                            this.setColor(this._disabledColor);
                        } else {
                            this.setColor(this._colorBackup);
                        }
                    }
                    cc.MenuItem.prototype.setEnabled.call(this, enabled);
                },
                initWithLabel: function(label, selector, target) {
                    this.initWithCallback(selector, target);
                    this._originalScale = 1;
                    this._colorBackup = cc.Color.WHITE;
                    this._disabledColor = cc.color(126, 126, 126);
                    this.setLabel(label);
                    this.setCascadeColorEnabled(true);
                    this.setCascadeOpacityEnabled(true);
                    return true;
                },
                setString: function(label) {
                    this._label.string = label;
                    this.width = this._label.width;
                    this.height = this._label.height;
                },
                getString: function() {
                    return this._label.string;
                },
                activate: function() {
                    if (this._enabled) {
                        this.stopAllActions();
                        this.scale = this._originalScale;
                        cc.MenuItem.prototype.activate.call(this);
                    }
                },
                selected: function() {
                    if (this._enabled) {
                        cc.MenuItem.prototype.selected.call(this);
                        var action = this.getActionByTag(cc.ZOOM_ACTION_TAG);
                        if (action) {
                            this.stopAction(action);
                        } else {
                            this._originalScale = this.scale;
                        }
                        var zoomAction = cc.scaleTo(.1, 1.2 * this._originalScale);
                        zoomAction.setTag(cc.ZOOM_ACTION_TAG);
                        this.runAction(zoomAction);
                    }
                },
                unselected: function() {
                    if (this._enabled) {
                        cc.MenuItem.prototype.unselected.call(this);
                        this.stopActionByTag(cc.ZOOM_ACTION_TAG);
                        var zoomAction = cc.scaleTo(.1, this._originalScale);
                        zoomAction.setTag(cc.ZOOM_ACTION_TAG);
                        this.runAction(zoomAction);
                    }
                }
            });
            var _p = cc.MenuItemLabel.prototype;
            _p.string;
            cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
            _p.disabledColor;
            cc.defineGetterSetter(_p, "disabledColor", _p.getDisabledColor, _p.setDisabledColor);
            _p.label;
            cc.defineGetterSetter(_p, "label", _p.getLabel, _p.setLabel);
            cc.MenuItemLabel.create = function(label, selector, target) {
                return new cc.MenuItemLabel(label, selector, target);
            };
            cc.MenuItemAtlasFont = cc.MenuItemLabel.extend({
                ctor: function(value, charMapFile, itemWidth, itemHeight, startCharMap, callback, target) {
                    var label;
                    if (value && value.length > 0) {
                        label = new cc.LabelAtlas(value, charMapFile, itemWidth, itemHeight, startCharMap);
                    }
                    cc.MenuItemLabel.prototype.ctor.call(this, label, callback, target);
                },
                initWithString: function(value, charMapFile, itemWidth, itemHeight, startCharMap, callback, target) {
                    if (!value || 0 === value.length) {
                        throw new Error("cc.MenuItemAtlasFont.initWithString(): value should be non-null and its length should be greater than 0");
                    }
                    var label = new cc.LabelAtlas();
                    label.initWithString(value, charMapFile, itemWidth, itemHeight, startCharMap);
                    if (this.initWithLabel(label, callback, target)) {}
                    return true;
                }
            });
            cc.MenuItemAtlasFont.create = function(value, charMapFile, itemWidth, itemHeight, startCharMap, callback, target) {
                return new cc.MenuItemAtlasFont(value, charMapFile, itemWidth, itemHeight, startCharMap, callback, target);
            };
            cc.MenuItemFont = cc.MenuItemLabel.extend({
                _fontSize: null,
                _fontName: null,
                ctor: function(value, callback, target) {
                    var label;
                    if (value && value.length > 0) {
                        this._fontName = cc._globalFontName;
                        this._fontSize = cc._globalFontSize;
                        label = new cc.LabelTTF(value, this._fontName, this._fontSize);
                    } else {
                        this._fontSize = 0;
                        this._fontName = "";
                    }
                    cc.MenuItemLabel.prototype.ctor.call(this, label, callback, target);
                },
                initWithString: function(value, callback, target) {
                    if (!value || 0 === value.length) {
                        throw new Error("Value should be non-null and its length should be greater than 0");
                    }
                    this._fontName = cc._globalFontName;
                    this._fontSize = cc._globalFontSize;
                    var label = new cc.LabelTTF(value, this._fontName, this._fontSize);
                    if (this.initWithLabel(label, callback, target)) {}
                    return true;
                },
                setFontSize: function(s) {
                    this._fontSize = s;
                    this._recreateLabel();
                },
                getFontSize: function() {
                    return this._fontSize;
                },
                setFontName: function(name) {
                    this._fontName = name;
                    this._recreateLabel();
                },
                getFontName: function() {
                    return this._fontName;
                },
                _recreateLabel: function() {
                    var label = new cc.LabelTTF(this._label.string, this._fontName, this._fontSize);
                    this.setLabel(label);
                }
            });
            cc.MenuItemFont.setFontSize = function(fontSize) {
                cc._globalFontSize = fontSize;
            };
            cc.MenuItemFont.fontSize = function() {
                return cc._globalFontSize;
            };
            cc.MenuItemFont.setFontName = function(name) {
                if (cc._globalFontNameRelease) {
                    cc._globalFontName = "";
                }
                cc._globalFontName = name;
                cc._globalFontNameRelease = true;
            };
            var _p = cc.MenuItemFont.prototype;
            _p.fontSize;
            cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize);
            _p.fontName;
            cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName);
            cc.MenuItemFont.fontName = function() {
                return cc._globalFontName;
            };
            cc.MenuItemFont.create = function(value, callback, target) {
                return new cc.MenuItemFont(value, callback, target);
            };
            cc.MenuItemSprite = cc.MenuItem.extend({
                _normalImage: null,
                _selectedImage: null,
                _disabledImage: null,
                ctor: function(normalSprite, selectedSprite, three, four, five) {
                    cc.MenuItem.prototype.ctor.call(this);
                    this._normalImage = null;
                    this._selectedImage = null;
                    this._disabledImage = null;
                    if (void 0 !== selectedSprite) {
                        var disabledImage, target, callback;
                        if (void 0 !== five) {
                            disabledImage = three;
                            callback = four;
                            target = five;
                        } else {
                            if (void 0 !== four && cc.js.isFunction(four)) {
                                disabledImage = three;
                                callback = four;
                            } else {
                                if (void 0 !== four && cc.js.isFunction(three)) {
                                    target = four;
                                    callback = three;
                                    disabledImage = null;
                                } else {
                                    if (void 0 === three) {
                                        disabledImage = null;
                                    }
                                }
                            }
                        }
                        this.initWithNormalSprite(normalSprite, selectedSprite, disabledImage, callback, target);
                    }
                },
                getNormalImage: function() {
                    return this._normalImage;
                },
                setNormalImage: function(normalImage) {
                    if (this._normalImage === normalImage) {
                        return;
                    }
                    if (normalImage) {
                        this.addChild(normalImage, 0, cc.NORMAL_TAG);
                        normalImage.anchorX = 0;
                        normalImage.anchorY = 0;
                    }
                    if (this._normalImage) {
                        this.removeChild(this._normalImage, true);
                    }
                    this._normalImage = normalImage;
                    if (!this._normalImage) {
                        return;
                    }
                    this.width = this._normalImage.width;
                    this.height = this._normalImage.height;
                    this._updateImagesVisibility();
                    if (normalImage.textureLoaded && !normalImage.textureLoaded()) {
                        normalImage.once("load", function(event) {
                            this.width = normalImage.width;
                            this.height = normalImage.height;
                        }, this);
                    }
                },
                getSelectedImage: function() {
                    return this._selectedImage;
                },
                setSelectedImage: function(selectedImage) {
                    if (this._selectedImage === selectedImage) {
                        return;
                    }
                    if (selectedImage) {
                        this.addChild(selectedImage, 0, cc.SELECTED_TAG);
                        selectedImage.anchorX = 0;
                        selectedImage.anchorY = 0;
                    }
                    if (this._selectedImage) {
                        this.removeChild(this._selectedImage, true);
                    }
                    this._selectedImage = selectedImage;
                    this._updateImagesVisibility();
                },
                getDisabledImage: function() {
                    return this._disabledImage;
                },
                setDisabledImage: function(disabledImage) {
                    if (this._disabledImage === disabledImage) {
                        return;
                    }
                    if (disabledImage) {
                        this.addChild(disabledImage, 0, cc.DISABLE_TAG);
                        disabledImage.anchorX = 0;
                        disabledImage.anchorY = 0;
                    }
                    if (this._disabledImage) {
                        this.removeChild(this._disabledImage, true);
                    }
                    this._disabledImage = disabledImage;
                    this._updateImagesVisibility();
                },
                initWithNormalSprite: function(normalSprite, selectedSprite, disabledSprite, callback, target) {
                    this.initWithCallback(callback, target);
                    this.setNormalImage(normalSprite);
                    this.setSelectedImage(selectedSprite);
                    this.setDisabledImage(disabledSprite);
                    var locNormalImage = this._normalImage;
                    if (locNormalImage) {
                        this.width = locNormalImage.width;
                        this.height = locNormalImage.height;
                        if (locNormalImage.textureLoaded && !locNormalImage.textureLoaded()) {
                            locNormalImage.once("load", function(event) {
                                this.width = locNormalImage.width;
                                this.height = locNormalImage.height;
                                this.setCascadeColorEnabled(true);
                                this.setCascadeOpacityEnabled(true);
                            }, this);
                        }
                    }
                    this.setCascadeColorEnabled(true);
                    this.setCascadeOpacityEnabled(true);
                    return true;
                },
                selected: function() {
                    cc.MenuItem.prototype.selected.call(this);
                    if (this._normalImage) {
                        if (this._disabledImage) {
                            this._disabledImage.visible = false;
                        }
                        if (this._selectedImage) {
                            this._normalImage.visible = false;
                            this._selectedImage.visible = true;
                        } else {
                            this._normalImage.visible = true;
                        }
                    }
                },
                unselected: function() {
                    cc.MenuItem.prototype.unselected.call(this);
                    if (this._normalImage) {
                        this._normalImage.visible = true;
                        if (this._selectedImage) {
                            this._selectedImage.visible = false;
                        }
                        if (this._disabledImage) {
                            this._disabledImage.visible = false;
                        }
                    }
                },
                setEnabled: function(bEnabled) {
                    if (this._enabled !== bEnabled) {
                        cc.MenuItem.prototype.setEnabled.call(this, bEnabled);
                        this._updateImagesVisibility();
                    }
                },
                _updateImagesVisibility: function() {
                    var locNormalImage = this._normalImage, locSelImage = this._selectedImage, locDisImage = this._disabledImage;
                    if (this._enabled) {
                        if (locNormalImage) {
                            locNormalImage.visible = true;
                        }
                        if (locSelImage) {
                            locSelImage.visible = false;
                        }
                        if (locDisImage) {
                            locDisImage.visible = false;
                        }
                    } else {
                        if (locDisImage) {
                            if (locNormalImage) {
                                locNormalImage.visible = false;
                            }
                            if (locSelImage) {
                                locSelImage.visible = false;
                            }
                            if (locDisImage) {
                                locDisImage.visible = true;
                            }
                        } else {
                            if (locNormalImage) {
                                locNormalImage.visible = true;
                            }
                            if (locSelImage) {
                                locSelImage.visible = false;
                            }
                        }
                    }
                }
            });
            var _p = cc.MenuItemSprite.prototype;
            _p.normalImage;
            cc.defineGetterSetter(_p, "normalImage", _p.getNormalImage, _p.setNormalImage);
            _p.selectedImage;
            cc.defineGetterSetter(_p, "selectedImage", _p.getSelectedImage, _p.setSelectedImage);
            _p.disabledImage;
            cc.defineGetterSetter(_p, "disabledImage", _p.getDisabledImage, _p.setDisabledImage);
            cc.MenuItemSprite.create = function(normalSprite, selectedSprite, three, four, five) {
                return new cc.MenuItemSprite(normalSprite, selectedSprite, three, four, five || void 0);
            };
            cc.MenuItemImage = cc.MenuItemSprite.extend({
                ctor: function(normalImage, selectedImage, three, four, five) {
                    var normalSprite = null, selectedSprite = null, disabledSprite = null, callback = null, target = null;
                    if (void 0 === normalImage || null === normalImage) {
                        cc.MenuItemSprite.prototype.ctor.call(this);
                    } else {
                        normalSprite = new _ccsg.Sprite(normalImage);
                        selectedImage && (selectedSprite = new _ccsg.Sprite(selectedImage));
                        if (void 0 === four) {
                            callback = three;
                        } else {
                            if (void 0 === five) {
                                callback = three;
                                target = four;
                            } else {
                                if (five) {
                                    disabledSprite = new _ccsg.Sprite(three);
                                    callback = four;
                                    target = five;
                                }
                            }
                        }
                        cc.MenuItemSprite.prototype.ctor.call(this, normalSprite, selectedSprite, disabledSprite, callback, target);
                    }
                },
                setNormalSpriteFrame: function(frame) {
                    this.setNormalImage(new _ccsg.Sprite(frame));
                },
                setSelectedSpriteFrame: function(frame) {
                    this.setSelectedImage(new _ccsg.Sprite(frame));
                },
                setDisabledSpriteFrame: function(frame) {
                    this.setDisabledImage(new _ccsg.Sprite(frame));
                },
                initWithNormalImage: function(normalImage, selectedImage, disabledImage, callback, target) {
                    var normalSprite = null;
                    var selectedSprite = null;
                    var disabledSprite = null;
                    if (normalImage) {
                        normalSprite = new _ccsg.Sprite(normalImage);
                    }
                    if (selectedImage) {
                        selectedSprite = new _ccsg.Sprite(selectedImage);
                    }
                    if (disabledImage) {
                        disabledSprite = new _ccsg.Sprite(disabledImage);
                    }
                    return this.initWithNormalSprite(normalSprite, selectedSprite, disabledSprite, callback, target);
                }
            });
            cc.MenuItemImage.create = function(normalImage, selectedImage, three, four, five) {
                return new cc.MenuItemImage(normalImage, selectedImage, three, four, five);
            };
            cc.MenuItemToggle = cc.MenuItem.extend({
                subItems: null,
                _selectedIndex: 0,
                _opacity: null,
                _color: null,
                ctor: function() {
                    cc.MenuItem.prototype.ctor.call(this);
                    this._selectedIndex = 0;
                    this.subItems = [];
                    this._opacity = 0;
                    this._color = cc.Color.WHITE;
                    if (arguments.length > 0) {
                        this.initWithItems(Array.prototype.slice.apply(arguments));
                    }
                },
                getOpacity: function() {
                    return this._opacity;
                },
                setOpacity: function(opacity) {
                    this._opacity = opacity;
                    if (this.subItems && this.subItems.length > 0) {
                        for (var it = 0; it < this.subItems.length; it++) {
                            this.subItems[it].opacity = opacity;
                        }
                    }
                    this._color.a = opacity;
                },
                getColor: function() {
                    var locColor = this._color;
                    return cc.color(locColor.r, locColor.g, locColor.b, locColor.a);
                },
                setColor: function(color) {
                    var locColor = this._color;
                    locColor.r = color.r;
                    locColor.g = color.g;
                    locColor.b = color.b;
                    if (this.subItems && this.subItems.length > 0) {
                        for (var it = 0; it < this.subItems.length; it++) {
                            this.subItems[it].setColor(color);
                        }
                    }
                    if (void 0 !== color.a && !color.a_undefined) {
                        this.setOpacity(color.a);
                    }
                },
                getSelectedIndex: function() {
                    return this._selectedIndex;
                },
                setSelectedIndex: function(SelectedIndex) {
                    if (SelectedIndex !== this._selectedIndex) {
                        this._selectedIndex = SelectedIndex;
                        var currItem = this.getChildByTag(cc.CURRENT_ITEM);
                        if (currItem) {
                            currItem.removeFromParent(false);
                        }
                        var item = this.subItems[this._selectedIndex];
                        this.addChild(item, 0, cc.CURRENT_ITEM);
                        var w = item.width, h = item.height;
                        this.width = w;
                        this.height = h;
                        item.setPosition(w / 2, h / 2);
                    }
                },
                getSubItems: function() {
                    return this.subItems;
                },
                setSubItems: function(subItems) {
                    this.subItems = subItems;
                },
                initWithItems: function(args) {
                    var l = args.length;
                    if (cc.js.isFunction(args[args.length - 2])) {
                        this.initWithCallback(args[args.length - 2], args[args.length - 1]);
                        l -= 2;
                    } else {
                        if (cc.js.isFunction(args[args.length - 1])) {
                            this.initWithCallback(args[args.length - 1], null);
                            l -= 1;
                        } else {
                            this.initWithCallback(null, null);
                        }
                    }
                    var locSubItems = this.subItems;
                    locSubItems.length = 0;
                    for (var i = 0; i < l; i++) {
                        if (args[i]) {
                            locSubItems.push(args[i]);
                        }
                    }
                    this._selectedIndex = cc.UINT_MAX;
                    this.setSelectedIndex(0);
                    this.setCascadeColorEnabled(true);
                    this.setCascadeOpacityEnabled(true);
                    return true;
                },
                addSubItem: function(item) {
                    this.subItems.push(item);
                },
                activate: function() {
                    if (this._enabled) {
                        var newIndex = (this._selectedIndex + 1) % this.subItems.length;
                        this.setSelectedIndex(newIndex);
                    }
                    cc.MenuItem.prototype.activate.call(this);
                },
                selected: function() {
                    cc.MenuItem.prototype.selected.call(this);
                    this.subItems[this._selectedIndex].selected();
                },
                unselected: function() {
                    cc.MenuItem.prototype.unselected.call(this);
                    this.subItems[this._selectedIndex].unselected();
                },
                setEnabled: function(enabled) {
                    if (this._enabled !== enabled) {
                        cc.MenuItem.prototype.setEnabled.call(this, enabled);
                        var locItems = this.subItems;
                        if (locItems && locItems.length > 0) {
                            for (var it = 0; it < locItems.length; it++) {
                                locItems[it].enabled = enabled;
                            }
                        }
                    }
                },
                selectedItem: function() {
                    return this.subItems[this._selectedIndex];
                },
                getSelectedItem: function() {
                    return this.subItems[this._selectedIndex];
                },
                onEnter: function() {
                    _ccsg.Node.prototype.onEnter.call(this);
                    this.setSelectedIndex(this._selectedIndex);
                }
            });
            var _p = cc.MenuItemToggle.prototype;
            _p.selectedIndex;
            cc.defineGetterSetter(_p, "selectedIndex", _p.getSelectedIndex, _p.setSelectedIndex);
            cc.MenuItemToggle.create = function() {
                if (arguments.length > 0 && null == arguments[arguments.length - 1]) {
                    cc.log("parameters should not be ending with null in Javascript");
                }
                var ret = new cc.MenuItemToggle();
                ret.initWithItems(Array.prototype.slice.apply(arguments));
                return ret;
            };
            cc.MENU_STATE_WAITING = 0;
            cc.MENU_STATE_TRACKING_TOUCH = 1;
            cc.MENU_HANDLER_PRIORITY = -128;
            cc.DEFAULT_PADDING = 5;
            cc.Menu = cc.Layer.extend({
                enabled: false,
                _selectedItem: null,
                _state: -1,
                _touchListener: null,
                _className: "Menu",
                ctor: function(menuItems) {
                    cc.Layer.prototype.ctor.call(this);
                    this._color = cc.Color.WHITE;
                    this.enabled = false;
                    this._opacity = 255;
                    this._selectedItem = null;
                    this._state = -1;
                    this._touchListener = cc.EventListener.create({
                        event: cc.EventListener.TOUCH_ONE_BY_ONE,
                        swallowTouches: true,
                        onTouchBegan: this._onTouchBegan,
                        onTouchMoved: this._onTouchMoved,
                        onTouchEnded: this._onTouchEnded,
                        onTouchCancelled: this._onTouchCancelled
                    });
                    if (arguments.length > 0 && null == arguments[arguments.length - 1]) {
                        cc.log("parameters should not be ending with null in Javascript");
                    }
                    var argc = arguments.length, items;
                    if (0 === argc) {
                        items = [];
                    } else {
                        if (1 === argc) {
                            if (menuItems instanceof Array) {
                                items = menuItems;
                            } else {
                                items = [ menuItems ];
                            }
                        } else {
                            if (argc > 1) {
                                items = [];
                                for (var i = 0; i < argc; i++) {
                                    if (arguments[i]) {
                                        items.push(arguments[i]);
                                    }
                                }
                            }
                        }
                    }
                    this.initWithArray(items);
                },
                onEnter: function() {
                    var locListener = this._touchListener;
                    if (!locListener._isRegistered()) {
                        cc.eventManager.addListener(locListener, this);
                    }
                    _ccsg.Node.prototype.onEnter.call(this);
                },
                isEnabled: function() {
                    return this.enabled;
                },
                setEnabled: function(enabled) {
                    this.enabled = enabled;
                },
                initWithItems: function(args) {
                    var pArray = [];
                    if (args) {
                        for (var i = 0; i < args.length; i++) {
                            if (args[i]) {
                                pArray.push(args[i]);
                            }
                        }
                    }
                    return this.initWithArray(pArray);
                },
                initWithArray: function(arrayOfItems) {
                    if (cc.Layer.prototype.init.call(this)) {
                        this.enabled = true;
                        var winSize = cc.winSize;
                        this.setPosition(winSize.width / 2, winSize.height / 2);
                        this.setContentSize(winSize);
                        this.setAnchorPoint(.5, .5);
                        this.ignoreAnchorPointForPosition(true);
                        if (arrayOfItems) {
                            for (var i = 0; i < arrayOfItems.length; i++) {
                                this.addChild(arrayOfItems[i], i);
                            }
                        }
                        this._selectedItem = null;
                        this._state = cc.MENU_STATE_WAITING;
                        this.cascadeColor = true;
                        this.cascadeOpacity = true;
                        return true;
                    }
                    return false;
                },
                addChild: function(child, zOrder, tag) {
                    if (!(child instanceof cc.MenuItem)) {
                        throw new Error("cc.Menu.addChild() : Menu only supports MenuItem objects as children");
                    }
                    cc.Layer.prototype.addChild.call(this, child, zOrder, tag);
                },
                alignItemsVertically: function() {
                    this.alignItemsVerticallyWithPadding(cc.DEFAULT_PADDING);
                },
                alignItemsVerticallyWithPadding: function(padding) {
                    var height = -padding, locChildren = this._children, len, i, locScaleY, locHeight, locChild;
                    if (locChildren && locChildren.length > 0) {
                        for (i = 0, len = locChildren.length; i < len; i++) {
                            height += locChildren[i].height * locChildren[i].scaleY + padding;
                        }
                        var y = height / 2;
                        for (i = 0, len = locChildren.length; i < len; i++) {
                            locChild = locChildren[i];
                            locHeight = locChild.height;
                            locScaleY = locChild.scaleY;
                            locChild.setPosition(0, y - locHeight * locScaleY / 2);
                            y -= locHeight * locScaleY + padding;
                        }
                    }
                },
                alignItemsHorizontally: function() {
                    this.alignItemsHorizontallyWithPadding(cc.DEFAULT_PADDING);
                },
                alignItemsHorizontallyWithPadding: function(padding) {
                    var width = -padding, locChildren = this._children, i, len, locScaleX, locWidth, locChild;
                    if (locChildren && locChildren.length > 0) {
                        for (i = 0, len = locChildren.length; i < len; i++) {
                            width += locChildren[i].width * locChildren[i].scaleX + padding;
                        }
                        var x = -width / 2;
                        for (i = 0, len = locChildren.length; i < len; i++) {
                            locChild = locChildren[i];
                            locScaleX = locChild.scaleX;
                            locWidth = locChildren[i].width;
                            locChild.setPosition(x + locWidth * locScaleX / 2, 0);
                            x += locWidth * locScaleX + padding;
                        }
                    }
                },
                alignItemsInColumns: function() {
                    if (arguments.length > 0 && null == arguments[arguments.length - 1]) {
                        cc.log("parameters should not be ending with null in Javascript");
                    }
                    var rows = [];
                    for (var i = 0; i < arguments.length; i++) {
                        rows.push(arguments[i]);
                    }
                    var height = -5;
                    var row = 0;
                    var rowHeight = 0;
                    var columnsOccupied = 0;
                    var rowColumns, tmp, len;
                    var locChildren = this._children;
                    if (locChildren && locChildren.length > 0) {
                        for (i = 0, len = locChildren.length; i < len; i++) {
                            if (row >= rows.length) {
                                continue;
                            }
                            rowColumns = rows[row];
                            if (!rowColumns) {
                                continue;
                            }
                            tmp = locChildren[i].height;
                            rowHeight = rowHeight >= tmp || isNaN(tmp) ? rowHeight : tmp;
                            ++columnsOccupied;
                            if (columnsOccupied >= rowColumns) {
                                height += rowHeight + 5;
                                columnsOccupied = 0;
                                rowHeight = 0;
                                ++row;
                            }
                        }
                    }
                    var winSize = cc.director.getWinSize();
                    row = 0;
                    rowHeight = 0;
                    rowColumns = 0;
                    var w = 0;
                    var x = 0;
                    var y = height / 2;
                    if (locChildren && locChildren.length > 0) {
                        for (i = 0, len = locChildren.length; i < len; i++) {
                            var child = locChildren[i];
                            if (0 === rowColumns) {
                                rowColumns = rows[row];
                                w = winSize.width / (1 + rowColumns);
                                x = w;
                            }
                            tmp = child._getHeight();
                            rowHeight = rowHeight >= tmp || isNaN(tmp) ? rowHeight : tmp;
                            child.setPosition(x - winSize.width / 2, y - tmp / 2);
                            x += w;
                            ++columnsOccupied;
                            if (columnsOccupied >= rowColumns) {
                                y -= rowHeight + 5;
                                columnsOccupied = 0;
                                rowColumns = 0;
                                rowHeight = 0;
                                ++row;
                            }
                        }
                    }
                },
                alignItemsInRows: function() {
                    if (arguments.length > 0 && null == arguments[arguments.length - 1]) {
                        cc.log("parameters should not be ending with null in Javascript");
                    }
                    var columns = [], i;
                    for (i = 0; i < arguments.length; i++) {
                        columns.push(arguments[i]);
                    }
                    var columnWidths = [];
                    var columnHeights = [];
                    var width = -10;
                    var columnHeight = -5;
                    var column = 0;
                    var columnWidth = 0;
                    var rowsOccupied = 0;
                    var columnRows, child, len, tmp;
                    var locChildren = this._children;
                    if (locChildren && locChildren.length > 0) {
                        for (i = 0, len = locChildren.length; i < len; i++) {
                            child = locChildren[i];
                            if (column >= columns.length) {
                                continue;
                            }
                            columnRows = columns[column];
                            if (!columnRows) {
                                continue;
                            }
                            tmp = child.width;
                            columnWidth = columnWidth >= tmp || isNaN(tmp) ? columnWidth : tmp;
                            columnHeight += child.height + 5;
                            ++rowsOccupied;
                            if (rowsOccupied >= columnRows) {
                                columnWidths.push(columnWidth);
                                columnHeights.push(columnHeight);
                                width += columnWidth + 10;
                                rowsOccupied = 0;
                                columnWidth = 0;
                                columnHeight = -5;
                                ++column;
                            }
                        }
                    }
                    var winSize = cc.director.getWinSize();
                    column = 0;
                    columnWidth = 0;
                    columnRows = 0;
                    var x = -width / 2;
                    var y = 0;
                    if (locChildren && locChildren.length > 0) {
                        for (i = 0, len = locChildren.length; i < len; i++) {
                            child = locChildren[i];
                            if (0 === columnRows) {
                                columnRows = columns[column];
                                y = columnHeights[column];
                            }
                            tmp = child._getWidth();
                            columnWidth = columnWidth >= tmp || isNaN(tmp) ? columnWidth : tmp;
                            child.setPosition(x + columnWidths[column] / 2, y - winSize.height / 2);
                            y -= child.height + 10;
                            ++rowsOccupied;
                            if (rowsOccupied >= columnRows) {
                                x += columnWidth + 5;
                                rowsOccupied = 0;
                                columnRows = 0;
                                columnWidth = 0;
                                ++column;
                            }
                        }
                    }
                },
                removeChild: function(child, cleanup) {
                    if (null == child) {
                        return;
                    }
                    if (!(child instanceof cc.MenuItem)) {
                        cc.log("cc.Menu.removeChild():Menu only supports MenuItem objects as children");
                        return;
                    }
                    if (this._selectedItem === child) {
                        this._selectedItem = null;
                    }
                    _ccsg.Node.prototype.removeChild.call(this, child, cleanup);
                },
                _onTouchBegan: function(touch, event) {
                    var target = event.getCurrentTarget();
                    if (target._state !== cc.MENU_STATE_WAITING || !target._visible || !target.enabled) {
                        return false;
                    }
                    for (var c = target.parent; null != c; c = c.parent) {
                        if (!c.isVisible()) {
                            return false;
                        }
                    }
                    target._selectedItem = target._itemForTouch(touch);
                    if (target._selectedItem) {
                        target._state = cc.MENU_STATE_TRACKING_TOUCH;
                        target._selectedItem.selected();
                        target._selectedItem.setNodeDirty();
                        return true;
                    }
                    return false;
                },
                _onTouchEnded: function(touch, event) {
                    var target = event.getCurrentTarget();
                    if (target._state !== cc.MENU_STATE_TRACKING_TOUCH) {
                        cc.log("cc.Menu.onTouchEnded(): invalid state");
                        return;
                    }
                    if (target._selectedItem) {
                        target._selectedItem.unselected();
                        target._selectedItem.setNodeDirty();
                        target._selectedItem.activate();
                    }
                    target._state = cc.MENU_STATE_WAITING;
                },
                _onTouchCancelled: function(touch, event) {
                    var target = event.getCurrentTarget();
                    if (target._state !== cc.MENU_STATE_TRACKING_TOUCH) {
                        cc.log("cc.Menu.onTouchCancelled(): invalid state");
                        return;
                    }
                    if (target._selectedItem) {
                        target._selectedItem.unselected();
                        target._selectedItem.setNodeDirty();
                    }
                    target._state = cc.MENU_STATE_WAITING;
                },
                _onTouchMoved: function(touch, event) {
                    var target = event.getCurrentTarget();
                    if (target._state !== cc.MENU_STATE_TRACKING_TOUCH) {
                        cc.log("cc.Menu.onTouchMoved(): invalid state");
                        return;
                    }
                    var currentItem = target._itemForTouch(touch);
                    if (currentItem !== target._selectedItem) {
                        if (target._selectedItem) {
                            target._selectedItem.unselected();
                            target._selectedItem.setNodeDirty();
                        }
                        target._selectedItem = currentItem;
                        if (target._selectedItem) {
                            target._selectedItem.selected();
                            target._selectedItem.setNodeDirty();
                        }
                    }
                },
                onExit: function() {
                    if (this._state === cc.MENU_STATE_TRACKING_TOUCH) {
                        if (this._selectedItem) {
                            this._selectedItem.unselected();
                            this._selectedItem = null;
                        }
                        this._state = cc.MENU_STATE_WAITING;
                    }
                    _ccsg.Node.prototype.onExit.call(this);
                },
                setOpacityModifyRGB: function(value) {},
                isOpacityModifyRGB: function() {
                    return false;
                },
                _itemForTouch: function(touch) {
                    var touchLocation = touch.getLocation();
                    var itemChildren = this._children, locItemChild;
                    if (itemChildren && itemChildren.length > 0) {
                        for (var i = itemChildren.length - 1; i >= 0; i--) {
                            locItemChild = itemChildren[i];
                            if (locItemChild.isVisible() && locItemChild.isEnabled()) {
                                var local = locItemChild.convertToNodeSpace(touchLocation);
                                var r = locItemChild.rect();
                                r.x = 0;
                                r.y = 0;
                                if (cc.rectContainsPoint(r, local)) {
                                    return locItemChild;
                                }
                            }
                        }
                    }
                    return null;
                }
            });
            var _p = cc.Menu.prototype;
            _p.enabled;
            cc.Menu.create = function(menuItems) {
                var argc = arguments.length;
                if (argc > 0 && null == arguments[argc - 1]) {
                    cc.log("parameters should not be ending with null in Javascript");
                }
                var ret;
                if (0 === argc) {
                    ret = new cc.Menu();
                } else {
                    if (1 === argc) {
                        ret = new cc.Menu(menuItems);
                    } else {
                        ret = new cc.Menu(Array.prototype.slice.call(arguments, 0));
                    }
                }
                return ret;
            };
            cc.TGA_OK = 0;
            cc.TGA_ERROR_FILE_OPEN = 1;
            cc.TGA_ERROR_READING_FILE = 2;
            cc.TGA_ERROR_INDEXED_COLOR = 3;
            cc.TGA_ERROR_MEMORY = 4;
            cc.TGA_ERROR_COMPRESSED_FILE = 5;
            cc.ImageTGA = function(status, type, pixelDepth, width, height, imageData, flipped) {
                this.status = status || 0;
                this.type = type || 0;
                this.pixelDepth = pixelDepth || 0;
                this.width = width || 0;
                this.height = height || 0;
                this.imageData = imageData || [];
                this.flipped = flipped || 0;
            };
            cc.tgaLoadHeader = function(buffer, bufSize, psInfo) {
                var step = 2;
                if (step + 1 > bufSize) {
                    return false;
                }
                var binaryReader = new cc.BinaryStreamReader(buffer);
                binaryReader.setOffset(step);
                psInfo.type = binaryReader.readByte();
                step += 10;
                if (step + 4 + 1 > bufSize) {
                    return false;
                }
                binaryReader.setOffset(step);
                psInfo.width = binaryReader.readUnsignedShort();
                psInfo.height = binaryReader.readUnsignedInteger();
                psInfo.pixelDepth = binaryReader.readByte();
                step += 5;
                if (step + 1 > bufSize) {
                    return false;
                }
                var garbage = binaryReader.readByte();
                psInfo.flipped = 0;
                if (32 & garbage) {
                    psInfo.flipped = 1;
                }
                return true;
            };
            cc.tgaLoadImageData = function(buffer, bufSize, psInfo) {
                var mode, total, i, aux;
                var step = 18;
                mode = 0 | psInfo.pixelDepth / 2;
                total = psInfo.height * psInfo.width * mode;
                if (step + total > bufSize) {
                    return false;
                }
                psInfo.imageData = cc.__getSubArray(buffer, step, step + total);
                if (mode >= 3) {
                    for (i = 0; i < total; i += mode) {
                        aux = psInfo.imageData[i];
                        psInfo.imageData[i] = psInfo.imageData[i + 2];
                        psInfo.imageData[i + 2] = aux;
                    }
                }
                return true;
            };
            cc.tgaRGBtogreyscale = function(psInfo) {
                var i, j;
                if (8 === psInfo.pixelDepth) {
                    return;
                }
                var mode = psInfo.pixelDepth / 8;
                var newImageData = new Uint8Array(psInfo.height * psInfo.width);
                if (null === newImageData) {
                    return;
                }
                for (i = 0, j = 0; j < psInfo.width * psInfo.height; i += mode, j++) {
                    newImageData[j] = .3 * psInfo.imageData[i] + .59 * psInfo.imageData[i + 1] + .11 * psInfo.imageData[i + 2];
                }
                psInfo.pixelDepth = 8;
                psInfo.type = 3;
                psInfo.imageData = newImageData;
            };
            cc.tgaDestroy = function(psInfo) {
                if (!psInfo) {
                    return;
                }
                psInfo.imageData = null;
                psInfo = null;
            };
            cc.tgaLoadRLEImageData = function(buffer, bufSize, psInfo) {
                var mode, total, i, index = 0, skip = 0, flag = 0;
                var aux = [], runlength = 0;
                var step = 18;
                mode = psInfo.pixelDepth / 8;
                total = psInfo.height * psInfo.width;
                for (i = 0; i < total; i++) {
                    if (0 !== runlength) {
                        runlength--;
                        skip = 0 !== flag;
                    } else {
                        if (step + 1 > bufSize) {
                            break;
                        }
                        runlength = buffer[step];
                        step += 1;
                        flag = 128 & runlength;
                        if (flag) {
                            runlength -= 128;
                        }
                        skip = 0;
                    }
                    if (!skip) {
                        if (step + mode > bufSize) {
                            break;
                        }
                        aux = cc.__getSubArray(buffer, step, step + mode);
                        step += mode;
                        if (mode >= 3) {
                            var tmp = aux[0];
                            aux[0] = aux[2];
                            aux[2] = tmp;
                        }
                    }
                    for (var j = 0; j < mode; j++) {
                        psInfo.imageData[index + j] = aux[j];
                    }
                    index += mode;
                }
                return true;
            };
            cc.tgaFlipImage = function(psInfo) {
                var mode = psInfo.pixelDepth / 8;
                var rowbytes = psInfo.width * mode;
                for (var y = 0; y < psInfo.height / 2; y++) {
                    var row = cc.__getSubArray(psInfo.imageData, y * rowbytes, y * rowbytes + rowbytes);
                    cc.__setDataToArray(cc.__getSubArray(psInfo.imageData, (psInfo.height - (y + 1)) * rowbytes, rowbytes), psInfo.imageData, y * rowbytes);
                    cc.__setDataToArray(row, psInfo.imageData, (psInfo.height - (y + 1)) * rowbytes);
                }
                psInfo.flipped = 0;
            };
            cc.__getSubArray = function(array, start, end) {
                if (array instanceof Array) {
                    return array.slice(start, end);
                } else {
                    return array.subarray(start, end);
                }
            };
            cc.__setDataToArray = function(sourceData, destArray, startIndex) {
                for (var i = 0; i < sourceData.length; i++) {
                    destArray[startIndex + i] = sourceData[i];
                }
            };
            cc.BinaryStreamReader = cc._Class.extend({
                _binaryData: null,
                _offset: 0,
                ctor: function(binaryData) {
                    this._binaryData = binaryData;
                },
                setBinaryData: function(binaryData) {
                    this._binaryData = binaryData;
                    this._offset = 0;
                },
                getBinaryData: function() {
                    return this._binaryData;
                },
                _checkSize: function(neededBits) {
                    if (!(this._offset + Math.ceil(neededBits / 8) < this._data.length)) {
                        throw new Error("Index out of bound");
                    }
                },
                _decodeFloat: function(precisionBits, exponentBits) {
                    var length = precisionBits + exponentBits + 1;
                    var size = length >> 3;
                    this._checkSize(length);
                    var bias = Math.pow(2, exponentBits - 1) - 1;
                    var signal = this._readBits(precisionBits + exponentBits, 1, size);
                    var exponent = this._readBits(precisionBits, exponentBits, size);
                    var significand = 0;
                    var divisor = 2;
                    var curByte = 0;
                    do {
                        var byteValue = this._readByte(++curByte, size);
                        var startBit = precisionBits % 8 || 8;
                        var mask = 1 << startBit;
                        while (mask >>= 1) {
                            if (byteValue & mask) {
                                significand += 1 / divisor;
                            }
                            divisor *= 2;
                        }
                    } while (precisionBits -= startBit);
                    this._offset += size;
                    return exponent === (bias << 1) + 1 ? significand ? 0 / 0 : signal ? -(1 / 0) : +(1 / 0) : (1 + -2 * signal) * (exponent || significand ? !exponent ? Math.pow(2, -bias + 1) * significand : Math.pow(2, exponent - bias) * (1 + significand) : 0);
                },
                _readByte: function(i, size) {
                    return this._data[this._offset + size - i - 1];
                },
                _decodeInt: function(bits, signed) {
                    var x = this._readBits(0, bits, bits / 8), max = Math.pow(2, bits);
                    var result = signed && x >= max / 2 ? x - max : x;
                    this._offset += bits / 8;
                    return result;
                },
                _shl: function(a, b) {
                    for (++b; --b; a = 1073741824 === (1073741824 & (a %= 2147483648)) ? 2 * a : 2 * (a - 1073741824) + 2147483647 + 1) {}
                    return a;
                },
                _readBits: function(start, length, size) {
                    var offsetLeft = (start + length) % 8;
                    var offsetRight = start % 8;
                    var curByte = size - (start >> 3) - 1;
                    var lastByte = size + (-(start + length) >> 3);
                    var diff = curByte - lastByte;
                    var sum = this._readByte(curByte, size) >> offsetRight & (1 << (diff ? 8 - offsetRight : length)) - 1;
                    if (diff && offsetLeft) {
                        sum += (this._readByte(lastByte++, size) & (1 << offsetLeft) - 1) << (diff-- << 3) - offsetRight;
                    }
                    while (diff) {
                        sum += this._shl(this._readByte(lastByte++, size), (diff-- << 3) - offsetRight);
                    }
                    return sum;
                },
                readInteger: function() {
                    return this._decodeInt(32, true);
                },
                readUnsignedInteger: function() {
                    return this._decodeInt(32, false);
                },
                readSingle: function() {
                    return this._decodeFloat(23, 8);
                },
                readShort: function() {
                    return this._decodeInt(16, true);
                },
                readUnsignedShort: function() {
                    return this._decodeInt(16, false);
                },
                readByte: function() {
                    var readByte = this._data[this._offset];
                    this._offset += 1;
                    return readByte;
                },
                readData: function(start, end) {
                    if (this._binaryData instanceof Array) {
                        return this._binaryData.slice(start, end);
                    } else {
                        return this._binaryData.subarray(start, end);
                    }
                },
                setOffset: function(offset) {
                    this._offset = offset;
                },
                getOffset: function() {
                    return this._offset;
                }
            });
            cc.TMX_ORIENTATION_ORTHO = 0;
            cc.TMX_ORIENTATION_HEX = 1;
            cc.TMX_ORIENTATION_ISO = 2;
            cc.TMXTiledMap = _ccsg.Node.extend({
                properties: null,
                mapOrientation: null,
                objectGroups: null,
                _mapSize: null,
                _tileSize: null,
                _tileProperties: null,
                _className: "TMXTiledMap",
                ctor: function(tmxFile, resourcePath) {
                    _ccsg.Node.prototype.ctor.call(this);
                    this._mapSize = cc.size(0, 0);
                    this._tileSize = cc.size(0, 0);
                    if (void 0 !== resourcePath) {
                        this.initWithXML(tmxFile, resourcePath);
                    } else {
                        if (void 0 !== tmxFile) {
                            this.initWithTMXFile(tmxFile);
                        }
                    }
                },
                getMapSize: function() {
                    return cc.size(this._mapSize.width, this._mapSize.height);
                },
                setMapSize: function(Var) {
                    this._mapSize.width = Var.width;
                    this._mapSize.height = Var.height;
                },
                _getMapWidth: function() {
                    return this._mapSize.width;
                },
                _setMapWidth: function(width) {
                    this._mapSize.width = width;
                },
                _getMapHeight: function() {
                    return this._mapSize.height;
                },
                _setMapHeight: function(height) {
                    this._mapSize.height = height;
                },
                getTileSize: function() {
                    return cc.size(this._tileSize.width, this._tileSize.height);
                },
                setTileSize: function(Var) {
                    this._tileSize.width = Var.width;
                    this._tileSize.height = Var.height;
                },
                _getTileWidth: function() {
                    return this._tileSize.width;
                },
                _setTileWidth: function(width) {
                    this._tileSize.width = width;
                },
                _getTileHeight: function() {
                    return this._tileSize.height;
                },
                _setTileHeight: function(height) {
                    this._tileSize.height = height;
                },
                getMapOrientation: function() {
                    return this.mapOrientation;
                },
                setMapOrientation: function(Var) {
                    this.mapOrientation = Var;
                },
                getObjectGroups: function() {
                    return this.objectGroups;
                },
                setObjectGroups: function(Var) {
                    this.objectGroups = Var;
                },
                getProperties: function() {
                    return this.properties;
                },
                setProperties: function(Var) {
                    this.properties = Var;
                },
                initWithTMXFile: function(tmxFile) {
                    if (!tmxFile || 0 === tmxFile.length) {
                        throw new Error("cc.TMXTiledMap.initWithTMXFile(): tmxFile should be non-null or non-empty string.");
                    }
                    this.width = 0;
                    this.height = 0;
                    var mapInfo = new cc.TMXMapInfo(tmxFile);
                    if (!mapInfo) {
                        return false;
                    }
                    var locTilesets = mapInfo.getTilesets();
                    if (!locTilesets || 0 === locTilesets.length) {
                        cc.log("cc.TMXTiledMap.initWithTMXFile(): Map not found. Please check the filename.");
                    }
                    this._buildWithMapInfo(mapInfo);
                    return true;
                },
                initWithXML: function(tmxString, resourcePath) {
                    this.width = 0;
                    this.height = 0;
                    var mapInfo = new cc.TMXMapInfo(tmxString, resourcePath);
                    var locTilesets = mapInfo.getTilesets();
                    if (!locTilesets || 0 === locTilesets.length) {
                        cc.log("cc.TMXTiledMap.initWithXML(): Map not found. Please check the filename.");
                    }
                    this._buildWithMapInfo(mapInfo);
                    return true;
                },
                _buildWithMapInfo: function(mapInfo) {
                    this._mapSize = mapInfo.getMapSize();
                    this._tileSize = mapInfo.getTileSize();
                    this.mapOrientation = mapInfo.orientation;
                    this.objectGroups = mapInfo.getObjectGroups();
                    this.properties = mapInfo.properties;
                    this._tileProperties = mapInfo.getTileProperties();
                    var idx = 0;
                    var layers = mapInfo.getLayers();
                    if (layers) {
                        var layerInfo = null;
                        for (var i = 0, len = layers.length; i < len; i++) {
                            layerInfo = layers[i];
                            if (layerInfo && layerInfo.visible) {
                                var child = this._parseLayer(layerInfo, mapInfo);
                                this.addChild(child, idx, idx);
                                this.width = Math.max(this.width, child.width);
                                this.height = Math.max(this.height, child.height);
                                idx++;
                            }
                        }
                    }
                },
                allLayers: function() {
                    var retArr = [], locChildren = this._children;
                    for (var i = 0, len = locChildren.length; i < len; i++) {
                        var layer = locChildren[i];
                        if (layer && layer instanceof cc.TMXLayer) {
                            retArr.push(layer);
                        }
                    }
                    return retArr;
                },
                getLayer: function(layerName) {
                    if (!layerName || 0 === layerName.length) {
                        throw new Error("cc.TMXTiledMap.getLayer(): layerName should be non-null or non-empty string.");
                    }
                    var locChildren = this._children;
                    for (var i = 0; i < locChildren.length; i++) {
                        var layer = locChildren[i];
                        if (layer && layer.layerName === layerName) {
                            return layer;
                        }
                    }
                    return null;
                },
                getObjectGroup: function(groupName) {
                    if (!groupName || 0 === groupName.length) {
                        throw new Error("cc.TMXTiledMap.getObjectGroup(): groupName should be non-null or non-empty string.");
                    }
                    if (this.objectGroups) {
                        for (var i = 0; i < this.objectGroups.length; i++) {
                            var objectGroup = this.objectGroups[i];
                            if (objectGroup && objectGroup.groupName === groupName) {
                                return objectGroup;
                            }
                        }
                    }
                    return null;
                },
                getProperty: function(propertyName) {
                    return this.properties[propertyName.toString()];
                },
                propertiesForGID: function(GID) {
                    cc.log("propertiesForGID is deprecated. Please use getPropertiesForGID instead.");
                    return this.getPropertiesForGID[GID];
                },
                getPropertiesForGID: function(GID) {
                    return this._tileProperties[GID];
                },
                _parseLayer: function(layerInfo, mapInfo) {
                    var tileset = this._tilesetForLayer(layerInfo, mapInfo);
                    var layer = new cc.TMXLayer(tileset, layerInfo, mapInfo);
                    layerInfo.ownTiles = false;
                    layer.setupTiles();
                    return layer;
                },
                _tilesetForLayer: function(layerInfo, mapInfo) {
                    var size = layerInfo._layerSize;
                    var tilesets = mapInfo.getTilesets();
                    if (tilesets) {
                        for (var i = tilesets.length - 1; i >= 0; i--) {
                            var tileset = tilesets[i];
                            if (tileset) {
                                for (var y = 0; y < size.height; y++) {
                                    for (var x = 0; x < size.width; x++) {
                                        var pos = x + size.width * y;
                                        var gid = layerInfo._tiles[pos];
                                        if (0 !== gid) {
                                            if ((gid & cc.TMX_TILE_FLIPPED_MASK) >>> 0 >= tileset.firstGid) {
                                                return tileset;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    cc.log("cocos2d: Warning: TMX Layer " + layerInfo.name + " has no tiles");
                    return null;
                }
            });
            var _p = cc.TMXTiledMap.prototype;
            _p.mapWidth;
            cc.defineGetterSetter(_p, "mapWidth", _p._getMapWidth, _p._setMapWidth);
            _p.mapHeight;
            cc.defineGetterSetter(_p, "mapHeight", _p._getMapHeight, _p._setMapHeight);
            _p.tileWidth;
            cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
            _p.tileHeight;
            cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
            cc.TMXTiledMap.create = function(tmxFile, resourcePath) {
                return new cc.TMXTiledMap(tmxFile, resourcePath);
            };
            cc.TMX_PROPERTY_NONE = 0;
            cc.TMX_PROPERTY_MAP = 1;
            cc.TMX_PROPERTY_LAYER = 2;
            cc.TMX_PROPERTY_OBJECTGROUP = 3;
            cc.TMX_PROPERTY_OBJECT = 4;
            cc.TMX_PROPERTY_TILE = 5;
            cc.TMX_TILE_HORIZONTAL_FLAG = 2147483648;
            cc.TMX_TILE_VERTICAL_FLAG = 1073741824;
            cc.TMX_TILE_DIAGONAL_FLAG = 536870912;
            cc.TMX_TILE_FLIPPED_ALL = (cc.TMX_TILE_HORIZONTAL_FLAG | cc.TMX_TILE_VERTICAL_FLAG | cc.TMX_TILE_DIAGONAL_FLAG) >>> 0;
            cc.TMX_TILE_FLIPPED_MASK = ~cc.TMX_TILE_FLIPPED_ALL >>> 0;
            cc.TMXLayerInfo = cc._Class.extend({
                properties: null,
                name: "",
                _layerSize: null,
                _tiles: null,
                visible: null,
                _opacity: null,
                ownTiles: true,
                _minGID: 1e5,
                _maxGID: 0,
                offset: null,
                ctor: function() {
                    this.properties = [];
                    this.name = "";
                    this._layerSize = null;
                    this._tiles = [];
                    this.visible = true;
                    this._opacity = 0;
                    this.ownTiles = true;
                    this._minGID = 1e5;
                    this._maxGID = 0;
                    this.offset = cc.p(0, 0);
                },
                getProperties: function() {
                    return this.properties;
                },
                setProperties: function(value) {
                    this.properties = value;
                }
            });
            cc.TMXTilesetInfo = cc._Class.extend({
                name: "",
                firstGid: 0,
                _tileSize: null,
                spacing: 0,
                margin: 0,
                sourceImage: "",
                imageSize: null,
                ctor: function() {
                    this._tileSize = cc.size(0, 0);
                    this.imageSize = cc.size(0, 0);
                },
                rectForGID: function(gid) {
                    var rect = cc.rect(0, 0, 0, 0);
                    rect.width = this._tileSize.width;
                    rect.height = this._tileSize.height;
                    gid &= cc.TMX_TILE_FLIPPED_MASK;
                    gid -= parseInt(this.firstGid, 10);
                    var max_x = parseInt((this.imageSize.width - 2 * this.margin + this.spacing) / (this._tileSize.width + this.spacing), 10);
                    rect.x = parseInt(gid % max_x * (this._tileSize.width + this.spacing) + this.margin, 10);
                    rect.y = parseInt(parseInt(gid / max_x, 10) * (this._tileSize.height + this.spacing) + this.margin, 10);
                    return rect;
                }
            });
            cc.TMXMapInfo = cc.SAXParser.extend({
                properties: null,
                orientation: null,
                parentElement: null,
                parentGID: null,
                layerAttrs: 0,
                storingCharacters: false,
                tmxFileName: null,
                currentString: null,
                _objectGroups: null,
                _mapSize: null,
                _tileSize: null,
                _layers: null,
                _tilesets: null,
                _tileProperties: null,
                _resources: "",
                _currentFirstGID: 0,
                ctor: function(tmxFile, resourcePath) {
                    cc.SAXParser.prototype.ctor.apply(this);
                    this._mapSize = cc.size(0, 0);
                    this._tileSize = cc.size(0, 0);
                    this._layers = [];
                    this._tilesets = [];
                    this._objectGroups = [];
                    this.properties = [];
                    this._tileProperties = {};
                    this._currentFirstGID = 0;
                    if (void 0 !== resourcePath) {
                        this.initWithXML(tmxFile, resourcePath);
                    } else {
                        if (void 0 !== tmxFile) {
                            this.initWithTMXFile(tmxFile);
                        }
                    }
                },
                getOrientation: function() {
                    return this.orientation;
                },
                setOrientation: function(value) {
                    this.orientation = value;
                },
                getMapSize: function() {
                    return cc.size(this._mapSize.width, this._mapSize.height);
                },
                setMapSize: function(value) {
                    this._mapSize.width = value.width;
                    this._mapSize.height = value.height;
                },
                _getMapWidth: function() {
                    return this._mapSize.width;
                },
                _setMapWidth: function(width) {
                    this._mapSize.width = width;
                },
                _getMapHeight: function() {
                    return this._mapSize.height;
                },
                _setMapHeight: function(height) {
                    this._mapSize.height = height;
                },
                getTileSize: function() {
                    return cc.size(this._tileSize.width, this._tileSize.height);
                },
                setTileSize: function(value) {
                    this._tileSize.width = value.width;
                    this._tileSize.height = value.height;
                },
                _getTileWidth: function() {
                    return this._tileSize.width;
                },
                _setTileWidth: function(width) {
                    this._tileSize.width = width;
                },
                _getTileHeight: function() {
                    return this._tileSize.height;
                },
                _setTileHeight: function(height) {
                    this._tileSize.height = height;
                },
                getLayers: function() {
                    return this._layers;
                },
                setLayers: function(value) {
                    this._layers.push(value);
                },
                getTilesets: function() {
                    return this._tilesets;
                },
                setTilesets: function(value) {
                    this._tilesets.push(value);
                },
                getObjectGroups: function() {
                    return this._objectGroups;
                },
                setObjectGroups: function(value) {
                    this._objectGroups.push(value);
                },
                getParentElement: function() {
                    return this.parentElement;
                },
                setParentElement: function(value) {
                    this.parentElement = value;
                },
                getParentGID: function() {
                    return this.parentGID;
                },
                setParentGID: function(value) {
                    this.parentGID = value;
                },
                getLayerAttribs: function() {
                    return this.layerAttrs;
                },
                setLayerAttribs: function(value) {
                    this.layerAttrs = value;
                },
                getStoringCharacters: function() {
                    return this.storingCharacters;
                },
                setStoringCharacters: function(value) {
                    this.storingCharacters = value;
                },
                getProperties: function() {
                    return this.properties;
                },
                setProperties: function(value) {
                    this.properties = value;
                },
                initWithTMXFile: function(tmxFile) {
                    this._internalInit(tmxFile, null);
                    return this.parseXMLFile(tmxFile);
                },
                initWithXML: function(tmxString, resourcePath) {
                    this._internalInit(null, resourcePath);
                    return this.parseXMLString(tmxString);
                },
                parseXMLFile: function(tmxFile, isXmlString) {
                    isXmlString = isXmlString || false;
                    var xmlStr = isXmlString ? tmxFile : cc.loader.getRes(tmxFile);
                    if (!xmlStr) {
                        throw new Error("Please load the resource first : " + tmxFile);
                    }
                    var mapXML = this._parseXML(xmlStr);
                    var i, j;
                    var map = mapXML.documentElement;
                    var version = map.getAttribute("version");
                    var orientationStr = map.getAttribute("orientation");
                    if ("map" === map.nodeName) {
                        if ("1.0" !== version && null !== version) {
                            cc.log("cocos2d: TMXFormat: Unsupported TMX version:" + version);
                        }
                        if ("orthogonal" === orientationStr) {
                            this.orientation = cc.TMX_ORIENTATION_ORTHO;
                        } else {
                            if ("isometric" === orientationStr) {
                                this.orientation = cc.TMX_ORIENTATION_ISO;
                            } else {
                                if ("hexagonal" === orientationStr) {
                                    this.orientation = cc.TMX_ORIENTATION_HEX;
                                } else {
                                    if (null !== orientationStr) {
                                        cc.log("cocos2d: TMXFomat: Unsupported orientation:" + orientationStr);
                                    }
                                }
                            }
                        }
                        var mapSize = cc.size(0, 0);
                        mapSize.width = parseFloat(map.getAttribute("width"));
                        mapSize.height = parseFloat(map.getAttribute("height"));
                        this.setMapSize(mapSize);
                        mapSize = cc.size(0, 0);
                        mapSize.width = parseFloat(map.getAttribute("tilewidth"));
                        mapSize.height = parseFloat(map.getAttribute("tileheight"));
                        this.setTileSize(mapSize);
                        var propertyArr = map.querySelectorAll("map > properties >  property");
                        if (propertyArr) {
                            var aPropertyDict = {};
                            for (i = 0; i < propertyArr.length; i++) {
                                aPropertyDict[propertyArr[i].getAttribute("name")] = propertyArr[i].getAttribute("value");
                            }
                            this.properties = aPropertyDict;
                        }
                    }
                    var tilesets = map.getElementsByTagName("tileset");
                    if ("map" !== map.nodeName) {
                        tilesets = [];
                        tilesets.push(map);
                    }
                    for (i = 0; i < tilesets.length; i++) {
                        var selTileset = tilesets[i];
                        var tsxName = selTileset.getAttribute("source");
                        if (tsxName) {
                            var tsxPath = isXmlString ? cc.path.join(this._resources, tsxName) : cc.path.changeBasename(tmxFile, tsxName);
                            this.parseXMLFile(tsxPath);
                        } else {
                            var tileset = new cc.TMXTilesetInfo();
                            tileset.name = selTileset.getAttribute("name") || "";
                            tileset.firstGid = parseInt(selTileset.getAttribute("firstgid")) || 0;
                            tileset.spacing = parseInt(selTileset.getAttribute("spacing")) || 0;
                            tileset.margin = parseInt(selTileset.getAttribute("margin")) || 0;
                            var tilesetSize = cc.size(0, 0);
                            tilesetSize.width = parseFloat(selTileset.getAttribute("tilewidth"));
                            tilesetSize.height = parseFloat(selTileset.getAttribute("tileheight"));
                            tileset._tileSize = tilesetSize;
                            var image = selTileset.getElementsByTagName("image")[0];
                            var imagename = image.getAttribute("source");
                            var num = -1;
                            if (this.tmxFileName) {
                                num = this.tmxFileName.lastIndexOf("/");
                            }
                            if (-1 !== num) {
                                var dir = this.tmxFileName.substr(0, num + 1);
                                tileset.sourceImage = dir + imagename;
                            } else {
                                tileset.sourceImage = this._resources + (this._resources ? "/" : "") + imagename;
                            }
                            this.setTilesets(tileset);
                            var tiles = selTileset.getElementsByTagName("tile");
                            if (tiles) {
                                for (var tIdx = 0; tIdx < tiles.length; tIdx++) {
                                    var t = tiles[tIdx];
                                    this.parentGID = parseInt(tileset.firstGid) + parseInt(t.getAttribute("id") || 0);
                                    var tp = t.querySelectorAll("properties > property");
                                    if (tp) {
                                        var dict = {};
                                        for (j = 0; j < tp.length; j++) {
                                            var name = tp[j].getAttribute("name");
                                            dict[name] = tp[j].getAttribute("value");
                                        }
                                        this._tileProperties[this.parentGID] = dict;
                                    }
                                }
                            }
                        }
                    }
                    var layers = map.getElementsByTagName("layer");
                    if (layers) {
                        for (i = 0; i < layers.length; i++) {
                            var selLayer = layers[i];
                            var data = selLayer.getElementsByTagName("data")[0];
                            var layer = new cc.TMXLayerInfo();
                            layer.name = selLayer.getAttribute("name");
                            var layerSize = cc.size(0, 0);
                            layerSize.width = parseFloat(selLayer.getAttribute("width"));
                            layerSize.height = parseFloat(selLayer.getAttribute("height"));
                            layer._layerSize = layerSize;
                            var visible = selLayer.getAttribute("visible");
                            layer.visible = !("0" == visible);
                            var opacity = selLayer.getAttribute("opacity") || 1;
                            if (opacity) {
                                layer._opacity = parseInt(255 * parseFloat(opacity));
                            } else {
                                layer._opacity = 255;
                            }
                            layer.offset = cc.p(parseFloat(selLayer.getAttribute("x")) || 0, parseFloat(selLayer.getAttribute("y")) || 0);
                            var nodeValue = "";
                            for (j = 0; j < data.childNodes.length; j++) {
                                nodeValue += data.childNodes[j].nodeValue;
                            }
                            nodeValue = nodeValue.trim();
                            var compression = data.getAttribute("compression");
                            var encoding = data.getAttribute("encoding");
                            if (compression && "gzip" !== compression && "zlib" !== compression) {
                                cc.log("cc.TMXMapInfo.parseXMLFile(): unsupported compression method");
                                return null;
                            }
                            switch (compression) {
                              case "gzip":
                                layer._tiles = cc.unzipBase64AsArray(nodeValue, 4);
                                break;

                              case "zlib":
                                var inflator = new Zlib.Inflate(cc.Codec.Base64.decodeAsArray(nodeValue, 1));
                                layer._tiles = cc.uint8ArrayToUint32Array(inflator.decompress());
                                break;

                              case null:
                              case "":
                                if ("base64" === encoding) {
                                    layer._tiles = cc.Codec.Base64.decodeAsArray(nodeValue, 4);
                                } else {
                                    if ("csv" === encoding) {
                                        layer._tiles = [];
                                        var csvTiles = nodeValue.split(",");
                                        for (var csvIdx = 0; csvIdx < csvTiles.length; csvIdx++) {
                                            layer._tiles.push(parseInt(csvTiles[csvIdx]));
                                        }
                                    } else {
                                        var selDataTiles = data.getElementsByTagName("tile");
                                        layer._tiles = [];
                                        for (var xmlIdx = 0; xmlIdx < selDataTiles.length; xmlIdx++) {
                                            layer._tiles.push(parseInt(selDataTiles[xmlIdx].getAttribute("gid")));
                                        }
                                    }
                                }
                                break;

                              default:
                                if (this.layerAttrs === cc.TMXLayerInfo.ATTRIB_NONE) {
                                    cc.log("cc.TMXMapInfo.parseXMLFile(): Only base64 and/or gzip/zlib maps are supported");
                                }
                            }
                            var layerProps = selLayer.querySelectorAll("properties > property");
                            if (layerProps) {
                                var layerProp = {};
                                for (j = 0; j < layerProps.length; j++) {
                                    layerProp[layerProps[j].getAttribute("name")] = layerProps[j].getAttribute("value");
                                }
                                layer.properties = layerProp;
                            }
                            this.setLayers(layer);
                        }
                    }
                    var objectGroups = map.getElementsByTagName("objectgroup");
                    if (objectGroups) {
                        for (i = 0; i < objectGroups.length; i++) {
                            var selGroup = objectGroups[i];
                            var objectGroup = new cc.TMXObjectGroup();
                            objectGroup.groupName = selGroup.getAttribute("name");
                            objectGroup.setPositionOffset(cc.p(parseFloat(selGroup.getAttribute("x")) * this.getTileSize().width || 0, parseFloat(selGroup.getAttribute("y")) * this.getTileSize().height || 0));
                            var groupProps = selGroup.querySelectorAll("objectgroup > properties > property");
                            if (groupProps) {
                                for (j = 0; j < groupProps.length; j++) {
                                    var groupProp = {};
                                    groupProp[groupProps[j].getAttribute("name")] = groupProps[j].getAttribute("value");
                                    objectGroup.properties = groupProp;
                                }
                            }
                            var objects = selGroup.querySelectorAll("object");
                            var getContentScaleFactor = cc.director.getContentScaleFactor();
                            if (objects) {
                                for (j = 0; j < objects.length; j++) {
                                    var selObj = objects[j];
                                    var objectProp = {};
                                    objectProp["name"] = selObj.getAttribute("name") || "";
                                    objectProp["type"] = selObj.getAttribute("type") || "";
                                    objectProp["width"] = parseInt(selObj.getAttribute("width")) || 0;
                                    objectProp["height"] = parseInt(selObj.getAttribute("height")) || 0;
                                    objectProp["x"] = ((0 | (selObj.getAttribute("x") || 0)) + objectGroup.getPositionOffset().x) / getContentScaleFactor;
                                    var y = (0 | (selObj.getAttribute("y") || 0)) + objectGroup.getPositionOffset().y / getContentScaleFactor;
                                    objectProp["y"] = (parseInt(this.getMapSize().height * this.getTileSize().height) - y - objectProp["height"]) / cc.director.getContentScaleFactor();
                                    objectProp["rotation"] = parseInt(selObj.getAttribute("rotation")) || 0;
                                    var docObjProps = selObj.querySelectorAll("properties > property");
                                    if (docObjProps) {
                                        for (var k = 0; k < docObjProps.length; k++) {
                                            objectProp[docObjProps[k].getAttribute("name")] = docObjProps[k].getAttribute("value");
                                        }
                                    }
                                    var polygonProps = selObj.querySelectorAll("polygon");
                                    if (polygonProps && polygonProps.length > 0) {
                                        var selPgPointStr = polygonProps[0].getAttribute("points");
                                        if (selPgPointStr) {
                                            objectProp["points"] = this._parsePointsString(selPgPointStr);
                                        }
                                    }
                                    var polylineProps = selObj.querySelectorAll("polyline");
                                    if (polylineProps && polylineProps.length > 0) {
                                        var selPlPointStr = polylineProps[0].getAttribute("points");
                                        if (selPlPointStr) {
                                            objectProp["polylinePoints"] = this._parsePointsString(selPlPointStr);
                                        }
                                    }
                                    objectGroup.setObjects(objectProp);
                                }
                            }
                            this.setObjectGroups(objectGroup);
                        }
                    }
                    return map;
                },
                _parsePointsString: function(pointsString) {
                    if (!pointsString) {
                        return null;
                    }
                    var points = [];
                    var pointsStr = pointsString.split(" ");
                    for (var i = 0; i < pointsStr.length; i++) {
                        var selPointStr = pointsStr[i].split(",");
                        points.push({
                            x: selPointStr[0],
                            y: selPointStr[1]
                        });
                    }
                    return points;
                },
                parseXMLString: function(xmlString) {
                    return this.parseXMLFile(xmlString, true);
                },
                getTileProperties: function() {
                    return this._tileProperties;
                },
                setTileProperties: function(tileProperties) {
                    this._tileProperties.push(tileProperties);
                },
                getCurrentString: function() {
                    return this.currentString;
                },
                setCurrentString: function(currentString) {
                    this.currentString = currentString;
                },
                getTMXFileName: function() {
                    return this.tmxFileName;
                },
                setTMXFileName: function(fileName) {
                    this.tmxFileName = fileName;
                },
                _internalInit: function(tmxFileName, resourcePath) {
                    this._tilesets.length = 0;
                    this._layers.length = 0;
                    this.tmxFileName = tmxFileName;
                    if (resourcePath) {
                        this._resources = resourcePath;
                    }
                    this._objectGroups.length = 0;
                    this.properties.length = 0;
                    this._tileProperties.length = 0;
                    this.currentString = "";
                    this.storingCharacters = false;
                    this.layerAttrs = cc.TMXLayerInfo.ATTRIB_NONE;
                    this.parentElement = cc.TMX_PROPERTY_NONE;
                    this._currentFirstGID = 0;
                }
            });
            var _p = cc.TMXMapInfo.prototype;
            _p.mapWidth;
            cc.defineGetterSetter(_p, "mapWidth", _p._getMapWidth, _p._setMapWidth);
            _p.mapHeight;
            cc.defineGetterSetter(_p, "mapHeight", _p._getMapHeight, _p._setMapHeight);
            _p.tileWidth;
            cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
            _p.tileHeight;
            cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
            cc.TMXMapInfo.create = function(tmxFile, resourcePath) {
                return new cc.TMXMapInfo(tmxFile, resourcePath);
            };
            cc.loader.register([ "tmx", "tsx" ], cc._txtLoader);
            cc.TMXLayerInfo.ATTRIB_NONE = 1;
            cc.TMXLayerInfo.ATTRIB_BASE64 = 2;
            cc.TMXLayerInfo.ATTRIB_GZIP = 4;
            cc.TMXLayerInfo.ATTRIB_ZLIB = 8;
            cc.TMXObjectGroup = cc._Class.extend({
                properties: null,
                groupName: "",
                _positionOffset: null,
                _objects: null,
                ctor: function() {
                    this.groupName = "";
                    this._positionOffset = cc.p(0, 0);
                    this.properties = [];
                    this._objects = [];
                },
                getPositionOffset: function() {
                    return cc.p(this._positionOffset);
                },
                setPositionOffset: function(offset) {
                    this._positionOffset.x = offset.x;
                    this._positionOffset.y = offset.y;
                },
                getProperties: function() {
                    return this.properties;
                },
                setProperties: function(Var) {
                    this.properties.push(Var);
                },
                getGroupName: function() {
                    return this.groupName.toString();
                },
                setGroupName: function(groupName) {
                    this.groupName = groupName;
                },
                propertyNamed: function(propertyName) {
                    return this.properties[propertyName];
                },
                objectNamed: function(objectName) {
                    return this.getObject(objectName);
                },
                getObject: function(objectName) {
                    if (this._objects && this._objects.length > 0) {
                        var locObjects = this._objects;
                        for (var i = 0, len = locObjects.length; i < len; i++) {
                            var name = locObjects[i]["name"];
                            if (name && name === objectName) {
                                return locObjects[i];
                            }
                        }
                    }
                    return null;
                },
                getObjects: function() {
                    return this._objects;
                },
                setObjects: function(objects) {
                    this._objects.push(objects);
                }
            });
            cc.TMXLayer = cc.SpriteBatchNode.extend({
                tiles: null,
                tileset: null,
                layerOrientation: null,
                properties: null,
                layerName: "",
                _layerSize: null,
                _mapTileSize: null,
                _opacity: 255,
                _minGID: null,
                _maxGID: null,
                _vertexZvalue: null,
                _useAutomaticVertexZ: null,
                _reusedTile: null,
                _atlasIndexArray: null,
                _contentScaleFactor: null,
                _className: "TMXLayer",
                ctor: function(tilesetInfo, layerInfo, mapInfo) {
                    cc.SpriteBatchNode.prototype.ctor.call(this);
                    this._descendants = [];
                    this._layerSize = cc.size(0, 0);
                    this._mapTileSize = cc.size(0, 0);
                    if (void 0 !== mapInfo) {
                        this.initWithTilesetInfo(tilesetInfo, layerInfo, mapInfo);
                    }
                },
                _createRenderCmd: function() {
                    if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                        return new cc.TMXLayer.CanvasRenderCmd(this);
                    } else {
                        return new cc.TMXLayer.WebGLRenderCmd(this);
                    }
                },
                setContentSize: function(size, height) {
                    _ccsg.Node.prototype.setContentSize.call(this, size, height);
                    this._renderCmd._updateCacheContext(size, height);
                },
                getTexture: function() {
                    return this._renderCmd.getTexture();
                },
                getLayerSize: function() {
                    return cc.size(this._layerSize.width, this._layerSize.height);
                },
                setLayerSize: function(Var) {
                    this._layerSize.width = Var.width;
                    this._layerSize.height = Var.height;
                },
                _getLayerWidth: function() {
                    return this._layerSize.width;
                },
                _setLayerWidth: function(width) {
                    this._layerSize.width = width;
                },
                _getLayerHeight: function() {
                    return this._layerSize.height;
                },
                _setLayerHeight: function(height) {
                    this._layerSize.height = height;
                },
                getMapTileSize: function() {
                    return cc.size(this._mapTileSize.width, this._mapTileSize.height);
                },
                setMapTileSize: function(Var) {
                    this._mapTileSize.width = Var.width;
                    this._mapTileSize.height = Var.height;
                },
                _getTileWidth: function() {
                    return this._mapTileSize.width;
                },
                _setTileWidth: function(width) {
                    this._mapTileSize.width = width;
                },
                _getTileHeight: function() {
                    return this._mapTileSize.height;
                },
                _setTileHeight: function(height) {
                    this._mapTileSize.height = height;
                },
                getTiles: function() {
                    return this.tiles;
                },
                setTiles: function(Var) {
                    this.tiles = Var;
                },
                getTileset: function() {
                    return this.tileset;
                },
                setTileset: function(Var) {
                    this.tileset = Var;
                },
                getLayerOrientation: function() {
                    return this.layerOrientation;
                },
                setLayerOrientation: function(Var) {
                    this.layerOrientation = Var;
                },
                getProperties: function() {
                    return this.properties;
                },
                setProperties: function(Var) {
                    this.properties = Var;
                },
                initWithTilesetInfo: function(tilesetInfo, layerInfo, mapInfo) {
                    var size = layerInfo._layerSize;
                    var totalNumberOfTiles = parseInt(size.width * size.height);
                    var capacity = .35 * totalNumberOfTiles + 1;
                    var texture;
                    if (tilesetInfo) {
                        texture = cc.textureCache.addImage(tilesetInfo.sourceImage);
                    }
                    if (this.initWithTexture(texture, capacity)) {
                        this.layerName = layerInfo.name;
                        this._layerSize = size;
                        this.tiles = layerInfo._tiles;
                        this._minGID = layerInfo._minGID;
                        this._maxGID = layerInfo._maxGID;
                        this._opacity = layerInfo._opacity;
                        this.properties = layerInfo.properties;
                        this._contentScaleFactor = cc.director.getContentScaleFactor();
                        this.tileset = tilesetInfo;
                        this._mapTileSize = mapInfo.getTileSize();
                        this.layerOrientation = mapInfo.orientation;
                        var offset = this._calculateLayerOffset(layerInfo.offset);
                        this.setPosition(cc.pointPixelsToPoints(offset));
                        this._atlasIndexArray = [];
                        this.setContentSize(cc.sizePixelsToPoints(cc.size(this._layerSize.width * this._mapTileSize.width, this._layerSize.height * this._mapTileSize.height)));
                        this._useAutomaticVertexZ = false;
                        this._vertexZvalue = 0;
                        return true;
                    }
                    return false;
                },
                releaseMap: function() {
                    if (this.tiles) {
                        this.tiles = null;
                    }
                    if (this._atlasIndexArray) {
                        this._atlasIndexArray = null;
                    }
                },
                getTileAt: function(pos, y) {
                    if (!pos) {
                        throw new Error("cc.TMXLayer.getTileAt(): pos should be non-null");
                    }
                    if (void 0 !== y) {
                        pos = cc.p(pos, y);
                    }
                    if (pos.x >= this._layerSize.width || pos.y >= this._layerSize.height || pos.x < 0 || pos.y < 0) {
                        throw new Error("cc.TMXLayer.getTileAt(): invalid position");
                    }
                    if (!this.tiles || !this._atlasIndexArray) {
                        cc.log("cc.TMXLayer.getTileAt(): TMXLayer: the tiles map has been released");
                        return null;
                    }
                    var tile = null, gid = this.getTileGIDAt(pos);
                    if (0 === gid) {
                        return tile;
                    }
                    var z = 0 | pos.x + pos.y * this._layerSize.width;
                    tile = this.getChildByTag(z);
                    if (!tile) {
                        var rect = this.tileset.rectForGID(gid);
                        rect = cc.rectPixelsToPoints(rect);
                        tile = new _ccsg.Sprite();
                        tile.initWithTexture(this.texture, rect);
                        tile.batchNode = this;
                        tile.setPosition(this.getPositionAt(pos));
                        tile.vertexZ = this._vertexZForPos(pos);
                        tile.anchorX = 0;
                        tile.anchorY = 0;
                        tile.opacity = this._opacity;
                        var indexForZ = this._atlasIndexForExistantZ(z);
                        this.addSpriteWithoutQuad(tile, indexForZ, z);
                    }
                    return tile;
                },
                getTileGIDAt: function(pos, y) {
                    if (null == pos) {
                        throw new Error("cc.TMXLayer.getTileGIDAt(): pos should be non-null");
                    }
                    if (void 0 !== y) {
                        pos = cc.p(pos, y);
                    }
                    if (pos.x >= this._layerSize.width || pos.y >= this._layerSize.height || pos.x < 0 || pos.y < 0) {
                        throw new Error("cc.TMXLayer.getTileGIDAt(): invalid position");
                    }
                    if (!this.tiles || !this._atlasIndexArray) {
                        cc.log("cc.TMXLayer.getTileGIDAt(): TMXLayer: the tiles map has been released");
                        return null;
                    }
                    var idx = 0 | pos.x + pos.y * this._layerSize.width;
                    var tile = this.tiles[idx];
                    return (tile & cc.TMX_TILE_FLIPPED_MASK) >>> 0;
                },
                getTileFlagsAt: function(pos, y) {
                    if (!pos) {
                        throw new Error("cc.TMXLayer.getTileFlagsAt(): pos should be non-null");
                    }
                    if (void 0 !== y) {
                        pos = cc.p(pos, y);
                    }
                    if (pos.x >= this._layerSize.width || pos.y >= this._layerSize.height || pos.x < 0 || pos.y < 0) {
                        throw new Error("cc.TMXLayer.getTileFlagsAt(): invalid position");
                    }
                    if (!this.tiles || !this._atlasIndexArray) {
                        cc.log("cc.TMXLayer.getTileFlagsAt(): TMXLayer: the tiles map has been released");
                        return null;
                    }
                    var idx = 0 | pos.x + pos.y * this._layerSize.width;
                    var tile = this.tiles[idx];
                    return (tile & cc.TMX_TILE_FLIPPED_ALL) >>> 0;
                },
                setTileGID: function(gid, posOrX, flagsOrY, flags) {
                    if (!posOrX) {
                        throw new Error("cc.TMXLayer.setTileGID(): pos should be non-null");
                    }
                    var pos;
                    if (void 0 !== flags) {
                        pos = cc.p(posOrX, flagsOrY);
                    } else {
                        pos = posOrX;
                        flags = flagsOrY;
                    }
                    if (pos.x >= this._layerSize.width || pos.y >= this._layerSize.height || pos.x < 0 || pos.y < 0) {
                        throw new Error("cc.TMXLayer.setTileGID(): invalid position");
                    }
                    if (!this.tiles || !this._atlasIndexArray) {
                        cc.log("cc.TMXLayer.setTileGID(): TMXLayer: the tiles map has been released");
                        return;
                    }
                    if (0 !== gid && gid < this.tileset.firstGid) {
                        cc.log("cc.TMXLayer.setTileGID(): invalid gid:" + gid);
                        return;
                    }
                    flags = flags || 0;
                    this._setNodeDirtyForCache();
                    var currentFlags = this.getTileFlagsAt(pos);
                    var currentGID = this.getTileGIDAt(pos);
                    if (currentGID !== gid || currentFlags !== flags) {
                        var gidAndFlags = (gid | flags) >>> 0;
                        if (0 === gid) {
                            this.removeTileAt(pos);
                        } else {
                            if (0 === currentGID) {
                                this._insertTileForGID(gidAndFlags, pos);
                            } else {
                                var z = pos.x + pos.y * this._layerSize.width;
                                var sprite = this.getChildByTag(z);
                                if (sprite) {
                                    var rect = this.tileset.rectForGID(gid);
                                    rect = cc.rectPixelsToPoints(rect);
                                    sprite.setTextureRect(rect, false);
                                    if (null != flags) {
                                        this._setupTileSprite(sprite, pos, gidAndFlags);
                                    }
                                    this.tiles[z] = gidAndFlags;
                                } else {
                                    this._updateTileForGID(gidAndFlags, pos);
                                }
                            }
                        }
                    }
                },
                removeTileAt: function(pos, y) {
                    if (!pos) {
                        throw new Error("cc.TMXLayer.removeTileAt(): pos should be non-null");
                    }
                    if (void 0 !== y) {
                        pos = cc.p(pos, y);
                    }
                    if (pos.x >= this._layerSize.width || pos.y >= this._layerSize.height || pos.x < 0 || pos.y < 0) {
                        throw new Error("cc.TMXLayer.removeTileAt(): invalid position");
                    }
                    if (!this.tiles || !this._atlasIndexArray) {
                        cc.log("cc.TMXLayer.removeTileAt(): TMXLayer: the tiles map has been released");
                        return;
                    }
                    var gid = this.getTileGIDAt(pos);
                    if (0 !== gid) {
                        if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                            this._setNodeDirtyForCache();
                        }
                        var z = 0 | pos.x + pos.y * this._layerSize.width;
                        var atlasIndex = this._atlasIndexForExistantZ(z);
                        this.tiles[z] = 0;
                        this._atlasIndexArray.splice(atlasIndex, 1);
                        var sprite = this.getChildByTag(z);
                        if (sprite) {
                            cc.SpriteBatchNode.prototype.removeChild.call(this, sprite, true);
                        } else {
                            if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
                                this.textureAtlas.removeQuadAtIndex(atlasIndex);
                            }
                            if (this._children) {
                                var locChildren = this._children;
                                for (var i = 0, len = locChildren.length; i < len; i++) {
                                    var child = locChildren[i];
                                    if (child) {
                                        var ai = child.atlasIndex;
                                        if (ai >= atlasIndex) {
                                            child.atlasIndex = ai - 1;
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                getPositionAt: function(pos, y) {
                    if (void 0 !== y) {
                        pos = cc.p(pos, y);
                    }
                    var ret = cc.p(0, 0);
                    switch (this.layerOrientation) {
                      case cc.TMX_ORIENTATION_ORTHO:
                        ret = this._positionForOrthoAt(pos);
                        break;

                      case cc.TMX_ORIENTATION_ISO:
                        ret = this._positionForIsoAt(pos);
                        break;

                      case cc.TMX_ORIENTATION_HEX:
                        ret = this._positionForHexAt(pos);
                    }
                    return cc.pointPixelsToPoints(ret);
                },
                getProperty: function(propertyName) {
                    return this.properties[propertyName];
                },
                setupTiles: function() {
                    this._renderCmd.initImageSize();
                    this._parseInternalProperties();
                    if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                        this._setNodeDirtyForCache();
                    }
                    var locLayerHeight = this._layerSize.height, locLayerWidth = this._layerSize.width;
                    for (var y = 0; y < locLayerHeight; y++) {
                        for (var x = 0; x < locLayerWidth; x++) {
                            var pos = x + locLayerWidth * y;
                            var gid = this.tiles[pos];
                            if (0 !== gid) {
                                this._appendTileForGID(gid, cc.p(x, y));
                                this._minGID = Math.min(gid, this._minGID);
                                this._maxGID = Math.max(gid, this._maxGID);
                            }
                        }
                    }
                    if (!(this._maxGID >= this.tileset.firstGid && this._minGID >= this.tileset.firstGid)) {
                        cc.log("cocos2d:TMX: Only 1 tileset per layer is supported");
                    }
                },
                addChild: function(child, zOrder, tag) {
                    cc.log("addChild: is not supported on cc.TMXLayer. Instead use setTileGID or tileAt.");
                },
                removeChild: function(sprite, cleanup) {
                    if (!sprite) {
                        return;
                    }
                    if (-1 === this._children.indexOf(sprite)) {
                        cc.log("cc.TMXLayer.removeChild(): Tile does not belong to TMXLayer");
                        return;
                    }
                    if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                        this._setNodeDirtyForCache();
                    }
                    var atlasIndex = sprite.atlasIndex;
                    var zz = this._atlasIndexArray[atlasIndex];
                    this.tiles[zz] = 0;
                    this._atlasIndexArray.splice(atlasIndex, 1);
                    cc.SpriteBatchNode.prototype.removeChild.call(this, sprite, cleanup);
                    cc.renderer.childrenOrderDirty = true;
                },
                getLayerName: function() {
                    return this.layerName;
                },
                setLayerName: function(layerName) {
                    this.layerName = layerName;
                },
                _positionForIsoAt: function(pos) {
                    return cc.p(this._mapTileSize.width / 2 * (this._layerSize.width + pos.x - pos.y - 1), this._mapTileSize.height / 2 * (2 * this._layerSize.height - pos.x - pos.y - 2));
                },
                _positionForOrthoAt: function(pos) {
                    return cc.p(pos.x * this._mapTileSize.width, (this._layerSize.height - pos.y - 1) * this._mapTileSize.height);
                },
                _positionForHexAt: function(pos) {
                    var diffY = pos.x % 2 === 1 ? -this._mapTileSize.height / 2 : 0;
                    return cc.p(pos.x * this._mapTileSize.width * 3 / 4, (this._layerSize.height - pos.y - 1) * this._mapTileSize.height + diffY);
                },
                _calculateLayerOffset: function(pos) {
                    var ret = cc.p(0, 0);
                    switch (this.layerOrientation) {
                      case cc.TMX_ORIENTATION_ORTHO:
                        ret = cc.p(pos.x * this._mapTileSize.width, -pos.y * this._mapTileSize.height);
                        break;

                      case cc.TMX_ORIENTATION_ISO:
                        ret = cc.p(this._mapTileSize.width / 2 * (pos.x - pos.y), this._mapTileSize.height / 2 * (-pos.x - pos.y));
                        break;

                      case cc.TMX_ORIENTATION_HEX:
                        if (0 !== pos.x || 0 !== pos.y) {
                            cc.log("offset for hexagonal map not implemented yet");
                        }
                    }
                    return ret;
                },
                _appendTileForGID: function(gid, pos) {
                    var rect = this.tileset.rectForGID(gid);
                    rect = cc.rectPixelsToPoints(rect);
                    var z = 0 | pos.x + pos.y * this._layerSize.width;
                    var tile = this._renderCmd._reusedTileWithRect(rect);
                    this._setupTileSprite(tile, pos, gid);
                    var indexForZ = this._atlasIndexArray.length;
                    this.insertQuadFromSprite(tile, indexForZ);
                    this._atlasIndexArray.splice(indexForZ, 0, z);
                    return tile;
                },
                _insertTileForGID: function(gid, pos) {
                    var rect = this.tileset.rectForGID(gid);
                    rect = cc.rectPixelsToPoints(rect);
                    var z = 0 | pos.x + pos.y * this._layerSize.width;
                    var tile = this._renderCmd._reusedTileWithRect(rect);
                    this._setupTileSprite(tile, pos, gid);
                    var indexForZ = this._atlasIndexForNewZ(z);
                    this.insertQuadFromSprite(tile, indexForZ);
                    this._atlasIndexArray.splice(indexForZ, 0, z);
                    if (this._children) {
                        var locChildren = this._children;
                        for (var i = 0, len = locChildren.length; i < len; i++) {
                            var child = locChildren[i];
                            if (child) {
                                var ai = child.atlasIndex;
                                if (ai >= indexForZ) {
                                    child.atlasIndex = ai + 1;
                                }
                            }
                        }
                    }
                    this.tiles[z] = gid;
                    return tile;
                },
                _updateTileForGID: function(gid, pos) {
                    var rect = this.tileset.rectForGID(gid);
                    var locScaleFactor = this._contentScaleFactor;
                    rect = cc.rect(rect.x / locScaleFactor, rect.y / locScaleFactor, rect.width / locScaleFactor, rect.height / locScaleFactor);
                    var z = pos.x + pos.y * this._layerSize.width;
                    var tile = this._renderCmd._reusedTileWithRect(rect);
                    this._setupTileSprite(tile, pos, gid);
                    tile.atlasIndex = this._atlasIndexForExistantZ(z);
                    tile.dirty = true;
                    tile.updateTransform();
                    this.tiles[z] = gid;
                    return tile;
                },
                _parseInternalProperties: function() {
                    var vertexz = this.getProperty("cc_vertexz");
                    if (vertexz) {
                        if ("automatic" === vertexz) {
                            this._useAutomaticVertexZ = true;
                            var alphaFuncVal = this.getProperty("cc_alpha_func");
                            var alphaFuncValue = 0;
                            if (alphaFuncVal) {
                                alphaFuncValue = parseFloat(alphaFuncVal);
                            }
                            if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
                                this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST);
                                var alphaValueLocation = cc._renderContext.getUniformLocation(this.shaderProgram.getProgram(), cc.UNIFORM_ALPHA_TEST_VALUE_S);
                                this.shaderProgram.use();
                                this.shaderProgram.setUniformLocationWith1f(alphaValueLocation, alphaFuncValue);
                            }
                        } else {
                            this._vertexZvalue = parseInt(vertexz, 10);
                        }
                    }
                },
                _setupTileSprite: function(sprite, pos, gid) {
                    var z = pos.x + pos.y * this._layerSize.width;
                    sprite.setPosition(this.getPositionAt(pos));
                    if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
                        sprite.vertexZ = this._vertexZForPos(pos);
                    } else {
                        sprite.tag = z;
                    }
                    sprite.anchorX = 0;
                    sprite.anchorY = 0;
                    sprite.opacity = this._opacity;
                    if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
                        sprite.rotation = 0;
                    }
                    sprite.setFlippedX(false);
                    sprite.setFlippedY(false);
                    if ((gid & cc.TMX_TILE_DIAGONAL_FLAG) >>> 0) {
                        sprite.anchorX = .5;
                        sprite.anchorY = .5;
                        sprite.x = this.getPositionAt(pos).x + sprite.width / 2;
                        sprite.y = this.getPositionAt(pos).y + sprite.height / 2;
                        var flag = (gid & (cc.TMX_TILE_HORIZONTAL_FLAG | cc.TMX_TILE_VERTICAL_FLAG) >>> 0) >>> 0;
                        if (flag === cc.TMX_TILE_HORIZONTAL_FLAG) {
                            sprite.rotation = 90;
                        } else {
                            if (flag === cc.TMX_TILE_VERTICAL_FLAG) {
                                sprite.rotation = 270;
                            } else {
                                if (flag === (cc.TMX_TILE_VERTICAL_FLAG | cc.TMX_TILE_HORIZONTAL_FLAG) >>> 0) {
                                    sprite.rotation = 90;
                                    sprite.setFlippedX(true);
                                } else {
                                    sprite.rotation = 270;
                                    sprite.setFlippedX(true);
                                }
                            }
                        }
                    } else {
                        if ((gid & cc.TMX_TILE_HORIZONTAL_FLAG) >>> 0) {
                            sprite.setFlippedX(true);
                        }
                        if ((gid & cc.TMX_TILE_VERTICAL_FLAG) >>> 0) {
                            sprite.setFlippedY(true);
                        }
                    }
                },
                _vertexZForPos: function(pos) {
                    var ret = 0;
                    var maxVal = 0;
                    if (this._useAutomaticVertexZ) {
                        switch (this.layerOrientation) {
                          case cc.TMX_ORIENTATION_ISO:
                            maxVal = this._layerSize.width + this._layerSize.height;
                            ret = -(maxVal - (pos.x + pos.y));
                            break;

                          case cc.TMX_ORIENTATION_ORTHO:
                            ret = -(this._layerSize.height - pos.y);
                            break;

                          case cc.TMX_ORIENTATION_HEX:
                            cc.log("TMX Hexa zOrder not supported");
                            break;

                          default:
                            cc.log("TMX invalid value");
                        }
                    } else {
                        ret = this._vertexZvalue;
                    }
                    return ret;
                },
                _atlasIndexForExistantZ: function(z) {
                    var item;
                    if (this._atlasIndexArray) {
                        var locAtlasIndexArray = this._atlasIndexArray;
                        for (var i = 0, len = locAtlasIndexArray.length; i < len; i++) {
                            item = locAtlasIndexArray[i];
                            if (item === z) {
                                break;
                            }
                        }
                    }
                    if (!cc.js.isNumber(item)) {
                        cc.log("cc.TMXLayer._atlasIndexForExistantZ(): TMX atlas index not found. Shall not happen");
                    }
                    return i;
                },
                _atlasIndexForNewZ: function(z) {
                    var locAtlasIndexArray = this._atlasIndexArray;
                    for (var i = 0, len = locAtlasIndexArray.length; i < len; i++) {
                        var val = locAtlasIndexArray[i];
                        if (z < val) {
                            break;
                        }
                    }
                    return i;
                }
            });
            var _p = cc.TMXLayer.prototype;
            cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
            _p.layerWidth;
            cc.defineGetterSetter(_p, "layerWidth", _p._getLayerWidth, _p._setLayerWidth);
            _p.layerHeight;
            cc.defineGetterSetter(_p, "layerHeight", _p._getLayerHeight, _p._setLayerHeight);
            _p.tileWidth;
            cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
            _p.tileHeight;
            cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
            cc.TMXLayer.create = function(tilesetInfo, layerInfo, mapInfo) {
                return new cc.TMXLayer(tilesetInfo, layerInfo, mapInfo);
            };
            !function() {
                cc.TMXLayer.CanvasRenderCmd = function(renderable) {
                    cc.SpriteBatchNode.CanvasRenderCmd.call(this, renderable);
                    this._needDraw = true;
                    this._realWorldTransform = {
                        a: 1,
                        b: 0,
                        c: 0,
                        d: 1,
                        tx: 0,
                        ty: 0
                    };
                    var locCanvas = cc._canvas;
                    var tmpCanvas = document.createElement("canvas");
                    tmpCanvas.width = locCanvas.width;
                    tmpCanvas.height = locCanvas.height;
                    this._cacheCanvas = tmpCanvas;
                    this._cacheContext = new cc.CanvasContextWrapper(this._cacheCanvas.getContext("2d"));
                    var tempTexture = new cc.Texture2D();
                    tempTexture.initWithElement(tmpCanvas);
                    tempTexture.handleLoadedTexture();
                    this._cacheTexture = tempTexture;
                    this._cacheDirty = false;
                };
                var proto = cc.TMXLayer.CanvasRenderCmd.prototype = Object.create(cc.SpriteBatchNode.CanvasRenderCmd.prototype);
                proto.constructor = cc.TMXLayer.CanvasRenderCmd;
                proto._setNodeDirtyForCache = function() {
                    this._cacheDirty = true;
                };
                proto._renderingChildToCache = function() {
                    if (this._cacheDirty) {
                        var wrapper = this._cacheContext, context = wrapper.getContext(), locCanvas = this._cacheCanvas;
                        context.setTransform(1, 0, 0, 1, 0, 0);
                        context.clearRect(0, 0, locCanvas.width, locCanvas.height);
                        var locChildren = this._node._children;
                        for (var i = 0, len = locChildren.length; i < len; i++) {
                            if (locChildren[i]) {
                                var selCmd = locChildren[i]._renderCmd;
                                if (selCmd) {
                                    selCmd.rendering(wrapper, 1, 1);
                                    selCmd._cacheDirty = false;
                                }
                            }
                        }
                        this._cacheDirty = false;
                    }
                };
                proto.rendering = function(ctx, scaleX, scaleY) {
                    var alpha = this._displayedOpacity / 255;
                    if (alpha <= 0) {
                        return;
                    }
                    var node = this._node;
                    this._renderingChildToCache();
                    var wrapper = ctx || cc._renderContext, context = wrapper.getContext();
                    wrapper.setGlobalAlpha(alpha);
                    var locCacheCanvas = this._cacheCanvas;
                    if (locCacheCanvas && 0 !== locCacheCanvas.width && 0 !== locCacheCanvas.height) {
                        wrapper.setTransform(this._realWorldTransform, scaleX, scaleY);
                        var locCanvasHeight = locCacheCanvas.height * scaleY;
                        if (node.layerOrientation === cc.TMX_ORIENTATION_HEX) {
                            var halfTileSize = .5 * node._mapTileSize.height * scaleY;
                            context.drawImage(locCacheCanvas, 0, 0, locCacheCanvas.width, locCacheCanvas.height, 0, -locCanvasHeight + halfTileSize, locCacheCanvas.width * scaleX, locCanvasHeight);
                        } else {
                            context.drawImage(locCacheCanvas, 0, 0, locCacheCanvas.width, locCacheCanvas.height, 0, -locCanvasHeight, locCacheCanvas.width * scaleX, locCanvasHeight);
                        }
                    }
                    cc.g_NumberOfDraws++;
                };
                proto._updateCacheContext = function(size, height) {
                    var node = this._node, locContentSize = node._contentSize, locCanvas = this._cacheCanvas, scaleFactor = cc.contentScaleFactor();
                    locCanvas.width = 0 | 1.5 * locContentSize.width * scaleFactor;
                    locCanvas.height = 0 | 1.5 * locContentSize.height * scaleFactor;
                    if (node.layerOrientation === cc.TMX_ORIENTATION_HEX) {
                        this._cacheContext.setOffset(0, .5 * -node._mapTileSize.height);
                    } else {
                        this._cacheContext.setOffset(0, 0);
                    }
                    var locTexContentSize = this._cacheTexture._contentSize;
                    locTexContentSize.width = locCanvas.width;
                    locTexContentSize.height = locCanvas.height;
                };
                proto.getTexture = function() {
                    return this._cacheTexture;
                };
                proto.visit = function(parentCmd) {
                    var node = this._node;
                    var i, len, locChildren = node._children;
                    if (!node._visible || !locChildren || 0 === locChildren.length) {
                        return;
                    }
                    parentCmd = parentCmd || this.getParentRenderCmd();
                    if (parentCmd) {
                        this._curLevel = parentCmd._curLevel + 1;
                    }
                    this._syncStatus(parentCmd);
                    if (this._cacheDirty) {
                        var wrapper = this._cacheContext, locCanvas = this._cacheCanvas, context = wrapper.getContext(), instanceID = node.__instanceId, renderer = cc.renderer;
                        renderer._turnToCacheMode(instanceID);
                        node.sortAllChildren();
                        for (i = 0, len = locChildren.length; i < len; i++) {
                            if (locChildren[i]) {
                                var selCmd = locChildren[i]._renderCmd;
                                if (selCmd) {
                                    selCmd.visit(this);
                                    selCmd._cacheDirty = false;
                                }
                            }
                        }
                        context.setTransform(1, 0, 0, 1, 0, 0);
                        context.clearRect(0, 0, locCanvas.width, locCanvas.height);
                        renderer._renderingToCacheCanvas(wrapper, instanceID);
                        this._cacheDirty = false;
                    }
                    cc.renderer.pushRenderCommand(this);
                    this._dirtyFlag = 0;
                };
                proto.transform = function(parentCmd, recursive) {
                    var t = this.getNodeToParentTransform(), worldT = this._realWorldTransform;
                    if (parentCmd) {
                        var pt = parentCmd._worldTransform;
                        worldT.a = t.a * pt.a + t.b * pt.c;
                        worldT.b = t.a * pt.b + t.b * pt.d;
                        worldT.c = t.c * pt.a + t.d * pt.c;
                        worldT.d = t.c * pt.b + t.d * pt.d;
                        worldT.tx = pt.a * t.tx + pt.c * t.ty + pt.tx;
                        worldT.ty = pt.d * t.ty + pt.ty + pt.b * t.tx;
                    } else {
                        worldT.a = t.a;
                        worldT.b = t.b;
                        worldT.c = t.c;
                        worldT.d = t.d;
                        worldT.tx = t.tx;
                        worldT.ty = t.ty;
                    }
                    if (recursive) {
                        var locChildren = this._node._children;
                        if (!locChildren || 0 === locChildren.length) {
                            return;
                        }
                        var i, len;
                        for (i = 0, len = locChildren.length; i < len; i++) {
                            locChildren[i]._renderCmd.transform(this, recursive);
                        }
                    }
                };
                proto.initImageSize = function() {
                    var node = this._node;
                    node.tileset.imageSize = this._texture.getContentSizeInPixels();
                };
                proto._reusedTileWithRect = function(rect) {
                    var node = this._node;
                    node._reusedTile = new _ccsg.Sprite();
                    node._reusedTile.initWithTexture(this._texture, rect, false);
                    node._reusedTile.batchNode = node;
                    node._reusedTile.parent = node;
                    node._reusedTile._renderCmd._cachedParent = node._renderCmd;
                    return node._reusedTile;
                };
            }();
            !function() {
                cc.TMXLayer.WebGLRenderCmd = function(renderableObject) {
                    cc.SpriteBatchNode.WebGLRenderCmd.call(this, renderableObject);
                    this._needDraw = true;
                };
                var proto = cc.TMXLayer.WebGLRenderCmd.prototype = Object.create(cc.SpriteBatchNode.WebGLRenderCmd.prototype);
                proto.constructor = cc.TMXLayer.WebGLRenderCmd;
                proto._updateCacheContext = function() {};
                proto.initImageSize = function() {
                    var node = this._node;
                    node.tileset.imageSize = this._textureAtlas.texture.getContentSizeInPixels();
                    this._textureAtlas.texture.setAliasTexParameters();
                };
                proto._reusedTileWithRect = function(rect) {
                    var node = this._node;
                    if (!node._reusedTile) {
                        node._reusedTile = new _ccsg.Sprite();
                        node._reusedTile.initWithTexture(node.texture, rect, false);
                        node._reusedTile.batchNode = node;
                    } else {
                        node._reusedTile.batchNode = null;
                        node._reusedTile.setTextureRect(rect, false);
                        node._reusedTile.batchNode = node;
                    }
                    return node._reusedTile;
                };
            }();
            cc.PointObject = cc._Class.extend({
                _ratio: null,
                _offset: null,
                _child: null,
                ctor: function(ratio, offset) {
                    this.initWithCCPoint(ratio, offset);
                },
                getRatio: function() {
                    return this._ratio;
                },
                setRatio: function(value) {
                    this._ratio = value;
                },
                getOffset: function() {
                    return this._offset;
                },
                setOffset: function(value) {
                    this._offset = value;
                },
                getChild: function() {
                    return this._child;
                },
                setChild: function(value) {
                    this._child = value;
                },
                initWithCCPoint: function(ratio, offset) {
                    this._ratio = ratio;
                    this._offset = offset;
                    this._child = null;
                    return true;
                }
            });
            cc.PointObject.create = function(ratio, offset) {
                return new cc.PointObject(ratio, offset);
            };
            cc.ParallaxNode = _ccsg.Node.extend({
                parallaxArray: null,
                _lastPosition: null,
                _className: "ParallaxNode",
                getParallaxArray: function() {
                    return this.parallaxArray;
                },
                setParallaxArray: function(value) {
                    this.parallaxArray = value;
                },
                ctor: function() {
                    _ccsg.Node.prototype.ctor.call(this);
                    this.parallaxArray = [];
                    this._lastPosition = cc.p(-100, -100);
                },
                addChild: function(child, z, ratio, offset) {
                    if (3 === arguments.length) {
                        cc.log("ParallaxNode: use addChild(child, z, ratio, offset) instead");
                        return;
                    }
                    if (!child) {
                        throw new Error("cc.ParallaxNode.addChild(): child should be non-null");
                    }
                    var obj = new cc.PointObject(ratio, offset);
                    obj.setChild(child);
                    this.parallaxArray.push(obj);
                    child.setPosition(this._position.x * ratio.x + offset.x, this._position.y * ratio.y + offset.y);
                    _ccsg.Node.prototype.addChild.call(this, child, z, child.tag);
                },
                removeChild: function(child, cleanup) {
                    var locParallaxArray = this.parallaxArray;
                    for (var i = 0; i < locParallaxArray.length; i++) {
                        var point = locParallaxArray[i];
                        if (point.getChild() === child) {
                            locParallaxArray.splice(i, 1);
                            break;
                        }
                    }
                    _ccsg.Node.prototype.removeChild.call(this, child, cleanup);
                },
                removeAllChildren: function(cleanup) {
                    this.parallaxArray.length = 0;
                    _ccsg.Node.prototype.removeAllChildren.call(this, cleanup);
                },
                _updateParallaxPosition: function() {
                    var pos = this._absolutePosition();
                    if (!cc.pointEqualToPoint(pos, this._lastPosition)) {
                        var locParallaxArray = this.parallaxArray;
                        for (var i = 0, len = locParallaxArray.length; i < len; i++) {
                            var point = locParallaxArray[i];
                            var child = point.getChild();
                            child.setPosition(-pos.x + pos.x * point.getRatio().x + point.getOffset().x, -pos.y + pos.y * point.getRatio().y + point.getOffset().y);
                        }
                        this._lastPosition = pos;
                    }
                },
                _absolutePosition: function() {
                    var ret = this._position;
                    var cn = this;
                    while (null !== cn.parent) {
                        cn = cn.parent;
                        ret = cc.pAdd(ret, cn.getPosition());
                    }
                    return ret;
                },
                _createRenderCmd: function() {
                    if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                        return new cc.ParallaxNode.CanvasRenderCmd(this);
                    } else {
                        return new cc.ParallaxNode.WebGLRenderCmd(this);
                    }
                }
            });
            cc.ParallaxNode.create = function() {
                return new cc.ParallaxNode();
            };
            !function() {
                cc.ParallaxNode.CanvasRenderCmd = function(renderable) {
                    _ccsg.Node.CanvasRenderCmd.call(this, renderable);
                    this._needDraw = false;
                };
                var proto = cc.ParallaxNode.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
                proto.constructor = cc.ParallaxNode.CanvasRenderCmd;
                proto.updateStatus = function() {
                    this._node._updateParallaxPosition();
                    _ccsg.Node.CanvasRenderCmd.prototype.updateStatus.call(this);
                };
                proto._syncStatus = function(parentCmd) {
                    this._node._updateParallaxPosition();
                    _ccsg.Node.CanvasRenderCmd.prototype._syncStatus.call(this, parentCmd);
                };
            }();
            cc.game.once(cc.game.EVENT_RENDERER_INITED, function() {
                if (cc._renderType !== cc.game.RENDER_TYPE_WEBGL) {
                    return;
                }
                cc.ParallaxNode.WebGLRenderCmd = function(renderable) {
                    _ccsg.Node.WebGLRenderCmd.call(this, renderable);
                    this._needDraw = false;
                };
                var proto = cc.ParallaxNode.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
                proto.constructor = cc.ParallaxNode.WebGLRenderCmd;
                proto.updateStatus = function() {
                    this._node._updateParallaxPosition();
                    _ccsg.Node.WebGLRenderCmd.prototype.updateStatus.call(this);
                };
                proto._syncStatus = function(parentCmd) {
                    this._node._updateParallaxPosition();
                    _ccsg.Node.WebGLRenderCmd.prototype._syncStatus.call(this, parentCmd);
                };
            });
            !function() {
                var DEBUG = false;
                var sys = cc.sys;
                var version = sys.browserVersion;
                var supportWebAudio = !!(window.AudioContext || window.webkitAudioContext || window.mozAudioContext);
                var supportTable = {
                    common: {
                        MULTI_CHANNEL: true,
                        WEB_AUDIO: supportWebAudio,
                        AUTOPLAY: true
                    }
                };
                supportTable[sys.BROWSER_TYPE_IE] = {
                    MULTI_CHANNEL: true,
                    WEB_AUDIO: supportWebAudio,
                    AUTOPLAY: true,
                    USE_EMPTIED_EVENT: true
                };
                supportTable[sys.BROWSER_TYPE_ANDROID] = {
                    MULTI_CHANNEL: false,
                    WEB_AUDIO: false,
                    AUTOPLAY: false
                };
                supportTable[sys.BROWSER_TYPE_CHROME] = {
                    MULTI_CHANNEL: true,
                    WEB_AUDIO: true,
                    AUTOPLAY: false
                };
                supportTable[sys.BROWSER_TYPE_FIREFOX] = {
                    MULTI_CHANNEL: true,
                    WEB_AUDIO: true,
                    AUTOPLAY: true,
                    DELAY_CREATE_CTX: true
                };
                supportTable[sys.BROWSER_TYPE_UC] = {
                    MULTI_CHANNEL: true,
                    WEB_AUDIO: false,
                    AUTOPLAY: false
                };
                supportTable[sys.BROWSER_TYPE_QQ] = {
                    MULTI_CHANNEL: false,
                    WEB_AUDIO: false,
                    AUTOPLAY: true
                };
                supportTable[sys.BROWSER_TYPE_OUPENG] = {
                    MULTI_CHANNEL: false,
                    WEB_AUDIO: false,
                    AUTOPLAY: false,
                    REPLAY_AFTER_TOUCH: true,
                    USE_EMPTIED_EVENT: true
                };
                supportTable[sys.BROWSER_TYPE_WECHAT] = {
                    MULTI_CHANNEL: false,
                    WEB_AUDIO: false,
                    AUTOPLAY: false,
                    REPLAY_AFTER_TOUCH: true,
                    USE_EMPTIED_EVENT: true
                };
                supportTable[sys.BROWSER_TYPE_360] = {
                    MULTI_CHANNEL: false,
                    WEB_AUDIO: false,
                    AUTOPLAY: true
                };
                supportTable[sys.BROWSER_TYPE_MIUI] = {
                    MULTI_CHANNEL: false,
                    WEB_AUDIO: false,
                    AUTOPLAY: true
                };
                supportTable[sys.BROWSER_TYPE_LIEBAO] = {
                    MULTI_CHANNEL: false,
                    WEB_AUDIO: false,
                    AUTOPLAY: false,
                    REPLAY_AFTER_TOUCH: true,
                    USE_EMPTIED_EVENT: true
                };
                supportTable[sys.BROWSER_TYPE_SOUGOU] = {
                    MULTI_CHANNEL: false,
                    WEB_AUDIO: false,
                    AUTOPLAY: false,
                    REPLAY_AFTER_TOUCH: true,
                    USE_EMPTIED_EVENT: true
                };
                supportTable[sys.BROWSER_TYPE_BAIDU] = {
                    MULTI_CHANNEL: false,
                    WEB_AUDIO: false,
                    AUTOPLAY: false,
                    REPLAY_AFTER_TOUCH: true,
                    USE_EMPTIED_EVENT: true
                };
                supportTable[sys.BROWSER_TYPE_BAIDU_APP] = {
                    MULTI_CHANNEL: false,
                    WEB_AUDIO: false,
                    AUTOPLAY: false,
                    REPLAY_AFTER_TOUCH: true,
                    USE_EMPTIED_EVENT: true
                };
                supportTable[sys.BROWSER_TYPE_SAFARI] = {
                    MULTI_CHANNEL: true,
                    WEB_AUDIO: true,
                    AUTOPLAY: false,
                    webAudioCallback: function(realUrl) {
                        document.createElement("audio").src = realUrl;
                    }
                };
                if (cc.sys.isMobile) {
                    if (cc.sys.os !== cc.sys.OS_IOS) {
                        window.__audioSupport = supportTable[sys.browserType] || supportTable["common"];
                    } else {
                        window.__audioSupport = supportTable[sys.BROWSER_TYPE_SAFARI];
                    }
                } else {
                    switch (sys.browserType) {
                      case sys.BROWSER_TYPE_IE:
                        window.__audioSupport = supportTable[sys.BROWSER_TYPE_IE];
                        break;

                      case sys.BROWSER_TYPE_FIREFOX:
                        window.__audioSupport = supportTable[sys.BROWSER_TYPE_FIREFOX];
                        break;

                      default:
                        window.__audioSupport = supportTable["common"];
                    }
                }
                if (version) {
                    switch (sys.browserType) {
                      case sys.BROWSER_TYPE_CHROME:
                        version = parseInt(version);
                        if (version < 30) {
                            window.__audioSupport = {
                                MULTI_CHANNEL: false,
                                WEB_AUDIO: true,
                                AUTOPLAY: false
                            };
                        } else {
                            if (42 === version) {
                                window.__audioSupport.NEED_MANUAL_LOOP = true;
                            }
                        }
                        break;

                      case sys.BROWSER_TYPE_MIUI:
                        if (cc.sys.isMobile) {
                            version = version.match(/\d+/g);
                            if (version[0] < 2 || 2 === version[0] && 0 === version[1] && version[2] <= 1) {
                                window.__audioSupport.AUTOPLAY = false;
                            }
                        }
                    }
                }
                if (DEBUG) {
                    setTimeout(function() {
                        cc.log("browse type: " + sys.browserType);
                        cc.log("browse version: " + version);
                        cc.log("MULTI_CHANNEL: " + window.__audioSupport.MULTI_CHANNEL);
                        cc.log("WEB_AUDIO: " + window.__audioSupport.WEB_AUDIO);
                        cc.log("AUTOPLAY: " + window.__audioSupport.AUTOPLAY);
                    }, 0);
                }
            }();
            cc.Audio = cc._Class.extend({
                volume: 1,
                loop: false,
                src: null,
                _touch: false,
                _playing: false,
                _AUDIO_TYPE: "AUDIO",
                _pause: false,
                _buffer: null,
                _currentSource: null,
                _startTime: null,
                _currentTime: null,
                _context: null,
                _volume: null,
                _ignoreEnded: false,
                _manualLoop: false,
                _element: null,
                ctor: function(context, volume, url) {
                    context && (this._context = context);
                    volume && (this._volume = volume);
                    if (context && volume) {
                        this._AUDIO_TYPE = "WEBAUDIO";
                    }
                    this.src = url;
                },
                _setBufferCallback: null,
                setBuffer: function(buffer) {
                    if (!buffer) {
                        return;
                    }
                    var playing = this._playing;
                    this._AUDIO_TYPE = "WEBAUDIO";
                    if (this._buffer && this._buffer !== buffer && this.getPlaying()) {
                        this.stop();
                    }
                    this._buffer = buffer;
                    if (playing) {
                        this.play();
                    }
                    this._volume["gain"].value = this.volume;
                    this._setBufferCallback && this._setBufferCallback(buffer);
                },
                _setElementCallback: null,
                setElement: function(element) {
                    if (!element) {
                        return;
                    }
                    var playing = this._playing;
                    this._AUDIO_TYPE = "AUDIO";
                    if (this._element && this._element !== element && this.getPlaying()) {
                        this.stop();
                    }
                    this._element = element;
                    if (playing) {
                        this.play();
                    }
                    element.volume = this.volume;
                    element.loop = this.loop;
                    this._setElementCallback && this._setElementCallback(element);
                },
                play: function(offset, loop) {
                    this._playing = true;
                    this.loop = void 0 === loop ? this.loop : loop;
                    if ("AUDIO" === this._AUDIO_TYPE) {
                        this._playOfAudio(offset);
                    } else {
                        this._playOfWebAudio(offset);
                    }
                },
                getPlaying: function() {
                    if (!this._playing) {
                        return false;
                    }
                    if ("AUDIO" === this._AUDIO_TYPE) {
                        var audio = this._element;
                        if (!audio || this._pause || audio.ended) {
                            return this._playing = false;
                        }
                        return true;
                    }
                    var sourceNode = this._currentSource;
                    if (!sourceNode || !sourceNode["playbackState"]) {
                        return true;
                    }
                    return this._currentTime + this._context.currentTime - this._startTime < sourceNode.buffer.duration;
                },
                _playOfWebAudio: function(offset) {
                    var cs = this._currentSource;
                    if (!this._buffer) {
                        return;
                    }
                    if (!this._pause && cs) {
                        if (0 === this._context.currentTime || this._currentTime + this._context.currentTime - this._startTime > cs.buffer.duration) {
                            this._stopOfWebAudio();
                        } else {
                            return;
                        }
                    }
                    var audio = this._context["createBufferSource"]();
                    audio.buffer = this._buffer;
                    audio["connect"](this._volume);
                    if (this._manualLoop) {
                        audio.loop = false;
                    } else {
                        audio.loop = this.loop;
                    }
                    this._startTime = this._context.currentTime;
                    this._currentTime = offset || 0;
                    this._ignoreEnded = false;
                    if (audio.start) {
                        audio.start(0, offset || 0);
                    } else {
                        if (audio["noteGrainOn"]) {
                            var duration = audio.buffer.duration;
                            if (this.loop) {
                                audio["noteGrainOn"](0, offset, duration);
                            } else {
                                audio["noteGrainOn"](0, offset, duration - offset);
                            }
                        } else {
                            audio["noteOn"](0);
                        }
                    }
                    this._currentSource = audio;
                    var self = this;
                    audio["onended"] = function() {
                        if (self._manualLoop && self._playing && self.loop) {
                            self.stop();
                            self.play();
                            return;
                        }
                        if (self._ignoreEnded) {
                            self._ignoreEnded = false;
                        } else {
                            if (!self._pause) {
                                self.stop();
                            } else {
                                self._playing = false;
                            }
                        }
                    };
                },
                _playOfAudio: function() {
                    var audio = this._element;
                    if (audio) {
                        audio.loop = this.loop;
                        audio.play();
                    }
                },
                stop: function() {
                    this._playing = false;
                    if ("AUDIO" === this._AUDIO_TYPE) {
                        this._stopOfAudio();
                    } else {
                        this._stopOfWebAudio();
                    }
                },
                _stopOfWebAudio: function() {
                    var audio = this._currentSource;
                    this._ignoreEnded = true;
                    if (audio) {
                        audio.stop(0);
                        this._currentSource = null;
                    }
                },
                _stopOfAudio: function() {
                    var audio = this._element;
                    if (audio) {
                        audio.pause();
                        if (audio.duration && audio.duration !== 1 / 0) {
                            audio.currentTime = 0;
                        }
                    }
                },
                pause: function() {
                    if (false === this.getPlaying()) {
                        return;
                    }
                    this._playing = false;
                    this._pause = true;
                    if ("AUDIO" === this._AUDIO_TYPE) {
                        this._pauseOfAudio();
                    } else {
                        this._pauseOfWebAudio();
                    }
                },
                _pauseOfWebAudio: function() {
                    this._currentTime += this._context.currentTime - this._startTime;
                    var audio = this._currentSource;
                    if (audio) {
                        audio.stop(0);
                    }
                },
                _pauseOfAudio: function() {
                    var audio = this._element;
                    if (audio) {
                        audio.pause();
                    }
                },
                resume: function() {
                    if (this._pause) {
                        if ("AUDIO" === this._AUDIO_TYPE) {
                            this._resumeOfAudio();
                        } else {
                            this._resumeOfWebAudio();
                        }
                        this._pause = false;
                        this._playing = true;
                    }
                },
                _resumeOfWebAudio: function() {
                    var audio = this._currentSource;
                    if (audio) {
                        this._startTime = this._context.currentTime;
                        var offset = this._currentTime % audio.buffer.duration;
                        this._playOfWebAudio(offset);
                    }
                },
                _resumeOfAudio: function() {
                    var audio = this._element;
                    if (audio) {
                        audio.play();
                    }
                },
                setVolume: function(volume) {
                    if (volume > 1) {
                        volume = 1;
                    }
                    if (volume < 0) {
                        volume = 0;
                    }
                    this.volume = volume;
                    if ("AUDIO" === this._AUDIO_TYPE) {
                        if (this._element) {
                            this._element.volume = volume;
                        }
                    } else {
                        if (this._volume) {
                            this._volume["gain"].value = volume;
                        }
                    }
                },
                getVolume: function() {
                    return this.volume;
                },
                cloneNode: function() {
                    var audio, self;
                    if ("AUDIO" === this._AUDIO_TYPE) {
                        audio = new cc.Audio();
                        var elem = document.createElement("audio");
                        elem.src = this.src;
                        audio.setElement(elem);
                    } else {
                        var volume = this._context["createGain"]();
                        volume["gain"].value = 1;
                        volume["connect"](this._context["destination"]);
                        audio = new cc.Audio(this._context, volume, this.src);
                        if (this._buffer) {
                            audio.setBuffer(this._buffer);
                        } else {
                            self = this;
                            this._setBufferCallback = function(buffer) {
                                audio.setBuffer(buffer);
                                self._setBufferCallback = null;
                            };
                        }
                        audio._manualLoop = this._manualLoop;
                    }
                    audio._AUDIO_TYPE = this._AUDIO_TYPE;
                    return audio;
                }
            });
            !function(polyfill) {
                var SWA = polyfill.WEB_AUDIO, SWB = polyfill.MULTI_CHANNEL, SWC = polyfill.AUTOPLAY;
                var support = [];
                !function() {
                    var audio = document.createElement("audio");
                    if (audio.canPlayType) {
                        var ogg = audio.canPlayType('audio/ogg; codecs="vorbis"');
                        if (ogg && "" !== ogg) {
                            support.push(".ogg");
                        }
                        var mp3 = audio.canPlayType("audio/mpeg");
                        if (mp3 && "" !== mp3) {
                            support.push(".mp3");
                        }
                        var wav = audio.canPlayType('audio/wav; codecs="1"');
                        if (wav && "" !== wav) {
                            support.push(".wav");
                        }
                        var mp4 = audio.canPlayType("audio/mp4");
                        if (mp4 && "" !== mp4) {
                            support.push(".mp4");
                        }
                        var m4a = audio.canPlayType("audio/x-m4a");
                        if (m4a && "" !== m4a) {
                            support.push(".m4a");
                        }
                    }
                }();
                try {
                    if (SWA) {
                        var context = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext)();
                        if (polyfill.DELAY_CREATE_CTX) {
                            setTimeout(function() {
                                context = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext)();
                            }, 0);
                        }
                    }
                } catch (error) {
                    SWA = false;
                    cc.log("browser don't support web audio");
                }
                var loader = {
                    cache: {},
                    load: function(realUrl, url, res, cb) {
                        if (0 === support.length) {
                            return cb("can not support audio!");
                        }
                        var i;
                        if (cc.loader.audioPath) {
                            realUrl = cc.path.join(cc.loader.audioPath, realUrl);
                        }
                        var extname = cc.path.extname(realUrl);
                        var typeList = [ extname ];
                        for (i = 0; i < support.length; i++) {
                            if (extname !== support[i]) {
                                typeList.push(support[i]);
                            }
                        }
                        var audio;
                        if (loader.cache[url]) {
                            return cb(null, loader.cache[url]);
                        }
                        if (SWA) {
                            try {
                                var volume = context["createGain"]();
                                volume["gain"].value = 1;
                                volume["connect"](context["destination"]);
                                audio = new cc.Audio(context, volume, realUrl);
                                if (polyfill.NEED_MANUAL_LOOP) {
                                    audio._manualLoop = true;
                                }
                            } catch (err) {
                                SWA = false;
                                cc.log("browser don't support web audio");
                                audio = new cc.Audio(null, null, realUrl);
                            }
                        } else {
                            audio = new cc.Audio(null, null, realUrl);
                        }
                        this.loadAudioFromExtList(realUrl, typeList, audio, cb);
                        loader.cache[url] = audio;
                    },
                    loadAudioFromExtList: function(realUrl, typeList, audio, cb) {
                        if (0 === typeList.length) {
                            var ERRSTR = "can not found the resource of audio! Last match url is : ";
                            ERRSTR += realUrl.replace(/\.(.*)?$/, "(");
                            support.forEach(function(ext) {
                                ERRSTR += ext + "|";
                            });
                            ERRSTR = ERRSTR.replace(/\|$/, ")");
                            return cb({
                                status: 520,
                                errorMessage: ERRSTR
                            }, null);
                        }
                        realUrl = cc.path.changeExtname(realUrl, typeList.splice(0, 1));
                        if (SWA) {
                            if (polyfill.webAudioCallback) {
                                polyfill.webAudioCallback(realUrl);
                            }
                            var request = new XMLHttpRequest();
                            request.open("GET", realUrl, true);
                            request.responseType = "arraybuffer";
                            request.onload = function() {
                                context["decodeAudioData"](request.response, function(buffer) {
                                    audio.setBuffer(buffer);
                                    cb(null, audio);
                                }, function() {
                                    loader.loadAudioFromExtList(realUrl, typeList, audio, cb);
                                });
                            };
                            request.onerror = function() {
                                cb({
                                    status: 520,
                                    errorMessage: ERRSTR
                                }, null);
                            };
                            request.send();
                        } else {
                            var element = document.createElement("audio");
                            var cbCheck = false;
                            var termination = false;
                            var timer = setTimeout(function() {
                                if (0 === element.readyState) {
                                    emptied();
                                } else {
                                    termination = true;
                                    element.pause();
                                    document.body.removeChild(element);
                                    cb("audio load timeout : " + realUrl, audio);
                                }
                            }, 1e4);
                            var success = function() {
                                if (!cbCheck) {
                                    try {
                                        element.currentTime = 0;
                                        element.volume = 1;
                                    } catch (e) {}
                                    document.body.removeChild(element);
                                    audio.setElement(element);
                                    element.removeEventListener("canplaythrough", success, false);
                                    element.removeEventListener("error", failure, false);
                                    element.removeEventListener("emptied", emptied, false);
                                    !termination && cb(null, audio);
                                    cbCheck = true;
                                    clearTimeout(timer);
                                }
                            };
                            var failure = function() {
                                if (!cbCheck) {
                                    return;
                                }
                                document.body.removeChild(element);
                                element.removeEventListener("canplaythrough", success, false);
                                element.removeEventListener("error", failure, false);
                                element.removeEventListener("emptied", emptied, false);
                                !termination && loader.loadAudioFromExtList(realUrl, typeList, audio, cb);
                                cbCheck = true;
                                clearTimeout(timer);
                            };
                            var emptied = function() {
                                termination = true;
                                success();
                                cb(null, audio);
                            };
                            element.addEventListener("canplaythrough", success, false);
                            element.addEventListener("error", failure, false);
                            if (polyfill.USE_EMPTIED_EVENT) {
                                element.addEventListener("emptied", emptied, false);
                            }
                            element.src = realUrl;
                            document.body.appendChild(element);
                            element.volume = 0;
                        }
                    }
                };
                cc.loader.register([ "mp3", "ogg", "wav", "mp4", "m4a" ], loader);
                cc.audioEngine = {
                    _currMusic: null,
                    _musicVolume: 1,
                    features: polyfill,
                    willPlayMusic: function() {
                        return false;
                    },
                    playMusic: function(url, loop) {
                        var bgMusic = this._currMusic;
                        if (bgMusic && bgMusic.src !== url && bgMusic.getPlaying()) {
                            bgMusic.stop();
                        }
                        var audio = loader.cache[url];
                        if (!audio) {
                            cc.loader.load(url);
                            audio = loader.cache[url];
                        }
                        audio.play(0, loop);
                        audio.setVolume(this._musicVolume);
                        this._currMusic = audio;
                    },
                    stopMusic: function(releaseData) {
                        var audio = this._currMusic;
                        if (audio) {
                            audio.stop();
                            if (releaseData) {
                                cc.loader.release(audio.src);
                            }
                        }
                    },
                    pauseMusic: function() {
                        var audio = this._currMusic;
                        if (audio) {
                            audio.pause();
                        }
                    },
                    resumeMusic: function() {
                        var audio = this._currMusic;
                        if (audio) {
                            audio.resume();
                        }
                    },
                    rewindMusic: function() {
                        var audio = this._currMusic;
                        if (audio) {
                            audio.stop();
                            audio.play();
                        }
                    },
                    getMusicVolume: function() {
                        return this._musicVolume;
                    },
                    setMusicVolume: function(volume) {
                        volume -= 0;
                        if (isNaN(volume)) {
                            volume = 1;
                        }
                        if (volume > 1) {
                            volume = 1;
                        }
                        if (volume < 0) {
                            volume = 0;
                        }
                        this._musicVolume = volume;
                        var audio = this._currMusic;
                        if (audio) {
                            audio.setVolume(volume);
                        }
                    },
                    isMusicPlaying: function() {
                        var audio = this._currMusic;
                        if (audio) {
                            return audio.getPlaying();
                        } else {
                            return false;
                        }
                    },
                    _audioPool: {},
                    _maxAudioInstance: 5,
                    _effectVolume: 1,
                    playEffect: function(url, loop) {
                        if (!SWB) {
                            return null;
                        }
                        var effectList = this._audioPool[url];
                        if (!effectList) {
                            effectList = this._audioPool[url] = [];
                        }
                        var i;
                        for (i = 0; i < effectList.length; i++) {
                            if (!effectList[i].getPlaying()) {
                                break;
                            }
                        }
                        if (effectList[i]) {
                            audio = effectList[i];
                            audio.setVolume(this._effectVolume);
                            audio.play(0, loop);
                        } else {
                            if (!SWA && i > this._maxAudioInstance) {
                                cc.log("Error: %s greater than %d", url, this._maxAudioInstance);
                            } else {
                                var audio = loader.cache[url];
                                if (!audio) {
                                    cc.loader.load(url);
                                    audio = loader.cache[url];
                                }
                                audio = audio.cloneNode();
                                audio.setVolume(this._effectVolume);
                                audio.loop = loop || false;
                                audio.play();
                                effectList.push(audio);
                            }
                        }
                        return audio;
                    },
                    setEffectsVolume: function(volume) {
                        volume -= 0;
                        if (isNaN(volume)) {
                            volume = 1;
                        }
                        if (volume > 1) {
                            volume = 1;
                        }
                        if (volume < 0) {
                            volume = 0;
                        }
                        this._effectVolume = volume;
                        var audioPool = this._audioPool;
                        for (var p in audioPool) {
                            var audioList = audioPool[p];
                            if (Array.isArray(audioList)) {
                                for (var i = 0; i < audioList.length; i++) {
                                    audioList[i].setVolume(volume);
                                }
                            }
                        }
                    },
                    getEffectsVolume: function() {
                        return this._effectVolume;
                    },
                    pauseEffect: function(audio) {
                        if (audio) {
                            audio.pause();
                        }
                    },
                    pauseAllEffects: function() {
                        var ap = this._audioPool;
                        for (var p in ap) {
                            var list = ap[p];
                            for (var i = 0; i < ap[p].length; i++) {
                                if (list[i].getPlaying()) {
                                    list[i].pause();
                                }
                            }
                        }
                    },
                    resumeEffect: function(audio) {
                        if (audio) {
                            audio.resume();
                        }
                    },
                    resumeAllEffects: function() {
                        var ap = this._audioPool;
                        for (var p in ap) {
                            var list = ap[p];
                            for (var i = 0; i < ap[p].length; i++) {
                                list[i].resume();
                            }
                        }
                    },
                    stopEffect: function(audio) {
                        if (audio) {
                            audio.stop();
                        }
                    },
                    stopAllEffects: function() {
                        var ap = this._audioPool;
                        for (var p in ap) {
                            var list = ap[p];
                            for (var i = 0; i < ap[p].length; i++) {
                                list[i].stop();
                            }
                        }
                    },
                    unloadEffect: function(url) {
                        if (!url) {
                            return;
                        }
                        cc.loader.release(url);
                        var pool = this._audioPool[url];
                        if (pool) {
                            pool.length = 0;
                        }
                        delete this._audioPool[url];
                        delete loader.cache[url];
                    },
                    end: function() {
                        this.stopMusic();
                        this.stopAllEffects();
                    },
                    _pauseCache: [],
                    _pausePlaying: function() {
                        var bgMusic = this._currMusic;
                        if (bgMusic && bgMusic.getPlaying()) {
                            bgMusic.pause();
                            this._pauseCache.push(bgMusic);
                        }
                        var ap = this._audioPool;
                        for (var p in ap) {
                            var list = ap[p];
                            for (var i = 0; i < ap[p].length; i++) {
                                if (list[i].getPlaying()) {
                                    list[i].pause();
                                    this._pauseCache.push(list[i]);
                                }
                            }
                        }
                    },
                    _resumePlaying: function() {
                        var list = this._pauseCache;
                        for (var i = 0; i < list.length; i++) {
                            list[i].resume();
                        }
                        list.length = 0;
                    }
                };
                if (!SWC) {
                    var reBGM = function() {
                        var bg = cc.audioEngine._currMusic;
                        if (bg && false === bg._touch && bg._playing && bg.getPlaying()) {
                            bg._touch = true;
                            bg.play(0, bg.loop);
                            !polyfill.REPLAY_AFTER_TOUCH && cc._canvas.removeEventListener("touchstart", reBGM);
                        }
                    };
                    setTimeout(function() {
                        if (cc._canvas) {
                            cc._canvas.addEventListener("touchstart", reBGM, false);
                        }
                    }, 150);
                }
            }(window.__audioSupport);
            var spine = {
                radDeg: 180 / Math.PI,
                degRad: Math.PI / 180,
                temp: [],
                Float32Array: "undefined" === typeof Float32Array ? Array : Float32Array,
                Uint16Array: "undefined" === typeof Uint16Array ? Array : Uint16Array
            };
            spine.BoneData = function(name, parent) {
                this.name = name;
                this.parent = parent;
            };
            spine.BoneData.prototype = {
                length: 0,
                x: 0,
                y: 0,
                rotation: 0,
                scaleX: 1,
                scaleY: 1,
                inheritScale: true,
                inheritRotation: true,
                flipX: false,
                flipY: false
            };
            spine.BlendMode = {
                normal: 0,
                additive: 1,
                multiply: 2,
                screen: 3
            };
            spine.SlotData = function(name, boneData) {
                this.name = name;
                this.boneData = boneData;
            };
            spine.SlotData.prototype = {
                r: 1,
                g: 1,
                b: 1,
                a: 1,
                attachmentName: null,
                blendMode: spine.BlendMode.normal
            };
            spine.IkConstraintData = function(name) {
                this.name = name;
                this.bones = [];
            };
            spine.IkConstraintData.prototype = {
                target: null,
                bendDirection: 1,
                mix: 1
            };
            spine.Bone = function(boneData, skeleton, parent) {
                this.data = boneData;
                this.skeleton = skeleton;
                this.parent = parent;
                this.setToSetupPose();
            };
            spine.Bone.yDown = false;
            spine.Bone.prototype = {
                x: 0,
                y: 0,
                rotation: 0,
                rotationIK: 0,
                scaleX: 1,
                scaleY: 1,
                flipX: false,
                flipY: false,
                m00: 0,
                m01: 0,
                worldX: 0,
                m10: 0,
                m11: 0,
                worldY: 0,
                worldRotation: 0,
                worldScaleX: 1,
                worldScaleY: 1,
                worldFlipX: false,
                worldFlipY: false,
                updateWorldTransform: function() {
                    var parent = this.parent;
                    if (parent) {
                        this.worldX = this.x * parent.m00 + this.y * parent.m01 + parent.worldX;
                        this.worldY = this.x * parent.m10 + this.y * parent.m11 + parent.worldY;
                        if (this.data.inheritScale) {
                            this.worldScaleX = parent.worldScaleX * this.scaleX;
                            this.worldScaleY = parent.worldScaleY * this.scaleY;
                        } else {
                            this.worldScaleX = this.scaleX;
                            this.worldScaleY = this.scaleY;
                        }
                        this.worldRotation = this.data.inheritRotation ? parent.worldRotation + this.rotationIK : this.rotationIK;
                        this.worldFlipX = parent.worldFlipX != this.flipX;
                        this.worldFlipY = parent.worldFlipY != this.flipY;
                    } else {
                        var skeletonFlipX = this.skeleton.flipX, skeletonFlipY = this.skeleton.flipY;
                        this.worldX = skeletonFlipX ? -this.x : this.x;
                        this.worldY = skeletonFlipY != spine.Bone.yDown ? -this.y : this.y;
                        this.worldScaleX = this.scaleX;
                        this.worldScaleY = this.scaleY;
                        this.worldRotation = this.rotationIK;
                        this.worldFlipX = skeletonFlipX != this.flipX;
                        this.worldFlipY = skeletonFlipY != this.flipY;
                    }
                    var radians = this.worldRotation * spine.degRad;
                    var cos = Math.cos(radians);
                    var sin = Math.sin(radians);
                    if (this.worldFlipX) {
                        this.m00 = -cos * this.worldScaleX;
                        this.m01 = sin * this.worldScaleY;
                    } else {
                        this.m00 = cos * this.worldScaleX;
                        this.m01 = -sin * this.worldScaleY;
                    }
                    if (this.worldFlipY != spine.Bone.yDown) {
                        this.m10 = -sin * this.worldScaleX;
                        this.m11 = -cos * this.worldScaleY;
                    } else {
                        this.m10 = sin * this.worldScaleX;
                        this.m11 = cos * this.worldScaleY;
                    }
                },
                setToSetupPose: function() {
                    var data = this.data;
                    this.x = data.x;
                    this.y = data.y;
                    this.rotation = data.rotation;
                    this.rotationIK = this.rotation;
                    this.scaleX = data.scaleX;
                    this.scaleY = data.scaleY;
                    this.flipX = data.flipX;
                    this.flipY = data.flipY;
                },
                worldToLocal: function(world) {
                    var dx = world[0] - this.worldX, dy = world[1] - this.worldY;
                    var m00 = this.m00, m10 = this.m10, m01 = this.m01, m11 = this.m11;
                    if (this.worldFlipX != (this.worldFlipY != spine.Bone.yDown)) {
                        m00 = -m00;
                        m11 = -m11;
                    }
                    var invDet = 1 / (m00 * m11 - m01 * m10);
                    world[0] = dx * m00 * invDet - dy * m01 * invDet;
                    world[1] = dy * m11 * invDet - dx * m10 * invDet;
                },
                localToWorld: function(local) {
                    var localX = local[0], localY = local[1];
                    local[0] = localX * this.m00 + localY * this.m01 + this.worldX;
                    local[1] = localX * this.m10 + localY * this.m11 + this.worldY;
                }
            };
            spine.Slot = function(slotData, bone) {
                this.data = slotData;
                this.bone = bone;
                this.setToSetupPose();
            };
            spine.Slot.prototype = {
                r: 1,
                g: 1,
                b: 1,
                a: 1,
                _attachmentTime: 0,
                attachment: null,
                attachmentVertices: [],
                setAttachment: function(attachment) {
                    this.attachment = attachment;
                    this._attachmentTime = this.bone.skeleton.time;
                    this.attachmentVertices.length = 0;
                },
                setAttachmentTime: function(time) {
                    this._attachmentTime = this.bone.skeleton.time - time;
                },
                getAttachmentTime: function() {
                    return this.bone.skeleton.time - this._attachmentTime;
                },
                setToSetupPose: function() {
                    var data = this.data;
                    this.r = data.r;
                    this.g = data.g;
                    this.b = data.b;
                    this.a = data.a;
                    var slotDatas = this.bone.skeleton.data.slots;
                    for (var i = 0, n = slotDatas.length; i < n; i++) {
                        if (slotDatas[i] == data) {
                            this.setAttachment(!data.attachmentName ? null : this.bone.skeleton.getAttachmentBySlotIndex(i, data.attachmentName));
                            break;
                        }
                    }
                }
            };
            spine.IkConstraint = function(data, skeleton) {
                this.data = data;
                this.mix = data.mix;
                this.bendDirection = data.bendDirection;
                this.bones = [];
                for (var i = 0, n = data.bones.length; i < n; i++) {
                    this.bones.push(skeleton.findBone(data.bones[i].name));
                }
                this.target = skeleton.findBone(data.target.name);
            };
            spine.IkConstraint.prototype = {
                apply: function() {
                    var target = this.target;
                    var bones = this.bones;
                    switch (bones.length) {
                      case 1:
                        spine.IkConstraint.apply1(bones[0], target.worldX, target.worldY, this.mix);
                        break;

                      case 2:
                        spine.IkConstraint.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.mix);
                    }
                }
            };
            spine.IkConstraint.apply1 = function(bone, targetX, targetY, alpha) {
                var parentRotation = !bone.data.inheritRotation || !bone.parent ? 0 : bone.parent.worldRotation;
                var rotation = bone.rotation;
                var rotationIK = Math.atan2(targetY - bone.worldY, targetX - bone.worldX) * spine.radDeg;
                if (bone.worldFlipX != (bone.worldFlipY != spine.Bone.yDown)) {
                    rotationIK = -rotationIK;
                }
                rotationIK -= parentRotation;
                bone.rotationIK = rotation + (rotationIK - rotation) * alpha;
            };
            spine.IkConstraint.apply2 = function(parent, child, targetX, targetY, bendDirection, alpha) {
                var childRotation = child.rotation, parentRotation = parent.rotation;
                if (!alpha) {
                    child.rotationIK = childRotation;
                    parent.rotationIK = parentRotation;
                    return;
                }
                var positionX, positionY, tempPosition = spine.temp;
                var parentParent = parent.parent;
                if (parentParent) {
                    tempPosition[0] = targetX;
                    tempPosition[1] = targetY;
                    parentParent.worldToLocal(tempPosition);
                    targetX = (tempPosition[0] - parent.x) * parentParent.worldScaleX;
                    targetY = (tempPosition[1] - parent.y) * parentParent.worldScaleY;
                } else {
                    targetX -= parent.x;
                    targetY -= parent.y;
                }
                if (child.parent == parent) {
                    positionX = child.x;
                    positionY = child.y;
                } else {
                    tempPosition[0] = child.x;
                    tempPosition[1] = child.y;
                    child.parent.localToWorld(tempPosition);
                    parent.worldToLocal(tempPosition);
                    positionX = tempPosition[0];
                    positionY = tempPosition[1];
                }
                var childX = positionX * parent.worldScaleX, childY = positionY * parent.worldScaleY;
                var offset = Math.atan2(childY, childX);
                var len1 = Math.sqrt(childX * childX + childY * childY), len2 = child.data.length * child.worldScaleX;
                var cosDenom = 2 * len1 * len2;
                if (cosDenom < 1e-4) {
                    child.rotationIK = childRotation + (Math.atan2(targetY, targetX) * spine.radDeg - parentRotation - childRotation) * alpha;
                    return;
                }
                var cos = (targetX * targetX + targetY * targetY - len1 * len1 - len2 * len2) / cosDenom;
                if (cos < -1) {
                    cos = -1;
                } else {
                    if (cos > 1) {
                        cos = 1;
                    }
                }
                var childAngle = Math.acos(cos) * bendDirection;
                var adjacent = len1 + len2 * cos, opposite = len2 * Math.sin(childAngle);
                var parentAngle = Math.atan2(targetY * adjacent - targetX * opposite, targetX * adjacent + targetY * opposite);
                var rotation = (parentAngle - offset) * spine.radDeg - parentRotation;
                if (rotation > 180) {
                    rotation -= 360;
                } else {
                    if (rotation < -180) {
                        rotation += 360;
                    }
                }
                parent.rotationIK = parentRotation + rotation * alpha;
                rotation = (childAngle + offset) * spine.radDeg - childRotation;
                if (rotation > 180) {
                    rotation -= 360;
                } else {
                    if (rotation < -180) {
                        rotation += 360;
                    }
                }
                child.rotationIK = childRotation + (rotation + parent.worldRotation - child.parent.worldRotation) * alpha;
            };
            spine.Skin = function(name) {
                this.name = name;
                this.attachments = {};
            };
            spine.Skin.prototype = {
                addAttachment: function(slotIndex, name, attachment) {
                    this.attachments[slotIndex + ":" + name] = attachment;
                },
                getAttachment: function(slotIndex, name) {
                    return this.attachments[slotIndex + ":" + name];
                },
                _attachAll: function(skeleton, oldSkin) {
                    for (var key in oldSkin.attachments) {
                        var colon = key.indexOf(":");
                        var slotIndex = parseInt(key.substring(0, colon));
                        var name = key.substring(colon + 1);
                        var slot = skeleton.slots[slotIndex];
                        if (slot.attachment && slot.attachment.name == name) {
                            var attachment = this.getAttachment(slotIndex, name);
                            if (attachment) {
                                slot.setAttachment(attachment);
                            }
                        }
                    }
                }
            };
            spine.Animation = function(name, timelines, duration) {
                this.name = name;
                this.timelines = timelines;
                this.duration = duration;
            };
            spine.Animation.prototype = {
                apply: function(skeleton, lastTime, time, loop, events) {
                    if (loop && 0 != this.duration) {
                        time %= this.duration;
                        lastTime %= this.duration;
                    }
                    var timelines = this.timelines;
                    for (var i = 0, n = timelines.length; i < n; i++) {
                        timelines[i].apply(skeleton, lastTime, time, events, 1);
                    }
                },
                mix: function(skeleton, lastTime, time, loop, events, alpha) {
                    if (loop && 0 != this.duration) {
                        time %= this.duration;
                        lastTime %= this.duration;
                    }
                    var timelines = this.timelines;
                    for (var i = 0, n = timelines.length; i < n; i++) {
                        timelines[i].apply(skeleton, lastTime, time, events, alpha);
                    }
                }
            };
            spine.Animation.binarySearch = function(values, target, step) {
                var low = 0;
                var high = Math.floor(values.length / step) - 2;
                if (!high) {
                    return step;
                }
                var current = high >>> 1;
                while (true) {
                    if (values[(current + 1) * step] <= target) {
                        low = current + 1;
                    } else {
                        high = current;
                    }
                    if (low == high) {
                        return (low + 1) * step;
                    }
                    current = low + high >>> 1;
                }
            };
            spine.Animation.binarySearch1 = function(values, target) {
                var low = 0;
                var high = values.length - 2;
                if (!high) {
                    return 1;
                }
                var current = high >>> 1;
                while (true) {
                    if (values[current + 1] <= target) {
                        low = current + 1;
                    } else {
                        high = current;
                    }
                    if (low == high) {
                        return low + 1;
                    }
                    current = low + high >>> 1;
                }
            };
            spine.Animation.linearSearch = function(values, target, step) {
                for (var i = 0, last = values.length - step; i <= last; i += step) {
                    if (values[i] > target) {
                        return i;
                    }
                }
                return -1;
            };
            spine.Curves = function(frameCount) {
                this.curves = [];
            };
            spine.Curves.prototype = {
                setLinear: function(frameIndex) {
                    this.curves[19 * frameIndex] = 0;
                },
                setStepped: function(frameIndex) {
                    this.curves[19 * frameIndex] = 1;
                },
                setCurve: function(frameIndex, cx1, cy1, cx2, cy2) {
                    var subdiv1 = .1, subdiv2 = subdiv1 * subdiv1, subdiv3 = subdiv2 * subdiv1;
                    var pre1 = 3 * subdiv1, pre2 = 3 * subdiv2, pre4 = 6 * subdiv2, pre5 = 6 * subdiv3;
                    var tmp1x = 2 * -cx1 + cx2, tmp1y = 2 * -cy1 + cy2, tmp2x = 3 * (cx1 - cx2) + 1, tmp2y = 3 * (cy1 - cy2) + 1;
                    var dfx = cx1 * pre1 + tmp1x * pre2 + tmp2x * subdiv3, dfy = cy1 * pre1 + tmp1y * pre2 + tmp2y * subdiv3;
                    var ddfx = tmp1x * pre4 + tmp2x * pre5, ddfy = tmp1y * pre4 + tmp2y * pre5;
                    var dddfx = tmp2x * pre5, dddfy = tmp2y * pre5;
                    var i = 19 * frameIndex;
                    var curves = this.curves;
                    curves[i++] = 2;
                    var x = dfx, y = dfy;
                    for (var n = i + 19 - 1; i < n; i += 2) {
                        curves[i] = x;
                        curves[i + 1] = y;
                        dfx += ddfx;
                        dfy += ddfy;
                        ddfx += dddfx;
                        ddfy += dddfy;
                        x += dfx;
                        y += dfy;
                    }
                },
                getCurvePercent: function(frameIndex, percent) {
                    percent = percent < 0 ? 0 : percent > 1 ? 1 : percent;
                    var curves = this.curves;
                    var i = 19 * frameIndex;
                    var type = curves[i];
                    if (0 === type) {
                        return percent;
                    }
                    if (1 == type) {
                        return 0;
                    }
                    i++;
                    var x = 0;
                    for (var start = i, n = i + 19 - 1; i < n; i += 2) {
                        x = curves[i];
                        if (x >= percent) {
                            var prevX, prevY;
                            if (i == start) {
                                prevX = 0;
                                prevY = 0;
                            } else {
                                prevX = curves[i - 2];
                                prevY = curves[i - 1];
                            }
                            return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);
                        }
                    }
                    var y = curves[i - 1];
                    return y + (1 - y) * (percent - x) / (1 - x);
                }
            };
            spine.RotateTimeline = function(frameCount) {
                this.curves = new spine.Curves(frameCount);
                this.frames = [];
                this.frames.length = 2 * frameCount;
            };
            spine.RotateTimeline.prototype = {
                boneIndex: 0,
                getFrameCount: function() {
                    return this.frames.length / 2;
                },
                setFrame: function(frameIndex, time, angle) {
                    frameIndex *= 2;
                    this.frames[frameIndex] = time;
                    this.frames[frameIndex + 1] = angle;
                },
                apply: function(skeleton, lastTime, time, firedEvents, alpha) {
                    var frames = this.frames;
                    if (time < frames[0]) {
                        return;
                    }
                    var bone = skeleton.bones[this.boneIndex];
                    if (time >= frames[frames.length - 2]) {
                        var amount = bone.data.rotation + frames[frames.length - 1] - bone.rotation;
                        while (amount > 180) {
                            amount -= 360;
                        }
                        while (amount < -180) {
                            amount += 360;
                        }
                        bone.rotation += amount * alpha;
                        return;
                    }
                    var frameIndex = spine.Animation.binarySearch(frames, time, 2);
                    var prevFrameValue = frames[frameIndex - 1];
                    var frameTime = frames[frameIndex];
                    var percent = 1 - (time - frameTime) / (frames[frameIndex - 2] - frameTime);
                    percent = this.curves.getCurvePercent(frameIndex / 2 - 1, percent);
                    var amount = frames[frameIndex + 1] - prevFrameValue;
                    while (amount > 180) {
                        amount -= 360;
                    }
                    while (amount < -180) {
                        amount += 360;
                    }
                    amount = bone.data.rotation + (prevFrameValue + amount * percent) - bone.rotation;
                    while (amount > 180) {
                        amount -= 360;
                    }
                    while (amount < -180) {
                        amount += 360;
                    }
                    bone.rotation += amount * alpha;
                }
            };
            spine.TranslateTimeline = function(frameCount) {
                this.curves = new spine.Curves(frameCount);
                this.frames = [];
                this.frames.length = 3 * frameCount;
            };
            spine.TranslateTimeline.prototype = {
                boneIndex: 0,
                getFrameCount: function() {
                    return this.frames.length / 3;
                },
                setFrame: function(frameIndex, time, x, y) {
                    frameIndex *= 3;
                    this.frames[frameIndex] = time;
                    this.frames[frameIndex + 1] = x;
                    this.frames[frameIndex + 2] = y;
                },
                apply: function(skeleton, lastTime, time, firedEvents, alpha) {
                    var frames = this.frames;
                    if (time < frames[0]) {
                        return;
                    }
                    var bone = skeleton.bones[this.boneIndex];
                    if (time >= frames[frames.length - 3]) {
                        bone.x += (bone.data.x + frames[frames.length - 2] - bone.x) * alpha;
                        bone.y += (bone.data.y + frames[frames.length - 1] - bone.y) * alpha;
                        return;
                    }
                    var frameIndex = spine.Animation.binarySearch(frames, time, 3);
                    var prevFrameX = frames[frameIndex - 2];
                    var prevFrameY = frames[frameIndex - 1];
                    var frameTime = frames[frameIndex];
                    var percent = 1 - (time - frameTime) / (frames[frameIndex + -3] - frameTime);
                    percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);
                    bone.x += (bone.data.x + prevFrameX + (frames[frameIndex + 1] - prevFrameX) * percent - bone.x) * alpha;
                    bone.y += (bone.data.y + prevFrameY + (frames[frameIndex + 2] - prevFrameY) * percent - bone.y) * alpha;
                }
            };
            spine.ScaleTimeline = function(frameCount) {
                this.curves = new spine.Curves(frameCount);
                this.frames = [];
                this.frames.length = 3 * frameCount;
            };
            spine.ScaleTimeline.prototype = {
                boneIndex: 0,
                getFrameCount: function() {
                    return this.frames.length / 3;
                },
                setFrame: function(frameIndex, time, x, y) {
                    frameIndex *= 3;
                    this.frames[frameIndex] = time;
                    this.frames[frameIndex + 1] = x;
                    this.frames[frameIndex + 2] = y;
                },
                apply: function(skeleton, lastTime, time, firedEvents, alpha) {
                    var frames = this.frames;
                    if (time < frames[0]) {
                        return;
                    }
                    var bone = skeleton.bones[this.boneIndex];
                    if (time >= frames[frames.length - 3]) {
                        bone.scaleX += (bone.data.scaleX * frames[frames.length - 2] - bone.scaleX) * alpha;
                        bone.scaleY += (bone.data.scaleY * frames[frames.length - 1] - bone.scaleY) * alpha;
                        return;
                    }
                    var frameIndex = spine.Animation.binarySearch(frames, time, 3);
                    var prevFrameX = frames[frameIndex - 2];
                    var prevFrameY = frames[frameIndex - 1];
                    var frameTime = frames[frameIndex];
                    var percent = 1 - (time - frameTime) / (frames[frameIndex + -3] - frameTime);
                    percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);
                    bone.scaleX += (bone.data.scaleX * (prevFrameX + (frames[frameIndex + 1] - prevFrameX) * percent) - bone.scaleX) * alpha;
                    bone.scaleY += (bone.data.scaleY * (prevFrameY + (frames[frameIndex + 2] - prevFrameY) * percent) - bone.scaleY) * alpha;
                }
            };
            spine.ColorTimeline = function(frameCount) {
                this.curves = new spine.Curves(frameCount);
                this.frames = [];
                this.frames.length = 5 * frameCount;
            };
            spine.ColorTimeline.prototype = {
                slotIndex: 0,
                getFrameCount: function() {
                    return this.frames.length / 5;
                },
                setFrame: function(frameIndex, time, r, g, b, a) {
                    frameIndex *= 5;
                    this.frames[frameIndex] = time;
                    this.frames[frameIndex + 1] = r;
                    this.frames[frameIndex + 2] = g;
                    this.frames[frameIndex + 3] = b;
                    this.frames[frameIndex + 4] = a;
                },
                apply: function(skeleton, lastTime, time, firedEvents, alpha) {
                    var frames = this.frames;
                    if (time < frames[0]) {
                        return;
                    }
                    var r, g, b, a;
                    if (time >= frames[frames.length - 5]) {
                        var i = frames.length - 1;
                        r = frames[i - 3];
                        g = frames[i - 2];
                        b = frames[i - 1];
                        a = frames[i];
                    } else {
                        var frameIndex = spine.Animation.binarySearch(frames, time, 5);
                        var prevFrameR = frames[frameIndex - 4];
                        var prevFrameG = frames[frameIndex - 3];
                        var prevFrameB = frames[frameIndex - 2];
                        var prevFrameA = frames[frameIndex - 1];
                        var frameTime = frames[frameIndex];
                        var percent = 1 - (time - frameTime) / (frames[frameIndex - 5] - frameTime);
                        percent = this.curves.getCurvePercent(frameIndex / 5 - 1, percent);
                        r = prevFrameR + (frames[frameIndex + 1] - prevFrameR) * percent;
                        g = prevFrameG + (frames[frameIndex + 2] - prevFrameG) * percent;
                        b = prevFrameB + (frames[frameIndex + 3] - prevFrameB) * percent;
                        a = prevFrameA + (frames[frameIndex + 4] - prevFrameA) * percent;
                    }
                    var slot = skeleton.slots[this.slotIndex];
                    if (alpha < 1) {
                        slot.r += (r - slot.r) * alpha;
                        slot.g += (g - slot.g) * alpha;
                        slot.b += (b - slot.b) * alpha;
                        slot.a += (a - slot.a) * alpha;
                    } else {
                        slot.r = r;
                        slot.g = g;
                        slot.b = b;
                        slot.a = a;
                    }
                }
            };
            spine.AttachmentTimeline = function(frameCount) {
                this.curves = new spine.Curves(frameCount);
                this.frames = [];
                this.frames.length = frameCount;
                this.attachmentNames = [];
                this.attachmentNames.length = frameCount;
            };
            spine.AttachmentTimeline.prototype = {
                slotIndex: 0,
                getFrameCount: function() {
                    return this.frames.length;
                },
                setFrame: function(frameIndex, time, attachmentName) {
                    this.frames[frameIndex] = time;
                    this.attachmentNames[frameIndex] = attachmentName;
                },
                apply: function(skeleton, lastTime, time, firedEvents, alpha) {
                    var frames = this.frames;
                    if (time < frames[0]) {
                        if (lastTime > time) {
                            this.apply(skeleton, lastTime, Number.MAX_VALUE, null, 0);
                        }
                        return;
                    } else {
                        if (lastTime > time) {
                            lastTime = -1;
                        }
                    }
                    var frameIndex = time >= frames[frames.length - 1] ? frames.length - 1 : spine.Animation.binarySearch1(frames, time) - 1;
                    if (frames[frameIndex] < lastTime) {
                        return;
                    }
                    var attachmentName = this.attachmentNames[frameIndex];
                    skeleton.slots[this.slotIndex].setAttachment(!attachmentName ? null : skeleton.getAttachmentBySlotIndex(this.slotIndex, attachmentName));
                }
            };
            spine.EventTimeline = function(frameCount) {
                this.frames = [];
                this.frames.length = frameCount;
                this.events = [];
                this.events.length = frameCount;
            };
            spine.EventTimeline.prototype = {
                getFrameCount: function() {
                    return this.frames.length;
                },
                setFrame: function(frameIndex, time, event) {
                    this.frames[frameIndex] = time;
                    this.events[frameIndex] = event;
                },
                apply: function(skeleton, lastTime, time, firedEvents, alpha) {
                    if (!firedEvents) {
                        return;
                    }
                    var frames = this.frames;
                    var frameCount = frames.length;
                    if (lastTime > time) {
                        this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha);
                        lastTime = -1;
                    } else {
                        if (lastTime >= frames[frameCount - 1]) {
                            return;
                        }
                    }
                    if (time < frames[0]) {
                        return;
                    }
                    var frameIndex;
                    if (lastTime < frames[0]) {
                        frameIndex = 0;
                    } else {
                        frameIndex = spine.Animation.binarySearch1(frames, lastTime);
                        var frame = frames[frameIndex];
                        while (frameIndex > 0) {
                            if (frames[frameIndex - 1] != frame) {
                                break;
                            }
                            frameIndex--;
                        }
                    }
                    var events = this.events;
                    for (;frameIndex < frameCount && time >= frames[frameIndex]; frameIndex++) {
                        firedEvents.push(events[frameIndex]);
                    }
                }
            };
            spine.DrawOrderTimeline = function(frameCount) {
                this.frames = [];
                this.frames.length = frameCount;
                this.drawOrders = [];
                this.drawOrders.length = frameCount;
            };
            spine.DrawOrderTimeline.prototype = {
                getFrameCount: function() {
                    return this.frames.length;
                },
                setFrame: function(frameIndex, time, drawOrder) {
                    this.frames[frameIndex] = time;
                    this.drawOrders[frameIndex] = drawOrder;
                },
                apply: function(skeleton, lastTime, time, firedEvents, alpha) {
                    var frames = this.frames;
                    if (time < frames[0]) {
                        return;
                    }
                    var frameIndex;
                    if (time >= frames[frames.length - 1]) {
                        frameIndex = frames.length - 1;
                    } else {
                        frameIndex = spine.Animation.binarySearch1(frames, time) - 1;
                    }
                    var drawOrder = skeleton.drawOrder;
                    var slots = skeleton.slots;
                    var drawOrderToSetupIndex = this.drawOrders[frameIndex];
                    if (!drawOrderToSetupIndex) {
                        for (var i = 0, n = slots.length; i < n; i++) {
                            drawOrder[i] = slots[i];
                        }
                    } else {
                        for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++) {
                            drawOrder[i] = skeleton.slots[drawOrderToSetupIndex[i]];
                        }
                    }
                }
            };
            spine.FfdTimeline = function(frameCount) {
                this.curves = new spine.Curves(frameCount);
                this.frames = [];
                this.frames.length = frameCount;
                this.frameVertices = [];
                this.frameVertices.length = frameCount;
            };
            spine.FfdTimeline.prototype = {
                slotIndex: 0,
                attachment: 0,
                getFrameCount: function() {
                    return this.frames.length;
                },
                setFrame: function(frameIndex, time, vertices) {
                    this.frames[frameIndex] = time;
                    this.frameVertices[frameIndex] = vertices;
                },
                apply: function(skeleton, lastTime, time, firedEvents, alpha) {
                    var slot = skeleton.slots[this.slotIndex];
                    if (slot.attachment != this.attachment) {
                        return;
                    }
                    var frames = this.frames;
                    if (time < frames[0]) {
                        return;
                    }
                    var frameVertices = this.frameVertices;
                    var vertexCount = frameVertices[0].length;
                    var vertices = slot.attachmentVertices;
                    if (vertices.length != vertexCount) {
                        alpha = 1;
                    }
                    vertices.length = vertexCount;
                    if (time >= frames[frames.length - 1]) {
                        var lastVertices = frameVertices[frames.length - 1];
                        if (alpha < 1) {
                            for (var i = 0; i < vertexCount; i++) {
                                vertices[i] += (lastVertices[i] - vertices[i]) * alpha;
                            }
                        } else {
                            for (var i = 0; i < vertexCount; i++) {
                                vertices[i] = lastVertices[i];
                            }
                        }
                        return;
                    }
                    var frameIndex = spine.Animation.binarySearch1(frames, time);
                    var frameTime = frames[frameIndex];
                    var percent = 1 - (time - frameTime) / (frames[frameIndex - 1] - frameTime);
                    percent = this.curves.getCurvePercent(frameIndex - 1, percent < 0 ? 0 : percent > 1 ? 1 : percent);
                    var prevVertices = frameVertices[frameIndex - 1];
                    var nextVertices = frameVertices[frameIndex];
                    if (alpha < 1) {
                        for (var i = 0; i < vertexCount; i++) {
                            var prev = prevVertices[i];
                            vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;
                        }
                    } else {
                        for (var i = 0; i < vertexCount; i++) {
                            var prev = prevVertices[i];
                            vertices[i] = prev + (nextVertices[i] - prev) * percent;
                        }
                    }
                }
            };
            spine.IkConstraintTimeline = function(frameCount) {
                this.curves = new spine.Curves(frameCount);
                this.frames = [];
                this.frames.length = 3 * frameCount;
            };
            spine.IkConstraintTimeline.prototype = {
                ikConstraintIndex: 0,
                getFrameCount: function() {
                    return this.frames.length / 3;
                },
                setFrame: function(frameIndex, time, mix, bendDirection) {
                    frameIndex *= 3;
                    this.frames[frameIndex] = time;
                    this.frames[frameIndex + 1] = mix;
                    this.frames[frameIndex + 2] = bendDirection;
                },
                apply: function(skeleton, lastTime, time, firedEvents, alpha) {
                    var frames = this.frames;
                    if (time < frames[0]) {
                        return;
                    }
                    var ikConstraint = skeleton.ikConstraints[this.ikConstraintIndex];
                    if (time >= frames[frames.length - 3]) {
                        ikConstraint.mix += (frames[frames.length - 2] - ikConstraint.mix) * alpha;
                        ikConstraint.bendDirection = frames[frames.length - 1];
                        return;
                    }
                    var frameIndex = spine.Animation.binarySearch(frames, time, 3);
                    var prevFrameMix = frames[frameIndex + -2];
                    var frameTime = frames[frameIndex];
                    var percent = 1 - (time - frameTime) / (frames[frameIndex + -3] - frameTime);
                    percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);
                    var mix = prevFrameMix + (frames[frameIndex + 1] - prevFrameMix) * percent;
                    ikConstraint.mix += (mix - ikConstraint.mix) * alpha;
                    ikConstraint.bendDirection = frames[frameIndex + -1];
                }
            };
            spine.FlipXTimeline = function(frameCount) {
                this.curves = new spine.Curves(frameCount);
                this.frames = [];
                this.frames.length = 2 * frameCount;
            };
            spine.FlipXTimeline.prototype = {
                boneIndex: 0,
                getFrameCount: function() {
                    return this.frames.length / 2;
                },
                setFrame: function(frameIndex, time, flip) {
                    frameIndex *= 2;
                    this.frames[frameIndex] = time;
                    this.frames[frameIndex + 1] = flip ? 1 : 0;
                },
                apply: function(skeleton, lastTime, time, firedEvents, alpha) {
                    var frames = this.frames;
                    if (time < frames[0]) {
                        if (lastTime > time) {
                            this.apply(skeleton, lastTime, Number.MAX_VALUE, null, 0);
                        }
                        return;
                    } else {
                        if (lastTime > time) {
                            lastTime = -1;
                        }
                    }
                    var frameIndex = (time >= frames[frames.length - 2] ? frames.length : spine.Animation.binarySearch(frames, time, 2)) - 2;
                    if (frames[frameIndex] < lastTime) {
                        return;
                    }
                    skeleton.bones[this.boneIndex].flipX = 0 != frames[frameIndex + 1];
                }
            };
            spine.FlipYTimeline = function(frameCount) {
                this.curves = new spine.Curves(frameCount);
                this.frames = [];
                this.frames.length = 2 * frameCount;
            };
            spine.FlipYTimeline.prototype = {
                boneIndex: 0,
                getFrameCount: function() {
                    return this.frames.length / 2;
                },
                setFrame: function(frameIndex, time, flip) {
                    frameIndex *= 2;
                    this.frames[frameIndex] = time;
                    this.frames[frameIndex + 1] = flip ? 1 : 0;
                },
                apply: function(skeleton, lastTime, time, firedEvents, alpha) {
                    var frames = this.frames;
                    if (time < frames[0]) {
                        if (lastTime > time) {
                            this.apply(skeleton, lastTime, Number.MAX_VALUE, null, 0);
                        }
                        return;
                    } else {
                        if (lastTime > time) {
                            lastTime = -1;
                        }
                    }
                    var frameIndex = (time >= frames[frames.length - 2] ? frames.length : spine.Animation.binarySearch(frames, time, 2)) - 2;
                    if (frames[frameIndex] < lastTime) {
                        return;
                    }
                    skeleton.bones[this.boneIndex].flipY = 0 != frames[frameIndex + 1];
                }
            };
            spine.SkeletonData = function() {
                this.bones = [];
                this.slots = [];
                this.skins = [];
                this.events = [];
                this.animations = [];
                this.ikConstraints = [];
            };
            spine.SkeletonData.prototype = {
                name: null,
                defaultSkin: null,
                width: 0,
                height: 0,
                version: null,
                hash: null,
                findBone: function(boneName) {
                    var bones = this.bones;
                    for (var i = 0, n = bones.length; i < n; i++) {
                        if (bones[i].name == boneName) {
                            return bones[i];
                        }
                    }
                    return null;
                },
                findBoneIndex: function(boneName) {
                    var bones = this.bones;
                    for (var i = 0, n = bones.length; i < n; i++) {
                        if (bones[i].name == boneName) {
                            return i;
                        }
                    }
                    return -1;
                },
                findSlot: function(slotName) {
                    var slots = this.slots;
                    for (var i = 0, n = slots.length; i < n; i++) {
                        if (slots[i].name == slotName) {
                            return slot[i];
                        }
                    }
                    return null;
                },
                findSlotIndex: function(slotName) {
                    var slots = this.slots;
                    for (var i = 0, n = slots.length; i < n; i++) {
                        if (slots[i].name == slotName) {
                            return i;
                        }
                    }
                    return -1;
                },
                findSkin: function(skinName) {
                    var skins = this.skins;
                    for (var i = 0, n = skins.length; i < n; i++) {
                        if (skins[i].name == skinName) {
                            return skins[i];
                        }
                    }
                    return null;
                },
                findEvent: function(eventName) {
                    var events = this.events;
                    for (var i = 0, n = events.length; i < n; i++) {
                        if (events[i].name == eventName) {
                            return events[i];
                        }
                    }
                    return null;
                },
                findAnimation: function(animationName) {
                    var animations = this.animations;
                    for (var i = 0, n = animations.length; i < n; i++) {
                        if (animations[i].name == animationName) {
                            return animations[i];
                        }
                    }
                    return null;
                },
                findIkConstraint: function(ikConstraintName) {
                    var ikConstraints = this.ikConstraints;
                    for (var i = 0, n = ikConstraints.length; i < n; i++) {
                        if (ikConstraints[i].name == ikConstraintName) {
                            return ikConstraints[i];
                        }
                    }
                    return null;
                }
            };
            spine.Skeleton = function(skeletonData) {
                this.data = skeletonData;
                this.bones = [];
                for (var i = 0, n = skeletonData.bones.length; i < n; i++) {
                    var boneData = skeletonData.bones[i];
                    var parent = !boneData.parent ? null : this.bones[skeletonData.bones.indexOf(boneData.parent)];
                    this.bones.push(new spine.Bone(boneData, this, parent));
                }
                this.slots = [];
                this.drawOrder = [];
                for (var i = 0, n = skeletonData.slots.length; i < n; i++) {
                    var slotData = skeletonData.slots[i];
                    var bone = this.bones[skeletonData.bones.indexOf(slotData.boneData)];
                    var slot = new spine.Slot(slotData, bone);
                    this.slots.push(slot);
                    this.drawOrder.push(slot);
                }
                this.ikConstraints = [];
                for (var i = 0, n = skeletonData.ikConstraints.length; i < n; i++) {
                    this.ikConstraints.push(new spine.IkConstraint(skeletonData.ikConstraints[i], this));
                }
                this.boneCache = [];
                this.updateCache();
            };
            spine.Skeleton.prototype = {
                x: 0,
                y: 0,
                skin: null,
                r: 1,
                g: 1,
                b: 1,
                a: 1,
                time: 0,
                flipX: false,
                flipY: false,
                updateCache: function() {
                    var ikConstraints = this.ikConstraints;
                    var ikConstraintsCount = ikConstraints.length;
                    var arrayCount = ikConstraintsCount + 1;
                    var boneCache = this.boneCache;
                    if (boneCache.length > arrayCount) {
                        boneCache.length = arrayCount;
                    }
                    for (var i = 0, n = boneCache.length; i < n; i++) {
                        boneCache[i].length = 0;
                    }
                    while (boneCache.length < arrayCount) {
                        boneCache[boneCache.length] = [];
                    }
                    var nonIkBones = boneCache[0];
                    var bones = this.bones;
                    outer: for (var i = 0, n = bones.length; i < n; i++) {
                        var bone = bones[i];
                        var current = bone;
                        do {
                            for (var ii = 0; ii < ikConstraintsCount; ii++) {
                                var ikConstraint = ikConstraints[ii];
                                var parent = ikConstraint.bones[0];
                                var child = ikConstraint.bones[ikConstraint.bones.length - 1];
                                while (true) {
                                    if (current == child) {
                                        boneCache[ii].push(bone);
                                        boneCache[ii + 1].push(bone);
                                        continue outer;
                                    }
                                    if (child == parent) {
                                        break;
                                    }
                                    child = child.parent;
                                }
                            }
                            current = current.parent;
                        } while (current);
                        nonIkBones[nonIkBones.length] = bone;
                    }
                },
                updateWorldTransform: function() {
                    var bones = this.bones;
                    for (var i = 0, n = bones.length; i < n; i++) {
                        var bone = bones[i];
                        bone.rotationIK = bone.rotation;
                    }
                    var i = 0, last = this.boneCache.length - 1;
                    while (true) {
                        var cacheBones = this.boneCache[i];
                        for (var ii = 0, nn = cacheBones.length; ii < nn; ii++) {
                            cacheBones[ii].updateWorldTransform();
                        }
                        if (i == last) {
                            break;
                        }
                        this.ikConstraints[i].apply();
                        i++;
                    }
                },
                setToSetupPose: function() {
                    this.setBonesToSetupPose();
                    this.setSlotsToSetupPose();
                },
                setBonesToSetupPose: function() {
                    var bones = this.bones;
                    for (var i = 0, n = bones.length; i < n; i++) {
                        bones[i].setToSetupPose();
                    }
                    var ikConstraints = this.ikConstraints;
                    for (var i = 0, n = ikConstraints.length; i < n; i++) {
                        var ikConstraint = ikConstraints[i];
                        ikConstraint.bendDirection = ikConstraint.data.bendDirection;
                        ikConstraint.mix = ikConstraint.data.mix;
                    }
                },
                setSlotsToSetupPose: function() {
                    var slots = this.slots;
                    var drawOrder = this.drawOrder;
                    for (var i = 0, n = slots.length; i < n; i++) {
                        drawOrder[i] = slots[i];
                        slots[i].setToSetupPose(i);
                    }
                },
                getRootBone: function() {
                    return this.bones.length ? this.bones[0] : null;
                },
                findBone: function(boneName) {
                    var bones = this.bones;
                    for (var i = 0, n = bones.length; i < n; i++) {
                        if (bones[i].data.name == boneName) {
                            return bones[i];
                        }
                    }
                    return null;
                },
                findBoneIndex: function(boneName) {
                    var bones = this.bones;
                    for (var i = 0, n = bones.length; i < n; i++) {
                        if (bones[i].data.name == boneName) {
                            return i;
                        }
                    }
                    return -1;
                },
                findSlot: function(slotName) {
                    var slots = this.slots;
                    for (var i = 0, n = slots.length; i < n; i++) {
                        if (slots[i].data.name == slotName) {
                            return slots[i];
                        }
                    }
                    return null;
                },
                findSlotIndex: function(slotName) {
                    var slots = this.slots;
                    for (var i = 0, n = slots.length; i < n; i++) {
                        if (slots[i].data.name == slotName) {
                            return i;
                        }
                    }
                    return -1;
                },
                setSkinByName: function(skinName) {
                    var skin = this.data.findSkin(skinName);
                    if (!skin) {
                        throw new Error("Skin not found: " + skinName);
                    }
                    this.setSkin(skin);
                },
                setSkin: function(newSkin) {
                    if (newSkin) {
                        if (this.skin) {
                            newSkin._attachAll(this, this.skin);
                        } else {
                            var slots = this.slots;
                            for (var i = 0, n = slots.length; i < n; i++) {
                                var slot = slots[i];
                                var name = slot.data.attachmentName;
                                if (name) {
                                    var attachment = newSkin.getAttachment(i, name);
                                    if (attachment) {
                                        slot.setAttachment(attachment);
                                    }
                                }
                            }
                        }
                    }
                    this.skin = newSkin;
                },
                getAttachmentBySlotName: function(slotName, attachmentName) {
                    return this.getAttachmentBySlotIndex(this.data.findSlotIndex(slotName), attachmentName);
                },
                getAttachmentBySlotIndex: function(slotIndex, attachmentName) {
                    if (this.skin) {
                        var attachment = this.skin.getAttachment(slotIndex, attachmentName);
                        if (attachment) {
                            return attachment;
                        }
                    }
                    if (this.data.defaultSkin) {
                        return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
                    }
                    return null;
                },
                setAttachment: function(slotName, attachmentName) {
                    var slots = this.slots;
                    for (var i = 0, n = slots.length; i < n; i++) {
                        var slot = slots[i];
                        if (slot.data.name == slotName) {
                            var attachment = null;
                            if (attachmentName) {
                                attachment = this.getAttachmentBySlotIndex(i, attachmentName);
                                if (!attachment) {
                                    throw new Error("Attachment not found: " + attachmentName + ", for slot: " + slotName);
                                }
                            }
                            slot.setAttachment(attachment);
                            return;
                        }
                    }
                    throw new Error("Slot not found: " + slotName);
                },
                findIkConstraint: function(ikConstraintName) {
                    var ikConstraints = this.ikConstraints;
                    for (var i = 0, n = ikConstraints.length; i < n; i++) {
                        if (ikConstraints[i].data.name == ikConstraintName) {
                            return ikConstraints[i];
                        }
                    }
                    return null;
                },
                update: function(delta) {
                    this.time += delta;
                }
            };
            spine.EventData = function(name) {
                this.name = name;
            };
            spine.EventData.prototype = {
                intValue: 0,
                floatValue: 0,
                stringValue: null
            };
            spine.Event = function(data) {
                this.data = data;
            };
            spine.Event.prototype = {
                intValue: 0,
                floatValue: 0,
                stringValue: null
            };
            spine.AttachmentType = {
                region: 0,
                boundingbox: 1,
                mesh: 2,
                skinnedmesh: 3
            };
            spine.RegionAttachment = function(name) {
                this.name = name;
                this.offset = [];
                this.offset.length = 8;
                this.uvs = [];
                this.uvs.length = 8;
            };
            spine.RegionAttachment.prototype = {
                type: spine.AttachmentType.region,
                x: 0,
                y: 0,
                rotation: 0,
                scaleX: 1,
                scaleY: 1,
                width: 0,
                height: 0,
                r: 1,
                g: 1,
                b: 1,
                a: 1,
                path: null,
                rendererObject: null,
                regionOffsetX: 0,
                regionOffsetY: 0,
                regionWidth: 0,
                regionHeight: 0,
                regionOriginalWidth: 0,
                regionOriginalHeight: 0,
                setUVs: function(u, v, u2, v2, rotate) {
                    var uvs = this.uvs;
                    if (rotate) {
                        uvs[2] = u;
                        uvs[3] = v2;
                        uvs[4] = u;
                        uvs[5] = v;
                        uvs[6] = u2;
                        uvs[7] = v;
                        uvs[0] = u2;
                        uvs[1] = v2;
                    } else {
                        uvs[0] = u;
                        uvs[1] = v2;
                        uvs[2] = u;
                        uvs[3] = v;
                        uvs[4] = u2;
                        uvs[5] = v;
                        uvs[6] = u2;
                        uvs[7] = v2;
                    }
                },
                updateOffset: function() {
                    var regionScaleX = this.width / this.regionOriginalWidth * this.scaleX;
                    var regionScaleY = this.height / this.regionOriginalHeight * this.scaleY;
                    var localX = -this.width / 2 * this.scaleX + this.regionOffsetX * regionScaleX;
                    var localY = -this.height / 2 * this.scaleY + this.regionOffsetY * regionScaleY;
                    var localX2 = localX + this.regionWidth * regionScaleX;
                    var localY2 = localY + this.regionHeight * regionScaleY;
                    var radians = this.rotation * spine.degRad;
                    var cos = Math.cos(radians);
                    var sin = Math.sin(radians);
                    var localXCos = localX * cos + this.x;
                    var localXSin = localX * sin;
                    var localYCos = localY * cos + this.y;
                    var localYSin = localY * sin;
                    var localX2Cos = localX2 * cos + this.x;
                    var localX2Sin = localX2 * sin;
                    var localY2Cos = localY2 * cos + this.y;
                    var localY2Sin = localY2 * sin;
                    var offset = this.offset;
                    offset[0] = localXCos - localYSin;
                    offset[1] = localYCos + localXSin;
                    offset[2] = localXCos - localY2Sin;
                    offset[3] = localY2Cos + localXSin;
                    offset[4] = localX2Cos - localY2Sin;
                    offset[5] = localY2Cos + localX2Sin;
                    offset[6] = localX2Cos - localYSin;
                    offset[7] = localYCos + localX2Sin;
                },
                computeVertices: function(x, y, bone, vertices) {
                    x += bone.worldX;
                    y += bone.worldY;
                    var m00 = bone.m00, m01 = bone.m01, m10 = bone.m10, m11 = bone.m11;
                    var offset = this.offset;
                    vertices[0] = offset[0] * m00 + offset[1] * m01 + x;
                    vertices[1] = offset[0] * m10 + offset[1] * m11 + y;
                    vertices[2] = offset[2] * m00 + offset[3] * m01 + x;
                    vertices[3] = offset[2] * m10 + offset[3] * m11 + y;
                    vertices[4] = offset[4] * m00 + offset[5] * m01 + x;
                    vertices[5] = offset[4] * m10 + offset[5] * m11 + y;
                    vertices[6] = offset[6] * m00 + offset[7] * m01 + x;
                    vertices[7] = offset[6] * m10 + offset[7] * m11 + y;
                }
            };
            spine.MeshAttachment = function(name) {
                this.name = name;
            };
            spine.MeshAttachment.prototype = {
                type: spine.AttachmentType.mesh,
                vertices: null,
                uvs: null,
                regionUVs: null,
                triangles: null,
                hullLength: 0,
                r: 1,
                g: 1,
                b: 1,
                a: 1,
                path: null,
                rendererObject: null,
                regionU: 0,
                regionV: 0,
                regionU2: 0,
                regionV2: 0,
                regionRotate: false,
                regionOffsetX: 0,
                regionOffsetY: 0,
                regionWidth: 0,
                regionHeight: 0,
                regionOriginalWidth: 0,
                regionOriginalHeight: 0,
                edges: null,
                width: 0,
                height: 0,
                updateUVs: function() {
                    var width = this.regionU2 - this.regionU, height = this.regionV2 - this.regionV;
                    var n = this.regionUVs.length;
                    if (!this.uvs || this.uvs.length != n) {
                        this.uvs = new spine.Float32Array(n);
                    }
                    if (this.regionRotate) {
                        for (var i = 0; i < n; i += 2) {
                            this.uvs[i] = this.regionU + this.regionUVs[i + 1] * width;
                            this.uvs[i + 1] = this.regionV + height - this.regionUVs[i] * height;
                        }
                    } else {
                        for (var i = 0; i < n; i += 2) {
                            this.uvs[i] = this.regionU + this.regionUVs[i] * width;
                            this.uvs[i + 1] = this.regionV + this.regionUVs[i + 1] * height;
                        }
                    }
                },
                computeWorldVertices: function(x, y, slot, worldVertices) {
                    var bone = slot.bone;
                    x += bone.worldX;
                    y += bone.worldY;
                    var m00 = bone.m00, m01 = bone.m01, m10 = bone.m10, m11 = bone.m11;
                    var vertices = this.vertices;
                    var verticesCount = vertices.length;
                    if (slot.attachmentVertices.length == verticesCount) {
                        vertices = slot.attachmentVertices;
                    }
                    for (var i = 0; i < verticesCount; i += 2) {
                        var vx = vertices[i];
                        var vy = vertices[i + 1];
                        worldVertices[i] = vx * m00 + vy * m01 + x;
                        worldVertices[i + 1] = vx * m10 + vy * m11 + y;
                    }
                }
            };
            spine.SkinnedMeshAttachment = function(name) {
                this.name = name;
            };
            spine.SkinnedMeshAttachment.prototype = {
                type: spine.AttachmentType.skinnedmesh,
                bones: null,
                weights: null,
                uvs: null,
                regionUVs: null,
                triangles: null,
                hullLength: 0,
                r: 1,
                g: 1,
                b: 1,
                a: 1,
                path: null,
                rendererObject: null,
                regionU: 0,
                regionV: 0,
                regionU2: 0,
                regionV2: 0,
                regionRotate: false,
                regionOffsetX: 0,
                regionOffsetY: 0,
                regionWidth: 0,
                regionHeight: 0,
                regionOriginalWidth: 0,
                regionOriginalHeight: 0,
                edges: null,
                width: 0,
                height: 0,
                updateUVs: function(u, v, u2, v2, rotate) {
                    var width = this.regionU2 - this.regionU, height = this.regionV2 - this.regionV;
                    var n = this.regionUVs.length;
                    if (!this.uvs || this.uvs.length != n) {
                        this.uvs = new spine.Float32Array(n);
                    }
                    if (this.regionRotate) {
                        for (var i = 0; i < n; i += 2) {
                            this.uvs[i] = this.regionU + this.regionUVs[i + 1] * width;
                            this.uvs[i + 1] = this.regionV + height - this.regionUVs[i] * height;
                        }
                    } else {
                        for (var i = 0; i < n; i += 2) {
                            this.uvs[i] = this.regionU + this.regionUVs[i] * width;
                            this.uvs[i + 1] = this.regionV + this.regionUVs[i + 1] * height;
                        }
                    }
                },
                computeWorldVertices: function(x, y, slot, worldVertices) {
                    var skeletonBones = slot.bone.skeleton.bones;
                    var weights = this.weights;
                    var bones = this.bones;
                    var w = 0, v = 0, b = 0, f = 0, n = bones.length, nn;
                    var wx, wy, bone, vx, vy, weight;
                    if (!slot.attachmentVertices.length) {
                        for (;v < n; w += 2) {
                            wx = 0;
                            wy = 0;
                            nn = bones[v++] + v;
                            for (;v < nn; v++, b += 3) {
                                bone = skeletonBones[bones[v]];
                                vx = weights[b];
                                vy = weights[b + 1];
                                weight = weights[b + 2];
                                wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;
                                wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;
                            }
                            worldVertices[w] = wx + x;
                            worldVertices[w + 1] = wy + y;
                        }
                    } else {
                        var ffd = slot.attachmentVertices;
                        for (;v < n; w += 2) {
                            wx = 0;
                            wy = 0;
                            nn = bones[v++] + v;
                            for (;v < nn; v++, b += 3, f += 2) {
                                bone = skeletonBones[bones[v]];
                                vx = weights[b] + ffd[f];
                                vy = weights[b + 1] + ffd[f + 1];
                                weight = weights[b + 2];
                                wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;
                                wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;
                            }
                            worldVertices[w] = wx + x;
                            worldVertices[w + 1] = wy + y;
                        }
                    }
                }
            };
            spine.BoundingBoxAttachment = function(name) {
                this.name = name;
                this.vertices = [];
            };
            spine.BoundingBoxAttachment.prototype = {
                type: spine.AttachmentType.boundingbox,
                computeWorldVertices: function(x, y, bone, worldVertices) {
                    x += bone.worldX;
                    y += bone.worldY;
                    var m00 = bone.m00, m01 = bone.m01, m10 = bone.m10, m11 = bone.m11;
                    var vertices = this.vertices;
                    for (var i = 0, n = vertices.length; i < n; i += 2) {
                        var px = vertices[i];
                        var py = vertices[i + 1];
                        worldVertices[i] = px * m00 + py * m01 + x;
                        worldVertices[i + 1] = px * m10 + py * m11 + y;
                    }
                }
            };
            spine.AnimationStateData = function(skeletonData) {
                this.skeletonData = skeletonData;
                this.animationToMixTime = {};
            };
            spine.AnimationStateData.prototype = {
                defaultMix: 0,
                setMixByName: function(fromName, toName, duration) {
                    var from = this.skeletonData.findAnimation(fromName);
                    if (!from) {
                        throw new Error("Animation not found: " + fromName);
                    }
                    var to = this.skeletonData.findAnimation(toName);
                    if (!to) {
                        throw new Error("Animation not found: " + toName);
                    }
                    this.setMix(from, to, duration);
                },
                setMix: function(from, to, duration) {
                    this.animationToMixTime[from.name + ":" + to.name] = duration;
                },
                getMix: function(from, to) {
                    var key = from.name + ":" + to.name;
                    return this.animationToMixTime.hasOwnProperty(key) ? this.animationToMixTime[key] : this.defaultMix;
                }
            };
            spine.TrackEntry = function() {};
            spine.TrackEntry.prototype = {
                next: null,
                previous: null,
                animation: null,
                loop: false,
                delay: 0,
                time: 0,
                lastTime: -1,
                endTime: 0,
                timeScale: 1,
                mixTime: 0,
                mixDuration: 0,
                mix: 1,
                onStart: null,
                onEnd: null,
                onComplete: null,
                onEvent: null
            };
            spine.AnimationState = function(stateData) {
                this.data = stateData;
                this.tracks = [];
                this.events = [];
            };
            spine.AnimationState.prototype = {
                onStart: null,
                onEnd: null,
                onComplete: null,
                onEvent: null,
                timeScale: 1,
                update: function(delta) {
                    delta *= this.timeScale;
                    for (var i = 0; i < this.tracks.length; i++) {
                        var current = this.tracks[i];
                        if (!current) {
                            continue;
                        }
                        current.time += delta * current.timeScale;
                        if (current.previous) {
                            var previousDelta = delta * current.previous.timeScale;
                            current.previous.time += previousDelta;
                            current.mixTime += previousDelta;
                        }
                        var next = current.next;
                        if (next) {
                            next.time = current.lastTime - next.delay;
                            if (next.time >= 0) {
                                this.setCurrent(i, next);
                            }
                        } else {
                            if (!current.loop && current.lastTime >= current.endTime) {
                                this.clearTrack(i);
                            }
                        }
                    }
                },
                apply: function(skeleton) {
                    for (var i = 0; i < this.tracks.length; i++) {
                        var current = this.tracks[i];
                        if (!current) {
                            continue;
                        }
                        this.events.length = 0;
                        var time = current.time;
                        var lastTime = current.lastTime;
                        var endTime = current.endTime;
                        var loop = current.loop;
                        if (!loop && time > endTime) {
                            time = endTime;
                        }
                        var previous = current.previous;
                        if (!previous) {
                            if (1 == current.mix) {
                                current.animation.apply(skeleton, current.lastTime, time, loop, this.events);
                            } else {
                                current.animation.mix(skeleton, current.lastTime, time, loop, this.events, current.mix);
                            }
                        } else {
                            var previousTime = previous.time;
                            if (!previous.loop && previousTime > previous.endTime) {
                                previousTime = previous.endTime;
                            }
                            previous.animation.apply(skeleton, previousTime, previousTime, previous.loop, null);
                            var alpha = current.mixTime / current.mixDuration * current.mix;
                            if (alpha >= 1) {
                                alpha = 1;
                                current.previous = null;
                            }
                            current.animation.mix(skeleton, current.lastTime, time, loop, this.events, alpha);
                        }
                        for (var ii = 0, nn = this.events.length; ii < nn; ii++) {
                            var event = this.events[ii];
                            if (current.onEvent) {
                                current.onEvent(i, event);
                            }
                            if (this.onEvent) {
                                this.onEvent(i, event);
                            }
                        }
                        if (loop ? lastTime % endTime > time % endTime : lastTime < endTime && time >= endTime) {
                            var count = Math.floor(time / endTime);
                            if (current.onComplete) {
                                current.onComplete(i, count);
                            }
                            if (this.onComplete) {
                                this.onComplete(i, count);
                            }
                        }
                        current.lastTime = current.time;
                    }
                },
                clearTracks: function() {
                    for (var i = 0, n = this.tracks.length; i < n; i++) {
                        this.clearTrack(i);
                    }
                    this.tracks.length = 0;
                },
                clearTrack: function(trackIndex) {
                    if (trackIndex >= this.tracks.length) {
                        return;
                    }
                    var current = this.tracks[trackIndex];
                    if (!current) {
                        return;
                    }
                    if (current.onEnd) {
                        current.onEnd(trackIndex);
                    }
                    if (this.onEnd) {
                        this.onEnd(trackIndex);
                    }
                    this.tracks[trackIndex] = null;
                },
                _expandToIndex: function(index) {
                    if (index < this.tracks.length) {
                        return this.tracks[index];
                    }
                    while (index >= this.tracks.length) {
                        this.tracks.push(null);
                    }
                    return null;
                },
                setCurrent: function(index, entry) {
                    var current = this._expandToIndex(index);
                    if (current) {
                        var previous = current.previous;
                        current.previous = null;
                        if (current.onEnd) {
                            current.onEnd(index);
                        }
                        if (this.onEnd) {
                            this.onEnd(index);
                        }
                        entry.mixDuration = this.data.getMix(current.animation, entry.animation);
                        if (entry.mixDuration > 0) {
                            entry.mixTime = 0;
                            if (previous && current.mixTime / current.mixDuration < .5) {
                                entry.previous = previous;
                            } else {
                                entry.previous = current;
                            }
                        }
                    }
                    this.tracks[index] = entry;
                    if (entry.onStart) {
                        entry.onStart(index);
                    }
                    if (this.onStart) {
                        this.onStart(index);
                    }
                },
                setAnimationByName: function(trackIndex, animationName, loop) {
                    var animation = this.data.skeletonData.findAnimation(animationName);
                    if (!animation) {
                        throw new Error("Animation not found: " + animationName);
                    }
                    return this.setAnimation(trackIndex, animation, loop);
                },
                setAnimation: function(trackIndex, animation, loop) {
                    var entry = new spine.TrackEntry();
                    entry.animation = animation;
                    entry.loop = loop;
                    entry.endTime = animation.duration;
                    this.setCurrent(trackIndex, entry);
                    return entry;
                },
                addAnimationByName: function(trackIndex, animationName, loop, delay) {
                    var animation = this.data.skeletonData.findAnimation(animationName);
                    if (!animation) {
                        throw new Error("Animation not found: " + animationName);
                    }
                    return this.addAnimation(trackIndex, animation, loop, delay);
                },
                addAnimation: function(trackIndex, animation, loop, delay) {
                    var entry = new spine.TrackEntry();
                    entry.animation = animation;
                    entry.loop = loop;
                    entry.endTime = animation.duration;
                    var last = this._expandToIndex(trackIndex);
                    if (last) {
                        while (last.next) {
                            last = last.next;
                        }
                        last.next = entry;
                    } else {
                        this.tracks[trackIndex] = entry;
                    }
                    if (delay <= 0) {
                        if (last) {
                            delay += last.endTime - this.data.getMix(last.animation, animation);
                        } else {
                            delay = 0;
                        }
                    }
                    entry.delay = delay;
                    return entry;
                },
                getCurrent: function(trackIndex) {
                    if (trackIndex >= this.tracks.length) {
                        return null;
                    }
                    return this.tracks[trackIndex];
                }
            };
            spine.SkeletonJson = function(attachmentLoader) {
                this.attachmentLoader = attachmentLoader;
            };
            spine.SkeletonJson.prototype = {
                scale: 1,
                readSkeletonData: function(root, name) {
                    var skeletonData = new spine.SkeletonData();
                    skeletonData.name = name;
                    var skeletonMap = root["skeleton"];
                    if (skeletonMap) {
                        skeletonData.hash = skeletonMap["hash"];
                        skeletonData.version = skeletonMap["spine"];
                        skeletonData.width = skeletonMap["width"] || 0;
                        skeletonData.height = skeletonMap["height"] || 0;
                    }
                    var bones = root["bones"];
                    for (var i = 0, n = bones.length; i < n; i++) {
                        var boneMap = bones[i];
                        var parent = null;
                        if (boneMap["parent"]) {
                            parent = skeletonData.findBone(boneMap["parent"]);
                            if (!parent) {
                                throw new Error("Parent bone not found: " + boneMap["parent"]);
                            }
                        }
                        var boneData = new spine.BoneData(boneMap["name"], parent);
                        boneData.length = (boneMap["length"] || 0) * this.scale;
                        boneData.x = (boneMap["x"] || 0) * this.scale;
                        boneData.y = (boneMap["y"] || 0) * this.scale;
                        boneData.rotation = boneMap["rotation"] || 0;
                        boneData.scaleX = boneMap.hasOwnProperty("scaleX") ? boneMap["scaleX"] : 1;
                        boneData.scaleY = boneMap.hasOwnProperty("scaleY") ? boneMap["scaleY"] : 1;
                        boneData.inheritScale = boneMap.hasOwnProperty("inheritScale") ? boneMap["inheritScale"] : true;
                        boneData.inheritRotation = boneMap.hasOwnProperty("inheritRotation") ? boneMap["inheritRotation"] : true;
                        skeletonData.bones.push(boneData);
                    }
                    var ik = root["ik"];
                    if (ik) {
                        for (var i = 0, n = ik.length; i < n; i++) {
                            var ikMap = ik[i];
                            var ikConstraintData = new spine.IkConstraintData(ikMap["name"]);
                            var bones = ikMap["bones"];
                            for (var ii = 0, nn = bones.length; ii < nn; ii++) {
                                var bone = skeletonData.findBone(bones[ii]);
                                if (!bone) {
                                    throw new Error("IK bone not found: " + bones[ii]);
                                }
                                ikConstraintData.bones.push(bone);
                            }
                            ikConstraintData.target = skeletonData.findBone(ikMap["target"]);
                            if (!ikConstraintData.target) {
                                throw new Error("Target bone not found: " + ikMap["target"]);
                            }
                            ikConstraintData.bendDirection = !ikMap.hasOwnProperty("bendPositive") || ikMap["bendPositive"] ? 1 : -1;
                            ikConstraintData.mix = ikMap.hasOwnProperty("mix") ? ikMap["mix"] : 1;
                            skeletonData.ikConstraints.push(ikConstraintData);
                        }
                    }
                    var slots = root["slots"];
                    for (var i = 0, n = slots.length; i < n; i++) {
                        var slotMap = slots[i];
                        var boneData = skeletonData.findBone(slotMap["bone"]);
                        if (!boneData) {
                            throw new Error("Slot bone not found: " + slotMap["bone"]);
                        }
                        var slotData = new spine.SlotData(slotMap["name"], boneData);
                        var color = slotMap["color"];
                        if (color) {
                            slotData.r = this.toColor(color, 0);
                            slotData.g = this.toColor(color, 1);
                            slotData.b = this.toColor(color, 2);
                            slotData.a = this.toColor(color, 3);
                        }
                        slotData.attachmentName = slotMap["attachment"];
                        slotData.blendMode = spine.AttachmentType[slotMap["blend"] || "normal"];
                        skeletonData.slots.push(slotData);
                    }
                    var skins = root["skins"];
                    for (var skinName in skins) {
                        if (!skins.hasOwnProperty(skinName)) {
                            continue;
                        }
                        var skinMap = skins[skinName];
                        var skin = new spine.Skin(skinName);
                        for (var slotName in skinMap) {
                            if (!skinMap.hasOwnProperty(slotName)) {
                                continue;
                            }
                            var slotIndex = skeletonData.findSlotIndex(slotName);
                            var slotEntry = skinMap[slotName];
                            for (var attachmentName in slotEntry) {
                                if (!slotEntry.hasOwnProperty(attachmentName)) {
                                    continue;
                                }
                                var attachment = this.readAttachment(skin, attachmentName, slotEntry[attachmentName]);
                                if (attachment) {
                                    skin.addAttachment(slotIndex, attachmentName, attachment);
                                }
                            }
                        }
                        skeletonData.skins.push(skin);
                        if ("default" == skin.name) {
                            skeletonData.defaultSkin = skin;
                        }
                    }
                    var events = root["events"];
                    for (var eventName in events) {
                        if (!events.hasOwnProperty(eventName)) {
                            continue;
                        }
                        var eventMap = events[eventName];
                        var eventData = new spine.EventData(eventName);
                        eventData.intValue = eventMap["int"] || 0;
                        eventData.floatValue = eventMap["float"] || 0;
                        eventData.stringValue = eventMap["string"] || null;
                        skeletonData.events.push(eventData);
                    }
                    var animations = root["animations"];
                    for (var animationName in animations) {
                        if (!animations.hasOwnProperty(animationName)) {
                            continue;
                        }
                        this.readAnimation(animationName, animations[animationName], skeletonData);
                    }
                    return skeletonData;
                },
                readAttachment: function(skin, name, map) {
                    name = map["name"] || name;
                    var type = spine.AttachmentType[map["type"] || "region"];
                    var path = map["path"] || name;
                    var scale = this.scale;
                    if (type == spine.AttachmentType.region) {
                        var region = this.attachmentLoader.newRegionAttachment(skin, name, path);
                        if (!region) {
                            return null;
                        }
                        region.path = path;
                        region.x = (map["x"] || 0) * scale;
                        region.y = (map["y"] || 0) * scale;
                        region.scaleX = map.hasOwnProperty("scaleX") ? map["scaleX"] : 1;
                        region.scaleY = map.hasOwnProperty("scaleY") ? map["scaleY"] : 1;
                        region.rotation = map["rotation"] || 0;
                        region.width = (map["width"] || 0) * scale;
                        region.height = (map["height"] || 0) * scale;
                        var color = map["color"];
                        if (color) {
                            region.r = this.toColor(color, 0);
                            region.g = this.toColor(color, 1);
                            region.b = this.toColor(color, 2);
                            region.a = this.toColor(color, 3);
                        }
                        region.updateOffset();
                        return region;
                    } else {
                        if (type == spine.AttachmentType.mesh) {
                            var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
                            if (!mesh) {
                                return null;
                            }
                            mesh.path = path;
                            mesh.vertices = this.getFloatArray(map, "vertices", scale);
                            mesh.triangles = this.getIntArray(map, "triangles");
                            mesh.regionUVs = this.getFloatArray(map, "uvs", 1);
                            mesh.updateUVs();
                            color = map["color"];
                            if (color) {
                                mesh.r = this.toColor(color, 0);
                                mesh.g = this.toColor(color, 1);
                                mesh.b = this.toColor(color, 2);
                                mesh.a = this.toColor(color, 3);
                            }
                            mesh.hullLength = 2 * (map["hull"] || 0);
                            if (map["edges"]) {
                                mesh.edges = this.getIntArray(map, "edges");
                            }
                            mesh.width = (map["width"] || 0) * scale;
                            mesh.height = (map["height"] || 0) * scale;
                            return mesh;
                        } else {
                            if (type == spine.AttachmentType.skinnedmesh) {
                                var mesh = this.attachmentLoader.newSkinnedMeshAttachment(skin, name, path);
                                if (!mesh) {
                                    return null;
                                }
                                mesh.path = path;
                                var uvs = this.getFloatArray(map, "uvs", 1);
                                var vertices = this.getFloatArray(map, "vertices", 1);
                                var weights = [];
                                var bones = [];
                                for (var i = 0, n = vertices.length; i < n; ) {
                                    var boneCount = 0 | vertices[i++];
                                    bones[bones.length] = boneCount;
                                    for (var nn = i + 4 * boneCount; i < nn; ) {
                                        bones[bones.length] = vertices[i];
                                        weights[weights.length] = vertices[i + 1] * scale;
                                        weights[weights.length] = vertices[i + 2] * scale;
                                        weights[weights.length] = vertices[i + 3];
                                        i += 4;
                                    }
                                }
                                mesh.bones = bones;
                                mesh.weights = weights;
                                mesh.triangles = this.getIntArray(map, "triangles");
                                mesh.regionUVs = uvs;
                                mesh.updateUVs();
                                color = map["color"];
                                if (color) {
                                    mesh.r = this.toColor(color, 0);
                                    mesh.g = this.toColor(color, 1);
                                    mesh.b = this.toColor(color, 2);
                                    mesh.a = this.toColor(color, 3);
                                }
                                mesh.hullLength = 2 * (map["hull"] || 0);
                                if (map["edges"]) {
                                    mesh.edges = this.getIntArray(map, "edges");
                                }
                                mesh.width = (map["width"] || 0) * scale;
                                mesh.height = (map["height"] || 0) * scale;
                                return mesh;
                            } else {
                                if (type == spine.AttachmentType.boundingbox) {
                                    var attachment = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
                                    var vertices = map["vertices"];
                                    for (var i = 0, n = vertices.length; i < n; i++) {
                                        attachment.vertices.push(vertices[i] * scale);
                                    }
                                    return attachment;
                                }
                            }
                        }
                    }
                    throw new Error("Unknown attachment type: " + type);
                },
                readAnimation: function(name, map, skeletonData) {
                    var timelines = [];
                    var duration = 0;
                    var slots = map["slots"];
                    for (var slotName in slots) {
                        if (!slots.hasOwnProperty(slotName)) {
                            continue;
                        }
                        var slotMap = slots[slotName];
                        var slotIndex = skeletonData.findSlotIndex(slotName);
                        for (var timelineName in slotMap) {
                            if (!slotMap.hasOwnProperty(timelineName)) {
                                continue;
                            }
                            var values = slotMap[timelineName];
                            if ("color" == timelineName) {
                                var timeline = new spine.ColorTimeline(values.length);
                                timeline.slotIndex = slotIndex;
                                var frameIndex = 0;
                                for (var i = 0, n = values.length; i < n; i++) {
                                    var valueMap = values[i];
                                    var color = valueMap["color"];
                                    var r = this.toColor(color, 0);
                                    var g = this.toColor(color, 1);
                                    var b = this.toColor(color, 2);
                                    var a = this.toColor(color, 3);
                                    timeline.setFrame(frameIndex, valueMap["time"], r, g, b, a);
                                    this.readCurve(timeline, frameIndex, valueMap);
                                    frameIndex++;
                                }
                                timelines.push(timeline);
                                duration = Math.max(duration, timeline.frames[5 * timeline.getFrameCount() - 5]);
                            } else {
                                if ("attachment" == timelineName) {
                                    var timeline = new spine.AttachmentTimeline(values.length);
                                    timeline.slotIndex = slotIndex;
                                    var frameIndex = 0;
                                    for (var i = 0, n = values.length; i < n; i++) {
                                        var valueMap = values[i];
                                        timeline.setFrame(frameIndex++, valueMap["time"], valueMap["name"]);
                                    }
                                    timelines.push(timeline);
                                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
                                } else {
                                    throw new Error("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");
                                }
                            }
                        }
                    }
                    var bones = map["bones"];
                    for (var boneName in bones) {
                        if (!bones.hasOwnProperty(boneName)) {
                            continue;
                        }
                        var boneIndex = skeletonData.findBoneIndex(boneName);
                        if (-1 == boneIndex) {
                            throw new Error("Bone not found: " + boneName);
                        }
                        var boneMap = bones[boneName];
                        for (var timelineName in boneMap) {
                            if (!boneMap.hasOwnProperty(timelineName)) {
                                continue;
                            }
                            var values = boneMap[timelineName];
                            if ("rotate" == timelineName) {
                                var timeline = new spine.RotateTimeline(values.length);
                                timeline.boneIndex = boneIndex;
                                var frameIndex = 0;
                                for (var i = 0, n = values.length; i < n; i++) {
                                    var valueMap = values[i];
                                    timeline.setFrame(frameIndex, valueMap["time"], valueMap["angle"]);
                                    this.readCurve(timeline, frameIndex, valueMap);
                                    frameIndex++;
                                }
                                timelines.push(timeline);
                                duration = Math.max(duration, timeline.frames[2 * timeline.getFrameCount() - 2]);
                            } else {
                                if ("translate" == timelineName || "scale" == timelineName) {
                                    var timeline;
                                    var timelineScale = 1;
                                    if ("scale" == timelineName) {
                                        timeline = new spine.ScaleTimeline(values.length);
                                    } else {
                                        timeline = new spine.TranslateTimeline(values.length);
                                        timelineScale = this.scale;
                                    }
                                    timeline.boneIndex = boneIndex;
                                    var frameIndex = 0;
                                    for (var i = 0, n = values.length; i < n; i++) {
                                        var valueMap = values[i];
                                        var x = (valueMap["x"] || 0) * timelineScale;
                                        var y = (valueMap["y"] || 0) * timelineScale;
                                        timeline.setFrame(frameIndex, valueMap["time"], x, y);
                                        this.readCurve(timeline, frameIndex, valueMap);
                                        frameIndex++;
                                    }
                                    timelines.push(timeline);
                                    duration = Math.max(duration, timeline.frames[3 * timeline.getFrameCount() - 3]);
                                } else {
                                    if ("flipX" == timelineName || "flipY" == timelineName) {
                                        var x = "flipX" == timelineName;
                                        var timeline = x ? new spine.FlipXTimeline(values.length) : new spine.FlipYTimeline(values.length);
                                        timeline.boneIndex = boneIndex;
                                        var field = x ? "x" : "y";
                                        var frameIndex = 0;
                                        for (var i = 0, n = values.length; i < n; i++) {
                                            var valueMap = values[i];
                                            timeline.setFrame(frameIndex, valueMap["time"], valueMap[field] || false);
                                            frameIndex++;
                                        }
                                        timelines.push(timeline);
                                        duration = Math.max(duration, timeline.frames[2 * timeline.getFrameCount() - 2]);
                                    } else {
                                        throw new Error("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");
                                    }
                                }
                            }
                        }
                    }
                    var ikMap = map["ik"];
                    for (var ikConstraintName in ikMap) {
                        if (!ikMap.hasOwnProperty(ikConstraintName)) {
                            continue;
                        }
                        var ikConstraint = skeletonData.findIkConstraint(ikConstraintName);
                        var values = ikMap[ikConstraintName];
                        var timeline = new spine.IkConstraintTimeline(values.length);
                        timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(ikConstraint);
                        var frameIndex = 0;
                        for (var i = 0, n = values.length; i < n; i++) {
                            var valueMap = values[i];
                            var mix = valueMap.hasOwnProperty("mix") ? valueMap["mix"] : 1;
                            var bendDirection = !valueMap.hasOwnProperty("bendPositive") || valueMap["bendPositive"] ? 1 : -1;
                            timeline.setFrame(frameIndex, valueMap["time"], mix, bendDirection);
                            this.readCurve(timeline, frameIndex, valueMap);
                            frameIndex++;
                        }
                        timelines.push(timeline);
                        duration = Math.max(duration, timeline.frames[3 * timeline.frameCount - 3]);
                    }
                    var ffd = map["ffd"];
                    for (var skinName in ffd) {
                        var skin = skeletonData.findSkin(skinName);
                        var slotMap = ffd[skinName];
                        for (slotName in slotMap) {
                            var slotIndex = skeletonData.findSlotIndex(slotName);
                            var meshMap = slotMap[slotName];
                            for (var meshName in meshMap) {
                                var values = meshMap[meshName];
                                var timeline = new spine.FfdTimeline(values.length);
                                var attachment = skin.getAttachment(slotIndex, meshName);
                                if (!attachment) {
                                    throw new Error("FFD attachment not found: " + meshName);
                                }
                                timeline.slotIndex = slotIndex;
                                timeline.attachment = attachment;
                                var isMesh = attachment.type == spine.AttachmentType.mesh;
                                var vertexCount;
                                if (isMesh) {
                                    vertexCount = attachment.vertices.length;
                                } else {
                                    vertexCount = attachment.weights.length / 3 * 2;
                                }
                                var frameIndex = 0;
                                for (var i = 0, n = values.length; i < n; i++) {
                                    var valueMap = values[i];
                                    var vertices;
                                    if (!valueMap["vertices"]) {
                                        if (isMesh) {
                                            vertices = attachment.vertices;
                                        } else {
                                            vertices = [];
                                            vertices.length = vertexCount;
                                        }
                                    } else {
                                        var verticesValue = valueMap["vertices"];
                                        var vertices = [];
                                        vertices.length = vertexCount;
                                        var start = valueMap["offset"] || 0;
                                        var nn = verticesValue.length;
                                        if (1 == this.scale) {
                                            for (var ii = 0; ii < nn; ii++) {
                                                vertices[ii + start] = verticesValue[ii];
                                            }
                                        } else {
                                            for (var ii = 0; ii < nn; ii++) {
                                                vertices[ii + start] = verticesValue[ii] * this.scale;
                                            }
                                        }
                                        if (isMesh) {
                                            var meshVertices = attachment.vertices;
                                            for (var ii = 0, nn = vertices.length; ii < nn; ii++) {
                                                vertices[ii] += meshVertices[ii];
                                            }
                                        }
                                    }
                                    timeline.setFrame(frameIndex, valueMap["time"], vertices);
                                    this.readCurve(timeline, frameIndex, valueMap);
                                    frameIndex++;
                                }
                                timelines[timelines.length] = timeline;
                                duration = Math.max(duration, timeline.frames[timeline.frameCount - 1]);
                            }
                        }
                    }
                    var drawOrderValues = map["drawOrder"];
                    if (!drawOrderValues) {
                        drawOrderValues = map["draworder"];
                    }
                    if (drawOrderValues) {
                        var timeline = new spine.DrawOrderTimeline(drawOrderValues.length);
                        var slotCount = skeletonData.slots.length;
                        var frameIndex = 0;
                        for (var i = 0, n = drawOrderValues.length; i < n; i++) {
                            var drawOrderMap = drawOrderValues[i];
                            var drawOrder = null;
                            if (drawOrderMap["offsets"]) {
                                drawOrder = [];
                                drawOrder.length = slotCount;
                                for (var ii = slotCount - 1; ii >= 0; ii--) {
                                    drawOrder[ii] = -1;
                                }
                                var offsets = drawOrderMap["offsets"];
                                var unchanged = [];
                                unchanged.length = slotCount - offsets.length;
                                var originalIndex = 0, unchangedIndex = 0;
                                for (var ii = 0, nn = offsets.length; ii < nn; ii++) {
                                    var offsetMap = offsets[ii];
                                    var slotIndex = skeletonData.findSlotIndex(offsetMap["slot"]);
                                    if (-1 == slotIndex) {
                                        throw new Error("Slot not found: " + offsetMap["slot"]);
                                    }
                                    while (originalIndex != slotIndex) {
                                        unchanged[unchangedIndex++] = originalIndex++;
                                    }
                                    drawOrder[originalIndex + offsetMap["offset"]] = originalIndex++;
                                }
                                while (originalIndex < slotCount) {
                                    unchanged[unchangedIndex++] = originalIndex++;
                                }
                                for (var ii = slotCount - 1; ii >= 0; ii--) {
                                    if (-1 == drawOrder[ii]) {
                                        drawOrder[ii] = unchanged[--unchangedIndex];
                                    }
                                }
                            }
                            timeline.setFrame(frameIndex++, drawOrderMap["time"], drawOrder);
                        }
                        timelines.push(timeline);
                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
                    }
                    var events = map["events"];
                    if (events) {
                        var timeline = new spine.EventTimeline(events.length);
                        var frameIndex = 0;
                        for (var i = 0, n = events.length; i < n; i++) {
                            var eventMap = events[i];
                            var eventData = skeletonData.findEvent(eventMap["name"]);
                            if (!eventData) {
                                throw new Error("Event not found: " + eventMap["name"]);
                            }
                            var event = new spine.Event(eventData);
                            event.intValue = eventMap.hasOwnProperty("int") ? eventMap["int"] : eventData.intValue;
                            event.floatValue = eventMap.hasOwnProperty("float") ? eventMap["float"] : eventData.floatValue;
                            event.stringValue = eventMap.hasOwnProperty("string") ? eventMap["string"] : eventData.stringValue;
                            timeline.setFrame(frameIndex++, eventMap["time"], event);
                        }
                        timelines.push(timeline);
                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
                    }
                    skeletonData.animations.push(new spine.Animation(name, timelines, duration));
                },
                readCurve: function(timeline, frameIndex, valueMap) {
                    var curve = valueMap["curve"];
                    if (!curve) {
                        timeline.curves.setLinear(frameIndex);
                    } else {
                        if ("stepped" == curve) {
                            timeline.curves.setStepped(frameIndex);
                        } else {
                            if (curve instanceof Array) {
                                timeline.curves.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);
                            }
                        }
                    }
                },
                toColor: function(hexString, colorIndex) {
                    if (8 != hexString.length) {
                        throw new Error("Color hexidecimal length must be 8, recieved: " + hexString);
                    }
                    return parseInt(hexString.substring(2 * colorIndex, 2 * colorIndex + 2), 16) / 255;
                },
                getFloatArray: function(map, name, scale) {
                    var list = map[name];
                    var values = new spine.Float32Array(list.length);
                    var i = 0, n = list.length;
                    if (1 == scale) {
                        for (;i < n; i++) {
                            values[i] = list[i];
                        }
                    } else {
                        for (;i < n; i++) {
                            values[i] = list[i] * scale;
                        }
                    }
                    return values;
                },
                getIntArray: function(map, name) {
                    var list = map[name];
                    var values = new spine.Uint16Array(list.length);
                    for (var i = 0, n = list.length; i < n; i++) {
                        values[i] = 0 | list[i];
                    }
                    return values;
                }
            };
            spine.Atlas = function(atlasText, textureLoader) {
                this.textureLoader = textureLoader;
                this.pages = [];
                this.regions = [];
                var reader = new spine.AtlasReader(atlasText);
                var tuple = [];
                tuple.length = 4;
                var page = null;
                while (true) {
                    var line = reader.readLine();
                    if (null === line) {
                        break;
                    }
                    line = reader.trim(line);
                    if (!line.length) {
                        page = null;
                    } else {
                        if (!page) {
                            page = new spine.AtlasPage();
                            page.name = line;
                            if (2 == reader.readTuple(tuple)) {
                                page.width = parseInt(tuple[0]);
                                page.height = parseInt(tuple[1]);
                                reader.readTuple(tuple);
                            }
                            page.format = spine.Atlas.Format[tuple[0]];
                            reader.readTuple(tuple);
                            page.minFilter = spine.Atlas.TextureFilter[tuple[0]];
                            page.magFilter = spine.Atlas.TextureFilter[tuple[1]];
                            var direction = reader.readValue();
                            page.uWrap = spine.Atlas.TextureWrap.clampToEdge;
                            page.vWrap = spine.Atlas.TextureWrap.clampToEdge;
                            if ("x" == direction) {
                                page.uWrap = spine.Atlas.TextureWrap.repeat;
                            } else {
                                if ("y" == direction) {
                                    page.vWrap = spine.Atlas.TextureWrap.repeat;
                                } else {
                                    if ("xy" == direction) {
                                        page.uWrap = page.vWrap = spine.Atlas.TextureWrap.repeat;
                                    }
                                }
                            }
                            textureLoader.load(page, line, this);
                            this.pages.push(page);
                        } else {
                            var region = new spine.AtlasRegion();
                            region.name = line;
                            region.page = page;
                            region.rotate = "true" == reader.readValue();
                            reader.readTuple(tuple);
                            var x = parseInt(tuple[0]);
                            var y = parseInt(tuple[1]);
                            reader.readTuple(tuple);
                            var width = parseInt(tuple[0]);
                            var height = parseInt(tuple[1]);
                            region.u = x / page.width;
                            region.v = y / page.height;
                            if (region.rotate) {
                                region.u2 = (x + height) / page.width;
                                region.v2 = (y + width) / page.height;
                            } else {
                                region.u2 = (x + width) / page.width;
                                region.v2 = (y + height) / page.height;
                            }
                            region.x = x;
                            region.y = y;
                            region.width = Math.abs(width);
                            region.height = Math.abs(height);
                            if (4 == reader.readTuple(tuple)) {
                                region.splits = [ parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3]) ];
                                if (4 == reader.readTuple(tuple)) {
                                    region.pads = [ parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3]) ];
                                    reader.readTuple(tuple);
                                }
                            }
                            region.originalWidth = parseInt(tuple[0]);
                            region.originalHeight = parseInt(tuple[1]);
                            reader.readTuple(tuple);
                            region.offsetX = parseInt(tuple[0]);
                            region.offsetY = parseInt(tuple[1]);
                            region.index = parseInt(reader.readValue());
                            this.regions.push(region);
                        }
                    }
                }
            };
            spine.Atlas.prototype = {
                findRegion: function(name) {
                    var regions = this.regions;
                    for (var i = 0, n = regions.length; i < n; i++) {
                        if (regions[i].name == name) {
                            return regions[i];
                        }
                    }
                    return null;
                },
                dispose: function() {
                    var pages = this.pages;
                    for (var i = 0, n = pages.length; i < n; i++) {
                        this.textureLoader.unload(pages[i].rendererObject);
                    }
                },
                updateUVs: function(page) {
                    var regions = this.regions;
                    for (var i = 0, n = regions.length; i < n; i++) {
                        var region = regions[i];
                        if (region.page != page) {
                            continue;
                        }
                        region.u = region.x / page.width;
                        region.v = region.y / page.height;
                        if (region.rotate) {
                            region.u2 = (region.x + region.height) / page.width;
                            region.v2 = (region.y + region.width) / page.height;
                        } else {
                            region.u2 = (region.x + region.width) / page.width;
                            region.v2 = (region.y + region.height) / page.height;
                        }
                    }
                }
            };
            spine.Atlas.Format = {
                alpha: 0,
                intensity: 1,
                luminanceAlpha: 2,
                rgb565: 3,
                rgba4444: 4,
                rgb888: 5,
                rgba8888: 6
            };
            spine.Atlas.TextureFilter = {
                nearest: 0,
                linear: 1,
                mipMap: 2,
                mipMapNearestNearest: 3,
                mipMapLinearNearest: 4,
                mipMapNearestLinear: 5,
                mipMapLinearLinear: 6
            };
            spine.Atlas.TextureWrap = {
                mirroredRepeat: 0,
                clampToEdge: 1,
                repeat: 2
            };
            spine.AtlasPage = function() {};
            spine.AtlasPage.prototype = {
                name: null,
                format: null,
                minFilter: null,
                magFilter: null,
                uWrap: null,
                vWrap: null,
                rendererObject: null,
                width: 0,
                height: 0
            };
            spine.AtlasRegion = function() {};
            spine.AtlasRegion.prototype = {
                page: null,
                name: null,
                x: 0,
                y: 0,
                width: 0,
                height: 0,
                u: 0,
                v: 0,
                u2: 0,
                v2: 0,
                offsetX: 0,
                offsetY: 0,
                originalWidth: 0,
                originalHeight: 0,
                index: 0,
                rotate: false,
                splits: null,
                pads: null
            };
            spine.AtlasReader = function(text) {
                this.lines = text.split(/\r\n|\r|\n/);
            };
            spine.AtlasReader.prototype = {
                index: 0,
                trim: function(value) {
                    return value.replace(/^\s+|\s+$/g, "");
                },
                readLine: function() {
                    if (this.index >= this.lines.length) {
                        return null;
                    }
                    return this.lines[this.index++];
                },
                readValue: function() {
                    var line = this.readLine();
                    var colon = line.indexOf(":");
                    if (-1 == colon) {
                        throw new Error("Invalid line: " + line);
                    }
                    return this.trim(line.substring(colon + 1));
                },
                readTuple: function(tuple) {
                    var line = this.readLine();
                    var colon = line.indexOf(":");
                    if (-1 == colon) {
                        throw new Error("Invalid line: " + line);
                    }
                    var i = 0, lastMatch = colon + 1;
                    for (;i < 3; i++) {
                        var comma = line.indexOf(",", lastMatch);
                        if (-1 == comma) {
                            break;
                        }
                        tuple[i] = this.trim(line.substr(lastMatch, comma - lastMatch));
                        lastMatch = comma + 1;
                    }
                    tuple[i] = this.trim(line.substring(lastMatch));
                    return i + 1;
                }
            };
            spine.AtlasAttachmentLoader = function(atlas) {
                this.atlas = atlas;
            };
            spine.AtlasAttachmentLoader.prototype = {
                newRegionAttachment: function(skin, name, path) {
                    var region = this.atlas.findRegion(path);
                    if (!region) {
                        throw new Error("Region not found in atlas: " + path + " (region attachment: " + name + ")");
                    }
                    var attachment = new spine.RegionAttachment(name);
                    attachment.rendererObject = region;
                    attachment.setUVs(region.u, region.v, region.u2, region.v2, region.rotate);
                    attachment.regionOffsetX = region.offsetX;
                    attachment.regionOffsetY = region.offsetY;
                    attachment.regionWidth = region.width;
                    attachment.regionHeight = region.height;
                    attachment.regionOriginalWidth = region.originalWidth;
                    attachment.regionOriginalHeight = region.originalHeight;
                    return attachment;
                },
                newMeshAttachment: function(skin, name, path) {
                    var region = this.atlas.findRegion(path);
                    if (!region) {
                        throw new Error("Region not found in atlas: " + path + " (mesh attachment: " + name + ")");
                    }
                    var attachment = new spine.MeshAttachment(name);
                    attachment.rendererObject = region;
                    attachment.regionU = region.u;
                    attachment.regionV = region.v;
                    attachment.regionU2 = region.u2;
                    attachment.regionV2 = region.v2;
                    attachment.regionRotate = region.rotate;
                    attachment.regionOffsetX = region.offsetX;
                    attachment.regionOffsetY = region.offsetY;
                    attachment.regionWidth = region.width;
                    attachment.regionHeight = region.height;
                    attachment.regionOriginalWidth = region.originalWidth;
                    attachment.regionOriginalHeight = region.originalHeight;
                    return attachment;
                },
                newSkinnedMeshAttachment: function(skin, name, path) {
                    var region = this.atlas.findRegion(path);
                    if (!region) {
                        throw new Error("Region not found in atlas: " + path + " (skinned mesh attachment: " + name + ")");
                    }
                    var attachment = new spine.SkinnedMeshAttachment(name);
                    attachment.rendererObject = region;
                    attachment.regionU = region.u;
                    attachment.regionV = region.v;
                    attachment.regionU2 = region.u2;
                    attachment.regionV2 = region.v2;
                    attachment.regionRotate = region.rotate;
                    attachment.regionOffsetX = region.offsetX;
                    attachment.regionOffsetY = region.offsetY;
                    attachment.regionWidth = region.width;
                    attachment.regionHeight = region.height;
                    attachment.regionOriginalWidth = region.originalWidth;
                    attachment.regionOriginalHeight = region.originalHeight;
                    return attachment;
                },
                newBoundingBoxAttachment: function(skin, name) {
                    return new spine.BoundingBoxAttachment(name);
                }
            };
            spine.SkeletonBounds = function() {
                this.polygonPool = [];
                this.polygons = [];
                this.boundingBoxes = [];
            };
            spine.SkeletonBounds.prototype = {
                minX: 0,
                minY: 0,
                maxX: 0,
                maxY: 0,
                update: function(skeleton, updateAabb) {
                    var slots = skeleton.slots;
                    var slotCount = slots.length;
                    var x = skeleton.x, y = skeleton.y;
                    var boundingBoxes = this.boundingBoxes;
                    var polygonPool = this.polygonPool;
                    var polygons = this.polygons;
                    boundingBoxes.length = 0;
                    for (var i = 0, n = polygons.length; i < n; i++) {
                        polygonPool.push(polygons[i]);
                    }
                    polygons.length = 0;
                    for (var i = 0; i < slotCount; i++) {
                        var slot = slots[i];
                        var boundingBox = slot.attachment;
                        if (boundingBox.type != spine.AttachmentType.boundingbox) {
                            continue;
                        }
                        boundingBoxes.push(boundingBox);
                        var poolCount = polygonPool.length, polygon;
                        if (poolCount > 0) {
                            polygon = polygonPool[poolCount - 1];
                            polygonPool.splice(poolCount - 1, 1);
                        } else {
                            polygon = [];
                        }
                        polygons.push(polygon);
                        polygon.length = boundingBox.vertices.length;
                        boundingBox.computeWorldVertices(x, y, slot.bone, polygon);
                    }
                    if (updateAabb) {
                        this.aabbCompute();
                    }
                },
                aabbCompute: function() {
                    var polygons = this.polygons;
                    var minX = Number.MAX_VALUE, minY = Number.MAX_VALUE, maxX = Number.MIN_VALUE, maxY = Number.MIN_VALUE;
                    for (var i = 0, n = polygons.length; i < n; i++) {
                        var vertices = polygons[i];
                        for (var ii = 0, nn = vertices.length; ii < nn; ii += 2) {
                            var x = vertices[ii];
                            var y = vertices[ii + 1];
                            minX = Math.min(minX, x);
                            minY = Math.min(minY, y);
                            maxX = Math.max(maxX, x);
                            maxY = Math.max(maxY, y);
                        }
                    }
                    this.minX = minX;
                    this.minY = minY;
                    this.maxX = maxX;
                    this.maxY = maxY;
                },
                aabbContainsPoint: function(x, y) {
                    return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;
                },
                aabbIntersectsSegment: function(x1, y1, x2, y2) {
                    var minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;
                    if (x1 <= minX && x2 <= minX || y1 <= minY && y2 <= minY || x1 >= maxX && x2 >= maxX || y1 >= maxY && y2 >= maxY) {
                        return false;
                    }
                    var m = (y2 - y1) / (x2 - x1);
                    var y = m * (minX - x1) + y1;
                    if (y > minY && y < maxY) {
                        return true;
                    }
                    y = m * (maxX - x1) + y1;
                    if (y > minY && y < maxY) {
                        return true;
                    }
                    var x = (minY - y1) / m + x1;
                    if (x > minX && x < maxX) {
                        return true;
                    }
                    x = (maxY - y1) / m + x1;
                    if (x > minX && x < maxX) {
                        return true;
                    }
                    return false;
                },
                aabbIntersectsSkeleton: function(bounds) {
                    return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;
                },
                containsPoint: function(x, y) {
                    var polygons = this.polygons;
                    for (var i = 0, n = polygons.length; i < n; i++) {
                        if (this.polygonContainsPoint(polygons[i], x, y)) {
                            return this.boundingBoxes[i];
                        }
                    }
                    return null;
                },
                intersectsSegment: function(x1, y1, x2, y2) {
                    var polygons = this.polygons;
                    for (var i = 0, n = polygons.length; i < n; i++) {
                        if (polygons[i].intersectsSegment(x1, y1, x2, y2)) {
                            return this.boundingBoxes[i];
                        }
                    }
                    return null;
                },
                polygonContainsPoint: function(polygon, x, y) {
                    var nn = polygon.length;
                    var prevIndex = nn - 2;
                    var inside = false;
                    for (var ii = 0; ii < nn; ii += 2) {
                        var vertexY = polygon[ii + 1];
                        var prevY = polygon[prevIndex + 1];
                        if (vertexY < y && prevY >= y || prevY < y && vertexY >= y) {
                            var vertexX = polygon[ii];
                            if (vertexX + (y - vertexY) / (prevY - vertexY) * (polygon[prevIndex] - vertexX) < x) {
                                inside = !inside;
                            }
                        }
                        prevIndex = ii;
                    }
                    return inside;
                },
                polygonIntersectsSegment: function(polygon, x1, y1, x2, y2) {
                    var nn = polygon.length;
                    var width12 = x1 - x2, height12 = y1 - y2;
                    var det1 = x1 * y2 - y1 * x2;
                    var x3 = polygon[nn - 2], y3 = polygon[nn - 1];
                    for (var ii = 0; ii < nn; ii += 2) {
                        var x4 = polygon[ii], y4 = polygon[ii + 1];
                        var det2 = x3 * y4 - y3 * x4;
                        var width34 = x3 - x4, height34 = y3 - y4;
                        var det3 = width12 * height34 - height12 * width34;
                        var x = (det1 * width34 - width12 * det2) / det3;
                        if ((x >= x3 && x <= x4 || x >= x4 && x <= x3) && (x >= x1 && x <= x2 || x >= x2 && x <= x1)) {
                            var y = (det1 * height34 - height12 * det2) / det3;
                            if ((y >= y3 && y <= y4 || y >= y4 && y <= y3) && (y >= y1 && y <= y2 || y >= y2 && y <= y1)) {
                                return true;
                            }
                        }
                        x3 = x4;
                        y3 = y4;
                    }
                    return false;
                },
                getPolygon: function(attachment) {
                    var index = this.boundingBoxes.indexOf(attachment);
                    return -1 == index ? null : this.polygons[index];
                },
                getWidth: function() {
                    return this.maxX - this.minX;
                },
                getHeight: function() {
                    return this.maxY - this.minY;
                }
            };
            var sp = sp || {};
            sp.VERTEX_INDEX = {
                X1: 0,
                Y1: 1,
                X2: 2,
                Y2: 3,
                X3: 4,
                Y3: 5,
                X4: 6,
                Y4: 7
            };
            sp.ATTACHMENT_TYPE = {
                REGION: 0,
                BOUNDING_BOX: 1,
                MESH: 2,
                SKINNED_MESH: 3
            };
            sp.Skeleton = _ccsg.Node.extend({
                _skeleton: null,
                _rootBone: null,
                _timeScale: 1,
                _debugSlots: false,
                _debugBones: false,
                _premultipliedAlpha: false,
                _ownsSkeletonData: null,
                _atlas: null,
                _blendFunc: null,
                ctor: function(skeletonDataFile, atlasFile, scale) {
                    _ccsg.Node.prototype.ctor.call(this);
                    this._blendFunc = {
                        src: cc.BLEND_SRC,
                        dst: cc.BLEND_DST
                    };
                    if (0 === arguments.length) {
                        this.init();
                    } else {
                        this.initWithArgs(skeletonDataFile, atlasFile, scale);
                    }
                },
                _createRenderCmd: function() {
                    if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                        return new sp.Skeleton.CanvasRenderCmd(this);
                    } else {
                        return new sp.Skeleton.WebGLRenderCmd(this);
                    }
                },
                init: function() {
                    _ccsg.Node.prototype.init.call(this);
                    this._blendFunc.src = cc.ONE;
                    this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA;
                    this.scheduleUpdate();
                },
                setDebugSolots: function(enable) {
                    this._debugSlots = enable;
                },
                setDebugBones: function(enable) {
                    this._debugBones = enable;
                },
                setDebugSlotsEnabled: function(enabled) {
                    this._debugSlots = enabled;
                },
                getDebugSlotsEnabled: function() {
                    return this._debugSlots;
                },
                setDebugBonesEnabled: function(enabled) {
                    this._debugBones = enabled;
                },
                getDebugBonesEnabled: function() {
                    return this._debugBones;
                },
                setTimeScale: function(scale) {
                    this._timeScale = scale;
                },
                getTimeScale: function() {
                    return this._timeScale;
                },
                initWithArgs: function(skeletonDataFile, atlasFile, scale) {
                    var argSkeletonFile = skeletonDataFile, argAtlasFile = atlasFile, skeletonData, atlas, ownsSkeletonData;
                    if (cc.js.isString(argSkeletonFile)) {
                        if (cc.js.isString(argAtlasFile)) {
                            var data = cc.loader.getRes(argAtlasFile);
                            sp._atlasLoader.setAtlasFile(argAtlasFile);
                            atlas = new spine.Atlas(data, sp._atlasLoader);
                        } else {
                            atlas = atlasFile;
                        }
                        scale = scale || 1 / cc.director.getContentScaleFactor();
                        var attachmentLoader = new spine.AtlasAttachmentLoader(atlas);
                        var skeletonJsonReader = new spine.SkeletonJson(attachmentLoader);
                        skeletonJsonReader.scale = scale;
                        var skeletonJson = cc.loader.getRes(argSkeletonFile);
                        skeletonData = skeletonJsonReader.readSkeletonData(skeletonJson);
                        atlas.dispose(skeletonJsonReader);
                        ownsSkeletonData = true;
                    } else {
                        skeletonData = skeletonDataFile;
                        ownsSkeletonData = atlasFile;
                    }
                    this.setSkeletonData(skeletonData, ownsSkeletonData);
                    this.init();
                },
                getBoundingBox: function() {
                    var minX = cc.FLT_MAX, minY = cc.FLT_MAX, maxX = cc.FLT_MIN, maxY = cc.FLT_MIN;
                    var scaleX = this.getScaleX(), scaleY = this.getScaleY(), vertices = [], slots = this._skeleton.slots, VERTEX = sp.VERTEX_INDEX;
                    for (var i = 0, slotCount = slots.length; i < slotCount; ++i) {
                        var slot = slots[i];
                        if (!slot.attachment || slot.attachment.type != sp.ATTACHMENT_TYPE.REGION) {
                            continue;
                        }
                        var attachment = slot.attachment;
                        this._computeRegionAttachmentWorldVertices(attachment, slot.bone.skeleton.x, slot.bone.skeleton.y, slot.bone, vertices);
                        minX = Math.min(minX, vertices[VERTEX.X1] * scaleX, vertices[VERTEX.X4] * scaleX, vertices[VERTEX.X2] * scaleX, vertices[VERTEX.X3] * scaleX);
                        minY = Math.min(minY, vertices[VERTEX.Y1] * scaleY, vertices[VERTEX.Y4] * scaleY, vertices[VERTEX.Y2] * scaleY, vertices[VERTEX.Y3] * scaleY);
                        maxX = Math.max(maxX, vertices[VERTEX.X1] * scaleX, vertices[VERTEX.X4] * scaleX, vertices[VERTEX.X2] * scaleX, vertices[VERTEX.X3] * scaleX);
                        maxY = Math.max(maxY, vertices[VERTEX.Y1] * scaleY, vertices[VERTEX.Y4] * scaleY, vertices[VERTEX.Y2] * scaleY, vertices[VERTEX.Y3] * scaleY);
                    }
                    var position = this.getPosition();
                    return cc.rect(position.x + minX, position.y + minY, maxX - minX, maxY - minY);
                },
                _computeRegionAttachmentWorldVertices: function(self, x, y, bone, vertices) {
                    var offset = self.offset, vertexIndex = sp.VERTEX_INDEX;
                    x += bone.worldX;
                    y += bone.worldY;
                    vertices[vertexIndex.X1] = offset[vertexIndex.X1] * bone.m00 + offset[vertexIndex.Y1] * bone.m01 + x;
                    vertices[vertexIndex.Y1] = offset[vertexIndex.X1] * bone.m10 + offset[vertexIndex.Y1] * bone.m11 + y;
                    vertices[vertexIndex.X2] = offset[vertexIndex.X2] * bone.m00 + offset[vertexIndex.Y2] * bone.m01 + x;
                    vertices[vertexIndex.Y2] = offset[vertexIndex.X2] * bone.m10 + offset[vertexIndex.Y2] * bone.m11 + y;
                    vertices[vertexIndex.X3] = offset[vertexIndex.X3] * bone.m00 + offset[vertexIndex.Y3] * bone.m01 + x;
                    vertices[vertexIndex.Y3] = offset[vertexIndex.X3] * bone.m10 + offset[vertexIndex.Y3] * bone.m11 + y;
                    vertices[vertexIndex.X4] = offset[vertexIndex.X4] * bone.m00 + offset[vertexIndex.Y4] * bone.m01 + x;
                    vertices[vertexIndex.Y4] = offset[vertexIndex.X4] * bone.m10 + offset[vertexIndex.Y4] * bone.m11 + y;
                },
                updateWorldTransform: function() {
                    this._skeleton.updateWorldTransform();
                },
                setToSetupPose: function() {
                    this._skeleton.setToSetupPose();
                },
                setBonesToSetupPose: function() {
                    this._skeleton.setBonesToSetupPose();
                },
                setSlotsToSetupPose: function() {
                    this._skeleton.setSlotsToSetupPose();
                },
                findBone: function(boneName) {
                    return this._skeleton.findBone(boneName);
                },
                findSlot: function(slotName) {
                    return this._skeleton.findSlot(slotName);
                },
                setSkin: function(skinName) {
                    return this._skeleton.setSkinByName(skinName);
                },
                getAttachment: function(slotName, attachmentName) {
                    return this._skeleton.getAttachmentBySlotName(slotName, attachmentName);
                },
                setAttachment: function(slotName, attachmentName) {
                    this._skeleton.setAttachment(slotName, attachmentName);
                },
                setOpacityModifyRGB: function(alpha) {
                    this._premultipliedAlpha = alpha;
                },
                isOpacityModifyRGB: function() {
                    return this._premultipliedAlpha;
                },
                setSkeletonData: function(skeletonData, ownsSkeletonData) {
                    if (null != skeletonData.width && null != skeletonData.height) {
                        this.setContentSize(skeletonData.width / cc.director.getContentScaleFactor(), skeletonData.height / cc.director.getContentScaleFactor());
                    }
                    this._skeleton = new spine.Skeleton(skeletonData);
                    this._skeleton.updateWorldTransform();
                    this._rootBone = this._skeleton.getRootBone();
                    this._ownsSkeletonData = ownsSkeletonData;
                    this._renderCmd._createChildFormSkeletonData();
                },
                getTextureAtlas: function(regionAttachment) {
                    return regionAttachment.rendererObject.page.rendererObject;
                },
                getBlendFunc: function() {
                    return this._blendFunc;
                },
                setBlendFunc: function(src, dst) {
                    var locBlendFunc = this._blendFunc;
                    if (void 0 === dst) {
                        locBlendFunc.src = src.src;
                        locBlendFunc.dst = src.dst;
                    } else {
                        locBlendFunc.src = src;
                        locBlendFunc.dst = dst;
                    }
                },
                update: function(dt) {
                    this._skeleton.update(dt);
                }
            });
            sp.Skeleton.create = function(skeletonDataFile, atlasFile, scale) {
                return new sp.Skeleton(skeletonDataFile, atlasFile, scale);
            };
            !function() {
                sp.Skeleton.CanvasRenderCmd = function(renderableObject) {
                    _ccsg.Node.CanvasRenderCmd.call(this, renderableObject);
                    this._needDraw = true;
                };
                var proto = sp.Skeleton.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
                proto.constructor = sp.Skeleton.CanvasRenderCmd;
                proto.rendering = function(wrapper, scaleX, scaleY) {
                    var node = this._node, i, n, slot, slotNode;
                    wrapper = wrapper || cc._renderContext;
                    var locSkeleton = node._skeleton, drawOrder = locSkeleton.drawOrder;
                    for (i = 0, n = drawOrder.length; i < n; i++) {
                        slot = drawOrder[i];
                        slotNode = slot._slotNode;
                        if (slotNode._visible && slotNode._renderCmd && slot.currentSprite) {
                            slotNode._renderCmd.transform(this, true);
                            slot.currentSprite._renderCmd.rendering(wrapper, scaleX, scaleY);
                            slotNode._renderCmd._dirtyFlag = slot.currentSprite._renderCmd._dirtyFlag = 0;
                        }
                    }
                    if (!node._debugSlots && !node._debugBones) {
                        return;
                    }
                    wrapper.setTransform(this._worldTransform, scaleX, scaleY);
                    wrapper.setGlobalAlpha(1);
                    var attachment, drawingUtil = cc._drawingUtil;
                    if (node._debugSlots) {
                        drawingUtil.setDrawColor(0, 0, 255, 255);
                        drawingUtil.setLineWidth(1);
                        var points = [];
                        for (i = 0, n = locSkeleton.slots.length; i < n; i++) {
                            slot = locSkeleton.drawOrder[i];
                            if (!slot.attachment || slot.attachment.type != sp.ATTACHMENT_TYPE.REGION) {
                                continue;
                            }
                            attachment = slot.attachment;
                            this._updateRegionAttachmentSlot(attachment, slot, points);
                            drawingUtil.drawPoly(points, 4, true);
                        }
                    }
                    if (node._debugBones) {
                        var bone;
                        drawingUtil.setLineWidth(2);
                        drawingUtil.setDrawColor(255, 0, 0, 255);
                        for (i = 0, n = locSkeleton.bones.length; i < n; i++) {
                            bone = locSkeleton.bones[i];
                            var x = bone.data.length * bone.m00 + bone.worldX;
                            var y = bone.data.length * bone.m10 + bone.worldY;
                            drawingUtil.drawLine({
                                x: bone.worldX,
                                y: bone.worldY
                            }, {
                                x: x,
                                y: y
                            });
                        }
                        drawingUtil.setPointSize(4);
                        drawingUtil.setDrawColor(0, 0, 255, 255);
                        for (i = 0, n = locSkeleton.bones.length; i < n; i++) {
                            bone = locSkeleton.bones[i];
                            drawingUtil.drawPoint({
                                x: bone.worldX,
                                y: bone.worldY
                            });
                            if (0 === i) {
                                drawingUtil.setDrawColor(0, 255, 0, 255);
                            }
                        }
                    }
                };
                proto._updateRegionAttachmentSlot = function(attachment, slot, points) {
                    if (!points) {
                        return;
                    }
                    var vertices = {}, VERTEX = sp.VERTEX_INDEX, bone = slot.bone;
                    attachment.computeVertices(bone.skeleton.x, bone.skeleton.y, bone, vertices);
                    points.length = 0;
                    points.push(cc.p(vertices[VERTEX.X1], vertices[VERTEX.Y1]));
                    points.push(cc.p(vertices[VERTEX.X4], vertices[VERTEX.Y4]));
                    points.push(cc.p(vertices[VERTEX.X3], vertices[VERTEX.Y3]));
                    points.push(cc.p(vertices[VERTEX.X2], vertices[VERTEX.Y2]));
                };
                proto._createChildFormSkeletonData = function() {
                    var node = this._node;
                    var locSkeleton = node._skeleton, spriteName, sprite;
                    for (var i = 0, n = locSkeleton.slots.length; i < n; i++) {
                        var slot = locSkeleton.slots[i], attachment = slot.attachment;
                        var slotNode = new _ccsg.Node();
                        slot._slotNode = slotNode;
                        if (attachment instanceof spine.RegionAttachment) {
                            spriteName = attachment.rendererObject.name;
                            sprite = this._createSprite(slot, attachment);
                            slot.currentSprite = sprite;
                            slot.currentSpriteName = spriteName;
                            slotNode.addChild(sprite);
                        } else {
                            if (attachment instanceof spine.MeshAttachment) {}
                        }
                    }
                };
                proto._createSprite = function(slot, attachment) {
                    var rendererObject = attachment.rendererObject;
                    var texture = rendererObject.page._texture;
                    var rect = new cc.Rect(rendererObject.x, rendererObject.y, rendererObject.width, rendererObject.height);
                    var sprite = new _ccsg.Sprite();
                    sprite.initWithTexture(rendererObject.page._texture, rect, rendererObject.rotate, false);
                    sprite._rect.width = attachment.width;
                    sprite._rect.height = attachment.height;
                    sprite.setContentSize(attachment.width, attachment.height);
                    sprite.setRotation(-attachment.rotation);
                    sprite.setScale(rendererObject.width / rendererObject.originalWidth * attachment.scaleX, rendererObject.height / rendererObject.originalHeight * attachment.scaleY);
                    slot.sprites = slot.sprites || {};
                    slot.sprites[rendererObject.name] = sprite;
                    return sprite;
                };
                proto._updateChild = function() {
                    var locSkeleton = this._node._skeleton, slots = locSkeleton.slots;
                    var i, n, selSprite;
                    var slot, attachment, slotNode;
                    for (i = 0, n = slots.length; i < n; i++) {
                        slot = slots[i];
                        attachment = slot.attachment;
                        slotNode = slot._slotNode;
                        if (!attachment) {
                            slotNode.setVisible(false);
                            continue;
                        }
                        var type = attachment.type;
                        if (type === spine.AttachmentType.region) {
                            if (attachment.rendererObject) {
                                if (!slot.currentSpriteName || slot.currentSpriteName !== attachment.name) {
                                    var spriteName = attachment.rendererObject.name;
                                    if (void 0 !== slot.currentSprite) {
                                        slot.currentSprite.setVisible(false);
                                    }
                                    slot.sprites = slot.sprites || {};
                                    if (void 0 !== slot.sprites[spriteName]) {
                                        slot.sprites[spriteName].setVisible(true);
                                    } else {
                                        var sprite = this._createSprite(slot, attachment);
                                        slotNode.addChild(sprite);
                                    }
                                    slot.currentSprite = slot.sprites[spriteName];
                                    slot.currentSpriteName = spriteName;
                                }
                            }
                            var bone = slot.bone;
                            slotNode.setPosition(bone.worldX + attachment.x * bone.m00 + attachment.y * bone.m01, bone.worldY + attachment.x * bone.m10 + attachment.y * bone.m11);
                            slotNode.setScale(bone.worldScaleX, bone.worldScaleY);
                            selSprite = slot.currentSprite;
                            selSprite._flippedX = bone.worldFlipX;
                            selSprite._flippedY = bone.worldFlipY;
                            if (selSprite._flippedY || selSprite._flippedX) {
                                slotNode.setRotation(bone.worldRotation);
                                selSprite.setRotation(attachment.rotation);
                            } else {
                                slotNode.setRotation(-bone.worldRotation);
                                selSprite.setRotation(-attachment.rotation);
                            }
                            selSprite._renderCmd._displayedOpacity = 0 | locSkeleton.a * slot.a * 255;
                            var r = 0 | locSkeleton.r * slot.r * 255, g = 0 | locSkeleton.g * slot.g * 255, b = 0 | locSkeleton.b * slot.b * 255;
                            selSprite.setColor(cc.color(r, g, b));
                            selSprite._renderCmd._updateColor();
                        } else {
                            if (type === spine.AttachmentType.skinnedmesh) {
                                ;
                            } else {
                                slotNode.setVisible(false);
                                continue;
                            }
                        }
                        slotNode.setVisible(true);
                    }
                };
            }();
            !function() {
                sp.Skeleton.WebGLRenderCmd = function(renderableObject) {
                    _ccsg.Node.WebGLRenderCmd.call(this, renderableObject);
                    this._needDraw = true;
                    this.setShaderProgram(cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR));
                    this._tmpQuad = new cc.V3F_C4B_T2F_Quad();
                };
                var proto = sp.Skeleton.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
                proto.constructor = sp.Skeleton.WebGLRenderCmd;
                proto.rendering = function(ctx) {
                    var node = this._node, tmpQuad = this._tmpQuad;
                    var color = node.getColor(), locSkeleton = node._skeleton;
                    var blendMode, textureAtlas, attachment, slot, i, n;
                    var locBlendFunc = node._blendFunc;
                    var premultiAlpha = node._premultipliedAlpha;
                    this._shaderProgram.use();
                    this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
                    locSkeleton.r = color.r / 255;
                    locSkeleton.g = color.g / 255;
                    locSkeleton.b = color.b / 255;
                    locSkeleton.a = node.getOpacity() / 255;
                    if (premultiAlpha) {
                        locSkeleton.r *= locSkeleton.a;
                        locSkeleton.g *= locSkeleton.a;
                        locSkeleton.b *= locSkeleton.a;
                    }
                    for (i = 0, n = locSkeleton.drawOrder.length; i < n; i++) {
                        slot = locSkeleton.drawOrder[i];
                        if (!slot.attachment) {
                            continue;
                        }
                        attachment = slot.attachment;
                        switch (slot.attachment.type) {
                          case sp.ATTACHMENT_TYPE.REGION:
                            this._updateRegionAttachmentQuad(attachment, slot, tmpQuad, premultiAlpha);
                            break;

                          case sp.ATTACHMENT_TYPE.MESH:
                            this._updateMeshAttachmentQuad(attachment, slot, tmpQuad, premultiAlpha);
                            break;

                          case sp.ATTACHMENT_TYPE.SKINNED_MESH:
                            break;

                          default:
                            continue;
                        }
                        var regionTextureAtlas = node.getTextureAtlas(attachment);
                        if (slot.data.blendMode != blendMode) {
                            if (textureAtlas) {
                                textureAtlas.drawQuads();
                                textureAtlas.removeAllQuads();
                            }
                            blendMode = slot.data.blendMode;
                            switch (blendMode) {
                              case spine.BlendMode.additive:
                                cc.glBlendFunc(premultiAlpha ? cc.ONE : cc.SRC_ALPHA, cc.ONE);
                                break;

                              case spine.BlendMode.multiply:
                                cc.glBlendFunc(cc.DST_COLOR, cc.ONE_MINUS_SRC_ALPHA);
                                break;

                              case spine.BlendMode.screen:
                                cc.glBlendFunc(cc.ONE, cc.ONE_MINUS_SRC_COLOR);
                                break;

                              default:
                                cc.glBlendFunc(locBlendFunc.src, locBlendFunc.dst);
                            }
                        } else {
                            if (regionTextureAtlas != textureAtlas && textureAtlas) {
                                textureAtlas.drawQuads();
                                textureAtlas.removeAllQuads();
                            }
                        }
                        textureAtlas = regionTextureAtlas;
                        var quadCount = textureAtlas.getTotalQuads();
                        if (textureAtlas.getCapacity() == quadCount) {
                            textureAtlas.drawQuads();
                            textureAtlas.removeAllQuads();
                            if (!textureAtlas.resizeCapacity(2 * textureAtlas.getCapacity())) {
                                return;
                            }
                        }
                        textureAtlas.updateQuad(tmpQuad, quadCount);
                    }
                    if (textureAtlas) {
                        textureAtlas.drawQuads();
                        textureAtlas.removeAllQuads();
                    }
                    if (node._debugBones || node._debugSlots) {
                        cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
                        cc.current_stack.stack.push(cc.current_stack.top);
                        cc.current_stack.top = this._stackMatrix;
                        var drawingUtil = cc._drawingUtil;
                        if (node._debugSlots) {
                            drawingUtil.setDrawColor(0, 0, 255, 255);
                            drawingUtil.setLineWidth(1);
                            for (i = 0, n = locSkeleton.slots.length; i < n; i++) {
                                slot = locSkeleton.drawOrder[i];
                                if (!slot.attachment || slot.attachment.type != sp.ATTACHMENT_TYPE.REGION) {
                                    continue;
                                }
                                attachment = slot.attachment;
                                this._updateRegionAttachmentQuad(attachment, slot, tmpQuad);
                                var points = [];
                                points.push(cc.p(tmpQuad.bl.vertices.x, tmpQuad.bl.vertices.y));
                                points.push(cc.p(tmpQuad.br.vertices.x, tmpQuad.br.vertices.y));
                                points.push(cc.p(tmpQuad.tr.vertices.x, tmpQuad.tr.vertices.y));
                                points.push(cc.p(tmpQuad.tl.vertices.x, tmpQuad.tl.vertices.y));
                                drawingUtil.drawPoly(points, 4, true);
                            }
                        }
                        if (node._debugBones) {
                            var bone;
                            drawingUtil.setLineWidth(2);
                            drawingUtil.setDrawColor(255, 0, 0, 255);
                            for (i = 0, n = locSkeleton.bones.length; i < n; i++) {
                                bone = locSkeleton.bones[i];
                                var x = bone.data.length * bone.m00 + bone.worldX;
                                var y = bone.data.length * bone.m10 + bone.worldY;
                                drawingUtil.drawLine(cc.p(bone.worldX, bone.worldY), cc.p(x, y));
                            }
                            drawingUtil.setPointSize(4);
                            drawingUtil.setDrawColor(0, 0, 255, 255);
                            for (i = 0, n = locSkeleton.bones.length; i < n; i++) {
                                bone = locSkeleton.bones[i];
                                drawingUtil.drawPoint(cc.p(bone.worldX, bone.worldY));
                                if (0 == i) {
                                    drawingUtil.setDrawColor(0, 255, 0, 255);
                                }
                            }
                        }
                        cc.kmGLPopMatrix();
                    }
                };
                proto._createChildFormSkeletonData = function() {};
                proto._updateChild = function() {};
                proto._updateRegionAttachmentQuad = function(self, slot, quad, premultipliedAlpha) {
                    var vertices = {};
                    self.computeVertices(slot.bone.skeleton.x, slot.bone.skeleton.y, slot.bone, vertices);
                    var r = slot.bone.skeleton.r * slot.r * 255;
                    var g = slot.bone.skeleton.g * slot.g * 255;
                    var b = slot.bone.skeleton.b * slot.b * 255;
                    var normalizedAlpha = slot.bone.skeleton.a * slot.a;
                    if (premultipliedAlpha) {
                        r *= normalizedAlpha;
                        g *= normalizedAlpha;
                        b *= normalizedAlpha;
                    }
                    var a = 255 * normalizedAlpha;
                    quad.bl.colors.r = quad.tl.colors.r = quad.tr.colors.r = quad.br.colors.r = r;
                    quad.bl.colors.g = quad.tl.colors.g = quad.tr.colors.g = quad.br.colors.g = g;
                    quad.bl.colors.b = quad.tl.colors.b = quad.tr.colors.b = quad.br.colors.b = b;
                    quad.bl.colors.a = quad.tl.colors.a = quad.tr.colors.a = quad.br.colors.a = a;
                    var VERTEX = sp.VERTEX_INDEX;
                    quad.bl.vertices.x = vertices[VERTEX.X1];
                    quad.bl.vertices.y = vertices[VERTEX.Y1];
                    quad.tl.vertices.x = vertices[VERTEX.X2];
                    quad.tl.vertices.y = vertices[VERTEX.Y2];
                    quad.tr.vertices.x = vertices[VERTEX.X3];
                    quad.tr.vertices.y = vertices[VERTEX.Y3];
                    quad.br.vertices.x = vertices[VERTEX.X4];
                    quad.br.vertices.y = vertices[VERTEX.Y4];
                    quad.bl.texCoords.u = self.uvs[VERTEX.X1];
                    quad.bl.texCoords.v = self.uvs[VERTEX.Y1];
                    quad.tl.texCoords.u = self.uvs[VERTEX.X2];
                    quad.tl.texCoords.v = self.uvs[VERTEX.Y2];
                    quad.tr.texCoords.u = self.uvs[VERTEX.X3];
                    quad.tr.texCoords.v = self.uvs[VERTEX.Y3];
                    quad.br.texCoords.u = self.uvs[VERTEX.X4];
                    quad.br.texCoords.v = self.uvs[VERTEX.Y4];
                };
                proto._updateMeshAttachmentQuad = function(self, slot, quad, premultipliedAlpha) {
                    var vertices = {};
                    self.computeWorldVertices(slot.bone.x, slot.bone.y, slot, vertices);
                    var r = slot.bone.skeleton.r * slot.r * 255;
                    var g = slot.bone.skeleton.g * slot.g * 255;
                    var b = slot.bone.skeleton.b * slot.b * 255;
                    var normalizedAlpha = slot.bone.skeleton.a * slot.a;
                    if (premultipliedAlpha) {
                        r *= normalizedAlpha;
                        g *= normalizedAlpha;
                        b *= normalizedAlpha;
                    }
                    var a = 255 * normalizedAlpha;
                    quad.bl.colors.r = quad.tl.colors.r = quad.tr.colors.r = quad.br.colors.r = r;
                    quad.bl.colors.g = quad.tl.colors.g = quad.tr.colors.g = quad.br.colors.g = g;
                    quad.bl.colors.b = quad.tl.colors.b = quad.tr.colors.b = quad.br.colors.b = b;
                    quad.bl.colors.a = quad.tl.colors.a = quad.tr.colors.a = quad.br.colors.a = a;
                    var VERTEX = sp.VERTEX_INDEX;
                    quad.bl.vertices.x = vertices[VERTEX.X1];
                    quad.bl.vertices.y = vertices[VERTEX.Y1];
                    quad.tl.vertices.x = vertices[VERTEX.X2];
                    quad.tl.vertices.y = vertices[VERTEX.Y2];
                    quad.tr.vertices.x = vertices[VERTEX.X3];
                    quad.tr.vertices.y = vertices[VERTEX.Y3];
                    quad.br.vertices.x = vertices[VERTEX.X4];
                    quad.br.vertices.y = vertices[VERTEX.Y4];
                    quad.bl.texCoords.u = self.uvs[VERTEX.X1];
                    quad.bl.texCoords.v = self.uvs[VERTEX.Y1];
                    quad.tl.texCoords.u = self.uvs[VERTEX.X2];
                    quad.tl.texCoords.v = self.uvs[VERTEX.Y2];
                    quad.tr.texCoords.u = self.uvs[VERTEX.X3];
                    quad.tr.texCoords.v = self.uvs[VERTEX.Y3];
                    quad.br.texCoords.u = self.uvs[VERTEX.X4];
                    quad.br.texCoords.v = self.uvs[VERTEX.Y4];
                };
            }();
            sp._atlasPage_createTexture_webGL = function(self, path) {
                var texture = cc.textureCache.addImage(path);
                self.rendererObject = new cc.TextureAtlas(texture, 128);
                self.width = texture.getPixelWidth();
                self.height = texture.getPixelHeight();
            };
            sp._atlasPage_createTexture_canvas = function(self, path) {
                self._texture = cc.textureCache.addImage(path);
            };
            sp._atlasPage_disposeTexture = function(self) {
                self.rendererObject.release();
            };
            sp._atlasLoader = {
                spAtlasFile: null,
                setAtlasFile: function(spAtlasFile) {
                    this.spAtlasFile = spAtlasFile;
                },
                load: function(page, line, spAtlas) {
                    var texturePath = cc.path.join(cc.path.dirname(this.spAtlasFile), line);
                    if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
                        sp._atlasPage_createTexture_webGL(page, texturePath);
                    } else {
                        sp._atlasPage_createTexture_canvas(page, texturePath);
                    }
                },
                unload: function(obj) {}
            };
            sp.ANIMATION_EVENT_TYPE = {
                START: 0,
                END: 1,
                COMPLETE: 2,
                EVENT: 3
            };
            sp.TrackEntryListeners = function(startListener, endListener, completeListener, eventListener) {
                this.startListener = startListener || null;
                this.endListener = endListener || null;
                this.completeListener = completeListener || null;
                this.eventListener = eventListener || null;
            };
            sp.TrackEntryListeners.getListeners = function(entry) {
                if (!entry.rendererObject) {
                    entry.rendererObject = new sp.TrackEntryListeners();
                    entry.listener = sp.trackEntryCallback;
                }
                return entry.rendererObject;
            };
            sp.trackEntryCallback = function(state, trackIndex, type, event, loopCount) {
                state.rendererObject.onTrackEntryEvent(trackIndex, type, event, loopCount);
            };
            sp.SkeletonAnimation = sp.Skeleton.extend({
                _state: null,
                _target: null,
                _callback: null,
                _ownsAnimationStateData: false,
                _startListener: null,
                _endListener: null,
                _completeListener: null,
                _eventListener: null,
                init: function() {
                    sp.Skeleton.prototype.init.call(this);
                    this._ownsAnimationStateData = true;
                    this.setAnimationStateData(new spine.AnimationStateData(this._skeleton.data));
                },
                setAnimationStateData: function(stateData) {
                    var state = new spine.AnimationState(stateData);
                    state.rendererObject = this;
                    state.onStart = this._onAnimationStateStart.bind(this);
                    state.onComplete = this._onAnimationStateComplete.bind(this);
                    state.onEnd = this._onAnimationStateEnd.bind(this);
                    state.onEvent = this._onAnimationStateEvent.bind(this);
                    this._state = state;
                },
                setMix: function(fromAnimation, toAnimation, duration) {
                    this._state.data.setMixByName(fromAnimation, toAnimation, duration);
                },
                setAnimationListener: function(target, callback) {
                    this._target = target;
                    this._callback = callback;
                },
                setAnimation: function(trackIndex, name, loop) {
                    var animation = this._skeleton.data.findAnimation(name);
                    if (!animation) {
                        cc.log("Spine: Animation not found: " + name);
                        return null;
                    }
                    return this._state.setAnimation(trackIndex, animation, loop);
                },
                addAnimation: function(trackIndex, name, loop, delay) {
                    delay = null == delay ? 0 : delay;
                    var animation = this._skeleton.data.findAnimation(name);
                    if (!animation) {
                        cc.log("Spine: Animation not found:" + name);
                        return null;
                    }
                    return this._state.addAnimation(trackIndex, animation, loop, delay);
                },
                getCurrent: function(trackIndex) {
                    return this._state.getCurrent(trackIndex);
                },
                clearTracks: function() {
                    this._state.clearTracks();
                },
                clearTrack: function(trackIndex) {
                    this._state.clearTrack(trackIndex);
                },
                update: function(dt) {
                    this._super(dt);
                    dt *= this._timeScale;
                    this._state.update(dt);
                    this._state.apply(this._skeleton);
                    this._skeleton.updateWorldTransform();
                    this._renderCmd._updateChild();
                },
                setStartListener: function(listener) {
                    this._startListener = listener;
                },
                setEndListener: function(listener) {
                    this._endListener = listener;
                },
                setCompleteListener: function(listener) {
                    this._completeListener = listener;
                },
                setEventListener: function(listener) {
                    this._eventListener = listener;
                },
                setTrackStartListener: function(entry, listener) {
                    sp.TrackEntryListeners.getListeners(entry).startListener = listener;
                },
                setTrackEndListener: function(entry, listener) {
                    sp.TrackEntryListeners.getListeners(entry).endListener = listener;
                },
                setTrackCompleteListener: function(entry, listener) {
                    sp.TrackEntryListeners.getListeners(entry).completeListener = listener;
                },
                setTrackEventListener: function(entry, listener) {
                    sp.TrackEntryListeners.getListeners(entry).eventListener = listener;
                },
                onTrackEntryEvent: function(traceIndex, type, event, loopCount) {
                    var entry = this._state.getCurrent(traceIndex);
                    if (!entry.rendererObject) {
                        return;
                    }
                    var listeners = entry.rendererObject;
                    switch (type) {
                      case sp.ANIMATION_EVENT_TYPE.START:
                        if (listeners.startListener) {
                            listeners.startListener(traceIndex);
                        }
                        break;

                      case sp.ANIMATION_EVENT_TYPE.END:
                        if (listeners.endListener) {
                            listeners.endListener(traceIndex);
                        }
                        break;

                      case sp.ANIMATION_EVENT_TYPE.COMPLETE:
                        if (listeners.completeListener) {
                            listeners.completeListener(traceIndex, loopCount);
                        }
                        break;

                      case sp.ANIMATION_EVENT_TYPE.EVENT:
                        if (listeners.eventListener) {
                            listeners.eventListener(traceIndex, event);
                        }
                    }
                },
                onAnimationStateEvent: function(trackIndex, type, event, loopCount) {
                    switch (type) {
                      case sp.ANIMATION_EVENT_TYPE.START:
                        if (this._startListener) {
                            this._startListener(trackIndex);
                        }
                        break;

                      case sp.ANIMATION_EVENT_TYPE.END:
                        if (this._endListener) {
                            this._endListener(trackIndex);
                        }
                        break;

                      case sp.ANIMATION_EVENT_TYPE.COMPLETE:
                        if (this._completeListener) {
                            this._completeListener(trackIndex, loopCount);
                        }
                        break;

                      case sp.ANIMATION_EVENT_TYPE.EVENT:
                        if (this._eventListener) {
                            this._eventListener(trackIndex, event);
                        }
                    }
                },
                getState: function() {
                    return this._state;
                },
                _onAnimationStateStart: function(trackIndex) {
                    this._animationStateCallback(trackIndex, sp.ANIMATION_EVENT_TYPE.START, null, 0);
                },
                _onAnimationStateEnd: function(trackIndex) {
                    this._animationStateCallback(trackIndex, sp.ANIMATION_EVENT_TYPE.END, null, 0);
                },
                _onAnimationStateComplete: function(trackIndex, count) {
                    this._animationStateCallback(trackIndex, sp.ANIMATION_EVENT_TYPE.COMPLETE, null, count);
                },
                _onAnimationStateEvent: function(trackIndex, event) {
                    this._animationStateCallback(trackIndex, sp.ANIMATION_EVENT_TYPE.EVENT, event, 0);
                },
                _animationStateCallback: function(trackIndex, type, event, loopCount) {
                    this.onAnimationStateEvent(trackIndex, type, event, loopCount);
                    if (this._target && this._callback) {
                        this._callback.call(this._target, this, trackIndex, type, event, loopCount);
                    }
                }
            });
            sp.SkeletonAnimation.create = function(skeletonDataFile, atlasFile, scale) {
                return new sp.SkeletonAnimation(skeletonDataFile, atlasFile, scale);
            };
            cc.pool = {
                _pool: {},
                _releaseCB: function() {
                    this.release();
                },
                _autoRelease: function(obj) {
                    var running = void 0 === obj._running ? false : !obj._running;
                    cc.director.getScheduler().schedule(this._releaseCB, obj, 0, 0, 0, running);
                },
                putInPool: function(obj) {
                    var cid = cc.js._getClassId(obj.constructor);
                    if (!cid) {
                        return;
                    }
                    if (!this._pool[cid]) {
                        this._pool[cid] = [];
                    }
                    obj.retain && obj.retain();
                    obj.unuse && obj.unuse();
                    this._pool[cid].push(obj);
                },
                hasObject: function(objClass) {
                    var cid = cc.js._getClassId(objClass);
                    var list = this._pool[cid];
                    if (!list || 0 === list.length) {
                        return false;
                    }
                    return true;
                },
                removeObject: function(obj) {
                    var cid = cc.js._getClassId(obj.constructor);
                    if (cid) {
                        var list = this._pool[cid];
                        if (list) {
                            for (var i = 0; i < list.length; i++) {
                                if (obj === list[i]) {
                                    obj.release && obj.release();
                                    list.splice(i, 1);
                                }
                            }
                        }
                    }
                },
                getFromPool: function(objClass) {
                    if (this.hasObject(objClass)) {
                        var cid = cc.js._getClassId(objClass);
                        var list = this._pool[cid];
                        var args = Array.prototype.slice.call(arguments);
                        args.shift();
                        var obj = list.pop();
                        obj.reuse && obj.reuse.apply(obj, args);
                        cc.sys.isNative && obj.release && this._autoRelease(obj);
                        return obj;
                    }
                },
                drainAllPools: function() {
                    for (var i in this._pool) {
                        for (var j = 0; j < this._pool[i].length; j++) {
                            var obj = this._pool[i][j];
                            obj.release && obj.release();
                        }
                    }
                    this._pool = {};
                }
            };
            cc.__convertVerts = function(verts) {
                var ret = [];
                for (var i = 0; i < verts.length / 2; i++) {
                    ret[i] = {
                        x: verts[2 * i],
                        y: verts[2 * i + 1]
                    };
                }
                return ret;
            };
            cc.ColorForBody = function(body) {
                if (body.isRogue() || body.isSleeping()) {
                    return cc.color(128, 128, 128, 128);
                } else {
                    if (body.nodeIdleTime > body.space.sleepTimeThreshold) {
                        return cc.color(84, 84, 84, 128);
                    } else {
                        return cc.color(255, 0, 0, 128);
                    }
                }
            };
            cc.DrawShape = function(shape, renderer) {
                var body = shape.body;
                var color = cc.ColorForBody(body);
                switch (shape.collisionCode) {
                  case cp.CircleShape.prototype.collisionCode:
                    this.drawDot(shape.tc, Math.max(shape.r, 1), color);
                    this.drawSegment(shape.tc, cp.v.add(shape.tc, cp.v.mult(body.rot, shape.r)), 1, color);
                    break;

                  case cp.SegmentShape.prototype.collisionCode:
                    this.drawSegment(shape.ta, shape.tb, Math.max(shape.r, 2), color);
                    break;

                  case cp.PolyShape.prototype.collisionCode:
                    var line = cc.color(color.r, color.g, color.b, cc.lerp(color.a, 255, .5));
                    this.drawPoly(cc.__convertVerts(shape.tVerts), color, 1, line);
                    break;

                  default:
                    cc.log("cc.DrawShape(): Bad assertion in DrawShape()");
                }
            };
            cc.DrawConstraint = function(constraint, renderer) {
                var body_a = constraint.a;
                var body_b = constraint.b;
                var a, b;
                if (constraint instanceof cp.PinJoint) {
                    a = body_a.local2World(constraint.anchr1);
                    b = body_b.local2World(constraint.anchr2);
                    this.drawDot(a, 3, cc.CONSTRAINT_COLOR);
                    this.drawDot(b, 3, cc.CONSTRAINT_COLOR);
                    this.drawSegment(a, b, 1, cc.CONSTRAINT_COLOR);
                } else {
                    if (constraint instanceof cp.SlideJoint) {
                        a = body_a.local2World(constraint.anchr1);
                        b = body_b.local2World(constraint.anchr2);
                        this.drawDot(a, 3, cc.CONSTRAINT_COLOR);
                        this.drawDot(b, 3, cc.CONSTRAINT_COLOR);
                        this.drawSegment(a, b, 1, cc.CONSTRAINT_COLOR);
                    } else {
                        if (constraint instanceof cp.PivotJoint) {
                            a = body_a.local2World(constraint.anchr1);
                            b = body_b.local2World(constraint.anchr2);
                            this.drawDot(a, 3, cc.CONSTRAINT_COLOR);
                            this.drawDot(b, 3, cc.CONSTRAINT_COLOR);
                        } else {
                            if (constraint instanceof cp.GrooveJoint) {
                                a = body_a.local2World(constraint.grv_a);
                                b = body_a.local2World(constraint.grv_b);
                                var c = body_b.local2World(constraint.anchr2);
                                this.drawDot(c, 3, cc.CONSTRAINT_COLOR);
                                this.drawSegment(a, b, 1, cc.CONSTRAINT_COLOR);
                            } else {
                                if (constraint instanceof cp.DampedSpring) {
                                    ;
                                } else {}
                            }
                        }
                    }
                }
            };
            cc.CONSTRAINT_COLOR = cc.color(0, 255, 0, 128);
            cc.PhysicsDebugNode = cc.DrawNode.extend({
                _space: null,
                _className: "PhysicsDebugNode",
                ctor: function(space) {
                    cc.DrawNode.prototype.ctor.call(this);
                    this._space = space;
                },
                getSpace: function() {
                    return this._space;
                },
                setSpace: function(space) {
                    this._space = space;
                },
                draw: function(context) {
                    if (!this._space) {
                        return;
                    }
                    this._space.eachShape(cc.DrawShape.bind(this));
                    this._space.eachConstraint(cc.DrawConstraint.bind(this));
                    cc.DrawNode.prototype.draw.call(this);
                    this.clear();
                },
                _createRenderCmd: function() {
                    if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                        return new cc.PhysicsDebugNode.CanvasRenderCmd(this);
                    } else {
                        return new cc.PhysicsDebugNode.WebGLRenderCmd(this);
                    }
                }
            });
            cc.PhysicsDebugNode.create = function(space) {
                return new cc.PhysicsDebugNode(space);
            };
            !function() {
                cc.PhysicsDebugNode.CanvasRenderCmd = function(renderableObject) {
                    _ccsg.Node.CanvasRenderCmd.call(this, renderableObject);
                    this._buffer = renderableObject._buffer;
                    this._needDraw = true;
                };
                var proto = cc.PhysicsDebugNode.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
                proto.constructor = cc.PhysicsDebugNode.CanvasRenderCmd;
                proto.rendering = function(ctx, scaleX, scaleY) {
                    var node = this._node;
                    if (!node._space) {
                        return;
                    }
                    node._space.eachShape(cc.DrawShape.bind(node));
                    node._space.eachConstraint(cc.DrawConstraint.bind(node));
                    cc.DrawNode.CanvasRenderCmd.prototype.rendering.call(this, ctx, scaleX, scaleY);
                    node.clear();
                };
                proto._drawDot = cc.DrawNode.CanvasRenderCmd.prototype._drawDot;
                proto._drawSegment = cc.DrawNode.CanvasRenderCmd.prototype._drawSegment;
                proto._drawPoly = cc.DrawNode.CanvasRenderCmd.prototype._drawPoly;
            }();
            !function() {
                cc.PhysicsDebugNode.WebGLRenderCmd = function(renderableObject) {
                    _ccsg.Node.WebGLRenderCmd.call(this, renderableObject);
                    this._needDraw = true;
                };
                cc.PhysicsDebugNode.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
                cc.PhysicsDebugNode.WebGLRenderCmd.prototype.constructor = cc.PhysicsDebugNode.WebGLRenderCmd;
                cc.PhysicsDebugNode.WebGLRenderCmd.prototype.rendering = function(ctx) {
                    var node = this._node;
                    if (!node._space) {
                        return;
                    }
                    node._space.eachShape(cc.DrawShape.bind(node));
                    node._space.eachConstraint(cc.DrawConstraint.bind(node));
                    cc.glBlendFunc(node._blendFunc.src, node._blendFunc.dst);
                    this._shaderProgram.use();
                    this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
                    node._render();
                    node.clear();
                };
            }();
            !function() {
                Object.create = Object.create || function(o) {
                    function F() {}
                    F.prototype = o;
                    return new F();
                };
                var assert = function(value, message) {
                    if (!value) {
                        throw new Error("Assertion failed: " + message);
                    }
                };
                var assertSoft = function(value, message) {
                    if (!value && console && console.warn) {
                        console.warn("ASSERTION FAILED: " + message);
                        if (console.trace) {
                            console.trace();
                        }
                    }
                };
                var mymin = function(a, b) {
                    return a < b ? a : b;
                };
                var mymax = function(a, b) {
                    return a > b ? a : b;
                };
                var min, max;
                if ("object" === typeof window && window.navigator.userAgent.indexOf("Firefox") > -1) {
                    min = Math.min;
                    max = Math.max;
                } else {
                    min = mymin;
                    max = mymax;
                }
                var hashPair = function(a, b) {
                    return a < b ? a + " " + b : b + " " + a;
                };
                var deleteObjFromList = function(arr, obj) {
                    for (var i = 0; i < arr.length; i++) {
                        if (arr[i] === obj) {
                            arr[i] = arr[arr.length - 1];
                            arr.length--;
                            return;
                        }
                    }
                };
                var closestPointOnSegment = function(p, a, b) {
                    var delta = vsub(a, b);
                    var t = clamp01(vdot(delta, vsub(p, b)) / vlengthsq(delta));
                    return vadd(b, vmult(delta, t));
                };
                var closestPointOnSegment2 = function(px, py, ax, ay, bx, by) {
                    var deltax = ax - bx;
                    var deltay = ay - by;
                    var t = clamp01(vdot2(deltax, deltay, px - bx, py - by) / vlengthsq2(deltax, deltay));
                    return new Vect(bx + deltax * t, by + deltay * t);
                };
                cp.momentForCircle = function(m, r1, r2, offset) {
                    return m * (.5 * (r1 * r1 + r2 * r2) + vlengthsq(offset));
                };
                cp.areaForCircle = function(r1, r2) {
                    return Math.PI * Math.abs(r1 * r1 - r2 * r2);
                };
                cp.momentForSegment = function(m, a, b) {
                    var offset = vmult(vadd(a, b), .5);
                    return m * (vdistsq(b, a) / 12 + vlengthsq(offset));
                };
                cp.areaForSegment = function(a, b, r) {
                    return r * (Math.PI * r + 2 * vdist(a, b));
                };
                cp.momentForPoly = function(m, verts, offset) {
                    var sum1 = 0;
                    var sum2 = 0;
                    var len = verts.length;
                    for (var i = 0; i < len; i += 2) {
                        var v1x = verts[i] + offset.x;
                        var v1y = verts[i + 1] + offset.y;
                        var v2x = verts[(i + 2) % len] + offset.x;
                        var v2y = verts[(i + 3) % len] + offset.y;
                        var a = vcross2(v2x, v2y, v1x, v1y);
                        var b = vdot2(v1x, v1y, v1x, v1y) + vdot2(v1x, v1y, v2x, v2y) + vdot2(v2x, v2y, v2x, v2y);
                        sum1 += a * b;
                        sum2 += a;
                    }
                    return m * sum1 / (6 * sum2);
                };
                cp.areaForPoly = function(verts) {
                    var area = 0;
                    for (var i = 0, len = verts.length; i < len; i += 2) {
                        area += vcross(new Vect(verts[i], verts[i + 1]), new Vect(verts[(i + 2) % len], verts[(i + 3) % len]));
                    }
                    return -area / 2;
                };
                cp.centroidForPoly = function(verts) {
                    var sum = 0;
                    var vsum = new Vect(0, 0);
                    for (var i = 0, len = verts.length; i < len; i += 2) {
                        var v1 = new Vect(verts[i], verts[i + 1]);
                        var v2 = new Vect(verts[(i + 2) % len], verts[(i + 3) % len]);
                        var cross = vcross(v1, v2);
                        sum += cross;
                        vsum = vadd(vsum, vmult(vadd(v1, v2), cross));
                    }
                    return vmult(vsum, 1 / (3 * sum));
                };
                cp.recenterPoly = function(verts) {
                    var centroid = cp.centroidForPoly(verts);
                    for (var i = 0; i < verts.length; i += 2) {
                        verts[i] -= centroid.x;
                        verts[i + 1] -= centroid.y;
                    }
                };
                cp.momentForBox = function(m, width, height) {
                    return m * (width * width + height * height) / 12;
                };
                cp.momentForBox2 = function(m, box) {
                    var width = box.r - box.l;
                    var height = box.t - box.b;
                    var offset = vmult([ box.l + box.r, box.b + box.t ], .5);
                    return cp.momentForBox(m, width, height) + m * vlengthsq(offset);
                };
                var loopIndexes = cp.loopIndexes = function(verts) {
                    var start = 0, end = 0;
                    var minx, miny, maxx, maxy;
                    minx = maxx = verts[0];
                    miny = maxy = verts[1];
                    var count = verts.length >> 1;
                    for (var i = 1; i < count; i++) {
                        var x = verts[2 * i];
                        var y = verts[2 * i + 1];
                        if (x < minx || x == minx && y < miny) {
                            minx = x;
                            miny = y;
                            start = i;
                        } else {
                            if (x > maxx || x == maxx && y > maxy) {
                                maxx = x;
                                maxy = y;
                                end = i;
                            }
                        }
                    }
                    return [ start, end ];
                };
                var SWAP = function(arr, idx1, idx2) {
                    var tmp = arr[2 * idx1];
                    arr[2 * idx1] = arr[2 * idx2];
                    arr[2 * idx2] = tmp;
                    tmp = arr[2 * idx1 + 1];
                    arr[2 * idx1 + 1] = arr[2 * idx2 + 1];
                    arr[2 * idx2 + 1] = tmp;
                };
                var QHullPartition = function(verts, offs, count, a, b, tol) {
                    if (0 === count) {
                        return 0;
                    }
                    var max = 0;
                    var pivot = offs;
                    var delta = vsub(b, a);
                    var valueTol = tol * vlength(delta);
                    var head = offs;
                    for (var tail = offs + count - 1; head <= tail; ) {
                        var v = new Vect(verts[2 * head], verts[2 * head + 1]);
                        var value = vcross(delta, vsub(v, a));
                        if (value > valueTol) {
                            if (value > max) {
                                max = value;
                                pivot = head;
                            }
                            head++;
                        } else {
                            SWAP(verts, head, tail);
                            tail--;
                        }
                    }
                    if (pivot != offs) {
                        SWAP(verts, offs, pivot);
                    }
                    return head - offs;
                };
                var QHullReduce = function(tol, verts, offs, count, a, pivot, b, resultPos) {
                    if (count < 0) {
                        return 0;
                    } else {
                        if (0 == count) {
                            verts[2 * resultPos] = pivot.x;
                            verts[2 * resultPos + 1] = pivot.y;
                            return 1;
                        } else {
                            var left_count = QHullPartition(verts, offs, count, a, pivot, tol);
                            var left = new Vect(verts[2 * offs], verts[2 * offs + 1]);
                            var index = QHullReduce(tol, verts, offs + 1, left_count - 1, a, left, pivot, resultPos);
                            var pivotPos = resultPos + index++;
                            verts[2 * pivotPos] = pivot.x;
                            verts[2 * pivotPos + 1] = pivot.y;
                            var right_count = QHullPartition(verts, offs + left_count, count - left_count, pivot, b, tol);
                            var right = new Vect(verts[2 * (offs + left_count)], verts[2 * (offs + left_count) + 1]);
                            return index + QHullReduce(tol, verts, offs + left_count + 1, right_count - 1, pivot, right, b, resultPos + index);
                        }
                    }
                };
                cp.convexHull = function(verts, result, tolerance) {
                    if (result) {
                        for (var i = 0; i < verts.length; i++) {
                            result[i] = verts[i];
                        }
                    } else {
                        result = verts;
                    }
                    var indexes = loopIndexes(verts);
                    var start = indexes[0], end = indexes[1];
                    if (start == end) {
                        result.length = 2;
                        return result;
                    }
                    SWAP(result, 0, start);
                    SWAP(result, 1, 0 == end ? start : end);
                    var a = new Vect(result[0], result[1]);
                    var b = new Vect(result[2], result[3]);
                    var count = verts.length >> 1;
                    var resultCount = QHullReduce(tolerance, result, 2, count - 2, a, b, a, 1) + 1;
                    result.length = 2 * resultCount;
                    assertSoft(polyValidate(result), "Internal error: cpConvexHull() and cpPolyValidate() did not agree.Please report this error with as much info as you can.");
                    return result;
                };
                var clamp = function(f, minv, maxv) {
                    return min(max(f, minv), maxv);
                };
                var clamp01 = function(f) {
                    return max(0, min(f, 1));
                };
                var lerp = function(f1, f2, t) {
                    return f1 * (1 - t) + f2 * t;
                };
                var lerpconst = function(f1, f2, d) {
                    return f1 + clamp(f2 - f1, -d, d);
                };
                var Vect = cp.Vect = function(x, y) {
                    this.x = x;
                    this.y = y;
                };
                cp.v = function(x, y) {
                    return new Vect(x, y);
                };
                var vzero = cp.vzero = new Vect(0, 0);
                var vdot = cp.v.dot = function(v1, v2) {
                    return v1.x * v2.x + v1.y * v2.y;
                };
                var vdot2 = function(x1, y1, x2, y2) {
                    return x1 * x2 + y1 * y2;
                };
                var vlength = cp.v.len = function(v) {
                    return Math.sqrt(vdot(v, v));
                };
                var vlength2 = cp.v.len2 = function(x, y) {
                    return Math.sqrt(x * x + y * y);
                };
                var veql = cp.v.eql = function(v1, v2) {
                    return v1.x === v2.x && v1.y === v2.y;
                };
                var vadd = cp.v.add = function(v1, v2) {
                    return new Vect(v1.x + v2.x, v1.y + v2.y);
                };
                Vect.prototype.add = function(v2) {
                    this.x += v2.x;
                    this.y += v2.y;
                    return this;
                };
                var vsub = cp.v.sub = function(v1, v2) {
                    return new Vect(v1.x - v2.x, v1.y - v2.y);
                };
                Vect.prototype.sub = function(v2) {
                    this.x -= v2.x;
                    this.y -= v2.y;
                    return this;
                };
                var vneg = cp.v.neg = function(v) {
                    return new Vect(-v.x, -v.y);
                };
                Vect.prototype.neg = function() {
                    this.x = -this.x;
                    this.y = -this.y;
                    return this;
                };
                var vmult = cp.v.mult = function(v, s) {
                    return new Vect(v.x * s, v.y * s);
                };
                Vect.prototype.mult = function(s) {
                    this.x *= s;
                    this.y *= s;
                    return this;
                };
                var vcross = cp.v.cross = function(v1, v2) {
                    return v1.x * v2.y - v1.y * v2.x;
                };
                var vcross2 = function(x1, y1, x2, y2) {
                    return x1 * y2 - y1 * x2;
                };
                var vperp = cp.v.perp = function(v) {
                    return new Vect(-v.y, v.x);
                };
                var vpvrperp = cp.v.pvrperp = function(v) {
                    return new Vect(v.y, -v.x);
                };
                var vproject = cp.v.project = function(v1, v2) {
                    return vmult(v2, vdot(v1, v2) / vlengthsq(v2));
                };
                Vect.prototype.project = function(v2) {
                    this.mult(vdot(this, v2) / vlengthsq(v2));
                    return this;
                };
                var vrotate = cp.v.rotate = function(v1, v2) {
                    return new Vect(v1.x * v2.x - v1.y * v2.y, v1.x * v2.y + v1.y * v2.x);
                };
                Vect.prototype.rotate = function(v2) {
                    this.x = this.x * v2.x - this.y * v2.y;
                    this.y = this.x * v2.y + this.y * v2.x;
                    return this;
                };
                var vunrotate = cp.v.unrotate = function(v1, v2) {
                    return new Vect(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y);
                };
                var vlengthsq = cp.v.lengthsq = function(v) {
                    return vdot(v, v);
                };
                var vlengthsq2 = cp.v.lengthsq2 = function(x, y) {
                    return x * x + y * y;
                };
                var vlerp = cp.v.lerp = function(v1, v2, t) {
                    return vadd(vmult(v1, 1 - t), vmult(v2, t));
                };
                var vnormalize = cp.v.normalize = function(v) {
                    return vmult(v, 1 / vlength(v));
                };
                var vnormalize_safe = cp.v.normalize_safe = function(v) {
                    return 0 === v.x && 0 === v.y ? vzero : vnormalize(v);
                };
                var vclamp = cp.v.clamp = function(v, len) {
                    return vdot(v, v) > len * len ? vmult(vnormalize(v), len) : v;
                };
                var vlerpconst = cp.v.lerpconst = function(v1, v2, d) {
                    return vadd(v1, vclamp(vsub(v2, v1), d));
                };
                var vdist = cp.v.dist = function(v1, v2) {
                    return vlength(vsub(v1, v2));
                };
                var vdistsq = cp.v.distsq = function(v1, v2) {
                    return vlengthsq(vsub(v1, v2));
                };
                var vnear = cp.v.near = function(v1, v2, dist) {
                    return vdistsq(v1, v2) < dist * dist;
                };
                var vslerp = cp.v.slerp = function(v1, v2, t) {
                    var omega = Math.acos(vdot(v1, v2));
                    if (omega) {
                        var denom = 1 / Math.sin(omega);
                        return vadd(vmult(v1, Math.sin((1 - t) * omega) * denom), vmult(v2, Math.sin(t * omega) * denom));
                    } else {
                        return v1;
                    }
                };
                var vslerpconst = cp.v.slerpconst = function(v1, v2, a) {
                    var angle = Math.acos(vdot(v1, v2));
                    return vslerp(v1, v2, min(a, angle) / angle);
                };
                var vforangle = cp.v.forangle = function(a) {
                    return new Vect(Math.cos(a), Math.sin(a));
                };
                var vtoangle = cp.v.toangle = function(v) {
                    return Math.atan2(v.y, v.x);
                };
                var vstr = cp.v.str = function(v) {
                    return "(" + v.x.toFixed(3) + ", " + v.y.toFixed(3) + ")";
                };
                var numBB = 0;
                var BB = cp.BB = function(l, b, r, t) {
                    this.l = l;
                    this.b = b;
                    this.r = r;
                    this.t = t;
                    numBB++;
                };
                cp.bb = function(l, b, r, t) {
                    return new BB(l, b, r, t);
                };
                var bbNewForCircle = function(p, r) {
                    return new BB(p.x - r, p.y - r, p.x + r, p.y + r);
                };
                var bbIntersects = function(a, b) {
                    return a.l <= b.r && b.l <= a.r && a.b <= b.t && b.b <= a.t;
                };
                var bbIntersects2 = function(bb, l, b, r, t) {
                    return bb.l <= r && l <= bb.r && bb.b <= t && b <= bb.t;
                };
                var bbContainsBB = function(bb, other) {
                    return bb.l <= other.l && bb.r >= other.r && bb.b <= other.b && bb.t >= other.t;
                };
                var bbContainsVect = function(bb, v) {
                    return bb.l <= v.x && bb.r >= v.x && bb.b <= v.y && bb.t >= v.y;
                };
                var bbContainsVect2 = function(l, b, r, t, v) {
                    return l <= v.x && r >= v.x && b <= v.y && t >= v.y;
                };
                var bbMerge = function(a, b) {
                    return new BB(min(a.l, b.l), min(a.b, b.b), max(a.r, b.r), max(a.t, b.t));
                };
                var bbExpand = function(bb, v) {
                    return new BB(min(bb.l, v.x), min(bb.b, v.y), max(bb.r, v.x), max(bb.t, v.y));
                };
                var bbArea = function(bb) {
                    return (bb.r - bb.l) * (bb.t - bb.b);
                };
                var bbMergedArea = function(a, b) {
                    return (max(a.r, b.r) - min(a.l, b.l)) * (max(a.t, b.t) - min(a.b, b.b));
                };
                var bbMergedArea2 = function(bb, l, b, r, t) {
                    return (max(bb.r, r) - min(bb.l, l)) * (max(bb.t, t) - min(bb.b, b));
                };
                var bbIntersectsSegment = function(bb, a, b) {
                    return bbSegmentQuery(bb, a, b) != 1 / 0;
                };
                var bbClampVect = function(bb, v) {
                    var x = min(max(bb.l, v.x), bb.r);
                    var y = min(max(bb.b, v.y), bb.t);
                    return new Vect(x, y);
                };
                var bbWrapVect = function(bb, v) {
                    var ix = Math.abs(bb.r - bb.l);
                    var modx = (v.x - bb.l) % ix;
                    var x = modx > 0 ? modx : modx + ix;
                    var iy = Math.abs(bb.t - bb.b);
                    var mody = (v.y - bb.b) % iy;
                    var y = mody > 0 ? mody : mody + iy;
                    return new Vect(x + bb.l, y + bb.b);
                };
                var shapeIDCounter = 0;
                var CP_NO_GROUP = cp.NO_GROUP = 0;
                var CP_ALL_LAYERS = cp.ALL_LAYERS = -1;
                cp.resetShapeIdCounter = function() {
                    shapeIDCounter = 0;
                };
                var Shape = cp.Shape = function(body) {
                    this.body = body;
                    this.bb_l = this.bb_b = this.bb_r = this.bb_t = 0;
                    this.hashid = shapeIDCounter++;
                    this.sensor = false;
                    this.e = 0;
                    this.u = 0;
                    this.surface_v = vzero;
                    this.collision_type = 0;
                    this.group = 0;
                    this.layers = CP_ALL_LAYERS;
                    this.space = null;
                    this.collisionCode = this.collisionCode;
                };
                Shape.prototype.setElasticity = function(e) {
                    this.e = e;
                };
                Shape.prototype.setFriction = function(u) {
                    this.body.activate();
                    this.u = u;
                };
                Shape.prototype.setLayers = function(layers) {
                    this.body.activate();
                    this.layers = layers;
                };
                Shape.prototype.setSensor = function(sensor) {
                    this.body.activate();
                    this.sensor = sensor;
                };
                Shape.prototype.setCollisionType = function(collision_type) {
                    this.body.activate();
                    this.collision_type = collision_type;
                };
                Shape.prototype.getBody = function() {
                    return this.body;
                };
                Shape.prototype.active = function() {
                    return this.body && -1 !== this.body.shapeList.indexOf(this);
                };
                Shape.prototype.setBody = function(body) {
                    assert(!this.active(), "You cannot change the body on an active shape. You must remove the shape from the space before changing the body.");
                    this.body = body;
                };
                Shape.prototype.cacheBB = function() {
                    return this.update(this.body.p, this.body.rot);
                };
                Shape.prototype.update = function(pos, rot) {
                    assert(!isNaN(rot.x), "Rotation is NaN");
                    assert(!isNaN(pos.x), "Position is NaN");
                    this.cacheData(pos, rot);
                };
                Shape.prototype.pointQuery = function(p) {
                    var info = this.nearestPointQuery(p);
                    if (info.d < 0) {
                        return info;
                    }
                };
                Shape.prototype.getBB = function() {
                    return new BB(this.bb_l, this.bb_b, this.bb_r, this.bb_t);
                };
                var PointQueryExtendedInfo = function(shape) {
                    this.shape = shape;
                    this.d = 1 / 0;
                    this.n = vzero;
                };
                var NearestPointQueryInfo = function(shape, p, d) {
                    this.shape = shape;
                    this.p = p;
                    this.d = d;
                };
                var SegmentQueryInfo = function(shape, t, n) {
                    this.shape = shape;
                    this.t = t;
                    this.n = n;
                };
                SegmentQueryInfo.prototype.hitPoint = function(start, end) {
                    return vlerp(start, end, this.t);
                };
                SegmentQueryInfo.prototype.hitDist = function(start, end) {
                    return vdist(start, end) * this.t;
                };
                var CircleShape = cp.CircleShape = function(body, radius, offset) {
                    this.c = this.tc = offset;
                    this.r = radius;
                    this.type = "circle";
                    Shape.call(this, body);
                };
                CircleShape.prototype = Object.create(Shape.prototype);
                CircleShape.prototype.cacheData = function(p, rot) {
                    var c = this.tc = vrotate(this.c, rot).add(p);
                    var r = this.r;
                    this.bb_l = c.x - r;
                    this.bb_b = c.y - r;
                    this.bb_r = c.x + r;
                    this.bb_t = c.y + r;
                };
                CircleShape.prototype.nearestPointQuery = function(p) {
                    var deltax = p.x - this.tc.x;
                    var deltay = p.y - this.tc.y;
                    var d = vlength2(deltax, deltay);
                    var r = this.r;
                    var nearestp = new Vect(this.tc.x + deltax * r / d, this.tc.y + deltay * r / d);
                    return new NearestPointQueryInfo(this, nearestp, d - r);
                };
                var circleSegmentQuery = function(shape, center, r, a, b, info) {
                    a = vsub(a, center);
                    b = vsub(b, center);
                    var qa = vdot(a, a) - 2 * vdot(a, b) + vdot(b, b);
                    var qb = -2 * vdot(a, a) + 2 * vdot(a, b);
                    var qc = vdot(a, a) - r * r;
                    var det = qb * qb - 4 * qa * qc;
                    if (det >= 0) {
                        var t = (-qb - Math.sqrt(det)) / (2 * qa);
                        if (0 <= t && t <= 1) {
                            return new SegmentQueryInfo(shape, t, vnormalize(vlerp(a, b, t)));
                        }
                    }
                };
                CircleShape.prototype.segmentQuery = function(a, b) {
                    return circleSegmentQuery(this, this.tc, this.r, a, b);
                };
                var SegmentShape = cp.SegmentShape = function(body, a, b, r) {
                    this.a = a;
                    this.b = b;
                    this.n = vperp(vnormalize(vsub(b, a)));
                    this.ta = this.tb = this.tn = null;
                    this.r = r;
                    this.a_tangent = vzero;
                    this.b_tangent = vzero;
                    this.type = "segment";
                    Shape.call(this, body);
                };
                SegmentShape.prototype = Object.create(Shape.prototype);
                SegmentShape.prototype.cacheData = function(p, rot) {
                    this.ta = vadd(p, vrotate(this.a, rot));
                    this.tb = vadd(p, vrotate(this.b, rot));
                    this.tn = vrotate(this.n, rot);
                    var l, r, b, t;
                    if (this.ta.x < this.tb.x) {
                        l = this.ta.x;
                        r = this.tb.x;
                    } else {
                        l = this.tb.x;
                        r = this.ta.x;
                    }
                    if (this.ta.y < this.tb.y) {
                        b = this.ta.y;
                        t = this.tb.y;
                    } else {
                        b = this.tb.y;
                        t = this.ta.y;
                    }
                    var rad = this.r;
                    this.bb_l = l - rad;
                    this.bb_b = b - rad;
                    this.bb_r = r + rad;
                    this.bb_t = t + rad;
                };
                SegmentShape.prototype.nearestPointQuery = function(p) {
                    var closest = closestPointOnSegment(p, this.ta, this.tb);
                    var deltax = p.x - closest.x;
                    var deltay = p.y - closest.y;
                    var d = vlength2(deltax, deltay);
                    var r = this.r;
                    var nearestp = d ? vadd(closest, vmult(new Vect(deltax, deltay), r / d)) : closest;
                    return new NearestPointQueryInfo(this, nearestp, d - r);
                };
                SegmentShape.prototype.segmentQuery = function(a, b) {
                    var n = this.tn;
                    var d = vdot(vsub(this.ta, a), n);
                    var r = this.r;
                    var flipped_n = d > 0 ? vneg(n) : n;
                    var n_offset = vsub(vmult(flipped_n, r), a);
                    var seg_a = vadd(this.ta, n_offset);
                    var seg_b = vadd(this.tb, n_offset);
                    var delta = vsub(b, a);
                    if (vcross(delta, seg_a) * vcross(delta, seg_b) <= 0) {
                        var d_offset = d + (d > 0 ? -r : r);
                        var ad = -d_offset;
                        var bd = vdot(delta, n) - d_offset;
                        if (ad * bd < 0) {
                            return new SegmentQueryInfo(this, ad / (ad - bd), flipped_n);
                        }
                    } else {
                        if (0 !== r) {
                            var info1 = circleSegmentQuery(this, this.ta, this.r, a, b);
                            var info2 = circleSegmentQuery(this, this.tb, this.r, a, b);
                            if (info1) {
                                return info2 && info2.t < info1.t ? info2 : info1;
                            } else {
                                return info2;
                            }
                        }
                    }
                };
                SegmentShape.prototype.setNeighbors = function(prev, next) {
                    this.a_tangent = vsub(prev, this.a);
                    this.b_tangent = vsub(next, this.b);
                };
                SegmentShape.prototype.setEndpoints = function(a, b) {
                    this.a = a;
                    this.b = b;
                    this.n = vperp(vnormalize(vsub(b, a)));
                };
                var polyValidate = function(verts) {
                    var len = verts.length;
                    for (var i = 0; i < len; i += 2) {
                        var ax = verts[i];
                        var ay = verts[i + 1];
                        var bx = verts[(i + 2) % len];
                        var by = verts[(i + 3) % len];
                        var cx = verts[(i + 4) % len];
                        var cy = verts[(i + 5) % len];
                        if (vcross2(bx - ax, by - ay, cx - bx, cy - by) > 0) {
                            return false;
                        }
                    }
                    return true;
                };
                var PolyShape = cp.PolyShape = function(body, verts, offset) {
                    this.setVerts(verts, offset);
                    this.type = "poly";
                    Shape.call(this, body);
                };
                PolyShape.prototype = Object.create(Shape.prototype);
                var SplittingPlane = function(n, d) {
                    this.n = n;
                    this.d = d;
                };
                SplittingPlane.prototype.compare = function(v) {
                    return vdot(this.n, v) - this.d;
                };
                PolyShape.prototype.setVerts = function(verts, offset) {
                    assert(verts.length >= 4, "Polygons require some verts");
                    assert("number" === typeof verts[0], "Polygon verticies should be specified in a flattened list (eg [x1,y1,x2,y2,x3,y3,...])");
                    assert(polyValidate(verts), "Polygon is concave or has a reversed winding. Consider using cpConvexHull()");
                    var len = verts.length;
                    var numVerts = len >> 1;
                    this.verts = new Array(len);
                    this.tVerts = new Array(len);
                    this.planes = new Array(numVerts);
                    this.tPlanes = new Array(numVerts);
                    for (var i = 0; i < len; i += 2) {
                        var ax = verts[i] + offset.x;
                        var ay = verts[i + 1] + offset.y;
                        var bx = verts[(i + 2) % len] + offset.x;
                        var by = verts[(i + 3) % len] + offset.y;
                        var n = vnormalize(vperp(new Vect(bx - ax, by - ay)));
                        this.verts[i] = ax;
                        this.verts[i + 1] = ay;
                        this.planes[i >> 1] = new SplittingPlane(n, vdot2(n.x, n.y, ax, ay));
                        this.tPlanes[i >> 1] = new SplittingPlane(new Vect(0, 0), 0);
                    }
                };
                var BoxShape = cp.BoxShape = function(body, width, height) {
                    var hw = width / 2;
                    var hh = height / 2;
                    return BoxShape2(body, new BB(-hw, -hh, hw, hh));
                };
                var BoxShape2 = cp.BoxShape2 = function(body, box) {
                    var verts = [ box.l, box.b, box.l, box.t, box.r, box.t, box.r, box.b ];
                    return new PolyShape(body, verts, vzero);
                };
                PolyShape.prototype.transformVerts = function(p, rot) {
                    var src = this.verts;
                    var dst = this.tVerts;
                    var l = 1 / 0, r = -(1 / 0);
                    var b = 1 / 0, t = -(1 / 0);
                    for (var i = 0; i < src.length; i += 2) {
                        var x = src[i];
                        var y = src[i + 1];
                        var vx = p.x + x * rot.x - y * rot.y;
                        var vy = p.y + x * rot.y + y * rot.x;
                        dst[i] = vx;
                        dst[i + 1] = vy;
                        l = min(l, vx);
                        r = max(r, vx);
                        b = min(b, vy);
                        t = max(t, vy);
                    }
                    this.bb_l = l;
                    this.bb_b = b;
                    this.bb_r = r;
                    this.bb_t = t;
                };
                PolyShape.prototype.transformAxes = function(p, rot) {
                    var src = this.planes;
                    var dst = this.tPlanes;
                    for (var i = 0; i < src.length; i++) {
                        var n = vrotate(src[i].n, rot);
                        dst[i].n = n;
                        dst[i].d = vdot(p, n) + src[i].d;
                    }
                };
                PolyShape.prototype.cacheData = function(p, rot) {
                    this.transformAxes(p, rot);
                    this.transformVerts(p, rot);
                };
                PolyShape.prototype.nearestPointQuery = function(p) {
                    var planes = this.tPlanes;
                    var verts = this.tVerts;
                    var v0x = verts[verts.length - 2];
                    var v0y = verts[verts.length - 1];
                    var minDist = 1 / 0;
                    var closestPoint = vzero;
                    var outside = false;
                    for (var i = 0; i < planes.length; i++) {
                        if (planes[i].compare(p) > 0) {
                            outside = true;
                        }
                        var v1x = verts[2 * i];
                        var v1y = verts[2 * i + 1];
                        var closest = closestPointOnSegment2(p.x, p.y, v0x, v0y, v1x, v1y);
                        var dist = vdist(p, closest);
                        if (dist < minDist) {
                            minDist = dist;
                            closestPoint = closest;
                        }
                        v0x = v1x;
                        v0y = v1y;
                    }
                    return new NearestPointQueryInfo(this, closestPoint, outside ? minDist : -minDist);
                };
                PolyShape.prototype.segmentQuery = function(a, b) {
                    var axes = this.tPlanes;
                    var verts = this.tVerts;
                    var numVerts = axes.length;
                    var len = 2 * numVerts;
                    for (var i = 0; i < numVerts; i++) {
                        var n = axes[i].n;
                        var an = vdot(a, n);
                        if (axes[i].d > an) {
                            continue;
                        }
                        var bn = vdot(b, n);
                        var t = (axes[i].d - an) / (bn - an);
                        if (t < 0 || 1 < t) {
                            continue;
                        }
                        var point = vlerp(a, b, t);
                        var dt = -vcross(n, point);
                        var dtMin = -vcross2(n.x, n.y, verts[2 * i], verts[2 * i + 1]);
                        var dtMax = -vcross2(n.x, n.y, verts[(2 * i + 2) % len], verts[(2 * i + 3) % len]);
                        if (dtMin <= dt && dt <= dtMax) {
                            return new SegmentQueryInfo(this, t, n);
                        }
                    }
                };
                PolyShape.prototype.valueOnAxis = function(n, d) {
                    var verts = this.tVerts;
                    var m = vdot2(n.x, n.y, verts[0], verts[1]);
                    for (var i = 2; i < verts.length; i += 2) {
                        m = min(m, vdot2(n.x, n.y, verts[i], verts[i + 1]));
                    }
                    return m - d;
                };
                PolyShape.prototype.containsVert = function(vx, vy) {
                    var planes = this.tPlanes;
                    for (var i = 0; i < planes.length; i++) {
                        var n = planes[i].n;
                        var dist = vdot2(n.x, n.y, vx, vy) - planes[i].d;
                        if (dist > 0) {
                            return false;
                        }
                    }
                    return true;
                };
                PolyShape.prototype.containsVertPartial = function(vx, vy, n) {
                    var planes = this.tPlanes;
                    for (var i = 0; i < planes.length; i++) {
                        var n2 = planes[i].n;
                        if (vdot(n2, n) < 0) {
                            continue;
                        }
                        var dist = vdot2(n2.x, n2.y, vx, vy) - planes[i].d;
                        if (dist > 0) {
                            return false;
                        }
                    }
                    return true;
                };
                PolyShape.prototype.getNumVerts = function() {
                    return this.verts.length / 2;
                };
                PolyShape.prototype.getVert = function(i) {
                    return new Vect(this.verts[2 * i], this.verts[2 * i + 1]);
                };
                var Body = cp.Body = function(m, i) {
                    this.p = new Vect(0, 0);
                    this.vx = this.vy = 0;
                    this.f = new Vect(0, 0);
                    this.w = 0;
                    this.t = 0;
                    this.v_limit = 1 / 0;
                    this.w_limit = 1 / 0;
                    this.v_biasx = this.v_biasy = 0;
                    this.w_bias = 0;
                    this.space = null;
                    this.shapeList = [];
                    this.arbiterList = null;
                    this.constraintList = null;
                    this.nodeRoot = null;
                    this.nodeNext = null;
                    this.nodeIdleTime = 0;
                    this.setMass(m);
                    this.setMoment(i);
                    this.rot = new Vect(0, 0);
                    this.setAngle(0);
                };
                var createStaticBody = function() {
                    var body = new Body(1 / 0, 1 / 0);
                    body.nodeIdleTime = 1 / 0;
                    return body;
                };
                cp.StaticBody = createStaticBody;
                if ("undefined" !== typeof DEBUG && DEBUG) {
                    var v_assert_nan = function(v, message) {
                        assert(v.x == v.x && v.y == v.y, message);
                    };
                    var v_assert_infinite = function(v, message) {
                        assert(Math.abs(v.x) !== 1 / 0 && Math.abs(v.y) !== 1 / 0, message);
                    };
                    var v_assert_sane = function(v, message) {
                        v_assert_nan(v, message);
                        v_assert_infinite(v, message);
                    };
                    Body.prototype.sanityCheck = function() {
                        assert(this.m === this.m && this.m_inv === this.m_inv, "Body's mass is invalid.");
                        assert(this.i === this.i && this.i_inv === this.i_inv, "Body's moment is invalid.");
                        v_assert_sane(this.p, "Body's position is invalid.");
                        v_assert_sane(this.f, "Body's force is invalid.");
                        assert(this.vx === this.vx && Math.abs(this.vx) !== 1 / 0, "Body's velocity is invalid.");
                        assert(this.vy === this.vy && Math.abs(this.vy) !== 1 / 0, "Body's velocity is invalid.");
                        assert(this.a === this.a && Math.abs(this.a) !== 1 / 0, "Body's angle is invalid.");
                        assert(this.w === this.w && Math.abs(this.w) !== 1 / 0, "Body's angular velocity is invalid.");
                        assert(this.t === this.t && Math.abs(this.t) !== 1 / 0, "Body's torque is invalid.");
                        v_assert_sane(this.rot, "Body's rotation vector is invalid.");
                        assert(this.v_limit === this.v_limit, "Body's velocity limit is invalid.");
                        assert(this.w_limit === this.w_limit, "Body's angular velocity limit is invalid.");
                    };
                } else {
                    Body.prototype.sanityCheck = function() {};
                }
                Body.prototype.getPos = function() {
                    return this.p;
                };
                Body.prototype.getVel = function() {
                    return new Vect(this.vx, this.vy);
                };
                Body.prototype.getAngVel = function() {
                    return this.w;
                };
                Body.prototype.isSleeping = function() {
                    return null !== this.nodeRoot;
                };
                Body.prototype.isStatic = function() {
                    return this.nodeIdleTime === 1 / 0;
                };
                Body.prototype.isRogue = function() {
                    return null === this.space;
                };
                Body.prototype.setMass = function(mass) {
                    assert(mass > 0, "Mass must be positive and non-zero.");
                    this.activate();
                    this.m = mass;
                    this.m_inv = 1 / mass;
                };
                Body.prototype.setMoment = function(moment) {
                    assert(moment > 0, "Moment of Inertia must be positive and non-zero.");
                    this.activate();
                    this.i = moment;
                    this.i_inv = 1 / moment;
                };
                Body.prototype.addShape = function(shape) {
                    this.shapeList.push(shape);
                };
                Body.prototype.removeShape = function(shape) {
                    deleteObjFromList(this.shapeList, shape);
                };
                var filterConstraints = function(node, body, filter) {
                    if (node === filter) {
                        return node.next(body);
                    } else {
                        if (node.a === body) {
                            node.next_a = filterConstraints(node.next_a, body, filter);
                        } else {
                            node.next_b = filterConstraints(node.next_b, body, filter);
                        }
                    }
                    return node;
                };
                Body.prototype.removeConstraint = function(constraint) {
                    this.constraintList = filterConstraints(this.constraintList, this, constraint);
                };
                Body.prototype.setPos = function(pos) {
                    this.activate();
                    this.sanityCheck();
                    if (pos === vzero) {
                        pos = cp.v(0, 0);
                    }
                    this.p = pos;
                };
                Body.prototype.setVel = function(velocity) {
                    this.activate();
                    this.vx = velocity.x;
                    this.vy = velocity.y;
                };
                Body.prototype.setAngVel = function(w) {
                    this.activate();
                    this.w = w;
                };
                Body.prototype.setAngleInternal = function(angle) {
                    assert(!isNaN(angle), "Internal Error: Attempting to set body's angle to NaN");
                    this.a = angle;
                    this.rot.x = Math.cos(angle);
                    this.rot.y = Math.sin(angle);
                };
                Body.prototype.setAngle = function(angle) {
                    this.activate();
                    this.sanityCheck();
                    this.setAngleInternal(angle);
                };
                Body.prototype.velocity_func = function(gravity, damping, dt) {
                    var vx = this.vx * damping + (gravity.x + this.f.x * this.m_inv) * dt;
                    var vy = this.vy * damping + (gravity.y + this.f.y * this.m_inv) * dt;
                    var v_limit = this.v_limit;
                    var lensq = vx * vx + vy * vy;
                    var scale = lensq > v_limit * v_limit ? v_limit / Math.sqrt(lensq) : 1;
                    this.vx = vx * scale;
                    this.vy = vy * scale;
                    var w_limit = this.w_limit;
                    this.w = clamp(this.w * damping + this.t * this.i_inv * dt, -w_limit, w_limit);
                    this.sanityCheck();
                };
                Body.prototype.position_func = function(dt) {
                    this.p.x += (this.vx + this.v_biasx) * dt;
                    this.p.y += (this.vy + this.v_biasy) * dt;
                    this.setAngleInternal(this.a + (this.w + this.w_bias) * dt);
                    this.v_biasx = this.v_biasy = 0;
                    this.w_bias = 0;
                    this.sanityCheck();
                };
                Body.prototype.resetForces = function() {
                    this.activate();
                    this.f = new Vect(0, 0);
                    this.t = 0;
                };
                Body.prototype.applyForce = function(force, r) {
                    this.activate();
                    this.f = vadd(this.f, force);
                    this.t += vcross(r, force);
                };
                Body.prototype.applyImpulse = function(j, r) {
                    this.activate();
                    apply_impulse(this, j.x, j.y, r);
                };
                Body.prototype.getVelAtPoint = function(r) {
                    return vadd(new Vect(this.vx, this.vy), vmult(vperp(r), this.w));
                };
                Body.prototype.getVelAtWorldPoint = function(point) {
                    return this.getVelAtPoint(vsub(point, this.p));
                };
                Body.prototype.getVelAtLocalPoint = function(point) {
                    return this.getVelAtPoint(vrotate(point, this.rot));
                };
                Body.prototype.eachShape = function(func) {
                    for (var i = 0, len = this.shapeList.length; i < len; i++) {
                        func(this.shapeList[i]);
                    }
                };
                Body.prototype.eachConstraint = function(func) {
                    var constraint = this.constraintList;
                    while (constraint) {
                        var next = constraint.next(this);
                        func(constraint);
                        constraint = next;
                    }
                };
                Body.prototype.eachArbiter = function(func) {
                    var arb = this.arbiterList;
                    while (arb) {
                        var next = arb.next(this);
                        arb.swappedColl = this === arb.body_b;
                        func(arb);
                        arb = next;
                    }
                };
                Body.prototype.local2World = function(v) {
                    return vadd(this.p, vrotate(v, this.rot));
                };
                Body.prototype.world2Local = function(v) {
                    return vunrotate(vsub(v, this.p), this.rot);
                };
                Body.prototype.kineticEnergy = function() {
                    var vsq = this.vx * this.vx + this.vy * this.vy;
                    var wsq = this.w * this.w;
                    return (vsq ? vsq * this.m : 0) + (wsq ? wsq * this.i : 0);
                };
                var SpatialIndex = cp.SpatialIndex = function(staticIndex) {
                    this.staticIndex = staticIndex;
                    if (staticIndex) {
                        if (staticIndex.dynamicIndex) {
                            throw new Error("This static index is already associated with a dynamic index.");
                        }
                        staticIndex.dynamicIndex = this;
                    }
                };
                SpatialIndex.prototype.collideStatic = function(staticIndex, func) {
                    if (staticIndex.count > 0) {
                        var query = staticIndex.query;
                        this.each(function(obj) {
                            query(obj, new BB(obj.bb_l, obj.bb_b, obj.bb_r, obj.bb_t), func);
                        });
                    }
                };
                var BBTree = cp.BBTree = function(staticIndex) {
                    SpatialIndex.call(this, staticIndex);
                    this.velocityFunc = null;
                    this.leaves = {};
                    this.count = 0;
                    this.root = null;
                    this.pooledNodes = null;
                    this.pooledPairs = null;
                    this.stamp = 0;
                };
                BBTree.prototype = Object.create(SpatialIndex.prototype);
                var numNodes = 0;
                var Node = function(tree, a, b) {
                    this.obj = null;
                    this.bb_l = min(a.bb_l, b.bb_l);
                    this.bb_b = min(a.bb_b, b.bb_b);
                    this.bb_r = max(a.bb_r, b.bb_r);
                    this.bb_t = max(a.bb_t, b.bb_t);
                    this.parent = null;
                    this.setA(a);
                    this.setB(b);
                };
                BBTree.prototype.makeNode = function(a, b) {
                    var node = this.pooledNodes;
                    if (node) {
                        this.pooledNodes = node.parent;
                        node.constructor(this, a, b);
                        return node;
                    } else {
                        numNodes++;
                        return new Node(this, a, b);
                    }
                };
                var numLeaves = 0;
                var Leaf = function(tree, obj) {
                    this.obj = obj;
                    tree.getBB(obj, this);
                    this.parent = null;
                    this.stamp = 1;
                    this.pairs = null;
                    numLeaves++;
                };
                BBTree.prototype.getBB = function(obj, dest) {
                    var velocityFunc = this.velocityFunc;
                    if (velocityFunc) {
                        var coef = .1;
                        var x = (obj.bb_r - obj.bb_l) * coef;
                        var y = (obj.bb_t - obj.bb_b) * coef;
                        var v = vmult(velocityFunc(obj), .1);
                        dest.bb_l = obj.bb_l + min(-x, v.x);
                        dest.bb_b = obj.bb_b + min(-y, v.y);
                        dest.bb_r = obj.bb_r + max(x, v.x);
                        dest.bb_t = obj.bb_t + max(y, v.y);
                    } else {
                        dest.bb_l = obj.bb_l;
                        dest.bb_b = obj.bb_b;
                        dest.bb_r = obj.bb_r;
                        dest.bb_t = obj.bb_t;
                    }
                };
                BBTree.prototype.getStamp = function() {
                    var dynamic = this.dynamicIndex;
                    return dynamic && dynamic.stamp ? dynamic.stamp : this.stamp;
                };
                BBTree.prototype.incrementStamp = function() {
                    if (this.dynamicIndex && this.dynamicIndex.stamp) {
                        this.dynamicIndex.stamp++;
                    } else {
                        this.stamp++;
                    }
                };
                var numPairs = 0;
                var Pair = function(leafA, nextA, leafB, nextB) {
                    this.prevA = null;
                    this.leafA = leafA;
                    this.nextA = nextA;
                    this.prevB = null;
                    this.leafB = leafB;
                    this.nextB = nextB;
                };
                BBTree.prototype.makePair = function(leafA, nextA, leafB, nextB) {
                    var pair = this.pooledPairs;
                    if (pair) {
                        this.pooledPairs = pair.prevA;
                        pair.prevA = null;
                        pair.leafA = leafA;
                        pair.nextA = nextA;
                        pair.prevB = null;
                        pair.leafB = leafB;
                        pair.nextB = nextB;
                        return pair;
                    } else {
                        numPairs++;
                        return new Pair(leafA, nextA, leafB, nextB);
                    }
                };
                Pair.prototype.recycle = function(tree) {
                    this.prevA = tree.pooledPairs;
                    tree.pooledPairs = this;
                };
                var unlinkThread = function(prev, leaf, next) {
                    if (next) {
                        if (next.leafA === leaf) {
                            next.prevA = prev;
                        } else {
                            next.prevB = prev;
                        }
                    }
                    if (prev) {
                        if (prev.leafA === leaf) {
                            prev.nextA = next;
                        } else {
                            prev.nextB = next;
                        }
                    } else {
                        leaf.pairs = next;
                    }
                };
                Leaf.prototype.clearPairs = function(tree) {
                    var pair = this.pairs, next;
                    this.pairs = null;
                    while (pair) {
                        if (pair.leafA === this) {
                            next = pair.nextA;
                            unlinkThread(pair.prevB, pair.leafB, pair.nextB);
                        } else {
                            next = pair.nextB;
                            unlinkThread(pair.prevA, pair.leafA, pair.nextA);
                        }
                        pair.recycle(tree);
                        pair = next;
                    }
                };
                var pairInsert = function(a, b, tree) {
                    var nextA = a.pairs, nextB = b.pairs;
                    var pair = tree.makePair(a, nextA, b, nextB);
                    a.pairs = b.pairs = pair;
                    if (nextA) {
                        if (nextA.leafA === a) {
                            nextA.prevA = pair;
                        } else {
                            nextA.prevB = pair;
                        }
                    }
                    if (nextB) {
                        if (nextB.leafA === b) {
                            nextB.prevA = pair;
                        } else {
                            nextB.prevB = pair;
                        }
                    }
                };
                Node.prototype.recycle = function(tree) {
                    this.parent = tree.pooledNodes;
                    tree.pooledNodes = this;
                };
                Leaf.prototype.recycle = function(tree) {};
                Node.prototype.setA = function(value) {
                    this.A = value;
                    value.parent = this;
                };
                Node.prototype.setB = function(value) {
                    this.B = value;
                    value.parent = this;
                };
                Leaf.prototype.isLeaf = true;
                Node.prototype.isLeaf = false;
                Node.prototype.otherChild = function(child) {
                    return this.A == child ? this.B : this.A;
                };
                Node.prototype.replaceChild = function(child, value, tree) {
                    assertSoft(child == this.A || child == this.B, "Node is not a child of parent.");
                    if (this.A == child) {
                        this.A.recycle(tree);
                        this.setA(value);
                    } else {
                        this.B.recycle(tree);
                        this.setB(value);
                    }
                    for (var node = this; node; node = node.parent) {
                        var a = node.A;
                        var b = node.B;
                        node.bb_l = min(a.bb_l, b.bb_l);
                        node.bb_b = min(a.bb_b, b.bb_b);
                        node.bb_r = max(a.bb_r, b.bb_r);
                        node.bb_t = max(a.bb_t, b.bb_t);
                    }
                };
                Node.prototype.bbArea = Leaf.prototype.bbArea = function() {
                    return (this.bb_r - this.bb_l) * (this.bb_t - this.bb_b);
                };
                var bbTreeMergedArea = function(a, b) {
                    return (max(a.bb_r, b.bb_r) - min(a.bb_l, b.bb_l)) * (max(a.bb_t, b.bb_t) - min(a.bb_b, b.bb_b));
                };
                var bbProximity = function(a, b) {
                    return Math.abs(a.bb_l + a.bb_r - b.bb_l - b.bb_r) + Math.abs(a.bb_b + a.bb_t - b.bb_b - b.bb_t);
                };
                var subtreeInsert = function(subtree, leaf, tree) {
                    if (null == subtree) {
                        return leaf;
                    } else {
                        if (subtree.isLeaf) {
                            return tree.makeNode(leaf, subtree);
                        } else {
                            var cost_a = subtree.B.bbArea() + bbTreeMergedArea(subtree.A, leaf);
                            var cost_b = subtree.A.bbArea() + bbTreeMergedArea(subtree.B, leaf);
                            if (cost_a === cost_b) {
                                cost_a = bbProximity(subtree.A, leaf);
                                cost_b = bbProximity(subtree.B, leaf);
                            }
                            if (cost_b < cost_a) {
                                subtree.setB(subtreeInsert(subtree.B, leaf, tree));
                            } else {
                                subtree.setA(subtreeInsert(subtree.A, leaf, tree));
                            }
                            subtree.bb_l = min(subtree.bb_l, leaf.bb_l);
                            subtree.bb_b = min(subtree.bb_b, leaf.bb_b);
                            subtree.bb_r = max(subtree.bb_r, leaf.bb_r);
                            subtree.bb_t = max(subtree.bb_t, leaf.bb_t);
                            return subtree;
                        }
                    }
                };
                Node.prototype.intersectsBB = Leaf.prototype.intersectsBB = function(bb) {
                    return this.bb_l <= bb.r && bb.l <= this.bb_r && this.bb_b <= bb.t && bb.b <= this.bb_t;
                };
                var subtreeQuery = function(subtree, bb, func) {
                    if (subtree.intersectsBB(bb)) {
                        if (subtree.isLeaf) {
                            func(subtree.obj);
                        } else {
                            subtreeQuery(subtree.A, bb, func);
                            subtreeQuery(subtree.B, bb, func);
                        }
                    }
                };
                var nodeSegmentQuery = function(node, a, b) {
                    var idx = 1 / (b.x - a.x);
                    var tx1 = node.bb_l == a.x ? -(1 / 0) : (node.bb_l - a.x) * idx;
                    var tx2 = node.bb_r == a.x ? 1 / 0 : (node.bb_r - a.x) * idx;
                    var txmin = min(tx1, tx2);
                    var txmax = max(tx1, tx2);
                    var idy = 1 / (b.y - a.y);
                    var ty1 = node.bb_b == a.y ? -(1 / 0) : (node.bb_b - a.y) * idy;
                    var ty2 = node.bb_t == a.y ? 1 / 0 : (node.bb_t - a.y) * idy;
                    var tymin = min(ty1, ty2);
                    var tymax = max(ty1, ty2);
                    if (tymin <= txmax && txmin <= tymax) {
                        var min_ = max(txmin, tymin);
                        var max_ = min(txmax, tymax);
                        if (0 <= max_ && min_ <= 1) {
                            return max(min_, 0);
                        }
                    }
                    return 1 / 0;
                };
                var subtreeSegmentQuery = function(subtree, a, b, t_exit, func) {
                    if (subtree.isLeaf) {
                        return func(subtree.obj);
                    } else {
                        var t_a = nodeSegmentQuery(subtree.A, a, b);
                        var t_b = nodeSegmentQuery(subtree.B, a, b);
                        if (t_a < t_b) {
                            if (t_a < t_exit) {
                                t_exit = min(t_exit, subtreeSegmentQuery(subtree.A, a, b, t_exit, func));
                            }
                            if (t_b < t_exit) {
                                t_exit = min(t_exit, subtreeSegmentQuery(subtree.B, a, b, t_exit, func));
                            }
                        } else {
                            if (t_b < t_exit) {
                                t_exit = min(t_exit, subtreeSegmentQuery(subtree.B, a, b, t_exit, func));
                            }
                            if (t_a < t_exit) {
                                t_exit = min(t_exit, subtreeSegmentQuery(subtree.A, a, b, t_exit, func));
                            }
                        }
                        return t_exit;
                    }
                };
                BBTree.prototype.subtreeRecycle = function(node) {
                    if (node.isLeaf) {
                        this.subtreeRecycle(node.A);
                        this.subtreeRecycle(node.B);
                        node.recycle(this);
                    }
                };
                var subtreeRemove = function(subtree, leaf, tree) {
                    if (leaf == subtree) {
                        return null;
                    } else {
                        var parent = leaf.parent;
                        if (parent == subtree) {
                            var other = subtree.otherChild(leaf);
                            other.parent = subtree.parent;
                            subtree.recycle(tree);
                            return other;
                        } else {
                            parent.parent.replaceChild(parent, parent.otherChild(leaf), tree);
                            return subtree;
                        }
                    }
                };
                var bbTreeIntersectsNode = function(a, b) {
                    return a.bb_l <= b.bb_r && b.bb_l <= a.bb_r && a.bb_b <= b.bb_t && b.bb_b <= a.bb_t;
                };
                Leaf.prototype.markLeafQuery = function(leaf, left, tree, func) {
                    if (bbTreeIntersectsNode(leaf, this)) {
                        if (left) {
                            pairInsert(leaf, this, tree);
                        } else {
                            if (this.stamp < leaf.stamp) {
                                pairInsert(this, leaf, tree);
                            }
                            if (func) {
                                func(leaf.obj, this.obj);
                            }
                        }
                    }
                };
                Node.prototype.markLeafQuery = function(leaf, left, tree, func) {
                    if (bbTreeIntersectsNode(leaf, this)) {
                        this.A.markLeafQuery(leaf, left, tree, func);
                        this.B.markLeafQuery(leaf, left, tree, func);
                    }
                };
                Leaf.prototype.markSubtree = function(tree, staticRoot, func) {
                    if (this.stamp == tree.getStamp()) {
                        if (staticRoot) {
                            staticRoot.markLeafQuery(this, false, tree, func);
                        }
                        for (var node = this; node.parent; node = node.parent) {
                            if (node == node.parent.A) {
                                node.parent.B.markLeafQuery(this, true, tree, func);
                            } else {
                                node.parent.A.markLeafQuery(this, false, tree, func);
                            }
                        }
                    } else {
                        var pair = this.pairs;
                        while (pair) {
                            if (this === pair.leafB) {
                                if (func) {
                                    func(pair.leafA.obj, this.obj);
                                }
                                pair = pair.nextB;
                            } else {
                                pair = pair.nextA;
                            }
                        }
                    }
                };
                Node.prototype.markSubtree = function(tree, staticRoot, func) {
                    this.A.markSubtree(tree, staticRoot, func);
                    this.B.markSubtree(tree, staticRoot, func);
                };
                Leaf.prototype.containsObj = function(obj) {
                    return this.bb_l <= obj.bb_l && this.bb_r >= obj.bb_r && this.bb_b <= obj.bb_b && this.bb_t >= obj.bb_t;
                };
                Leaf.prototype.update = function(tree) {
                    var root = tree.root;
                    var obj = this.obj;
                    if (!this.containsObj(obj)) {
                        tree.getBB(this.obj, this);
                        root = subtreeRemove(root, this, tree);
                        tree.root = subtreeInsert(root, this, tree);
                        this.clearPairs(tree);
                        this.stamp = tree.getStamp();
                        return true;
                    }
                    return false;
                };
                Leaf.prototype.addPairs = function(tree) {
                    var dynamicIndex = tree.dynamicIndex;
                    if (dynamicIndex) {
                        var dynamicRoot = dynamicIndex.root;
                        if (dynamicRoot) {
                            dynamicRoot.markLeafQuery(this, true, dynamicIndex, null);
                        }
                    } else {
                        var staticRoot = tree.staticIndex.root;
                        this.markSubtree(tree, staticRoot, null);
                    }
                };
                BBTree.prototype.insert = function(obj, hashid) {
                    var leaf = new Leaf(this, obj);
                    this.leaves[hashid] = leaf;
                    this.root = subtreeInsert(this.root, leaf, this);
                    this.count++;
                    leaf.stamp = this.getStamp();
                    leaf.addPairs(this);
                    this.incrementStamp();
                };
                BBTree.prototype.remove = function(obj, hashid) {
                    var leaf = this.leaves[hashid];
                    delete this.leaves[hashid];
                    this.root = subtreeRemove(this.root, leaf, this);
                    this.count--;
                    leaf.clearPairs(this);
                    leaf.recycle(this);
                };
                BBTree.prototype.contains = function(obj, hashid) {
                    return null != this.leaves[hashid];
                };
                var voidQueryFunc = function(obj1, obj2) {};
                BBTree.prototype.reindexQuery = function(func) {
                    if (!this.root) {
                        return;
                    }
                    var hashid, leaves = this.leaves;
                    for (hashid in leaves) {
                        leaves[hashid].update(this);
                    }
                    var staticIndex = this.staticIndex;
                    var staticRoot = staticIndex && staticIndex.root;
                    this.root.markSubtree(this, staticRoot, func);
                    if (staticIndex && !staticRoot) {
                        this.collideStatic(this, staticIndex, func);
                    }
                    this.incrementStamp();
                };
                BBTree.prototype.reindex = function() {
                    this.reindexQuery(voidQueryFunc);
                };
                BBTree.prototype.reindexObject = function(obj, hashid) {
                    var leaf = this.leaves[hashid];
                    if (leaf) {
                        if (leaf.update(this)) {
                            leaf.addPairs(this);
                        }
                        this.incrementStamp();
                    }
                };
                BBTree.prototype.pointQuery = function(point, func) {
                    this.query(new BB(point.x, point.y, point.x, point.y), func);
                };
                BBTree.prototype.segmentQuery = function(a, b, t_exit, func) {
                    if (this.root) {
                        subtreeSegmentQuery(this.root, a, b, t_exit, func);
                    }
                };
                BBTree.prototype.query = function(bb, func) {
                    if (this.root) {
                        subtreeQuery(this.root, bb, func);
                    }
                };
                BBTree.prototype.count = function() {
                    return this.count;
                };
                BBTree.prototype.each = function(func) {
                    var hashid;
                    for (hashid in this.leaves) {
                        func(this.leaves[hashid].obj);
                    }
                };
                var bbTreeMergedArea2 = function(node, l, b, r, t) {
                    return (max(node.bb_r, r) - min(node.bb_l, l)) * (max(node.bb_t, t) - min(node.bb_b, b));
                };
                var partitionNodes = function(tree, nodes, offset, count) {
                    if (1 == count) {
                        return nodes[offset];
                    } else {
                        if (2 == count) {
                            return tree.makeNode(nodes[offset], nodes[offset + 1]);
                        }
                    }
                    var node = nodes[offset];
                    var bb_l = node.bb_l, bb_b = node.bb_b, bb_r = node.bb_r, bb_t = node.bb_t;
                    var end = offset + count;
                    for (var i = offset + 1; i < end; i++) {
                        node = nodes[i];
                        bb_l = min(bb_l, node.bb_l);
                        bb_b = min(bb_b, node.bb_b);
                        bb_r = max(bb_r, node.bb_r);
                        bb_t = max(bb_t, node.bb_t);
                    }
                    var splitWidth = bb_r - bb_l > bb_t - bb_b;
                    var bounds = new Array(2 * count);
                    if (splitWidth) {
                        for (var i = offset; i < end; i++) {
                            bounds[2 * i + 0] = nodes[i].bb_l;
                            bounds[2 * i + 1] = nodes[i].bb_r;
                        }
                    } else {
                        for (var i = offset; i < end; i++) {
                            bounds[2 * i + 0] = nodes[i].bb_b;
                            bounds[2 * i + 1] = nodes[i].bb_t;
                        }
                    }
                    bounds.sort(function(a, b) {
                        return a - b;
                    });
                    var split = .5 * (bounds[count - 1] + bounds[count]);
                    var a_l = bb_l, a_b = bb_b, a_r = bb_r, a_t = bb_t;
                    var b_l = bb_l, b_b = bb_b, b_r = bb_r, b_t = bb_t;
                    if (splitWidth) {
                        a_r = b_l = split;
                    } else {
                        a_t = b_b = split;
                    }
                    var right = end;
                    for (var left = offset; left < right; ) {
                        var node = nodes[left];
                        if (bbTreeMergedArea2(node, b_l, b_b, b_r, b_t) < bbTreeMergedArea2(node, a_l, a_b, a_r, a_t)) {
                            right--;
                            nodes[left] = nodes[right];
                            nodes[right] = node;
                        } else {
                            left++;
                        }
                    }
                    if (right == count) {
                        var node = null;
                        for (var i = offset; i < end; i++) {
                            node = subtreeInsert(node, nodes[i], tree);
                        }
                        return node;
                    }
                    return NodeNew(tree, partitionNodes(tree, nodes, offset, right - offset), partitionNodes(tree, nodes, right, end - right));
                };
                BBTree.prototype.optimize = function() {
                    var nodes = new Array(this.count);
                    var i = 0;
                    for (var hashid in this.leaves) {
                        nodes[i++] = this.nodes[hashid];
                    }
                    tree.subtreeRecycle(root);
                    this.root = partitionNodes(tree, nodes, nodes.length);
                };
                var nodeRender = function(node, depth) {
                    if (!node.isLeaf && depth <= 10) {
                        nodeRender(node.A, depth + 1);
                        nodeRender(node.B, depth + 1);
                    }
                    var str = "";
                    for (var i = 0; i < depth; i++) {
                        str += " ";
                    }
                    console.log(str + node.bb_b + " " + node.bb_t);
                };
                BBTree.prototype.log = function() {
                    if (this.root) {
                        nodeRender(this.root, 0);
                    }
                };
                var CollisionHandler = cp.CollisionHandler = function() {
                    this.a = this.b = 0;
                };
                CollisionHandler.prototype.begin = function(arb, space) {
                    return true;
                };
                CollisionHandler.prototype.preSolve = function(arb, space) {
                    return true;
                };
                CollisionHandler.prototype.postSolve = function(arb, space) {};
                CollisionHandler.prototype.separate = function(arb, space) {};
                var CP_MAX_CONTACTS_PER_ARBITER = 4;
                var Arbiter = function(a, b) {
                    this.e = 0;
                    this.u = 0;
                    this.surface_vr = vzero;
                    this.a = a;
                    this.body_a = a.body;
                    this.b = b;
                    this.body_b = b.body;
                    this.thread_a_next = this.thread_a_prev = null;
                    this.thread_b_next = this.thread_b_prev = null;
                    this.contacts = null;
                    this.stamp = 0;
                    this.handler = null;
                    this.swappedColl = false;
                    this.state = "first coll";
                };
                Arbiter.prototype.getShapes = function() {
                    if (this.swappedColl) {
                        return [ this.b, this.a ];
                    } else {
                        return [ this.a, this.b ];
                    }
                };
                Arbiter.prototype.totalImpulse = function() {
                    var contacts = this.contacts;
                    var sum = new Vect(0, 0);
                    for (var i = 0, count = contacts.length; i < count; i++) {
                        var con = contacts[i];
                        sum.add(vmult(con.n, con.jnAcc));
                    }
                    return this.swappedColl ? sum : sum.neg();
                };
                Arbiter.prototype.totalImpulseWithFriction = function() {
                    var contacts = this.contacts;
                    var sum = new Vect(0, 0);
                    for (var i = 0, count = contacts.length; i < count; i++) {
                        var con = contacts[i];
                        sum.add(new Vect(con.jnAcc, con.jtAcc).rotate(con.n));
                    }
                    return this.swappedColl ? sum : sum.neg();
                };
                Arbiter.prototype.totalKE = function() {
                    var eCoef = (1 - this.e) / (1 + this.e);
                    var sum = 0;
                    var contacts = this.contacts;
                    for (var i = 0, count = contacts.length; i < count; i++) {
                        var con = contacts[i];
                        var jnAcc = con.jnAcc;
                        var jtAcc = con.jtAcc;
                        sum += eCoef * jnAcc * jnAcc / con.nMass + jtAcc * jtAcc / con.tMass;
                    }
                    return sum;
                };
                Arbiter.prototype.ignore = function() {
                    this.state = "ignore";
                };
                Arbiter.prototype.getA = function() {
                    return this.swappedColl ? this.b : this.a;
                };
                Arbiter.prototype.getB = function() {
                    return this.swappedColl ? this.a : this.b;
                };
                Arbiter.prototype.isFirstContact = function() {
                    return "first coll" === this.state;
                };
                var ContactPoint = function(point, normal, dist) {
                    this.point = point;
                    this.normal = normal;
                    this.dist = dist;
                };
                Arbiter.prototype.getContactPointSet = function() {
                    var set = new Array(this.contacts.length);
                    var i;
                    for (i = 0; i < set.length; i++) {
                        set[i] = new ContactPoint(this.contacts[i].p, this.contacts[i].n, this.contacts[i].dist);
                    }
                    return set;
                };
                Arbiter.prototype.getNormal = function(i) {
                    var n = this.contacts[i].n;
                    return this.swappedColl ? vneg(n) : n;
                };
                Arbiter.prototype.getPoint = function(i) {
                    return this.contacts[i].p;
                };
                Arbiter.prototype.getDepth = function(i) {
                    return this.contacts[i].dist;
                };
                var unthreadHelper = function(arb, body, prev, next) {
                    if (prev) {
                        if (prev.body_a === body) {
                            prev.thread_a_next = next;
                        } else {
                            prev.thread_b_next = next;
                        }
                    } else {
                        body.arbiterList = next;
                    }
                    if (next) {
                        if (next.body_a === body) {
                            next.thread_a_prev = prev;
                        } else {
                            next.thread_b_prev = prev;
                        }
                    }
                };
                Arbiter.prototype.unthread = function() {
                    unthreadHelper(this, this.body_a, this.thread_a_prev, this.thread_a_next);
                    unthreadHelper(this, this.body_b, this.thread_b_prev, this.thread_b_next);
                    this.thread_a_prev = this.thread_a_next = null;
                    this.thread_b_prev = this.thread_b_next = null;
                };
                Arbiter.prototype.update = function(contacts, handler, a, b) {
                    if (this.contacts) {
                        for (var i = 0; i < this.contacts.length; i++) {
                            var old = this.contacts[i];
                            for (var j = 0; j < contacts.length; j++) {
                                var new_contact = contacts[j];
                                if (new_contact.hash === old.hash) {
                                    new_contact.jnAcc = old.jnAcc;
                                    new_contact.jtAcc = old.jtAcc;
                                }
                            }
                        }
                    }
                    this.contacts = contacts;
                    this.handler = handler;
                    this.swappedColl = a.collision_type !== handler.a;
                    this.e = a.e * b.e;
                    this.u = a.u * b.u;
                    this.surface_vr = vsub(a.surface_v, b.surface_v);
                    this.a = a;
                    this.body_a = a.body;
                    this.b = b;
                    this.body_b = b.body;
                    if ("cached" == this.state) {
                        this.state = "first coll";
                    }
                };
                Arbiter.prototype.preStep = function(dt, slop, bias) {
                    var a = this.body_a;
                    var b = this.body_b;
                    for (var i = 0; i < this.contacts.length; i++) {
                        var con = this.contacts[i];
                        con.r1 = vsub(con.p, a.p);
                        con.r2 = vsub(con.p, b.p);
                        con.nMass = 1 / k_scalar(a, b, con.r1, con.r2, con.n);
                        con.tMass = 1 / k_scalar(a, b, con.r1, con.r2, vperp(con.n));
                        con.bias = -bias * min(0, con.dist + slop) / dt;
                        con.jBias = 0;
                        con.bounce = normal_relative_velocity(a, b, con.r1, con.r2, con.n) * this.e;
                    }
                };
                Arbiter.prototype.applyCachedImpulse = function(dt_coef) {
                    if (this.isFirstContact()) {
                        return;
                    }
                    var a = this.body_a;
                    var b = this.body_b;
                    for (var i = 0; i < this.contacts.length; i++) {
                        var con = this.contacts[i];
                        var nx = con.n.x;
                        var ny = con.n.y;
                        var jx = nx * con.jnAcc - ny * con.jtAcc;
                        var jy = nx * con.jtAcc + ny * con.jnAcc;
                        apply_impulses(a, b, con.r1, con.r2, jx * dt_coef, jy * dt_coef);
                    }
                };
                var numApplyImpulse = 0;
                var numApplyContact = 0;
                Arbiter.prototype.applyImpulse = function() {
                    numApplyImpulse++;
                    var a = this.body_a;
                    var b = this.body_b;
                    var surface_vr = this.surface_vr;
                    var friction = this.u;
                    for (var i = 0; i < this.contacts.length; i++) {
                        numApplyContact++;
                        var con = this.contacts[i];
                        var nMass = con.nMass;
                        var n = con.n;
                        var r1 = con.r1;
                        var r2 = con.r2;
                        var vrx = b.vx - r2.y * b.w - (a.vx - r1.y * a.w);
                        var vry = b.vy + r2.x * b.w - (a.vy + r1.x * a.w);
                        var vbn = n.x * (b.v_biasx - r2.y * b.w_bias - a.v_biasx + r1.y * a.w_bias) + n.y * (r2.x * b.w_bias + b.v_biasy - r1.x * a.w_bias - a.v_biasy);
                        var vrn = vdot2(vrx, vry, n.x, n.y);
                        var vrt = vdot2(vrx + surface_vr.x, vry + surface_vr.y, -n.y, n.x);
                        var jbn = (con.bias - vbn) * nMass;
                        var jbnOld = con.jBias;
                        con.jBias = max(jbnOld + jbn, 0);
                        var jn = -(con.bounce + vrn) * nMass;
                        var jnOld = con.jnAcc;
                        con.jnAcc = max(jnOld + jn, 0);
                        var jtMax = friction * con.jnAcc;
                        var jt = -vrt * con.tMass;
                        var jtOld = con.jtAcc;
                        con.jtAcc = clamp(jtOld + jt, -jtMax, jtMax);
                        var bias_x = n.x * (con.jBias - jbnOld);
                        var bias_y = n.y * (con.jBias - jbnOld);
                        apply_bias_impulse(a, -bias_x, -bias_y, r1);
                        apply_bias_impulse(b, bias_x, bias_y, r2);
                        var rot_x = con.jnAcc - jnOld;
                        var rot_y = con.jtAcc - jtOld;
                        apply_impulses(a, b, r1, r2, n.x * rot_x - n.y * rot_y, n.x * rot_y + n.y * rot_x);
                    }
                };
                Arbiter.prototype.callSeparate = function(space) {
                    var handler = space.lookupHandler(this.a.collision_type, this.b.collision_type);
                    handler.separate(this, space);
                };
                Arbiter.prototype.next = function(body) {
                    return this.body_a == body ? this.thread_a_next : this.thread_b_next;
                };
                var numContacts = 0;
                var Contact = function(p, n, dist, hash) {
                    this.p = p;
                    this.n = n;
                    this.dist = dist;
                    this.r1 = this.r2 = vzero;
                    this.nMass = this.tMass = this.bounce = this.bias = 0;
                    this.jnAcc = this.jtAcc = this.jBias = 0;
                    this.hash = hash;
                    numContacts++;
                };
                var NONE = [];
                var circle2circleQuery = function(p1, p2, r1, r2) {
                    var mindist = r1 + r2;
                    var delta = vsub(p2, p1);
                    var distsq = vlengthsq(delta);
                    if (distsq >= mindist * mindist) {
                        return;
                    }
                    var dist = Math.sqrt(distsq);
                    return new Contact(vadd(p1, vmult(delta, .5 + (r1 - .5 * mindist) / (dist ? dist : 1 / 0))), dist ? vmult(delta, 1 / dist) : new Vect(1, 0), dist - mindist, 0);
                };
                var circle2circle = function(circ1, circ2) {
                    var contact = circle2circleQuery(circ1.tc, circ2.tc, circ1.r, circ2.r);
                    return contact ? [ contact ] : NONE;
                };
                var circle2segment = function(circleShape, segmentShape) {
                    var seg_a = segmentShape.ta;
                    var seg_b = segmentShape.tb;
                    var center = circleShape.tc;
                    var seg_delta = vsub(seg_b, seg_a);
                    var closest_t = clamp01(vdot(seg_delta, vsub(center, seg_a)) / vlengthsq(seg_delta));
                    var closest = vadd(seg_a, vmult(seg_delta, closest_t));
                    var contact = circle2circleQuery(center, closest, circleShape.r, segmentShape.r);
                    if (contact) {
                        var n = contact.n;
                        return 0 === closest_t && vdot(n, segmentShape.a_tangent) < 0 || 1 === closest_t && vdot(n, segmentShape.b_tangent) < 0 ? NONE : [ contact ];
                    } else {
                        return NONE;
                    }
                };
                var last_MSA_min = 0;
                var findMSA = function(poly, planes) {
                    var min_index = 0;
                    var min = poly.valueOnAxis(planes[0].n, planes[0].d);
                    if (min > 0) {
                        return -1;
                    }
                    for (var i = 1; i < planes.length; i++) {
                        var dist = poly.valueOnAxis(planes[i].n, planes[i].d);
                        if (dist > 0) {
                            return -1;
                        } else {
                            if (dist > min) {
                                min = dist;
                                min_index = i;
                            }
                        }
                    }
                    last_MSA_min = min;
                    return min_index;
                };
                var findVertsFallback = function(poly1, poly2, n, dist) {
                    var arr = [];
                    var verts1 = poly1.tVerts;
                    for (var i = 0; i < verts1.length; i += 2) {
                        var vx = verts1[i];
                        var vy = verts1[i + 1];
                        if (poly2.containsVertPartial(vx, vy, vneg(n))) {
                            arr.push(new Contact(new Vect(vx, vy), n, dist, hashPair(poly1.hashid, i)));
                        }
                    }
                    var verts2 = poly2.tVerts;
                    for (var i = 0; i < verts2.length; i += 2) {
                        var vx = verts2[i];
                        var vy = verts2[i + 1];
                        if (poly1.containsVertPartial(vx, vy, n)) {
                            arr.push(new Contact(new Vect(vx, vy), n, dist, hashPair(poly2.hashid, i)));
                        }
                    }
                    return arr;
                };
                var findVerts = function(poly1, poly2, n, dist) {
                    var arr = [];
                    var verts1 = poly1.tVerts;
                    for (var i = 0; i < verts1.length; i += 2) {
                        var vx = verts1[i];
                        var vy = verts1[i + 1];
                        if (poly2.containsVert(vx, vy)) {
                            arr.push(new Contact(new Vect(vx, vy), n, dist, hashPair(poly1.hashid, i >> 1)));
                        }
                    }
                    var verts2 = poly2.tVerts;
                    for (var i = 0; i < verts2.length; i += 2) {
                        var vx = verts2[i];
                        var vy = verts2[i + 1];
                        if (poly1.containsVert(vx, vy)) {
                            arr.push(new Contact(new Vect(vx, vy), n, dist, hashPair(poly2.hashid, i >> 1)));
                        }
                    }
                    return arr.length ? arr : findVertsFallback(poly1, poly2, n, dist);
                };
                var poly2poly = function(poly1, poly2) {
                    var mini1 = findMSA(poly2, poly1.tPlanes);
                    if (-1 == mini1) {
                        return NONE;
                    }
                    var min1 = last_MSA_min;
                    var mini2 = findMSA(poly1, poly2.tPlanes);
                    if (-1 == mini2) {
                        return NONE;
                    }
                    var min2 = last_MSA_min;
                    if (min1 > min2) {
                        return findVerts(poly1, poly2, poly1.tPlanes[mini1].n, min1);
                    } else {
                        return findVerts(poly1, poly2, vneg(poly2.tPlanes[mini2].n), min2);
                    }
                };
                var segValueOnAxis = function(seg, n, d) {
                    var a = vdot(n, seg.ta) - seg.r;
                    var b = vdot(n, seg.tb) - seg.r;
                    return min(a, b) - d;
                };
                var findPointsBehindSeg = function(arr, seg, poly, pDist, coef) {
                    var dta = vcross(seg.tn, seg.ta);
                    var dtb = vcross(seg.tn, seg.tb);
                    var n = vmult(seg.tn, coef);
                    var verts = poly.tVerts;
                    for (var i = 0; i < verts.length; i += 2) {
                        var vx = verts[i];
                        var vy = verts[i + 1];
                        if (vdot2(vx, vy, n.x, n.y) < vdot(seg.tn, seg.ta) * coef + seg.r) {
                            var dt = vcross2(seg.tn.x, seg.tn.y, vx, vy);
                            if (dta >= dt && dt >= dtb) {
                                arr.push(new Contact(new Vect(vx, vy), n, pDist, hashPair(poly.hashid, i)));
                            }
                        }
                    }
                };
                var seg2poly = function(seg, poly) {
                    var arr = [];
                    var planes = poly.tPlanes;
                    var numVerts = planes.length;
                    var segD = vdot(seg.tn, seg.ta);
                    var minNorm = poly.valueOnAxis(seg.tn, segD) - seg.r;
                    var minNeg = poly.valueOnAxis(vneg(seg.tn), -segD) - seg.r;
                    if (minNeg > 0 || minNorm > 0) {
                        return NONE;
                    }
                    var mini = 0;
                    var poly_min = segValueOnAxis(seg, planes[0].n, planes[0].d);
                    if (poly_min > 0) {
                        return NONE;
                    }
                    for (var i = 0; i < numVerts; i++) {
                        var dist = segValueOnAxis(seg, planes[i].n, planes[i].d);
                        if (dist > 0) {
                            return NONE;
                        } else {
                            if (dist > poly_min) {
                                poly_min = dist;
                                mini = i;
                            }
                        }
                    }
                    var poly_n = vneg(planes[mini].n);
                    var va = vadd(seg.ta, vmult(poly_n, seg.r));
                    var vb = vadd(seg.tb, vmult(poly_n, seg.r));
                    if (poly.containsVert(va.x, va.y)) {
                        arr.push(new Contact(va, poly_n, poly_min, hashPair(seg.hashid, 0)));
                    }
                    if (poly.containsVert(vb.x, vb.y)) {
                        arr.push(new Contact(vb, poly_n, poly_min, hashPair(seg.hashid, 1)));
                    }
                    if (minNorm >= poly_min || minNeg >= poly_min) {
                        if (minNorm > minNeg) {
                            findPointsBehindSeg(arr, seg, poly, minNorm, 1);
                        } else {
                            findPointsBehindSeg(arr, seg, poly, minNeg, -1);
                        }
                    }
                    if (0 === arr.length) {
                        var mini2 = 2 * mini;
                        var verts = poly.tVerts;
                        var poly_a = new Vect(verts[mini2], verts[mini2 + 1]);
                        var con;
                        if (con = circle2circleQuery(seg.ta, poly_a, seg.r, 0, arr)) {
                            return [ con ];
                        }
                        if (con = circle2circleQuery(seg.tb, poly_a, seg.r, 0, arr)) {
                            return [ con ];
                        }
                        var len = 2 * numVerts;
                        var poly_b = new Vect(verts[(mini2 + 2) % len], verts[(mini2 + 3) % len]);
                        if (con = circle2circleQuery(seg.ta, poly_b, seg.r, 0, arr)) {
                            return [ con ];
                        }
                        if (con = circle2circleQuery(seg.tb, poly_b, seg.r, 0, arr)) {
                            return [ con ];
                        }
                    }
                    return arr;
                };
                var circle2poly = function(circ, poly) {
                    var planes = poly.tPlanes;
                    var mini = 0;
                    var min = vdot(planes[0].n, circ.tc) - planes[0].d - circ.r;
                    for (var i = 0; i < planes.length; i++) {
                        var dist = vdot(planes[i].n, circ.tc) - planes[i].d - circ.r;
                        if (dist > 0) {
                            return NONE;
                        } else {
                            if (dist > min) {
                                min = dist;
                                mini = i;
                            }
                        }
                    }
                    var n = planes[mini].n;
                    var verts = poly.tVerts;
                    var len = verts.length;
                    var mini2 = mini << 1;
                    var ax = verts[mini2];
                    var ay = verts[mini2 + 1];
                    var bx = verts[(mini2 + 2) % len];
                    var by = verts[(mini2 + 3) % len];
                    var dta = vcross2(n.x, n.y, ax, ay);
                    var dtb = vcross2(n.x, n.y, bx, by);
                    var dt = vcross(n, circ.tc);
                    if (dt < dtb) {
                        var con = circle2circleQuery(circ.tc, new Vect(bx, by), circ.r, 0, con);
                        return con ? [ con ] : NONE;
                    } else {
                        if (dt < dta) {
                            return [ new Contact(vsub(circ.tc, vmult(n, circ.r + min / 2)), vneg(n), min, 0) ];
                        } else {
                            var con = circle2circleQuery(circ.tc, new Vect(ax, ay), circ.r, 0, con);
                            return con ? [ con ] : NONE;
                        }
                    }
                };
                CircleShape.prototype.collisionCode = 0;
                SegmentShape.prototype.collisionCode = 1;
                PolyShape.prototype.collisionCode = 2;
                CircleShape.prototype.collisionTable = [ circle2circle, circle2segment, circle2poly ];
                SegmentShape.prototype.collisionTable = [ null, function(segA, segB) {
                    return NONE;
                }, seg2poly ];
                PolyShape.prototype.collisionTable = [ null, null, poly2poly ];
                var collideShapes = cp.collideShapes = function(a, b) {
                    assert(a.collisionCode <= b.collisionCode, "Collided shapes must be sorted by type");
                    return a.collisionTable[b.collisionCode](a, b);
                };
                var defaultCollisionHandler = new CollisionHandler();
                var Space = cp.Space = function() {
                    this.stamp = 0;
                    this.curr_dt = 0;
                    this.bodies = [];
                    this.rousedBodies = [];
                    this.sleepingComponents = [];
                    this.staticShapes = new BBTree(null);
                    this.activeShapes = new BBTree(this.staticShapes);
                    this.arbiters = [];
                    this.contactBuffersHead = null;
                    this.cachedArbiters = {};
                    this.constraints = [];
                    this.locked = 0;
                    this.collisionHandlers = {};
                    this.defaultHandler = defaultCollisionHandler;
                    this.postStepCallbacks = [];
                    this.iterations = 10;
                    this.gravity = vzero;
                    this.damping = 1;
                    this.idleSpeedThreshold = 0;
                    this.sleepTimeThreshold = 1 / 0;
                    this.collisionSlop = .1;
                    this.collisionBias = Math.pow(.9, 60);
                    this.collisionPersistence = 3;
                    this.enableContactGraph = false;
                    this.staticBody = new Body(1 / 0, 1 / 0);
                    this.staticBody.nodeIdleTime = 1 / 0;
                    this.collideShapes = this.makeCollideShapes();
                };
                Space.prototype.getCurrentTimeStep = function() {
                    return this.curr_dt;
                };
                Space.prototype.setIterations = function(iter) {
                    this.iterations = iter;
                };
                Space.prototype.isLocked = function() {
                    return this.locked;
                };
                var assertSpaceUnlocked = function(space) {
                    assert(!space.locked, "This addition/removal cannot be done safely during a call to cpSpaceStep()  or during a query. Put these calls into a post-step callback.");
                };
                Space.prototype.addCollisionHandler = function(a, b, begin, preSolve, postSolve, separate) {
                    assertSpaceUnlocked(this);
                    this.removeCollisionHandler(a, b);
                    var handler = new CollisionHandler();
                    handler.a = a;
                    handler.b = b;
                    if (begin) {
                        handler.begin = begin;
                    }
                    if (preSolve) {
                        handler.preSolve = preSolve;
                    }
                    if (postSolve) {
                        handler.postSolve = postSolve;
                    }
                    if (separate) {
                        handler.separate = separate;
                    }
                    this.collisionHandlers[hashPair(a, b)] = handler;
                };
                Space.prototype.removeCollisionHandler = function(a, b) {
                    assertSpaceUnlocked(this);
                    delete this.collisionHandlers[hashPair(a, b)];
                };
                Space.prototype.setDefaultCollisionHandler = function(begin, preSolve, postSolve, separate) {
                    assertSpaceUnlocked(this);
                    var handler = new CollisionHandler();
                    if (begin) {
                        handler.begin = begin;
                    }
                    if (preSolve) {
                        handler.preSolve = preSolve;
                    }
                    if (postSolve) {
                        handler.postSolve = postSolve;
                    }
                    if (separate) {
                        handler.separate = separate;
                    }
                    this.defaultHandler = handler;
                };
                Space.prototype.lookupHandler = function(a, b) {
                    return this.collisionHandlers[hashPair(a, b)] || this.defaultHandler;
                };
                Space.prototype.addShape = function(shape) {
                    var body = shape.body;
                    if (body.isStatic()) {
                        return this.addStaticShape(shape);
                    }
                    assert(!shape.space, "This shape is already added to a space and cannot be added to another.");
                    assertSpaceUnlocked(this);
                    body.activate();
                    body.addShape(shape);
                    shape.update(body.p, body.rot);
                    this.activeShapes.insert(shape, shape.hashid);
                    shape.space = this;
                    return shape;
                };
                Space.prototype.addStaticShape = function(shape) {
                    assert(!shape.space, "This shape is already added to a space and cannot be added to another.");
                    assertSpaceUnlocked(this);
                    var body = shape.body;
                    body.addShape(shape);
                    shape.update(body.p, body.rot);
                    this.staticShapes.insert(shape, shape.hashid);
                    shape.space = this;
                    return shape;
                };
                Space.prototype.addBody = function(body) {
                    assert(!body.isStatic(), "Static bodies cannot be added to a space as they are not meant to be simulated.");
                    assert(!body.space, "This body is already added to a space and cannot be added to another.");
                    assertSpaceUnlocked(this);
                    this.bodies.push(body);
                    body.space = this;
                    return body;
                };
                Space.prototype.addConstraint = function(constraint) {
                    assert(!constraint.space, "This shape is already added to a space and cannot be added to another.");
                    assertSpaceUnlocked(this);
                    var a = constraint.a, b = constraint.b;
                    a.activate();
                    b.activate();
                    this.constraints.push(constraint);
                    constraint.next_a = a.constraintList;
                    a.constraintList = constraint;
                    constraint.next_b = b.constraintList;
                    b.constraintList = constraint;
                    constraint.space = this;
                    return constraint;
                };
                Space.prototype.filterArbiters = function(body, filter) {
                    for (var hash in this.cachedArbiters) {
                        var arb = this.cachedArbiters[hash];
                        if (body === arb.body_a && (filter === arb.a || null === filter) || body === arb.body_b && (filter === arb.b || null === filter)) {
                            if (filter && "cached" !== arb.state) {
                                arb.callSeparate(this);
                            }
                            arb.unthread();
                            deleteObjFromList(this.arbiters, arb);
                            delete this.cachedArbiters[hash];
                        }
                    }
                };
                Space.prototype.removeShape = function(shape) {
                    var body = shape.body;
                    if (body.isStatic()) {
                        this.removeStaticShape(shape);
                    } else {
                        assert(this.containsShape(shape), "Cannot remove a shape that was not added to the space. (Removed twice maybe?)");
                        assertSpaceUnlocked(this);
                        body.activate();
                        body.removeShape(shape);
                        this.filterArbiters(body, shape);
                        this.activeShapes.remove(shape, shape.hashid);
                        shape.space = null;
                    }
                };
                Space.prototype.removeStaticShape = function(shape) {
                    assert(this.containsShape(shape), "Cannot remove a static or sleeping shape that was not added to the space. (Removed twice maybe?)");
                    assertSpaceUnlocked(this);
                    var body = shape.body;
                    if (body.isStatic()) {
                        body.activateStatic(shape);
                    }
                    body.removeShape(shape);
                    this.filterArbiters(body, shape);
                    this.staticShapes.remove(shape, shape.hashid);
                    shape.space = null;
                };
                Space.prototype.removeBody = function(body) {
                    assert(this.containsBody(body), "Cannot remove a body that was not added to the space. (Removed twice maybe?)");
                    assertSpaceUnlocked(this);
                    body.activate();
                    deleteObjFromList(this.bodies, body);
                    body.space = null;
                };
                Space.prototype.removeConstraint = function(constraint) {
                    assert(this.containsConstraint(constraint), "Cannot remove a constraint that was not added to the space. (Removed twice maybe?)");
                    assertSpaceUnlocked(this);
                    constraint.a.activate();
                    constraint.b.activate();
                    deleteObjFromList(this.constraints, constraint);
                    constraint.a.removeConstraint(constraint);
                    constraint.b.removeConstraint(constraint);
                    constraint.space = null;
                };
                Space.prototype.containsShape = function(shape) {
                    return shape.space === this;
                };
                Space.prototype.containsBody = function(body) {
                    return body.space == this;
                };
                Space.prototype.containsConstraint = function(constraint) {
                    return constraint.space == this;
                };
                Space.prototype.uncacheArbiter = function(arb) {
                    delete this.cachedArbiters[hashPair(arb.a.hashid, arb.b.hashid)];
                    deleteObjFromList(this.arbiters, arb);
                };
                Space.prototype.eachBody = function(func) {
                    this.lock();
                    var bodies = this.bodies;
                    for (var i = 0; i < bodies.length; i++) {
                        func(bodies[i]);
                    }
                    var components = this.sleepingComponents;
                    for (var i = 0; i < components.length; i++) {
                        var root = components[i];
                        var body = root;
                        while (body) {
                            var next = body.nodeNext;
                            func(body);
                            body = next;
                        }
                    }
                    this.unlock(true);
                };
                Space.prototype.eachShape = function(func) {
                    this.lock();
                    this.activeShapes.each(func);
                    this.staticShapes.each(func);
                    this.unlock(true);
                };
                Space.prototype.eachConstraint = function(func) {
                    this.lock();
                    var constraints = this.constraints;
                    for (var i = 0; i < constraints.length; i++) {
                        func(constraints[i]);
                    }
                    this.unlock(true);
                };
                Space.prototype.reindexStatic = function() {
                    assert(!this.locked, "You cannot manually reindex objects while the space is locked. Wait until the current query or step is complete.");
                    this.staticShapes.each(function(shape) {
                        var body = shape.body;
                        shape.update(body.p, body.rot);
                    });
                    this.staticShapes.reindex();
                };
                Space.prototype.reindexShape = function(shape) {
                    assert(!this.locked, "You cannot manually reindex objects while the space is locked. Wait until the current query or step is complete.");
                    var body = shape.body;
                    shape.update(body.p, body.rot);
                    this.activeShapes.reindexObject(shape, shape.hashid);
                    this.staticShapes.reindexObject(shape, shape.hashid);
                };
                Space.prototype.reindexShapesForBody = function(body) {
                    for (var shape = body.shapeList; shape; shape = shape.next) {
                        this.reindexShape(shape);
                    }
                };
                Space.prototype.useSpatialHash = function(dim, count) {
                    throw new Error("Spatial Hash not implemented.");
                    var staticShapes;
                    var activeShapes;
                };
                Space.prototype.activateBody = function(body) {
                    assert(!body.isRogue(), "Internal error: Attempting to activate a rogue body.");
                    if (this.locked) {
                        if (-1 === this.rousedBodies.indexOf(body)) {
                            this.rousedBodies.push(body);
                        }
                    } else {
                        this.bodies.push(body);
                        for (var i = 0; i < body.shapeList.length; i++) {
                            var shape = body.shapeList[i];
                            this.staticShapes.remove(shape, shape.hashid);
                            this.activeShapes.insert(shape, shape.hashid);
                        }
                        for (var arb = body.arbiterList; arb; arb = arb.next(body)) {
                            var bodyA = arb.body_a;
                            if (body === bodyA || bodyA.isStatic()) {
                                var a = arb.a, b = arb.b;
                                this.cachedArbiters[hashPair(a.hashid, b.hashid)] = arb;
                                arb.stamp = this.stamp;
                                arb.handler = this.lookupHandler(a.collision_type, b.collision_type);
                                this.arbiters.push(arb);
                            }
                        }
                        for (var constraint = body.constraintList; constraint; constraint = constraint.nodeNext) {
                            var bodyA = constraint.a;
                            if (body === bodyA || bodyA.isStatic()) {
                                this.constraints.push(constraint);
                            }
                        }
                    }
                };
                Space.prototype.deactivateBody = function(body) {
                    assert(!body.isRogue(), "Internal error: Attempting to deactivate a rogue body.");
                    deleteObjFromList(this.bodies, body);
                    for (var i = 0; i < body.shapeList.length; i++) {
                        var shape = body.shapeList[i];
                        this.activeShapes.remove(shape, shape.hashid);
                        this.staticShapes.insert(shape, shape.hashid);
                    }
                    for (var arb = body.arbiterList; arb; arb = arb.next(body)) {
                        var bodyA = arb.body_a;
                        if (body === bodyA || bodyA.isStatic()) {
                            this.uncacheArbiter(arb);
                        }
                    }
                    for (var constraint = body.constraintList; constraint; constraint = constraint.nodeNext) {
                        var bodyA = constraint.a;
                        if (body === bodyA || bodyA.isStatic()) {
                            deleteObjFromList(this.constraints, constraint);
                        }
                    }
                };
                var componentRoot = function(body) {
                    return body ? body.nodeRoot : null;
                };
                var componentActivate = function(root) {
                    if (!root || !root.isSleeping(root)) {
                        return;
                    }
                    assert(!root.isRogue(), "Internal Error: componentActivate() called on a rogue body.");
                    var space = root.space;
                    var body = root;
                    while (body) {
                        var next = body.nodeNext;
                        body.nodeIdleTime = 0;
                        body.nodeRoot = null;
                        body.nodeNext = null;
                        space.activateBody(body);
                        body = next;
                    }
                    deleteObjFromList(space.sleepingComponents, root);
                };
                Body.prototype.activate = function() {
                    if (!this.isRogue()) {
                        this.nodeIdleTime = 0;
                        componentActivate(componentRoot(this));
                    }
                };
                Body.prototype.activateStatic = function(filter) {
                    assert(this.isStatic(), "Body.activateStatic() called on a non-static body.");
                    for (var arb = this.arbiterList; arb; arb = arb.next(this)) {
                        if (!filter || filter == arb.a || filter == arb.b) {
                            (arb.body_a == this ? arb.body_b : arb.body_a).activate();
                        }
                    }
                };
                Body.prototype.pushArbiter = function(arb) {
                    assertSoft(null === (arb.body_a === this ? arb.thread_a_next : arb.thread_b_next), "Internal Error: Dangling contact graph pointers detected. (A)");
                    assertSoft(null === (arb.body_a === this ? arb.thread_a_prev : arb.thread_b_prev), "Internal Error: Dangling contact graph pointers detected. (B)");
                    var next = this.arbiterList;
                    assertSoft(null === next || null === (next.body_a === this ? next.thread_a_prev : next.thread_b_prev), "Internal Error: Dangling contact graph pointers detected. (C)");
                    if (arb.body_a === this) {
                        arb.thread_a_next = next;
                    } else {
                        arb.thread_b_next = next;
                    }
                    if (next) {
                        if (next.body_a === this) {
                            next.thread_a_prev = arb;
                        } else {
                            next.thread_b_prev = arb;
                        }
                    }
                    this.arbiterList = arb;
                };
                var componentAdd = function(root, body) {
                    body.nodeRoot = root;
                    if (body !== root) {
                        body.nodeNext = root.nodeNext;
                        root.nodeNext = body;
                    }
                };
                var floodFillComponent = function(root, body) {
                    if (!body.isRogue()) {
                        var other_root = componentRoot(body);
                        if (null == other_root) {
                            componentAdd(root, body);
                            for (var arb = body.arbiterList; arb; arb = arb.next(body)) {
                                floodFillComponent(root, body == arb.body_a ? arb.body_b : arb.body_a);
                            }
                            for (var constraint = body.constraintList; constraint; constraint = constraint.next(body)) {
                                floodFillComponent(root, body == constraint.a ? constraint.b : constraint.a);
                            }
                        } else {
                            assertSoft(other_root === root, "Internal Error: Inconsistency detected in the contact graph.");
                        }
                    }
                };
                var componentActive = function(root, threshold) {
                    for (var body = root; body; body = body.nodeNext) {
                        if (body.nodeIdleTime < threshold) {
                            return true;
                        }
                    }
                    return false;
                };
                Space.prototype.processComponents = function(dt) {
                    var sleep = this.sleepTimeThreshold !== 1 / 0;
                    var bodies = this.bodies;
                    for (var i = 0; i < bodies.length; i++) {
                        var body = bodies[i];
                        assertSoft(null === body.nodeNext, "Internal Error: Dangling next pointer detected in contact graph.");
                        assertSoft(null === body.nodeRoot, "Internal Error: Dangling root pointer detected in contact graph.");
                    }
                    if (sleep) {
                        var dv = this.idleSpeedThreshold;
                        var dvsq = dv ? dv * dv : vlengthsq(this.gravity) * dt * dt;
                        for (var i = 0; i < bodies.length; i++) {
                            var body = bodies[i];
                            var keThreshold = dvsq ? body.m * dvsq : 0;
                            body.nodeIdleTime = body.kineticEnergy() > keThreshold ? 0 : body.nodeIdleTime + dt;
                        }
                    }
                    var arbiters = this.arbiters;
                    for (var i = 0, count = arbiters.length; i < count; i++) {
                        var arb = arbiters[i];
                        var a = arb.body_a, b = arb.body_b;
                        if (sleep) {
                            if (b.isRogue() && !b.isStatic() || a.isSleeping()) {
                                a.activate();
                            }
                            if (a.isRogue() && !a.isStatic() || b.isSleeping()) {
                                b.activate();
                            }
                        }
                        a.pushArbiter(arb);
                        b.pushArbiter(arb);
                    }
                    if (sleep) {
                        var constraints = this.constraints;
                        for (var i = 0; i < constraints.length; i++) {
                            var constraint = constraints[i];
                            var a = constraint.a, b = constraint.b;
                            if (b.isRogue() && !b.isStatic()) {
                                a.activate();
                            }
                            if (a.isRogue() && !a.isStatic()) {
                                b.activate();
                            }
                        }
                        for (var i = 0; i < bodies.length; ) {
                            var body = bodies[i];
                            if (null === componentRoot(body)) {
                                floodFillComponent(body, body);
                                if (!componentActive(body, this.sleepTimeThreshold)) {
                                    this.sleepingComponents.push(body);
                                    for (var other = body; other; other = other.nodeNext) {
                                        this.deactivateBody(other);
                                    }
                                    continue;
                                }
                            }
                            i++;
                            body.nodeRoot = null;
                            body.nodeNext = null;
                        }
                    }
                };
                Body.prototype.sleep = function() {
                    this.sleepWithGroup(null);
                };
                Body.prototype.sleepWithGroup = function(group) {
                    assert(!this.isStatic() && !this.isRogue(), "Rogue and static bodies cannot be put to sleep.");
                    var space = this.space;
                    assert(space, "Cannot put a rogue body to sleep.");
                    assert(!space.locked, "Bodies cannot be put to sleep during a query or a call to cpSpaceStep(). Put these calls into a post-step callback.");
                    assert(null === group || group.isSleeping(), "Cannot use a non-sleeping body as a group identifier.");
                    if (this.isSleeping()) {
                        assert(componentRoot(this) === componentRoot(group), "The body is already sleeping and it's group cannot be reassigned.");
                        return;
                    }
                    for (var i = 0; i < this.shapeList.length; i++) {
                        this.shapeList[i].update(this.p, this.rot);
                    }
                    space.deactivateBody(this);
                    if (group) {
                        var root = componentRoot(group);
                        this.nodeRoot = root;
                        this.nodeNext = root.nodeNext;
                        this.nodeIdleTime = 0;
                        root.nodeNext = this;
                    } else {
                        this.nodeRoot = this;
                        this.nodeNext = null;
                        this.nodeIdleTime = 0;
                        space.sleepingComponents.push(this);
                    }
                    deleteObjFromList(space.bodies, this);
                };
                Space.prototype.activateShapesTouchingShape = function(shape) {
                    if (this.sleepTimeThreshold !== 1 / 0) {
                        this.shapeQuery(shape, function(shape, points) {
                            shape.body.activate();
                        });
                    }
                };
                Space.prototype.pointQuery = function(point, layers, group, func) {
                    var helper = function(shape) {
                        if (!(shape.group && group === shape.group) && layers & shape.layers && shape.pointQuery(point)) {
                            func(shape);
                        }
                    };
                    var bb = new BB(point.x, point.y, point.x, point.y);
                    this.lock();
                    this.activeShapes.query(bb, helper);
                    this.staticShapes.query(bb, helper);
                    this.unlock(true);
                };
                Space.prototype.pointQueryFirst = function(point, layers, group) {
                    var outShape = null;
                    this.pointQuery(point, layers, group, function(shape) {
                        if (!shape.sensor) {
                            outShape = shape;
                        }
                    });
                    return outShape;
                };
                Space.prototype.nearestPointQuery = function(point, maxDistance, layers, group, func) {
                    var helper = function(shape) {
                        if (!(shape.group && group === shape.group) && layers & shape.layers) {
                            var info = shape.nearestPointQuery(point);
                            if (info.d < maxDistance) {
                                func(shape, info.d, info.p);
                            }
                        }
                    };
                    var bb = bbNewForCircle(point, maxDistance);
                    this.lock();
                    this.activeShapes.query(bb, helper);
                    this.staticShapes.query(bb, helper);
                    this.unlock(true);
                };
                Space.prototype.nearestPointQueryNearest = function(point, maxDistance, layers, group) {
                    var out;
                    var helper = function(shape) {
                        if (!(shape.group && group === shape.group) && layers & shape.layers && !shape.sensor) {
                            var info = shape.nearestPointQuery(point);
                            if (info.d < maxDistance && (!out || info.d < out.d)) {
                                out = info;
                            }
                        }
                    };
                    var bb = bbNewForCircle(point, maxDistance);
                    this.activeShapes.query(bb, helper);
                    this.staticShapes.query(bb, helper);
                    return out;
                };
                Space.prototype.segmentQuery = function(start, end, layers, group, func) {
                    var helper = function(shape) {
                        var info;
                        if (!(shape.group && group === shape.group) && layers & shape.layers && (info = shape.segmentQuery(start, end))) {
                            func(shape, info.t, info.n);
                        }
                        return 1;
                    };
                    this.lock();
                    this.staticShapes.segmentQuery(start, end, 1, helper);
                    this.activeShapes.segmentQuery(start, end, 1, helper);
                    this.unlock(true);
                };
                Space.prototype.segmentQueryFirst = function(start, end, layers, group) {
                    var out = null;
                    var helper = function(shape) {
                        var info;
                        if (!(shape.group && group === shape.group) && layers & shape.layers && !shape.sensor && (info = shape.segmentQuery(start, end)) && (null === out || info.t < out.t)) {
                            out = info;
                        }
                        return out ? out.t : 1;
                    };
                    this.staticShapes.segmentQuery(start, end, 1, helper);
                    this.activeShapes.segmentQuery(start, end, out ? out.t : 1, helper);
                    return out;
                };
                Space.prototype.bbQuery = function(bb, layers, group, func) {
                    var helper = function(shape) {
                        if (!(shape.group && group === shape.group) && layers & shape.layers && bbIntersects2(bb, shape.bb_l, shape.bb_b, shape.bb_r, shape.bb_t)) {
                            func(shape);
                        }
                    };
                    this.lock();
                    this.activeShapes.query(bb, helper);
                    this.staticShapes.query(bb, helper);
                    this.unlock(true);
                };
                Space.prototype.shapeQuery = function(shape, func) {
                    var body = shape.body;
                    if (body) {
                        shape.update(body.p, body.rot);
                    }
                    var bb = new BB(shape.bb_l, shape.bb_b, shape.bb_r, shape.bb_t);
                    var anyCollision = false;
                    var helper = function(b) {
                        var a = shape;
                        if (a.group && a.group === b.group || !(a.layers & b.layers) || a === b) {
                            return;
                        }
                        var contacts;
                        if (a.collisionCode <= b.collisionCode) {
                            contacts = collideShapes(a, b);
                        } else {
                            contacts = collideShapes(b, a);
                            for (var i = 0; i < contacts.length; i++) {
                                contacts[i].n = vneg(contacts[i].n);
                            }
                        }
                        if (contacts.length) {
                            anyCollision = !(a.sensor || b.sensor);
                            if (func) {
                                var set = new Array(contacts.length);
                                for (var i = 0; i < contacts.length; i++) {
                                    set[i] = new ContactPoint(contacts[i].p, contacts[i].n, contacts[i].dist);
                                }
                                func(b, set);
                            }
                        }
                    };
                    this.lock();
                    this.activeShapes.query(bb, helper);
                    this.staticShapes.query(bb, helper);
                    this.unlock(true);
                    return anyCollision;
                };
                Space.prototype.addPostStepCallback = function(func) {
                    assertSoft(this.locked, "Adding a post-step callback when the space is not locked is unnecessary. Post-step callbacks will not called until the end of the next call to cpSpaceStep() or the next query.");
                    this.postStepCallbacks.push(func);
                };
                Space.prototype.runPostStepCallbacks = function() {
                    for (var i = 0; i < this.postStepCallbacks.length; i++) {
                        this.postStepCallbacks[i]();
                    }
                    this.postStepCallbacks = [];
                };
                Space.prototype.lock = function() {
                    this.locked++;
                };
                Space.prototype.unlock = function(runPostStep) {
                    this.locked--;
                    assert(this.locked >= 0, "Internal Error: Space lock underflow.");
                    if (0 === this.locked && runPostStep) {
                        var waking = this.rousedBodies;
                        for (var i = 0; i < waking.length; i++) {
                            this.activateBody(waking[i]);
                        }
                        waking.length = 0;
                        this.runPostStepCallbacks();
                    }
                };
                Space.prototype.makeCollideShapes = function() {
                    var space_ = this;
                    return function(a, b) {
                        var space = space_;
                        if (!(a.bb_l <= b.bb_r && b.bb_l <= a.bb_r && a.bb_b <= b.bb_t && b.bb_b <= a.bb_t) || a.body === b.body || a.group && a.group === b.group || !(a.layers & b.layers)) {
                            return;
                        }
                        var handler = space.lookupHandler(a.collision_type, b.collision_type);
                        var sensor = a.sensor || b.sensor;
                        if (sensor && handler === defaultCollisionHandler) {
                            return;
                        }
                        if (a.collisionCode > b.collisionCode) {
                            var temp = a;
                            a = b;
                            b = temp;
                        }
                        var contacts = collideShapes(a, b);
                        if (0 === contacts.length) {
                            return;
                        }
                        var arbHash = hashPair(a.hashid, b.hashid);
                        var arb = space.cachedArbiters[arbHash];
                        if (!arb) {
                            arb = space.cachedArbiters[arbHash] = new Arbiter(a, b);
                        }
                        arb.update(contacts, handler, a, b);
                        if ("first coll" == arb.state && !handler.begin(arb, space)) {
                            arb.ignore();
                        }
                        if ("ignore" !== arb.state && handler.preSolve(arb, space) && !sensor) {
                            space.arbiters.push(arb);
                        } else {
                            arb.contacts = null;
                            if ("ignore" !== arb.state) {
                                arb.state = "normal";
                            }
                        }
                        arb.stamp = space.stamp;
                    };
                };
                Space.prototype.arbiterSetFilter = function(arb) {
                    var ticks = this.stamp - arb.stamp;
                    var a = arb.body_a, b = arb.body_b;
                    if ((a.isStatic() || a.isSleeping()) && (b.isStatic() || b.isSleeping())) {
                        return true;
                    }
                    if (ticks >= 1 && "cached" != arb.state) {
                        arb.callSeparate(this);
                        arb.state = "cached";
                    }
                    if (ticks >= this.collisionPersistence) {
                        arb.contacts = null;
                        return false;
                    }
                    return true;
                };
                var updateFunc = function(shape) {
                    var body = shape.body;
                    shape.update(body.p, body.rot);
                };
                Space.prototype.step = function(dt) {
                    if (0 === dt) {
                        return;
                    }
                    assert(0 === vzero.x && 0 === vzero.y, "vzero is invalid");
                    this.stamp++;
                    var prev_dt = this.curr_dt;
                    this.curr_dt = dt;
                    var i;
                    var j;
                    var hash;
                    var bodies = this.bodies;
                    var constraints = this.constraints;
                    var arbiters = this.arbiters;
                    for (i = 0; i < arbiters.length; i++) {
                        var arb = arbiters[i];
                        arb.state = "normal";
                        if (!arb.body_a.isSleeping() && !arb.body_b.isSleeping()) {
                            arb.unthread();
                        }
                    }
                    arbiters.length = 0;
                    this.lock();
                    for (i = 0; i < bodies.length; i++) {
                        bodies[i].position_func(dt);
                    }
                    this.activeShapes.each(updateFunc);
                    this.activeShapes.reindexQuery(this.collideShapes);
                    this.unlock(false);
                    this.processComponents(dt);
                    this.lock();
                    for (hash in this.cachedArbiters) {
                        if (!this.arbiterSetFilter(this.cachedArbiters[hash])) {
                            delete this.cachedArbiters[hash];
                        }
                    }
                    var slop = this.collisionSlop;
                    var biasCoef = 1 - Math.pow(this.collisionBias, dt);
                    for (i = 0; i < arbiters.length; i++) {
                        arbiters[i].preStep(dt, slop, biasCoef);
                    }
                    for (i = 0; i < constraints.length; i++) {
                        var constraint = constraints[i];
                        constraint.preSolve(this);
                        constraint.preStep(dt);
                    }
                    var damping = Math.pow(this.damping, dt);
                    var gravity = this.gravity;
                    for (i = 0; i < bodies.length; i++) {
                        bodies[i].velocity_func(gravity, damping, dt);
                    }
                    var dt_coef = 0 === prev_dt ? 0 : dt / prev_dt;
                    for (i = 0; i < arbiters.length; i++) {
                        arbiters[i].applyCachedImpulse(dt_coef);
                    }
                    for (i = 0; i < constraints.length; i++) {
                        constraints[i].applyCachedImpulse(dt_coef);
                    }
                    for (i = 0; i < this.iterations; i++) {
                        for (j = 0; j < arbiters.length; j++) {
                            arbiters[j].applyImpulse();
                        }
                        for (j = 0; j < constraints.length; j++) {
                            constraints[j].applyImpulse();
                        }
                    }
                    for (i = 0; i < constraints.length; i++) {
                        constraints[i].postSolve(this);
                    }
                    for (i = 0; i < arbiters.length; i++) {
                        arbiters[i].handler.postSolve(arbiters[i], this);
                    }
                    this.unlock(true);
                };
                var relative_velocity = function(a, b, r1, r2) {
                    var v1_sumx = a.vx + -r1.y * a.w;
                    var v1_sumy = a.vy + r1.x * a.w;
                    var v2_sumx = b.vx + -r2.y * b.w;
                    var v2_sumy = b.vy + r2.x * b.w;
                    return new Vect(v2_sumx - v1_sumx, v2_sumy - v1_sumy);
                };
                var normal_relative_velocity = function(a, b, r1, r2, n) {
                    var v1_sumx = a.vx + -r1.y * a.w;
                    var v1_sumy = a.vy + r1.x * a.w;
                    var v2_sumx = b.vx + -r2.y * b.w;
                    var v2_sumy = b.vy + r2.x * b.w;
                    return vdot2(v2_sumx - v1_sumx, v2_sumy - v1_sumy, n.x, n.y);
                };
                var apply_impulse = function(body, jx, jy, r) {
                    body.vx += jx * body.m_inv;
                    body.vy += jy * body.m_inv;
                    body.w += body.i_inv * (r.x * jy - r.y * jx);
                };
                var apply_impulses = function(a, b, r1, r2, jx, jy) {
                    apply_impulse(a, -jx, -jy, r1);
                    apply_impulse(b, jx, jy, r2);
                };
                var apply_bias_impulse = function(body, jx, jy, r) {
                    body.v_biasx += jx * body.m_inv;
                    body.v_biasy += jy * body.m_inv;
                    body.w_bias += body.i_inv * vcross2(r.x, r.y, jx, jy);
                };
                var k_scalar_body = function(body, r, n) {
                    var rcn = vcross(r, n);
                    return body.m_inv + body.i_inv * rcn * rcn;
                };
                var k_scalar = function(a, b, r1, r2, n) {
                    var value = k_scalar_body(a, r1, n) + k_scalar_body(b, r2, n);
                    assertSoft(0 !== value, "Unsolvable collision or constraint.");
                    return value;
                };
                var k_tensor = function(a, b, r1, r2, k1, k2) {
                    var k11, k12, k21, k22;
                    var m_sum = a.m_inv + b.m_inv;
                    k11 = m_sum;
                    k12 = 0;
                    k21 = 0;
                    k22 = m_sum;
                    var a_i_inv = a.i_inv;
                    var r1xsq = r1.x * r1.x * a_i_inv;
                    var r1ysq = r1.y * r1.y * a_i_inv;
                    var r1nxy = -r1.x * r1.y * a_i_inv;
                    k11 += r1ysq;
                    k12 += r1nxy;
                    k21 += r1nxy;
                    k22 += r1xsq;
                    var b_i_inv = b.i_inv;
                    var r2xsq = r2.x * r2.x * b_i_inv;
                    var r2ysq = r2.y * r2.y * b_i_inv;
                    var r2nxy = -r2.x * r2.y * b_i_inv;
                    k11 += r2ysq;
                    k12 += r2nxy;
                    k21 += r2nxy;
                    k22 += r2xsq;
                    var determinant = k11 * k22 - k12 * k21;
                    assertSoft(0 !== determinant, "Unsolvable constraint.");
                    var det_inv = 1 / determinant;
                    k1.x = k22 * det_inv;
                    k1.y = -k12 * det_inv;
                    k2.x = -k21 * det_inv;
                    k2.y = k11 * det_inv;
                };
                var mult_k = function(vr, k1, k2) {
                    return new Vect(vdot(vr, k1), vdot(vr, k2));
                };
                var bias_coef = function(errorBias, dt) {
                    return 1 - Math.pow(errorBias, dt);
                };
                var Constraint = cp.Constraint = function(a, b) {
                    this.a = a;
                    this.b = b;
                    this.space = null;
                    this.next_a = null;
                    this.next_b = null;
                    this.maxForce = 1 / 0;
                    this.errorBias = Math.pow(.9, 60);
                    this.maxBias = 1 / 0;
                };
                Constraint.prototype.activateBodies = function() {
                    if (this.a) {
                        this.a.activate();
                    }
                    if (this.b) {
                        this.b.activate();
                    }
                };
                Constraint.prototype.preStep = function(dt) {};
                Constraint.prototype.applyCachedImpulse = function(dt_coef) {};
                Constraint.prototype.applyImpulse = function() {};
                Constraint.prototype.getImpulse = function() {
                    return 0;
                };
                Constraint.prototype.preSolve = function(space) {};
                Constraint.prototype.postSolve = function(space) {};
                Constraint.prototype.next = function(body) {
                    return this.a === body ? this.next_a : this.next_b;
                };
                var PinJoint = cp.PinJoint = function(a, b, anchr1, anchr2) {
                    Constraint.call(this, a, b);
                    this.anchr1 = anchr1;
                    this.anchr2 = anchr2;
                    var p1 = a ? vadd(a.p, vrotate(anchr1, a.rot)) : anchr1;
                    var p2 = b ? vadd(b.p, vrotate(anchr2, b.rot)) : anchr2;
                    this.dist = vlength(vsub(p2, p1));
                    assertSoft(this.dist > 0, "You created a 0 length pin joint. A pivot joint will be much more stable.");
                    this.r1 = this.r2 = null;
                    this.n = null;
                    this.nMass = 0;
                    this.jnAcc = this.jnMax = 0;
                    this.bias = 0;
                };
                PinJoint.prototype = Object.create(Constraint.prototype);
                PinJoint.prototype.preStep = function(dt) {
                    var a = this.a;
                    var b = this.b;
                    this.r1 = vrotate(this.anchr1, a.rot);
                    this.r2 = vrotate(this.anchr2, b.rot);
                    var delta = vsub(vadd(b.p, this.r2), vadd(a.p, this.r1));
                    var dist = vlength(delta);
                    this.n = vmult(delta, 1 / (dist ? dist : 1 / 0));
                    this.nMass = 1 / k_scalar(a, b, this.r1, this.r2, this.n);
                    var maxBias = this.maxBias;
                    this.bias = clamp(-bias_coef(this.errorBias, dt) * (dist - this.dist) / dt, -maxBias, maxBias);
                    this.jnMax = this.maxForce * dt;
                };
                PinJoint.prototype.applyCachedImpulse = function(dt_coef) {
                    var j = vmult(this.n, this.jnAcc * dt_coef);
                    apply_impulses(this.a, this.b, this.r1, this.r2, j.x, j.y);
                };
                PinJoint.prototype.applyImpulse = function() {
                    var a = this.a;
                    var b = this.b;
                    var n = this.n;
                    var vrn = normal_relative_velocity(a, b, this.r1, this.r2, n);
                    var jn = (this.bias - vrn) * this.nMass;
                    var jnOld = this.jnAcc;
                    this.jnAcc = clamp(jnOld + jn, -this.jnMax, this.jnMax);
                    jn = this.jnAcc - jnOld;
                    apply_impulses(a, b, this.r1, this.r2, n.x * jn, n.y * jn);
                };
                PinJoint.prototype.getImpulse = function() {
                    return Math.abs(this.jnAcc);
                };
                var SlideJoint = cp.SlideJoint = function(a, b, anchr1, anchr2, min, max) {
                    Constraint.call(this, a, b);
                    this.anchr1 = anchr1;
                    this.anchr2 = anchr2;
                    this.min = min;
                    this.max = max;
                    this.r1 = this.r2 = this.n = null;
                    this.nMass = 0;
                    this.jnAcc = this.jnMax = 0;
                    this.bias = 0;
                };
                SlideJoint.prototype = Object.create(Constraint.prototype);
                SlideJoint.prototype.preStep = function(dt) {
                    var a = this.a;
                    var b = this.b;
                    this.r1 = vrotate(this.anchr1, a.rot);
                    this.r2 = vrotate(this.anchr2, b.rot);
                    var delta = vsub(vadd(b.p, this.r2), vadd(a.p, this.r1));
                    var dist = vlength(delta);
                    var pdist = 0;
                    if (dist > this.max) {
                        pdist = dist - this.max;
                        this.n = vnormalize_safe(delta);
                    } else {
                        if (dist < this.min) {
                            pdist = this.min - dist;
                            this.n = vneg(vnormalize_safe(delta));
                        } else {
                            this.n = vzero;
                            this.jnAcc = 0;
                        }
                    }
                    this.nMass = 1 / k_scalar(a, b, this.r1, this.r2, this.n);
                    var maxBias = this.maxBias;
                    this.bias = clamp(-bias_coef(this.errorBias, dt) * pdist / dt, -maxBias, maxBias);
                    this.jnMax = this.maxForce * dt;
                };
                SlideJoint.prototype.applyCachedImpulse = function(dt_coef) {
                    var jn = this.jnAcc * dt_coef;
                    apply_impulses(this.a, this.b, this.r1, this.r2, this.n.x * jn, this.n.y * jn);
                };
                SlideJoint.prototype.applyImpulse = function() {
                    if (0 === this.n.x && 0 === this.n.y) {
                        return;
                    }
                    var a = this.a;
                    var b = this.b;
                    var n = this.n;
                    var r1 = this.r1;
                    var r2 = this.r2;
                    var vr = relative_velocity(a, b, r1, r2);
                    var vrn = vdot(vr, n);
                    var jn = (this.bias - vrn) * this.nMass;
                    var jnOld = this.jnAcc;
                    this.jnAcc = clamp(jnOld + jn, -this.jnMax, 0);
                    jn = this.jnAcc - jnOld;
                    apply_impulses(a, b, this.r1, this.r2, n.x * jn, n.y * jn);
                };
                SlideJoint.prototype.getImpulse = function() {
                    return Math.abs(this.jnAcc);
                };
                var PivotJoint = cp.PivotJoint = function(a, b, anchr1, anchr2) {
                    Constraint.call(this, a, b);
                    if ("undefined" === typeof anchr2) {
                        var pivot = anchr1;
                        anchr1 = a ? a.world2Local(pivot) : pivot;
                        anchr2 = b ? b.world2Local(pivot) : pivot;
                    }
                    this.anchr1 = anchr1;
                    this.anchr2 = anchr2;
                    this.r1 = this.r2 = vzero;
                    this.k1 = new Vect(0, 0);
                    this.k2 = new Vect(0, 0);
                    this.jAcc = vzero;
                    this.jMaxLen = 0;
                    this.bias = vzero;
                };
                PivotJoint.prototype = Object.create(Constraint.prototype);
                PivotJoint.prototype.preStep = function(dt) {
                    var a = this.a;
                    var b = this.b;
                    this.r1 = vrotate(this.anchr1, a.rot);
                    this.r2 = vrotate(this.anchr2, b.rot);
                    k_tensor(a, b, this.r1, this.r2, this.k1, this.k2);
                    this.jMaxLen = this.maxForce * dt;
                    var delta = vsub(vadd(b.p, this.r2), vadd(a.p, this.r1));
                    this.bias = vclamp(vmult(delta, -bias_coef(this.errorBias, dt) / dt), this.maxBias);
                };
                PivotJoint.prototype.applyCachedImpulse = function(dt_coef) {
                    apply_impulses(this.a, this.b, this.r1, this.r2, this.jAcc.x * dt_coef, this.jAcc.y * dt_coef);
                };
                PivotJoint.prototype.applyImpulse = function() {
                    var a = this.a;
                    var b = this.b;
                    var r1 = this.r1;
                    var r2 = this.r2;
                    var vr = relative_velocity(a, b, r1, r2);
                    var j = mult_k(vsub(this.bias, vr), this.k1, this.k2);
                    var jOld = this.jAcc;
                    this.jAcc = vclamp(vadd(this.jAcc, j), this.jMaxLen);
                    apply_impulses(a, b, this.r1, this.r2, this.jAcc.x - jOld.x, this.jAcc.y - jOld.y);
                };
                PivotJoint.prototype.getImpulse = function() {
                    return vlength(this.jAcc);
                };
                var GrooveJoint = cp.GrooveJoint = function(a, b, groove_a, groove_b, anchr2) {
                    Constraint.call(this, a, b);
                    this.grv_a = groove_a;
                    this.grv_b = groove_b;
                    this.grv_n = vperp(vnormalize(vsub(groove_b, groove_a)));
                    this.anchr2 = anchr2;
                    this.grv_tn = null;
                    this.clamp = 0;
                    this.r1 = this.r2 = null;
                    this.k1 = new Vect(0, 0);
                    this.k2 = new Vect(0, 0);
                    this.jAcc = vzero;
                    this.jMaxLen = 0;
                    this.bias = null;
                };
                GrooveJoint.prototype = Object.create(Constraint.prototype);
                GrooveJoint.prototype.preStep = function(dt) {
                    var a = this.a;
                    var b = this.b;
                    var ta = a.local2World(this.grv_a);
                    var tb = a.local2World(this.grv_b);
                    var n = vrotate(this.grv_n, a.rot);
                    var d = vdot(ta, n);
                    this.grv_tn = n;
                    this.r2 = vrotate(this.anchr2, b.rot);
                    var td = vcross(vadd(b.p, this.r2), n);
                    if (td <= vcross(ta, n)) {
                        this.clamp = 1;
                        this.r1 = vsub(ta, a.p);
                    } else {
                        if (td >= vcross(tb, n)) {
                            this.clamp = -1;
                            this.r1 = vsub(tb, a.p);
                        } else {
                            this.clamp = 0;
                            this.r1 = vsub(vadd(vmult(vperp(n), -td), vmult(n, d)), a.p);
                        }
                    }
                    k_tensor(a, b, this.r1, this.r2, this.k1, this.k2);
                    this.jMaxLen = this.maxForce * dt;
                    var delta = vsub(vadd(b.p, this.r2), vadd(a.p, this.r1));
                    this.bias = vclamp(vmult(delta, -bias_coef(this.errorBias, dt) / dt), this.maxBias);
                };
                GrooveJoint.prototype.applyCachedImpulse = function(dt_coef) {
                    apply_impulses(this.a, this.b, this.r1, this.r2, this.jAcc.x * dt_coef, this.jAcc.y * dt_coef);
                };
                GrooveJoint.prototype.grooveConstrain = function(j) {
                    var n = this.grv_tn;
                    var jClamp = this.clamp * vcross(j, n) > 0 ? j : vproject(j, n);
                    return vclamp(jClamp, this.jMaxLen);
                };
                GrooveJoint.prototype.applyImpulse = function() {
                    var a = this.a;
                    var b = this.b;
                    var r1 = this.r1;
                    var r2 = this.r2;
                    var vr = relative_velocity(a, b, r1, r2);
                    var j = mult_k(vsub(this.bias, vr), this.k1, this.k2);
                    var jOld = this.jAcc;
                    this.jAcc = this.grooveConstrain(vadd(jOld, j));
                    apply_impulses(a, b, this.r1, this.r2, this.jAcc.x - jOld.x, this.jAcc.y - jOld.y);
                };
                GrooveJoint.prototype.getImpulse = function() {
                    return vlength(this.jAcc);
                };
                GrooveJoint.prototype.setGrooveA = function(value) {
                    this.grv_a = value;
                    this.grv_n = vperp(vnormalize(vsub(this.grv_b, value)));
                    this.activateBodies();
                };
                GrooveJoint.prototype.setGrooveB = function(value) {
                    this.grv_b = value;
                    this.grv_n = vperp(vnormalize(vsub(value, this.grv_a)));
                    this.activateBodies();
                };
                var defaultSpringForce = function(spring, dist) {
                    return (spring.restLength - dist) * spring.stiffness;
                };
                var DampedSpring = cp.DampedSpring = function(a, b, anchr1, anchr2, restLength, stiffness, damping) {
                    Constraint.call(this, a, b);
                    this.anchr1 = anchr1;
                    this.anchr2 = anchr2;
                    this.restLength = restLength;
                    this.stiffness = stiffness;
                    this.damping = damping;
                    this.springForceFunc = defaultSpringForce;
                    this.target_vrn = this.v_coef = 0;
                    this.r1 = this.r2 = null;
                    this.nMass = 0;
                    this.n = null;
                };
                DampedSpring.prototype = Object.create(Constraint.prototype);
                DampedSpring.prototype.preStep = function(dt) {
                    var a = this.a;
                    var b = this.b;
                    this.r1 = vrotate(this.anchr1, a.rot);
                    this.r2 = vrotate(this.anchr2, b.rot);
                    var delta = vsub(vadd(b.p, this.r2), vadd(a.p, this.r1));
                    var dist = vlength(delta);
                    this.n = vmult(delta, 1 / (dist ? dist : 1 / 0));
                    var k = k_scalar(a, b, this.r1, this.r2, this.n);
                    assertSoft(0 !== k, "Unsolvable this.");
                    this.nMass = 1 / k;
                    this.target_vrn = 0;
                    this.v_coef = 1 - Math.exp(-this.damping * dt * k);
                    var f_spring = this.springForceFunc(this, dist);
                    apply_impulses(a, b, this.r1, this.r2, this.n.x * f_spring * dt, this.n.y * f_spring * dt);
                };
                DampedSpring.prototype.applyCachedImpulse = function(dt_coef) {};
                DampedSpring.prototype.applyImpulse = function() {
                    var a = this.a;
                    var b = this.b;
                    var n = this.n;
                    var r1 = this.r1;
                    var r2 = this.r2;
                    var vrn = normal_relative_velocity(a, b, r1, r2, n);
                    var v_damp = (this.target_vrn - vrn) * this.v_coef;
                    this.target_vrn = vrn + v_damp;
                    v_damp *= this.nMass;
                    apply_impulses(a, b, this.r1, this.r2, this.n.x * v_damp, this.n.y * v_damp);
                };
                DampedSpring.prototype.getImpulse = function() {
                    return 0;
                };
                var defaultSpringTorque = function(spring, relativeAngle) {
                    return (relativeAngle - spring.restAngle) * spring.stiffness;
                };
                var DampedRotarySpring = cp.DampedRotarySpring = function(a, b, restAngle, stiffness, damping) {
                    Constraint.call(this, a, b);
                    this.restAngle = restAngle;
                    this.stiffness = stiffness;
                    this.damping = damping;
                    this.springTorqueFunc = defaultSpringTorque;
                    this.target_wrn = 0;
                    this.w_coef = 0;
                    this.iSum = 0;
                };
                DampedRotarySpring.prototype = Object.create(Constraint.prototype);
                DampedRotarySpring.prototype.preStep = function(dt) {
                    var a = this.a;
                    var b = this.b;
                    var moment = a.i_inv + b.i_inv;
                    assertSoft(0 !== moment, "Unsolvable spring.");
                    this.iSum = 1 / moment;
                    this.w_coef = 1 - Math.exp(-this.damping * dt * moment);
                    this.target_wrn = 0;
                    var j_spring = this.springTorqueFunc(this, a.a - b.a) * dt;
                    a.w -= j_spring * a.i_inv;
                    b.w += j_spring * b.i_inv;
                };
                DampedRotarySpring.prototype.applyImpulse = function() {
                    var a = this.a;
                    var b = this.b;
                    var wrn = a.w - b.w;
                    var w_damp = (this.target_wrn - wrn) * this.w_coef;
                    this.target_wrn = wrn + w_damp;
                    var j_damp = w_damp * this.iSum;
                    a.w += j_damp * a.i_inv;
                    b.w -= j_damp * b.i_inv;
                };
                var RotaryLimitJoint = cp.RotaryLimitJoint = function(a, b, min, max) {
                    Constraint.call(this, a, b);
                    this.min = min;
                    this.max = max;
                    this.jAcc = 0;
                    this.iSum = this.bias = this.jMax = 0;
                };
                RotaryLimitJoint.prototype = Object.create(Constraint.prototype);
                RotaryLimitJoint.prototype.preStep = function(dt) {
                    var a = this.a;
                    var b = this.b;
                    var dist = b.a - a.a;
                    var pdist = 0;
                    if (dist > this.max) {
                        pdist = this.max - dist;
                    } else {
                        if (dist < this.min) {
                            pdist = this.min - dist;
                        }
                    }
                    this.iSum = 1 / (1 / a.i + 1 / b.i);
                    var maxBias = this.maxBias;
                    this.bias = clamp(-bias_coef(this.errorBias, dt) * pdist / dt, -maxBias, maxBias);
                    this.jMax = this.maxForce * dt;
                    if (!this.bias) {
                        this.jAcc = 0;
                    }
                };
                RotaryLimitJoint.prototype.applyCachedImpulse = function(dt_coef) {
                    var a = this.a;
                    var b = this.b;
                    var j = this.jAcc * dt_coef;
                    a.w -= j * a.i_inv;
                    b.w += j * b.i_inv;
                };
                RotaryLimitJoint.prototype.applyImpulse = function() {
                    if (!this.bias) {
                        return;
                    }
                    var a = this.a;
                    var b = this.b;
                    var wr = b.w - a.w;
                    var j = -(this.bias + wr) * this.iSum;
                    var jOld = this.jAcc;
                    if (this.bias < 0) {
                        this.jAcc = clamp(jOld + j, 0, this.jMax);
                    } else {
                        this.jAcc = clamp(jOld + j, -this.jMax, 0);
                    }
                    j = this.jAcc - jOld;
                    a.w -= j * a.i_inv;
                    b.w += j * b.i_inv;
                };
                RotaryLimitJoint.prototype.getImpulse = function() {
                    return Math.abs(joint.jAcc);
                };
                var RatchetJoint = cp.RatchetJoint = function(a, b, phase, ratchet) {
                    Constraint.call(this, a, b);
                    this.angle = 0;
                    this.phase = phase;
                    this.ratchet = ratchet;
                    this.angle = (b ? b.a : 0) - (a ? a.a : 0);
                    this.iSum = this.bias = this.jAcc = this.jMax = 0;
                };
                RatchetJoint.prototype = Object.create(Constraint.prototype);
                RatchetJoint.prototype.preStep = function(dt) {
                    var a = this.a;
                    var b = this.b;
                    var angle = this.angle;
                    var phase = this.phase;
                    var ratchet = this.ratchet;
                    var delta = b.a - a.a;
                    var diff = angle - delta;
                    var pdist = 0;
                    if (diff * ratchet > 0) {
                        pdist = diff;
                    } else {
                        this.angle = Math.floor((delta - phase) / ratchet) * ratchet + phase;
                    }
                    this.iSum = 1 / (a.i_inv + b.i_inv);
                    var maxBias = this.maxBias;
                    this.bias = clamp(-bias_coef(this.errorBias, dt) * pdist / dt, -maxBias, maxBias);
                    this.jMax = this.maxForce * dt;
                    if (!this.bias) {
                        this.jAcc = 0;
                    }
                };
                RatchetJoint.prototype.applyCachedImpulse = function(dt_coef) {
                    var a = this.a;
                    var b = this.b;
                    var j = this.jAcc * dt_coef;
                    a.w -= j * a.i_inv;
                    b.w += j * b.i_inv;
                };
                RatchetJoint.prototype.applyImpulse = function() {
                    if (!this.bias) {
                        return;
                    }
                    var a = this.a;
                    var b = this.b;
                    var wr = b.w - a.w;
                    var ratchet = this.ratchet;
                    var j = -(this.bias + wr) * this.iSum;
                    var jOld = this.jAcc;
                    this.jAcc = clamp((jOld + j) * ratchet, 0, this.jMax * Math.abs(ratchet)) / ratchet;
                    j = this.jAcc - jOld;
                    a.w -= j * a.i_inv;
                    b.w += j * b.i_inv;
                };
                RatchetJoint.prototype.getImpulse = function(joint) {
                    return Math.abs(joint.jAcc);
                };
                var GearJoint = cp.GearJoint = function(a, b, phase, ratio) {
                    Constraint.call(this, a, b);
                    this.phase = phase;
                    this.ratio = ratio;
                    this.ratio_inv = 1 / ratio;
                    this.jAcc = 0;
                    this.iSum = this.bias = this.jMax = 0;
                };
                GearJoint.prototype = Object.create(Constraint.prototype);
                GearJoint.prototype.preStep = function(dt) {
                    var a = this.a;
                    var b = this.b;
                    this.iSum = 1 / (a.i_inv * this.ratio_inv + this.ratio * b.i_inv);
                    var maxBias = this.maxBias;
                    this.bias = clamp(-bias_coef(this.errorBias, dt) * (b.a * this.ratio - a.a - this.phase) / dt, -maxBias, maxBias);
                    this.jMax = this.maxForce * dt;
                };
                GearJoint.prototype.applyCachedImpulse = function(dt_coef) {
                    var a = this.a;
                    var b = this.b;
                    var j = this.jAcc * dt_coef;
                    a.w -= j * a.i_inv * this.ratio_inv;
                    b.w += j * b.i_inv;
                };
                GearJoint.prototype.applyImpulse = function() {
                    var a = this.a;
                    var b = this.b;
                    var wr = b.w * this.ratio - a.w;
                    var j = (this.bias - wr) * this.iSum;
                    var jOld = this.jAcc;
                    this.jAcc = clamp(jOld + j, -this.jMax, this.jMax);
                    j = this.jAcc - jOld;
                    a.w -= j * a.i_inv * this.ratio_inv;
                    b.w += j * b.i_inv;
                };
                GearJoint.prototype.getImpulse = function() {
                    return Math.abs(this.jAcc);
                };
                GearJoint.prototype.setRatio = function(value) {
                    this.ratio = value;
                    this.ratio_inv = 1 / value;
                    this.activateBodies();
                };
                var SimpleMotor = cp.SimpleMotor = function(a, b, rate) {
                    Constraint.call(this, a, b);
                    this.rate = rate;
                    this.jAcc = 0;
                    this.iSum = this.jMax = 0;
                };
                SimpleMotor.prototype = Object.create(Constraint.prototype);
                SimpleMotor.prototype.preStep = function(dt) {
                    this.iSum = 1 / (this.a.i_inv + this.b.i_inv);
                    this.jMax = this.maxForce * dt;
                };
                SimpleMotor.prototype.applyCachedImpulse = function(dt_coef) {
                    var a = this.a;
                    var b = this.b;
                    var j = this.jAcc * dt_coef;
                    a.w -= j * a.i_inv;
                    b.w += j * b.i_inv;
                };
                SimpleMotor.prototype.applyImpulse = function() {
                    var a = this.a;
                    var b = this.b;
                    var wr = b.w - a.w + this.rate;
                    var j = -wr * this.iSum;
                    var jOld = this.jAcc;
                    this.jAcc = clamp(jOld + j, -this.jMax, this.jMax);
                    j = this.jAcc - jOld;
                    a.w -= j * a.i_inv;
                    b.w += j * b.i_inv;
                };
                SimpleMotor.prototype.getImpulse = function() {
                    return Math.abs(this.jAcc);
                };
            }();
        }).call(window, cc, ccui, ccs, sp, cp);
    }, {
        "../cocos2d/core/CCGame": 19,
        "../cocos2d/core/event/event-target": 52,
        "../cocos2d/core/platform/CCLoader": 60,
        "../cocos2d/core/platform/CCSys": 63,
        "../cocos2d/core/sprites/CCSpriteFrame": 77,
        "../cocos2d/core/utils": 87
    } ],
    3: [ function(require, module, exports) {
        var JS = cc.js;
        var Animator = require("./animators").Animator;
        var DynamicAnimCurve = require("./animation-curves").DynamicAnimCurve;
        var SampledAnimCurve = require("./animation-curves").SampledAnimCurve;
        var sampleMotionPaths = require("./motion-path-helper").sampleMotionPaths;
        var EventAnimCurve = require("./animation-curves").EventAnimCurve;
        var EventInfo = require("./animation-curves").EventInfo;
        var WrapModeMask = require("./types").WrapModeMask;
        var binarySearch = require("./binary-search");
        function AnimationAnimator(target, animation) {
            Animator.call(this, target);
            this.animation = animation;
        }
        JS.extend(AnimationAnimator, Animator);
        var p = AnimationAnimator.prototype;
        p.playState = function(state, startTime) {
            if (!state.clip) {
                return;
            }
            if (!state.curveLoaded) {
                initClipData(this.target, state);
            }
            this.playingAnims.push(state);
            state.play();
            if ("number" === typeof startTime) {
                state.time = startTime;
            }
            this.play();
        };
        p.sample = function() {
            var anims = this.playingAnims;
            for (var i = 0; i < anims.length; i++) {
                var anim = anims[i];
                anim.sample();
            }
        };
        p.stopState = function(state) {
            if (JS.array.remove(this.playingAnims, state)) {
                state.stop();
            }
        };
        p.pauseState = function(state) {
            if (state) {
                state.pause();
            }
        };
        p.resumeState = function(state) {
            if (state) {
                state.resume();
            }
            if (this.isPaused) {
                this.resume();
            }
        };
        p.setStateTime = function(state, time) {
            if (state) {
                state.setTime(time);
            }
        };
        p.onStop = function() {
            var anims = this.playingAnims;
            for (var i = 0, l = anims.length; i < l; i++) {
                anims[i].stop();
            }
            Animator.prototype.onStop.call(this);
        };
        p.onPause = function() {
            var anims = this.playingAnims;
            for (var i = 0, l = anims.length; i < l; i++) {
                anims[i].pause();
            }
        };
        p.onResume = function() {
            var anims = this.playingAnims;
            for (var i = 0, l = anims.length; i < l; i++) {
                anims[i].resume();
            }
        };
        if (false) {
            p.reloadClip = function(state) {
                initClipData(this.target, state);
            };
        }
        function createBatchedProperty(propPath, firstDotIndex, mainValue, animValue) {
            mainValue = mainValue.clone();
            var nextValue = mainValue;
            var leftIndex = firstDotIndex + 1;
            var rightIndex = propPath.indexOf(".", leftIndex);
            while (-1 !== rightIndex) {
                var nextName = propPath.slice(leftIndex, rightIndex);
                nextValue = nextValue[nextName];
                leftIndex = rightIndex + 1;
                rightIndex = propPath.indexOf(".", leftIndex);
            }
            var lastPropName = propPath.slice(leftIndex);
            nextValue[lastPropName] = animValue;
            return mainValue;
        }
        if (false) {
            cc._Test.createBatchedProperty = createBatchedProperty;
        }
        function splitPropPath(propPath) {
            var array = propPath.split(".");
            array.shift();
            return array.length > 0 ? array : null;
        }
        function initClipData(root, state) {
            var clip = state.clip;
            var curves = state.curves;
            curves.length = 0;
            state.duration = clip.duration;
            state.speed = clip.speed;
            state.wrapMode = clip.wrapMode;
            state.frameRate = clip.sample;
            if ((state.wrapMode & WrapModeMask.Loop) === WrapModeMask.Loop) {
                state.repeatCount = 1 / 0;
            } else {
                state.repeatCount = 1;
            }
            function checkMotionPath(motionPath) {
                if (!Array.isArray(motionPath)) {
                    return false;
                }
                for (var i = 0, l = motionPath.length; i < l; i++) {
                    var controls = motionPath[i];
                    if (!Array.isArray(controls) || 6 !== controls.length) {
                        return false;
                    }
                }
                return true;
            }
            function createPropCurve(target, propPath, keyframes) {
                var curve;
                var isMotionPathProp = target instanceof cc.Node && "position" === propPath;
                var motionPaths = [];
                var curve;
                if (isMotionPathProp) {
                    curve = new SampledAnimCurve();
                } else {
                    curve = new DynamicAnimCurve();
                }
                curve.target = target;
                var propName, propValue;
                var dotIndex = propPath.indexOf(".");
                var hasSubProp = -1 !== dotIndex;
                if (hasSubProp) {
                    propName = propPath.slice(0, dotIndex);
                    propValue = target[propName];
                } else {
                    propName = propPath;
                }
                curve.prop = propName;
                curve.subProps = splitPropPath(propPath);
                for (var j = 0, l = keyframes.length; j < l; j++) {
                    var keyframe = keyframes[j];
                    var ratio = keyframe.frame / state.duration;
                    curve.ratios.push(ratio);
                    if (isMotionPathProp) {
                        var motionPath = keyframe.motionPath;
                        if (motionPath && !checkMotionPath(motionPath)) {
                            cc.error("motion path of target [" + target.name + "] in prop [" + propPath + "] frame [" + j + "] is not valid");
                            motionPath = null;
                        }
                        motionPaths.push(motionPath);
                    }
                    var curveValue = keyframe.value;
                    curve.values.push(curveValue);
                    var curveTypes = keyframe.curve;
                    if (curveTypes) {
                        if ("string" === typeof curveTypes) {
                            curve.types.push(curveTypes);
                            continue;
                        } else {
                            if (Array.isArray(curveTypes)) {
                                if (curveTypes[0] === curveTypes[1] && curveTypes[2] === curveTypes[3]) {
                                    curve.types.push(DynamicAnimCurve.Linear);
                                } else {
                                    curve.types.push(DynamicAnimCurve.Bezier(curveTypes));
                                }
                                continue;
                            }
                        }
                    }
                    curve.types.push(DynamicAnimCurve.Linear);
                }
                if (isMotionPathProp) {
                    sampleMotionPaths(motionPaths, curve, clip.duration, clip.sample);
                }
                return curve;
            }
            function createTargetCurves(target, curveData) {
                var propsData = curveData.props;
                var compsData = curveData.comps;
                if (propsData) {
                    for (var propPath in propsData) {
                        var data = propsData[propPath];
                        var curve = createPropCurve(target, propPath, data);
                        curves.push(curve);
                    }
                }
                if (compsData) {
                    for (var compName in compsData) {
                        var comp = target.getComponent(compName);
                        if (!comp) {
                            continue;
                        }
                        var compData = compsData[compName];
                        for (var propPath in compData) {
                            var data = compData[propPath];
                            var curve = createPropCurve(comp, propPath, data);
                            curves.push(curve);
                        }
                    }
                }
            }
            var events = clip.events;
            if (true && events) {
                var curve;
                for (var i = 0, l = events.length; i < l; i++) {
                    if (!curve) {
                        curve = new EventAnimCurve();
                        curve.target = root;
                        curves.push(curve);
                    }
                    var eventData = events[i];
                    var ratio = eventData.frame / state.duration;
                    var eventInfo;
                    var index = binarySearch(curve.ratios, ratio);
                    if (index >= 0) {
                        eventInfo = curve.events[index];
                    } else {
                        eventInfo = new EventInfo();
                        curve.ratios.push(ratio);
                        curve.events.push(eventInfo);
                    }
                    eventInfo.add(eventData.func, eventData.params);
                }
            }
            var curveData = clip.curveData;
            var childrenCurveDatas = curveData.paths;
            createTargetCurves(root, curveData);
            for (var namePath in childrenCurveDatas) {
                var target = cc.find(namePath, root);
                if (!target) {
                    continue;
                }
                var childCurveDatas = childrenCurveDatas[namePath];
                createTargetCurves(target, childCurveDatas);
            }
        }
        if (false) {
            cc._Test.initClipData = initClipData;
        }
        module.exports = AnimationAnimator;
    }, {
        "./animation-curves": 5,
        "./animators": 8,
        "./binary-search": 10,
        "./motion-path-helper": 13,
        "./types": 15
    } ],
    4: [ function(require, module, exports) {
        var AnimationClip = cc.Class({
            name: "cc.AnimationClip",
            "extends": cc.Asset,
            properties: {
                _duration: {
                    "default": 0,
                    type: "Float"
                },
                duration: {
                    get: function() {
                        return this._duration;
                    }
                },
                sample: {
                    "default": 60
                },
                speed: {
                    "default": 1
                },
                wrapMode: {
                    "default": cc.WrapMode.Normal
                },
                curveData: {
                    "default": {},
                    visible: false
                },
                events: {
                    "default": [],
                    visible: false
                }
            }
        });
        cc.AnimationClip = module.exports = AnimationClip;
    }, {} ],
    5: [ function(require, module, exports) {
        var bezierByTime = require("./bezier").bezierByTime;
        var binarySearch = require("./binary-search");
        var WrapModeMask = require("./types").WrapModeMask;
        function computeRatioByType(ratio, type) {
            if ("string" === typeof type) {
                var func = cc.Easing[type];
                if (func) {
                    ratio = func(ratio);
                } else {
                    cc.error("Can't find easing type [" + type + "]");
                }
            } else {
                if (Array.isArray(type)) {
                    ratio = bezierByTime(type, ratio);
                }
            }
            return ratio;
        }
        var AnimCurve = cc.Class({
            name: "cc.AnimCurve",
            sample: function(time, ratio, animationNode) {},
            onTimeChangedManually: function() {}
        });
        var DynamicAnimCurve = cc.Class({
            name: "cc.DynamicAnimCurve",
            "extends": AnimCurve,
            properties: {
                target: null,
                prop: "",
                values: [],
                ratios: [],
                types: [],
                subProps: null
            },
            _calcValue: function(frameIndex, ratio) {
                var values = this.values;
                var fromVal = values[frameIndex - 1];
                var toVal = values[frameIndex];
                var value;
                if ("number" === typeof fromVal) {
                    value = fromVal + (toVal - fromVal) * ratio;
                } else {
                    var lerp = fromVal.lerp;
                    if (lerp) {
                        value = fromVal.lerp(toVal, ratio);
                    } else {
                        value = fromVal;
                    }
                }
                return value;
            },
            _applyValue: function(target, prop, value) {
                target[prop] = value;
            },
            _findFrameIndex: binarySearch,
            sample: function(time, ratio, animationNode) {
                var values = this.values;
                var ratios = this.ratios;
                var frameCount = ratios.length;
                if (0 === frameCount) {
                    return;
                }
                var value;
                var index = this._findFrameIndex(ratios, ratio);
                if (index < 0) {
                    index = ~index;
                    if (index <= 0) {
                        value = values[0];
                    } else {
                        if (index >= frameCount) {
                            value = values[frameCount - 1];
                        } else {
                            var fromRatio = ratios[index - 1];
                            var toRatio = ratios[index];
                            var type = this.types[index - 1];
                            var ratioBetweenFrames = (ratio - fromRatio) / (toRatio - fromRatio);
                            ratioBetweenFrames = computeRatioByType(ratioBetweenFrames, type);
                            value = this._calcValue(index, ratioBetweenFrames);
                        }
                    }
                } else {
                    value = values[index];
                }
                var subProps = this.subProps;
                if (subProps) {
                    var mainProp = this.target[this.prop];
                    var subProp = mainProp;
                    for (var i = 0; i < subProps.length - 1; i++) {
                        var subPropName = subProps[i];
                        if (subProp) {
                            subProp = subProp[subPropName];
                        } else {
                            return;
                        }
                    }
                    var propName = subProps[subProps.length - 1];
                    if (subProp) {
                        this._applyValue(subProp, propName, value);
                    } else {
                        return;
                    }
                    value = mainProp;
                }
                this._applyValue(this.target, this.prop, value);
            }
        });
        DynamicAnimCurve.Linear = null;
        DynamicAnimCurve.Bezier = function(controlPoints) {
            return controlPoints;
        };
        var SampledAnimCurve = cc.Class({
            name: "cc.SampledAnimCurve",
            "extends": DynamicAnimCurve,
            _findFrameIndex: function(ratios, ratio) {
                var length = ratios.length - 1;
                if (0 === length) {
                    return 0;
                }
                var start = ratios[0];
                if (ratio < start) {
                    return 0;
                }
                var end = ratios[length];
                if (ratio > end) {
                    return length;
                }
                ratio = (ratio - start) / (end - start);
                var eachLength = 1 / length;
                var index = ratio / eachLength;
                var floorIndex = 0 | index;
                var EPSILON = 1e-6;
                if (index - floorIndex < EPSILON) {
                    return floorIndex;
                }
                return ~(floorIndex + 1);
            }
        });
        var EventInfo = function() {
            this.events = [];
        };
        EventInfo.prototype.add = function(func, params) {
            this.events.push({
                func: func || "",
                params: params || []
            });
        };
        var EventAnimCurve = cc.Class({
            name: "cc.EventAnimCurve",
            "extends": AnimCurve,
            properties: {
                target: null,
                ratios: [],
                events: [],
                _lastWrappedInfo: null
            },
            _wrapIterations: function(iterations) {
                if (iterations - (0 | iterations) === 0) {
                    iterations -= 1;
                }
                return 0 | iterations;
            },
            sample: function(time, ratio, animationNode) {
                var length = this.ratios.length;
                var currentWrappedInfo = animationNode.getWrappedInfo(animationNode.time);
                var direction = currentWrappedInfo.direction;
                var currentIndex = binarySearch(this.ratios, currentWrappedInfo.ratio);
                if (currentIndex < 0) {
                    currentIndex = ~currentIndex - 1;
                    if (direction < 0) {
                        currentIndex += 1;
                    }
                }
                var lastWrappedInfo = this._lastWrappedInfo;
                var lastIndex = lastWrappedInfo ? lastWrappedInfo.frameIndex : currentWrappedInfo.frameIndex;
                if (!lastWrappedInfo) {
                    this._fireEvent(currentIndex);
                } else {
                    if (lastIndex !== currentIndex) {
                        var wrapMode = animationNode.wrapMode;
                        var currentIterations = this._wrapIterations(currentWrappedInfo.iterations);
                        var lastIntIterations = this._wrapIterations(lastWrappedInfo.iterations);
                        direction = lastWrappedInfo.direction;
                        do {
                            if (lastIntIterations <= currentIterations) {
                                if (-1 === direction && 0 === lastIndex) {
                                    if ((wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong) {
                                        direction *= -1;
                                    } else {
                                        lastIndex = length;
                                    }
                                    lastIntIterations++;
                                } else {
                                    if (1 === direction && lastIndex === length - 1) {
                                        if ((wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong) {
                                            direction *= -1;
                                        } else {
                                            lastIndex = -1;
                                        }
                                        lastIntIterations++;
                                    }
                                }
                                if (lastIndex === currentIndex) {
                                    break;
                                }
                            }
                            lastIndex += direction;
                            this._fireEvent(lastIndex);
                        } while (lastIndex !== currentIndex);
                    }
                }
                currentWrappedInfo.frameIndex = currentIndex;
                this._lastWrappedInfo = currentWrappedInfo;
            },
            _fireEvent: function(index) {
                if (index < 0 || index >= this.events.length) {
                    return;
                }
                var eventInfo = this.events[index];
                var events = eventInfo.events;
                var components = this.target._components;
                for (var i = 0; i < events.length; i++) {
                    var event = events[i];
                    var funcName = event.func;
                    for (var j = 0; j < components.length; j++) {
                        var component = components[j];
                        var func = component[funcName];
                        if (func) {
                            func.apply(component, event.params);
                        }
                    }
                }
            },
            onTimeChangedManually: function() {
                this._lastWrappedInfo = null;
            }
        });
        if (false) {
            cc._Test.DynamicAnimCurve = DynamicAnimCurve;
            cc._Test.SampledAnimCurve = SampledAnimCurve;
            cc._Test.EventAnimCurve = EventAnimCurve;
        }
        module.exports = {
            AnimCurve: AnimCurve,
            DynamicAnimCurve: DynamicAnimCurve,
            SampledAnimCurve: SampledAnimCurve,
            EventAnimCurve: EventAnimCurve,
            EventInfo: EventInfo,
            computeRatioByType: computeRatioByType
        };
    }, {
        "./bezier": 9,
        "./binary-search": 10,
        "./types": 15
    } ],
    6: [ function(require, module, exports) {
        var JS = cc.js;
        var AnimationManager = cc.Class({
            ctor: function() {
                this.animators = [];
                this.__instanceId = cc.ClassManager.getNewInstanceId();
            },
            update: function(dt) {
                var animators = this.animators;
                for (var i = 0, len = animators.length; i < len; i++) {
                    var animator = animators[i];
                    if (animator._isPlaying && !animator._isPaused) {
                        animator.update(dt);
                        if (!animator._isPlaying) {
                            i--;
                            len--;
                        }
                    }
                }
            },
            destruct: function() {},
            addAnimator: function(animator) {
                this.animators.push(animator);
            },
            removeAnimator: function(animator) {
                var index = this.animators.indexOf(animator);
                if (index >= 0) {
                    this.animators.splice(index, 1);
                } else {
                    cc.error("animator not added or already removed");
                }
            }
        });
        cc.AnimationManager = module.exports = AnimationManager;
    }, {} ],
    7: [ function(require, module, exports) {
        var JS = cc.js;
        var AnimationNode = require("./types").AnimationNode;
        function AnimationState(clip, name) {
            AnimationNode.call(this, null, null, {
                duration: clip.length
            });
            this._clip = clip;
            this._name = name || clip.name;
        }
        JS.extend(AnimationState, AnimationNode);
        var state = AnimationState.prototype;
        JS.get(state, "clip", function() {
            return this._clip;
        });
        JS.get(state, "name", function() {
            return this._name;
        });
        JS.obsolete(state, "AnimationState.length", "duration");
        JS.getset(state, "curveLoaded", function() {
            return this.curves.length > 0;
        }, function(value) {
            this.curves.length = 0;
        });
        state.onPlay = function() {
            this.setTime(0);
        };
        state.setTime = function(time) {
            this.time = time || 0;
            this.curves.forEach(function(curve) {
                curve.onTimeChangedManually();
            });
        };
        cc.AnimationState = module.exports = AnimationState;
    }, {
        "./types": 15
    } ],
    8: [ function(require, module, exports) {
        var JS = cc.js;
        var Playable = require("./playable");
        var AnimationNode = require("./types").AnimationNode;
        var DynamicAnimCurve = require("./animation-curves").DynamicAnimCurve;
        function Animator(target) {
            this.target = target;
            this.playingAnims = [];
        }
        JS.extend(Animator, Playable);
        var animProto = Animator.prototype;
        animProto.update = function(deltaTime) {
            var anims = this.playingAnims;
            for (var i = 0; i < anims.length; i++) {
                var anim = anims[i];
                if (anim._isPlaying && !anim._isPaused) {
                    anim.update(deltaTime);
                    if (!anim._isPlaying) {
                        anims.splice(i, 1);
                        i--;
                    }
                }
            }
            if (0 === anims.length) {
                this.stop();
            }
        };
        animProto.onPlay = function() {
            cc.director.getAnimationManager().addAnimator(this);
        };
        animProto.onStop = function() {
            this.playingAnims.length = 0;
            cc.director.getAnimationManager().removeAnimator(this);
        };
        function EntityAnimator(target) {
            Animator.call(this, target);
        }
        JS.extend(EntityAnimator, Animator);
        var entProto = EntityAnimator.prototype;
        function computeNullRatios(keyFrames) {
            var lastIndex = 0;
            var lastRatio = 0;
            var len = keyFrames.length;
            for (var i = 0; i < len; i++) {
                var frame = keyFrames[i];
                var ratio = frame.ratio;
                if (0 === i && "number" !== typeof ratio) {
                    frame.computedRatio = ratio = 0;
                } else {
                    if (i === len - 1 && "number" !== typeof ratio) {
                        frame.computedRatio = ratio = 1;
                    }
                }
                if ("number" === typeof ratio) {
                    if (lastIndex + 1 < i) {
                        var count = i - lastIndex;
                        var step = (ratio - lastRatio) / count;
                        for (var j = lastIndex + 1; j < i; j++) {
                            lastRatio += step;
                            keyFrames[j].computedRatio = lastRatio;
                        }
                    }
                    lastIndex = i;
                    lastRatio = ratio;
                }
            }
        }
        if (false) {
            cc._Test.computeNullRatios = computeNullRatios;
        }
        entProto.animate = function(keyFrames, timingInput) {
            if (!keyFrames) {
                cc.error("[animate] keyFrames must be non-nil");
                return null;
            }
            computeNullRatios(keyFrames);
            var anim = this._doAnimate(keyFrames, timingInput);
            this.play();
            return anim;
        };
        function findCurve(curves, target, propName) {
            var i = 0, curve;
            for (;i < curves.length; i++) {
                curve = curves[i];
                if (curve.target === target && curve.prop === propName) {
                    return curve;
                }
            }
            return null;
        }
        function createPropCurve(curves, target, propName, value, ratio) {
            var curve = findCurve(curves, target, propName);
            if (!curve) {
                curve = new DynamicAnimCurve();
                curves.push(curve);
                curve.target = target;
                curve.prop = propName;
            }
            curve.values.push(value);
            curve.ratios.push(ratio);
        }
        entProto._doAnimate = function(keyFrames, timingInput) {
            var anim = new AnimationNode(this, null, timingInput);
            anim.play();
            var curves = anim.curves;
            var lastRatio = -1;
            for (var i = 0; i < keyFrames.length; i++) {
                var frame = keyFrames[i];
                var ratio = frame.ratio;
                if ("number" !== typeof ratio) {
                    ratio = frame.computedRatio;
                }
                if (ratio < 0) {
                    cc.error("[animate] ratio should >= 0!");
                    continue;
                }
                if (ratio < lastRatio) {
                    cc.error("[animate] ratio should in the order of smallest to largest!");
                    continue;
                }
                lastRatio = ratio;
                for (var key in frame) {
                    var data = frame[key];
                    if ("props" === key) {
                        for (var propName in data) {
                            createPropCurve(curves, this.target, propName, data[propName], ratio);
                        }
                    } else {
                        if ("comps" === key) {
                            for (var compName in data) {
                                var comp = this.target.getComponent(compName);
                                var compData = data[compName];
                                for (var propName in compData) {
                                    createPropCurve(curves, comp, propName, compData[propName], ratio);
                                }
                            }
                        }
                    }
                }
            }
            this.playingAnims.push(anim);
            return anim;
        };
        if (false) {
            cc._Test.EntityAnimator = EntityAnimator;
        }
        module.exports = {
            Animator: Animator,
            EntityAnimator: EntityAnimator
        };
    }, {
        "./animation-curves": 5,
        "./playable": 14,
        "./types": 15
    } ],
    9: [ function(require, module, exports) {
        function bezier(C1, C2, C3, C4, t) {
            var t1 = 1 - t;
            return C1 * t1 * t1 * t1 + 3 * C2 * t1 * t1 * t + 3 * C3 * t1 * t * t + C4 * t * t * t;
        }
        var cos = Math.cos, acos = Math.acos, max = Math.max, pi = Math.PI, tau = 2 * pi, sqrt = Math.sqrt;
        function crt(v) {
            if (v < 0) {
                return -Math.pow(-v, 1 / 3);
            } else {
                return Math.pow(v, 1 / 3);
            }
        }
        function cardano(curve, x) {
            var pa = x - 0;
            var pb = x - curve[0];
            var pc = x - curve[2];
            var pd = x - 1;
            var pa3 = 3 * pa;
            var pb3 = 3 * pb;
            var pc3 = 3 * pc;
            var d = -pa + pb3 - pc3 + pd, rd = 1 / d, r3 = 1 / 3, a = (pa3 - 6 * pb + pc3) * rd, a3 = a * r3, b = (-pa3 + pb3) * rd, c = pa * rd, p = (3 * b - a * a) * r3, p3 = p * r3, q = (2 * a * a * a - 9 * a * b + 27 * c) / 27, q2 = q / 2, discriminant = q2 * q2 + p3 * p3 * p3, u1, v1, x1, x2, x3;
            if (discriminant < 0) {
                var mp3 = -p * r3, mp33 = mp3 * mp3 * mp3, r = sqrt(mp33), t = -q / (2 * r), cosphi = t < -1 ? -1 : t > 1 ? 1 : t, phi = acos(cosphi), crtr = crt(r), t1 = 2 * crtr;
                x1 = t1 * cos(phi * r3) - a3;
                x2 = t1 * cos((phi + tau) * r3) - a3;
                x3 = t1 * cos((phi + 2 * tau) * r3) - a3;
                if (0 <= x1 && x1 <= 1) {
                    if (0 <= x2 && x2 <= 1) {
                        if (0 <= x3 && x3 <= 1) {
                            return max(x1, x2, x3);
                        } else {
                            return max(x1, x2);
                        }
                    } else {
                        if (0 <= x3 && x3 <= 1) {
                            return max(x1, x3);
                        } else {
                            return x1;
                        }
                    }
                } else {
                    if (0 <= x2 && x2 <= 1) {
                        if (0 <= x3 && x3 <= 1) {
                            return max(x2, x3);
                        } else {
                            return x2;
                        }
                    } else {
                        return x3;
                    }
                }
            } else {
                if (0 === discriminant) {
                    u1 = q2 < 0 ? crt(-q2) : -crt(q2);
                    x1 = 2 * u1 - a3;
                    x2 = -u1 - a3;
                    if (0 <= x1 && x1 <= 1) {
                        if (0 <= x2 && x2 <= 1) {
                            return max(x1, x2);
                        } else {
                            return x1;
                        }
                    } else {
                        return x2;
                    }
                } else {
                    var sd = sqrt(discriminant);
                    u1 = crt(-q2 + sd);
                    v1 = crt(q2 + sd);
                    x1 = u1 - v1 - a3;
                    return x1;
                }
            }
        }
        function bezierByTime(controlPoints, x) {
            var percent = cardano(controlPoints, x);
            var p0y = 0;
            var p1y = controlPoints[1];
            var p2y = controlPoints[3];
            var p3y = 1;
            var t1 = 1 - percent;
            return p0y * t1 * t1 * t1 + 3 * p1y * percent * t1 * t1 + 3 * p2y * percent * percent * t1 + p3y * percent * percent * percent;
        }
        if (false) {
            cc._Test.bezier = bezier;
            cc._Test.bezierByTime = bezierByTime;
        }
        module.exports = {
            bezier: bezier,
            bezierByTime: bezierByTime
        };
    }, {} ],
    10: [ function(require, module, exports) {
        var EPSILON = 1e-6;
        function binarySearch(array, value) {
            var l = 0, h = array.length - 1;
            while (l <= h) {
                var m = l + h >> 1;
                if (Math.abs(array[m] - value) < EPSILON) {
                    return m;
                }
                if (array[m] > value) {
                    h = m - 1;
                } else {
                    l = m + 1;
                }
            }
            return ~l;
        }
        module.exports = binarySearch;
    }, {} ],
    11: [ function(require, module, exports) {
        var Easing = {
            linear: function(k) {
                return k;
            },
            quadIn: function(k) {
                return k * k;
            },
            quadOut: function(k) {
                return k * (2 - k);
            },
            quadInOut: function(k) {
                if ((k *= 2) < 1) {
                    return .5 * k * k;
                }
                return -.5 * (--k * (k - 2) - 1);
            },
            cubicIn: function(k) {
                return k * k * k;
            },
            cubicOut: function(k) {
                return --k * k * k + 1;
            },
            cubicInOut: function(k) {
                if ((k *= 2) < 1) {
                    return .5 * k * k * k;
                }
                return .5 * ((k -= 2) * k * k + 2);
            },
            quartIn: function(k) {
                return k * k * k * k;
            },
            quartOut: function(k) {
                return 1 - --k * k * k * k;
            },
            quartInOut: function(k) {
                if ((k *= 2) < 1) {
                    return .5 * k * k * k * k;
                }
                return -.5 * ((k -= 2) * k * k * k - 2);
            },
            quintIn: function(k) {
                return k * k * k * k * k;
            },
            quintOut: function(k) {
                return --k * k * k * k * k + 1;
            },
            quintInOut: function(k) {
                if ((k *= 2) < 1) {
                    return .5 * k * k * k * k * k;
                }
                return .5 * ((k -= 2) * k * k * k * k + 2);
            },
            sineIn: function(k) {
                return 1 - Math.cos(k * Math.PI / 2);
            },
            sineOut: function(k) {
                return Math.sin(k * Math.PI / 2);
            },
            sineInOut: function(k) {
                return .5 * (1 - Math.cos(Math.PI * k));
            },
            expoIn: function(k) {
                return 0 === k ? 0 : Math.pow(1024, k - 1);
            },
            expoOut: function(k) {
                return 1 === k ? 1 : 1 - Math.pow(2, -10 * k);
            },
            expoInOut: function(k) {
                if (0 === k) {
                    return 0;
                }
                if (1 === k) {
                    return 1;
                }
                if ((k *= 2) < 1) {
                    return .5 * Math.pow(1024, k - 1);
                }
                return .5 * (-Math.pow(2, -10 * (k - 1)) + 2);
            },
            circIn: function(k) {
                return 1 - Math.sqrt(1 - k * k);
            },
            circOut: function(k) {
                return Math.sqrt(1 - --k * k);
            },
            circInOut: function(k) {
                if ((k *= 2) < 1) {
                    return -.5 * (Math.sqrt(1 - k * k) - 1);
                }
                return .5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
            },
            elasticIn: function(k) {
                var s, a = .1, p = .4;
                if (0 === k) {
                    return 0;
                }
                if (1 === k) {
                    return 1;
                }
                if (!a || a < 1) {
                    a = 1;
                    s = p / 4;
                } else {
                    s = p * Math.asin(1 / a) / (2 * Math.PI);
                }
                return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin(2 * (k - s) * Math.PI / p));
            },
            elasticOut: function(k) {
                var s, a = .1, p = .4;
                if (0 === k) {
                    return 0;
                }
                if (1 === k) {
                    return 1;
                }
                if (!a || a < 1) {
                    a = 1;
                    s = p / 4;
                } else {
                    s = p * Math.asin(1 / a) / (2 * Math.PI);
                }
                return a * Math.pow(2, -10 * k) * Math.sin(2 * (k - s) * Math.PI / p) + 1;
            },
            elasticInOut: function(k) {
                var s, a = .1, p = .4;
                if (0 === k) {
                    return 0;
                }
                if (1 === k) {
                    return 1;
                }
                if (!a || a < 1) {
                    a = 1;
                    s = p / 4;
                } else {
                    s = p * Math.asin(1 / a) / (2 * Math.PI);
                }
                if ((k *= 2) < 1) {
                    return -.5 * a * Math.pow(2, 10 * (k -= 1)) * Math.sin(2 * (k - s) * Math.PI / p);
                }
                return a * Math.pow(2, -10 * (k -= 1)) * Math.sin(2 * (k - s) * Math.PI / p) * .5 + 1;
            },
            backIn: function(k) {
                var s = 1.70158;
                return k * k * ((s + 1) * k - s);
            },
            backOut: function(k) {
                var s = 1.70158;
                return --k * k * ((s + 1) * k + s) + 1;
            },
            backInOut: function(k) {
                var s = 2.5949095;
                if ((k *= 2) < 1) {
                    return .5 * k * k * ((s + 1) * k - s);
                }
                return .5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
            },
            bounceOut: function(k) {
                if (k < 1 / 2.75) {
                    return 7.5625 * k * k;
                } else {
                    if (k < 2 / 2.75) {
                        return 7.5625 * (k -= 1.5 / 2.75) * k + .75;
                    } else {
                        if (k < 2.5 / 2.75) {
                            return 7.5625 * (k -= 2.25 / 2.75) * k + .9375;
                        } else {
                            return 7.5625 * (k -= 2.625 / 2.75) * k + .984375;
                        }
                    }
                }
            },
            smooth: function(t) {
                if (t <= 0) {
                    return 0;
                }
                if (t >= 1) {
                    return 1;
                }
                return t * t * (3 - 2 * t);
            },
            fade: function(t) {
                if (t <= 0) {
                    return 0;
                }
                if (t >= 1) {
                    return 1;
                }
                return t * t * t * (t * (6 * t - 15) + 10);
            }
        };
        function _makeOutIn(fnIn, fnOut) {
            return function(k) {
                if (k < .5) {
                    return fnOut(2 * k) / 2;
                }
                return fnIn(2 * k - 1) / 2 + .5;
            };
        }
        Easing.quadOutIn = _makeOutIn(Easing.quadIn, Easing.quadOut);
        Easing.cubicOutIn = _makeOutIn(Easing.cubicIn, Easing.cubicOut);
        Easing.quartOutIn = _makeOutIn(Easing.quartIn, Easing.quartOut);
        Easing.quintOutIn = _makeOutIn(Easing.quintIn, Easing.quintOut);
        Easing.sineOutIn = _makeOutIn(Easing.sineIn, Easing.sineOut);
        Easing.expoOutIn = _makeOutIn(Easing.expoIn, Easing.expoOut);
        Easing.circOutIn = _makeOutIn(Easing.circIn, Easing.circOut);
        Easing.backOutIn = _makeOutIn(Easing.backIn, Easing.backOut);
        Easing.backOutIn = _makeOutIn(Easing.backIn, Easing.backOut);
        Easing.bounceIn = function(k) {
            return 1 - Easing.bounceOut(1 - k);
        };
        Easing.bounceInOut = function(k) {
            if (k < .5) {
                return .5 * Easing.bounceIn(2 * k);
            }
            return .5 * Easing.bounceOut(2 * k - 1) + .5;
        };
        Easing.bounceOutIn = _makeOutIn(Easing.bounceIn, Easing.bounceOut);
        cc.Easing = module.exports = Easing;
    }, {} ],
    12: [ function(require, module, exports) {
        require("./bezier");
        require("./easing");
        require("./types");
        require("./motion-path-helper");
        require("./animation-curves");
        require("./animation-clip");
        require("./animators");
        require("./animation-manager");
        require("./animation-state");
        require("./animation-animator");
    }, {
        "./animation-animator": 3,
        "./animation-clip": 4,
        "./animation-curves": 5,
        "./animation-manager": 6,
        "./animation-state": 7,
        "./animators": 8,
        "./bezier": 9,
        "./easing": 11,
        "./motion-path-helper": 13,
        "./types": 15
    } ],
    13: [ function(require, module, exports) {
        var DynamicAnimCurve = require("./animation-curves").DynamicAnimCurve;
        var computeRatioByType = require("./animation-curves").computeRatioByType;
        var bezier = require("./bezier").bezier;
        var binarySearch = require("./binary-search");
        var v2 = cc.v2;
        function Curve(points) {
            this.points = points || [];
            this.beziers = [];
            this.ratios = [];
            this.progresses = [];
            this.length = 0;
            this.computeBeziers();
        }
        Curve.prototype.computeBeziers = function() {
            this.beziers.length = 0;
            this.ratios.length = 0;
            this.progresses.length = 0;
            this.length = 0;
            var bezier;
            for (var i = 1; i < this.points.length; i++) {
                var startPoint = this.points[i - 1];
                var endPoint = this.points[i];
                bezier = new Bezier();
                bezier.start = startPoint.pos;
                bezier.startCtrlPoint = startPoint.out;
                bezier.end = endPoint.pos;
                bezier.endCtrlPoint = endPoint["in"];
                this.beziers.push(bezier);
                this.length += bezier.getLength();
            }
            var current = 0;
            for (var i = 0; i < this.beziers.length; i++) {
                bezier = this.beziers[i];
                this.ratios[i] = bezier.getLength() / this.length;
                this.progresses[i] = current += this.ratios[i];
            }
            return this.beziers;
        };
        function Bezier() {
            this.start = v2();
            this.end = v2();
            this.startCtrlPoint = v2();
            this.endCtrlPoint = v2();
        }
        Bezier.prototype.getPointAt = function(u) {
            var t = this.getUtoTmapping(u);
            return this.getPoint(t);
        };
        Bezier.prototype.getPoint = function(t) {
            var x = bezier(this.start.x, this.startCtrlPoint.x, this.endCtrlPoint.x, this.end.x, t);
            var y = bezier(this.start.y, this.startCtrlPoint.y, this.endCtrlPoint.y, this.end.y, t);
            return new v2(x, y);
        };
        Bezier.prototype.getLength = function() {
            var lengths = this.getLengths();
            return lengths[lengths.length - 1];
        };
        Bezier.prototype.getLengths = function(divisions) {
            if (!divisions) {
                divisions = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200;
            }
            if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1) {
                return this.cacheArcLengths;
            }
            var cache = [];
            var current, last = this.getPoint(0);
            var p, sum = 0;
            cache.push(0);
            for (p = 1; p <= divisions; p++) {
                current = this.getPoint(p / divisions);
                sum += cc.pDistance(current, last);
                cache.push(sum);
                last = current;
            }
            this.cacheArcLengths = cache;
            return cache;
        };
        Bezier.prototype.getUtoTmapping = function(u, distance) {
            var arcLengths = this.getLengths();
            var i = 0, il = arcLengths.length;
            var targetArcLength;
            if (distance) {
                targetArcLength = distance;
            } else {
                targetArcLength = u * arcLengths[il - 1];
            }
            var low = 0, high = il - 1, comparison;
            while (low <= high) {
                i = Math.floor(low + (high - low) / 2);
                comparison = arcLengths[i] - targetArcLength;
                if (comparison < 0) {
                    low = i + 1;
                    continue;
                } else {
                    if (comparison > 0) {
                        high = i - 1;
                        continue;
                    } else {
                        high = i;
                        break;
                    }
                }
            }
            i = high;
            if (arcLengths[i] === targetArcLength) {
                var t = i / (il - 1);
                return t;
            }
            var lengthBefore = arcLengths[i];
            var lengthAfter = arcLengths[i + 1];
            var segmentLength = lengthAfter - lengthBefore;
            var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
            var t = (i + segmentFraction) / (il - 1);
            return t;
        };
        function sampleMotionPaths(motionPaths, data, duration, fps) {
            function createControlPoints(array) {
                if (array instanceof cc.Vec2) {
                    return {
                        "in": array,
                        pos: array,
                        out: array
                    };
                } else {
                    if (Array.isArray(array) && 6 === array.length) {
                        return {
                            "in": v2(array[2], array[3]),
                            pos: v2(array[0], array[1]),
                            out: v2(array[4], array[5])
                        };
                    }
                }
                return {
                    "in": cc.Vec2.ZERO,
                    pos: cc.Vec2.ZERO,
                    out: cc.Vec2.ZERO
                };
            }
            var values = data.values;
            if (0 === motionPaths.length || 0 === values.length) {
                return;
            }
            values = values.map(function(value) {
                return v2(value[0], value[1]);
            });
            if (1 === values.length) {
                data.values = values;
                return;
            }
            var types = data.types;
            var ratios = data.ratios;
            var newValues = data.values = [];
            var newTypes = data.types = [];
            var newRatios = data.ratios = [];
            function addNewDatas(value, type, ratio) {
                newValues.push(value);
                newTypes.push(type);
                newRatios.push(ratio);
            }
            var startRatioOffset = 0;
            var EPSILON = 1e-6;
            for (var i = 0, l = motionPaths.length; i < l - 1; i++) {
                var motionPath = motionPaths[i];
                var ratio = ratios[i];
                var nextRatio = ratios[i + 1];
                var betweenRatio = nextRatio - ratio;
                var value = values[i];
                var nextValue = values[i + 1];
                var type = types[i];
                var results = [];
                var progress = startRatioOffset / betweenRatio;
                var speed = 1 / (betweenRatio * duration * fps);
                var finalProgress;
                if (motionPath && motionPath.length > 0) {
                    var points = [];
                    points.push(createControlPoints(value));
                    for (var j = 0, l2 = motionPath.length; j < l2; j++) {
                        var controlPoints = createControlPoints(motionPath[j]);
                        points.push(controlPoints);
                    }
                    points.push(createControlPoints(nextValue));
                    var curve = new Curve(points);
                    curve.computeBeziers();
                    var progresses = curve.progresses;
                    while (1 - progress > EPSILON) {
                        finalProgress = progress;
                        finalProgress = computeRatioByType(finalProgress, type);
                        var pos, bezier, normal, length;
                        if (finalProgress < 0) {
                            bezier = curve.beziers[0];
                            length = (0 - finalProgress) * bezier.getLength();
                            normal = bezier.start.sub(bezier.endCtrlPoint).normalize();
                            pos = bezier.start.add(normal.mul(length));
                        } else {
                            if (finalProgress > 1) {
                                bezier = curve.beziers[curve.beziers.length - 1];
                                length = (finalProgress - 1) * bezier.getLength();
                                normal = bezier.end.sub(bezier.startCtrlPoint).normalize();
                                pos = bezier.end.add(normal.mul(length));
                            } else {
                                var bezierIndex = binarySearch(progresses, finalProgress);
                                if (bezierIndex < 0) {
                                    bezierIndex = ~bezierIndex;
                                }
                                finalProgress -= bezierIndex > 0 ? progresses[bezierIndex - 1] : 0;
                                finalProgress /= curve.ratios[bezierIndex];
                                pos = curve.beziers[bezierIndex].getPointAt(finalProgress);
                            }
                        }
                        results.push(pos);
                        progress += speed;
                    }
                } else {
                    while (1 - progress > EPSILON) {
                        finalProgress = progress;
                        finalProgress = computeRatioByType(finalProgress, type);
                        results.push(value.lerp(nextValue, finalProgress));
                        progress += speed;
                    }
                }
                for (var j = 0, l2 = results.length; j < l2; j++) {
                    var newRatio = ratio + startRatioOffset + speed * j * betweenRatio;
                    addNewDatas(results[j], DynamicAnimCurve.Linear, newRatio);
                }
                if (Math.abs(progress - 1) > EPSILON) {
                    startRatioOffset = (progress - 1) * betweenRatio;
                } else {
                    startRatioOffset = 0;
                }
            }
            if (ratios[ratios.length - 1] !== newRatios[newRatios.length - 1]) {
                addNewDatas(values[values.length - 1], DynamicAnimCurve.Linear, ratios[ratios.length - 1]);
            }
        }
        if (false) {
            cc._Test.sampleMotionPaths = sampleMotionPaths;
        }
        module.exports = {
            sampleMotionPaths: sampleMotionPaths,
            Curve: Curve,
            Bezier: Bezier
        };
    }, {
        "./animation-curves": 5,
        "./bezier": 9,
        "./binary-search": 10
    } ],
    14: [ function(require, module, exports) {
        var JS = cc.js;
        function Playable() {
            this._isPlaying = false;
            this._isPaused = false;
            this._stepOnce = false;
        }
        var prototype = Playable.prototype;
        JS.get(prototype, "isPlaying", function() {
            return this._isPlaying;
        }, true);
        JS.get(prototype, "isPaused", function() {
            return this._isPaused;
        }, true);
        var virtual = function() {};
        prototype.onPlay = virtual;
        prototype.onPause = virtual;
        prototype.onResume = virtual;
        prototype.onStop = virtual;
        prototype.onError = virtual;
        prototype.play = function() {
            if (this._isPlaying) {
                if (this._isPaused) {
                    this._isPaused = false;
                    this.onResume();
                } else {
                    this.onError("already-playing");
                }
            } else {
                this._isPlaying = true;
                this.onPlay();
            }
        };
        prototype.stop = function() {
            if (this._isPlaying) {
                this._isPlaying = false;
                this._isPaused = false;
                this.onStop();
            }
        };
        prototype.pause = function() {
            this._isPaused = true;
            this.onPause();
        };
        prototype.resume = function() {
            this._isPaused = false;
            this.onResume();
        };
        prototype.step = function() {
            this.pause();
            this._stepOnce = true;
            if (!this._isPlaying) {
                this.play();
            }
        };
        module.exports = Playable;
    }, {} ],
    15: [ function(require, module, exports) {
        var JS = cc.js;
        var Playable = require("./playable");
        var WrapModeMask = {
            Loop: 2,
            ShouldWrap: 4,
            PingPong: 22,
            Reverse: 36
        };
        var WrapMode = cc.Enum({
            Default: 0,
            Normal: 1,
            Reverse: WrapModeMask.Reverse,
            Loop: WrapModeMask.Loop,
            LoopReverse: WrapModeMask.Loop | WrapModeMask.Reverse,
            PingPong: WrapModeMask.PingPong,
            PingPongReverse: WrapModeMask.PingPong | WrapModeMask.Reverse
        });
        cc.WrapMode = WrapMode;
        var AnimationNodeBase = function() {
            Playable.call(this);
        };
        JS.extend(AnimationNodeBase, Playable);
        AnimationNodeBase.prototype.update = function(deltaTime) {};
        function AnimationNode(animator, curves, timingInput) {
            AnimationNodeBase.call(this);
            this.animator = animator;
            this.curves = curves || [];
            this.delay = 0;
            this.repeatCount = 1;
            this.duration = 1;
            this.speed = 1;
            this.wrapMode = WrapMode.Normal;
            if (timingInput) {
                this.delay = timingInput.delay || this.delay;
                var duration = timingInput.duration;
                if ("undefined" !== typeof duration) {
                    this.duration = duration;
                }
                var speed = timingInput.speed;
                if ("undefined" !== typeof speed) {
                    this.speed = speed;
                }
                var wrapMode = timingInput.wrapMode;
                if ("undefined" !== typeof wrapMode) {
                    var isEnum = "number" === typeof wrapMode;
                    if (isEnum) {
                        this.wrapMode = wrapMode;
                    } else {
                        this.wrapMode = WrapMode[wrapMode];
                    }
                }
                var repeatCount = timingInput.repeatCount;
                if ("undefined" !== typeof repeatCount) {
                    this.repeatCount = repeatCount;
                } else {
                    if (this.wrapMode & WrapModeMask.Loop) {
                        this.repeatCount = 1 / 0;
                    }
                }
            }
            this.time = 0;
            this._timeNoScale = 0;
            this._firstFramePlayed = false;
            this._duringDelay = false;
            if (this.delay > 0) {
                this._duringDelay = true;
            }
        }
        JS.extend(AnimationNode, AnimationNodeBase);
        JS.mixin(AnimationNode.prototype, {
            update: function(delta) {
                if (this._duringDelay) {
                    this._timeNoScale += delta;
                    if (this._timeNoScale < this.delay) {
                        return;
                    } else {
                        this._duringDelay = false;
                    }
                }
                if (this._firstFramePlayed) {
                    this.time += delta * this.speed;
                } else {
                    this._firstFramePlayed = true;
                }
                if (this.sample()) {
                    this.stop();
                }
            },
            _needRevers: function(currentIterations) {
                var wrapMode = this.wrapMode;
                var needRevers = false;
                if ((wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong) {
                    var isEnd = currentIterations - (0 | currentIterations) === 0;
                    if (isEnd && currentIterations > 0) {
                        currentIterations -= 1;
                    }
                    var isOddIteration = 1 & currentIterations;
                    if (isOddIteration) {
                        needRevers = !needRevers;
                    }
                }
                if ((wrapMode & WrapModeMask.Reverse) === WrapModeMask.Reverse) {
                    needRevers = !needRevers;
                }
                return needRevers;
            },
            getWrappedInfo: function(time) {
                var stopped = false;
                var duration = this.duration;
                var ratio = 0;
                var wrapMode = this.wrapMode;
                var currentIterations = Math.abs(time / duration);
                if (currentIterations > this.repeatCount) {
                    currentIterations = this.repeatCount;
                }
                var needRevers = false;
                if (wrapMode & WrapModeMask.ShouldWrap) {
                    needRevers = this._needRevers(currentIterations);
                }
                var direction = needRevers ? -1 : 1;
                if (this.speed < 0) {
                    direction *= -1;
                }
                if (currentIterations >= this.repeatCount) {
                    stopped = true;
                    var tempRatio = this.repeatCount - (0 | this.repeatCount);
                    if (0 === tempRatio) {
                        tempRatio = 1;
                    }
                    time = tempRatio * duration * (time > 0 ? 1 : -1);
                }
                if (time > duration) {
                    var tempTime = time % duration;
                    time = 0 === tempTime ? duration : tempTime;
                } else {
                    if (time < 0) {
                        time %= duration;
                        if (0 !== time) {
                            time += duration;
                        }
                    }
                }
                if (wrapMode & WrapModeMask.ShouldWrap) {
                    if (needRevers) {
                        time = duration - time;
                    }
                }
                ratio = time / duration;
                return {
                    ratio: ratio,
                    time: time,
                    direction: direction,
                    stopped: stopped,
                    iterations: currentIterations
                };
            },
            sample: function() {
                var info = this.getWrappedInfo(this.time);
                var curves = this.curves;
                for (var i = 0, len = curves.length; i < len; i++) {
                    var curve = curves[i];
                    curve.sample(info.time, info.ratio, this);
                }
                return info.stopped;
            }
        });
        cc.AnimationNode = AnimationNode;
        module.exports = {
            WrapModeMask: WrapModeMask,
            WrapMode: WrapMode,
            AnimationNode: AnimationNode
        };
    }, {
        "./playable": 14
    } ],
    16: [ function(require, module, exports) {
        var EventTarget = require("./event/event-target");
        var Class = require("./platform/_CCClass");
        var CCObject = require("./platform/CCObject");
        cc.g_NumberOfDraws = 0;
        cc.Director = Class.extend({
            _landscape: false,
            _nextDeltaTimeZero: false,
            _paused: false,
            _purgeDirectorInNextLoop: false,
            _sendCleanupToScene: false,
            _animationInterval: 0,
            _oldAnimationInterval: 0,
            _projection: 0,
            _contentScaleFactor: 1,
            _deltaTime: 0,
            _winSizeInPoints: null,
            _lastUpdate: null,
            _nextScene: null,
            _notificationNode: null,
            _openGLView: null,
            _scenesStack: null,
            _projectionDelegate: null,
            _loadingScene: "",
            _runningScene: null,
            _scene: null,
            _totalFrames: 0,
            _secondsPerFrame: 0,
            _dirtyRegion: null,
            _scheduler: null,
            _actionManager: null,
            ctor: function() {
                var self = this;
                EventTarget.call(self);
                self._lastUpdate = Date.now();
                cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function() {
                    self._lastUpdate = Date.now();
                });
            },
            init: function() {
                this._oldAnimationInterval = this._animationInterval = 1 / cc.defaultFPS;
                this._scenesStack = [];
                this._projection = cc.Director.PROJECTION_DEFAULT;
                this._projectionDelegate = null;
                this._totalFrames = 0;
                this._lastUpdate = Date.now();
                this._paused = false;
                this._purgeDirectorInNextLoop = false;
                this._winSizeInPoints = cc.size(0, 0);
                this._openGLView = null;
                this._contentScaleFactor = 1;
                this._scheduler = new cc.Scheduler();
                if (cc.ActionManager) {
                    this._actionManager = new cc.ActionManager();
                    this._scheduler.scheduleUpdate(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, false);
                } else {
                    this._actionManager = null;
                }
                this.sharedInit();
                return true;
            },
            sharedInit: function() {
                if (cc.AnimationManager) {
                    this._animationManager = new cc.AnimationManager();
                    this._scheduler.scheduleUpdate(this._animationManager, cc.Scheduler.PRIORITY_SYSTEM, false);
                } else {
                    this._animationManager = null;
                }
                cc._widgetManager.init(this);
            },
            calculateDeltaTime: function() {
                var now = Date.now();
                if (this._nextDeltaTimeZero) {
                    this._deltaTime = 0;
                    this._nextDeltaTimeZero = false;
                } else {
                    this._deltaTime = (now - this._lastUpdate) / 1e3;
                }
                if (cc.game.config[cc.game.CONFIG_KEY.debugMode] > 0 && this._deltaTime > .2) {
                    this._deltaTime = 1 / 60;
                }
                this._lastUpdate = now;
            },
            convertToGL: null,
            convertToUI: null,
            engineUpdate: function(deltaTime) {
                this._scheduler.update(deltaTime);
            },
            visit: function(deltaTime) {
                this.emit(cc.Director.EVENT_BEFORE_VISIT, this);
                if (this._beforeVisitScene) {
                    this._beforeVisitScene();
                }
                if (this._scene) {
                    clearFlags(this._scene);
                }
                if (this._runningScene) {
                    var renderer = cc.renderer;
                    if (true === renderer.childrenOrderDirty) {
                        renderer.clearRenderCommands();
                        this._runningScene._renderCmd._curLevel = 0;
                        this._runningScene.visit();
                        renderer.resetFlag();
                    } else {
                        if (true === renderer.transformDirty()) {
                            renderer.transform();
                        }
                    }
                }
                if (this._notificationNode) {
                    this._notificationNode.visit();
                }
                this.emit(cc.Director.EVENT_AFTER_VISIT, this);
                if (this._afterVisitScene) {
                    this._afterVisitScene();
                }
            },
            render: function(deltaTime) {
                cc.g_NumberOfDraws = 0;
                cc.renderer.clear();
                cc.renderer.rendering(cc._renderContext);
                this._totalFrames++;
                this.emit(cc.Director.EVENT_AFTER_DRAW);
            },
            _beforeVisitScene: null,
            _afterVisitScene: null,
            end: function() {
                this._purgeDirectorInNextLoop = true;
            },
            getContentScaleFactor: function() {
                return this._contentScaleFactor;
            },
            getNotificationNode: function() {
                return this._notificationNode;
            },
            getWinSize: function() {
                return cc.size(this._winSizeInPoints);
            },
            getWinSizeInPixels: function() {
                return cc.size(this._winSizeInPoints.width * this._contentScaleFactor, this._winSizeInPoints.height * this._contentScaleFactor);
            },
            getVisibleSize: null,
            getVisibleOrigin: null,
            getZEye: null,
            pause: function() {
                if (this._paused) {
                    return;
                }
                this._oldAnimationInterval = this._animationInterval;
                this.setAnimationInterval(.25);
                this._paused = true;
            },
            popScene: function() {
                cc.assert(this._runningScene, cc._LogInfos.Director.popScene);
                this._scenesStack.pop();
                var c = this._scenesStack.length;
                if (0 === c) {
                    this.end();
                } else {
                    this._sendCleanupToScene = true;
                    this._nextScene = this._scenesStack[c - 1];
                }
            },
            purgeCachedData: function() {
                cc.spriteFrameAnimationCache._clear();
                cc.spriteFrameCache._clear();
                cc.textureCache._clear();
            },
            purgeDirector: function() {
                this.getScheduler().unscheduleAll();
                if (cc.eventManager) {
                    cc.eventManager.setEnabled(false);
                }
                if (this._runningScene) {
                    this._runningScene.onExitTransitionDidStart();
                    this._runningScene.onExit();
                    this._runningScene.cleanup();
                    cc.renderer.clearRenderCommands();
                }
                this._runningScene = null;
                this._nextScene = null;
                this._scenesStack.length = 0;
                this.stopAnimation();
                this.purgeCachedData();
                cc.checkGLErrorDebug();
            },
            reset: function() {
                this.purgeDirector();
                if (cc.eventManager) {
                    cc.eventManager.setEnabled(true);
                }
                if (this._actionManager) {
                    this._scheduler.scheduleUpdate(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, false);
                }
                if (this._animationManager) {
                    this._scheduler.scheduleUpdate(this._animationManager, cc.Scheduler.PRIORITY_SYSTEM, false);
                }
                this.startAnimation();
            },
            pushScene: function(scene) {
                cc.assert(scene, cc._LogInfos.Director.pushScene);
                this._sendCleanupToScene = false;
                this._scenesStack.push(scene);
                this._nextScene = scene;
            },
            runScene: function(scene, _onBeforeLoadScene) {
                cc.assert(scene, cc._LogInfos.Director.pushScene);
                var i, node, game = cc.game;
                var persistNodes = game._persistRootNodes;
                for (i = persistNodes.length - 1; i >= 0; --i) {
                    node = persistNodes[i];
                    game._ignoreRemovePersistNode = node;
                    node.parent = null;
                    game._ignoreRemovePersistNode = null;
                }
                var oldScene = this._scene;
                if (cc.isValid(oldScene)) {
                    oldScene.destroy();
                }
                this._scene = null;
                cc.Object._deferredDestroy();
                if (_onBeforeLoadScene) {
                    _onBeforeLoadScene();
                }
                this.emit(cc.Director.EVENT_BEFORE_SCENE_LAUNCH, scene);
                var sgScene = scene;
                if (scene instanceof cc.Scene) {
                    scene._load();
                    this._scene = scene;
                    sgScene = scene._sgNode;
                    for (i = 0; i < persistNodes.length; ++i) {
                        node = persistNodes[i];
                        node.parent = scene;
                    }
                }
                if (!this._runningScene) {
                    this.pushScene(sgScene);
                    this.startAnimation();
                } else {
                    var i = this._scenesStack.length;
                    this._scenesStack[Math.max(i - 1, 0)] = sgScene;
                    this._sendCleanupToScene = true;
                    this._nextScene = sgScene;
                }
                if (this._nextScene) {
                    this.setNextScene();
                }
                if (scene instanceof cc.Scene) {
                    scene._activate();
                }
            },
            loadScene: function(sceneName, onLaunched, _onUnloaded) {
                var uuid, info;
                if (this._loadingScene) {
                    cc.error('[loadScene] Failed to load scene "%s" because "%s" is already loading', sceneName, this._loadingScene);
                    return false;
                }
                if ("string" === typeof sceneName) {
                    if (!sceneName.endsWith(".fire")) {
                        sceneName += ".fire";
                    }
                    if ("/" !== sceneName[0] && !sceneName.startsWith("db://assets/")) {
                        sceneName = "/" + sceneName;
                    }
                    for (var i = 0; i < cc.game._sceneInfos.length; i++) {
                        info = cc.game._sceneInfos[i];
                        var url = info.url;
                        if (url.endsWith(sceneName)) {
                            uuid = info.uuid;
                            break;
                        }
                    }
                } else {
                    info = cc.game._sceneInfos[sceneName];
                    if ("object" === typeof info) {
                        uuid = info.uuid;
                    } else {
                        cc.error("[loadScene] The scene index to load (%s) is out of range.", sceneName);
                        return false;
                    }
                }
                if (uuid) {
                    this._loadingScene = sceneName;
                    this._loadSceneByUuid(uuid, onLaunched, _onUnloaded);
                    return true;
                } else {
                    cc.error('[loadScene] Can not load the scene "%s" because it has not been added to the build settings before play.', sceneName);
                    return false;
                }
            },
            _loadRawAssets: function(assetObjects, done) {
                var urls = assetObjects.map(function(asset) {
                    return asset.url;
                });
                var index = 0;
                var count = 30;
                var total = urls.length;
                function preload() {
                    if (index + count > total) {
                        count = total - index;
                    }
                    var assets = urls.slice(index, count);
                    index += count;
                    if (index < total) {
                        cc.loader.load(assets, preload);
                    } else {
                        done();
                    }
                }
                preload();
            },
            _loadSceneByUuid: function(uuid, onLaunched, onUnloaded) {
                var handle = cc.AssetLibrary.loadAsset(uuid, function(error, sceneAsset) {
                    var self = cc.director;
                    var scene;
                    if (error) {
                        error = "Failed to load scene: " + error;
                        cc.error(error);
                        if (false) {
                            console.assert(false, error);
                        }
                    } else {
                        var uuid = sceneAsset._uuid;
                        scene = sceneAsset.scene;
                        if (scene instanceof cc.Scene) {
                            scene._id = uuid;
                            self._loadRawAssets(handle.assetsNeedPostLoad, function() {
                                self.runScene(scene, onUnloaded);
                            });
                        } else {
                            error = "The asset " + uuid + " is not a scene";
                            cc.error(error);
                            scene = null;
                        }
                    }
                    self._loadingScene = "";
                    if (onLaunched) {
                        onLaunched(error, scene);
                    }
                }, {
                    recordAssets: true
                });
            },
            resume: function() {
                if (!this._paused) {
                    return;
                }
                this.setAnimationInterval(this._oldAnimationInterval);
                this._lastUpdate = Date.now();
                if (!this._lastUpdate) {
                    cc.log(cc._LogInfos.Director.resume);
                }
                this._paused = false;
                this._deltaTime = 0;
            },
            setContentScaleFactor: function(scaleFactor) {
                if (scaleFactor !== this._contentScaleFactor) {
                    this._contentScaleFactor = scaleFactor;
                }
            },
            setDepthTest: null,
            setClearColor: null,
            setDefaultValues: function() {},
            setNextDeltaTimeZero: function(nextDeltaTimeZero) {
                this._nextDeltaTimeZero = nextDeltaTimeZero;
            },
            setNextScene: function() {
                var runningIsTransition = false, newIsTransition = false;
                if (cc.TransitionScene) {
                    runningIsTransition = this._runningScene ? this._runningScene instanceof cc.TransitionScene : false;
                    newIsTransition = this._nextScene ? this._nextScene instanceof cc.TransitionScene : false;
                }
                if (!newIsTransition) {
                    var locRunningScene = this._runningScene;
                    if (locRunningScene) {
                        locRunningScene.onExitTransitionDidStart();
                        locRunningScene.onExit();
                    }
                    if (this._sendCleanupToScene && locRunningScene) {
                        locRunningScene.cleanup();
                    }
                }
                this._runningScene = this._nextScene;
                cc.renderer.childrenOrderDirty = true;
                this._nextScene = null;
                if (!runningIsTransition && null !== this._runningScene) {
                    this._runningScene.onEnter();
                    this._runningScene.onEnterTransitionDidFinish();
                }
            },
            setNotificationNode: function(node) {
                cc.renderer.childrenOrderDirty = true;
                if (this._notificationNode) {
                    this._notificationNode.onExitTransitionDidStart();
                    this._notificationNode.onExit();
                    this._notificationNode.cleanup();
                }
                this._notificationNode = node;
                if (!node) {
                    return;
                }
                this._notificationNode.onEnter();
                this._notificationNode.onEnterTransitionDidFinish();
            },
            getDelegate: function() {
                return this._projectionDelegate;
            },
            setDelegate: function(delegate) {
                this._projectionDelegate = delegate;
            },
            setOpenGLView: null,
            setProjection: null,
            setViewport: null,
            getOpenGLView: null,
            getProjection: null,
            setAlphaBlending: null,
            isSendCleanupToScene: function() {
                return this._sendCleanupToScene;
            },
            getRunningScene: function() {
                return this._runningScene;
            },
            getScene: function() {
                return this._scene;
            },
            getAnimationInterval: function() {
                return this._animationInterval;
            },
            isDisplayStats: function() {
                return cc.profiler ? cc.profiler.isShowingStats() : false;
            },
            setDisplayStats: function(displayStats) {
                if (cc.profiler) {
                    displayStats ? cc.profiler.showStats() : cc.profiler.hideStats();
                }
            },
            getSecondsPerFrame: function() {
                return this._secondsPerFrame;
            },
            isNextDeltaTimeZero: function() {
                return this._nextDeltaTimeZero;
            },
            isPaused: function() {
                return this._paused;
            },
            getTotalFrames: function() {
                return this._totalFrames;
            },
            popToRootScene: function() {
                this.popToSceneStackLevel(1);
            },
            popToSceneStackLevel: function(level) {
                cc.assert(this._runningScene, cc._LogInfos.Director.popToSceneStackLevel_2);
                var locScenesStack = this._scenesStack;
                var c = locScenesStack.length;
                if (0 === c) {
                    this.end();
                    return;
                }
                if (level > c) {
                    return;
                }
                while (c > level) {
                    var current = locScenesStack.pop();
                    if (current.running) {
                        current.onExitTransitionDidStart();
                        current.onExit();
                    }
                    current.cleanup();
                    c--;
                }
                this._nextScene = locScenesStack[locScenesStack.length - 1];
                this._sendCleanupToScene = false;
            },
            getScheduler: function() {
                return this._scheduler;
            },
            setScheduler: function(scheduler) {
                if (this._scheduler !== scheduler) {
                    this._scheduler = scheduler;
                }
            },
            getActionManager: function() {
                return this._actionManager;
            },
            setActionManager: function(actionManager) {
                if (this._actionManager !== actionManager) {
                    this._actionManager = actionManager;
                }
            },
            getAnimationManager: function() {
                return this._animationManager;
            },
            getDeltaTime: function() {
                return this._deltaTime;
            },
            _calculateMPF: function() {
                var now = Date.now();
                this._secondsPerFrame = (now - this._lastUpdate) / 1e3;
            }
        });
        cc.js.addon(cc.Director.prototype, EventTarget.prototype);
        cc.Director.EVENT_PROJECTION_CHANGED = "director_projection_changed";
        cc.Director.EVENT_BEFORE_SCENE_LAUNCH = "director_before_scene_launch";
        cc.Director.EVENT_BEFORE_UPDATE = "director_before_update";
        cc.Director.EVENT_COMPONENT_UPDATE = "director_component_update";
        cc.Director.EVENT_COMPONENT_LATE_UPDATE = "director_component_late_update";
        cc.Director.EVENT_AFTER_UPDATE = "director_after_update";
        cc.Director.EVENT_AFTER_VISIT = "director_after_visit";
        cc.Director.EVENT_BEFORE_VISIT = "director_before_visit";
        cc.Director.EVENT_AFTER_DRAW = "director_after_draw";
        cc.DisplayLinkDirector = cc.Director.extend({
            invalid: false,
            startAnimation: function() {
                this._nextDeltaTimeZero = true;
                this.invalid = false;
            },
            mainLoop: false ? function(deltaTime, updateAnimate) {
                if (!this._paused) {
                    this.emit(cc.Director.EVENT_BEFORE_UPDATE);
                    this.emit(cc.Director.EVENT_COMPONENT_UPDATE, deltaTime);
                    if (updateAnimate) {
                        cc.director.engineUpdate(deltaTime);
                    }
                    this.emit(cc.Director.EVENT_COMPONENT_LATE_UPDATE, deltaTime);
                    this.emit(cc.Director.EVENT_AFTER_UPDATE);
                }
                this.visit();
                this.render();
            } : function() {
                if (this._purgeDirectorInNextLoop) {
                    this._purgeDirectorInNextLoop = false;
                    this.purgeDirector();
                } else {
                    if (!this.invalid) {
                        this.calculateDeltaTime();
                        if (!this._paused) {
                            this.emit(cc.Director.EVENT_BEFORE_UPDATE);
                            this.emit(cc.Director.EVENT_COMPONENT_UPDATE, this._deltaTime);
                            CCObject._deferredDestroy();
                            this.engineUpdate(this._deltaTime);
                            this.emit(cc.Director.EVENT_COMPONENT_LATE_UPDATE, this._deltaTime);
                            this.emit(cc.Director.EVENT_AFTER_UPDATE);
                        }
                        if (this._nextScene) {
                            this.setNextScene();
                        }
                        this.visit(this._deltaTime);
                        this.render(this._deltaTime);
                        this._calculateMPF();
                    }
                }
            },
            stopAnimation: function() {
                this.invalid = true;
            },
            setAnimationInterval: function(value) {
                this._animationInterval = value;
                if (!this.invalid) {
                    this.stopAnimation();
                    this.startAnimation();
                }
            }
        });
        cc.Director.sharedDirector = null;
        cc.Director.firstUseDirector = true;
        cc.Director._getInstance = function() {
            if (cc.Director.firstUseDirector) {
                cc.Director.firstUseDirector = false;
                cc.Director.sharedDirector = new cc.DisplayLinkDirector();
                cc.Director.sharedDirector.init();
            }
            return cc.Director.sharedDirector;
        };
        cc.defaultFPS = 60;
        cc.Director.PROJECTION_2D = 0;
        cc.Director.PROJECTION_3D = 1;
        cc.Director.PROJECTION_CUSTOM = 3;
        cc.Director.PROJECTION_DEFAULT = cc.Director.PROJECTION_3D;
        function clearFlags(node) {
            var children = node._children;
            for (var i = 0, len = children.length; i < len; i++) {
                var child = children[i];
                child._dirtyFlags = 0;
                clearFlags(child);
            }
        }
    }, {
        "./event/event-target": 52,
        "./platform/CCObject": 62,
        "./platform/_CCClass": 64
    } ],
    17: [ function(require, module, exports) {
        require("./CCDirector");
        require("./CCGame");
        cc.game.once(cc.game.EVENT_RENDERER_INITED, function() {
            if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                var _p = cc.Director.prototype;
                _p.getProjection = function(projection) {
                    return this._projection;
                };
                _p.setProjection = function(projection) {
                    this._projection = projection;
                    this.emit(cc.Director.EVENT_PROJECTION_CHANGED, this);
                };
                _p.setDepthTest = function() {};
                _p.setClearColor = function(clearColor) {
                    cc.renderer._clearColor = clearColor;
                    cc.renderer._clearFillStyle = "rgb(" + clearColor.r + "," + clearColor.g + "," + clearColor.b + ")";
                };
                _p.setOpenGLView = function(openGLView) {
                    this._winSizeInPoints.width = cc._canvas.width;
                    this._winSizeInPoints.height = cc._canvas.height;
                    this._openGLView = openGLView || cc.view;
                    if (cc.eventManager) {
                        cc.eventManager.setEnabled(true);
                    }
                };
                _p.getVisibleSize = function() {
                    return this.getWinSize();
                };
                _p.getVisibleOrigin = function() {
                    return cc.p(0, 0);
                };
            } else {
                cc.Director._fpsImage = new Image();
                cc.Director._fpsImage.addEventListener("load", function() {
                    cc.Director._fpsImageLoaded = true;
                });
                if (cc._fpsImage) {
                    cc.Director._fpsImage.src = cc._fpsImage;
                }
            }
        });
    }, {
        "./CCDirector": 16,
        "./CCGame": 19
    } ],
    18: [ function(require, module, exports) {
        require("./CCDirector");
        require("./CCGame");
        var GLToClipTransform = function(transformOut) {
            cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, transformOut);
            var modelview = new cc.math.Matrix4();
            cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, modelview);
            transformOut.multiply(modelview);
        };
        cc.game.once(cc.game.EVENT_RENDERER_INITED, function() {
            if (cc._renderType !== cc.game.RENDER_TYPE_WEBGL) {
                return;
            }
            cc.DirectorDelegate = cc._Class.extend({
                updateProjection: function() {}
            });
            var _p = cc.Director.prototype;
            var recursiveChild = function(node) {
                if (node && node._renderCmd) {
                    node._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
                    var i, children = node._children;
                    for (i = 0; i < children.length; i++) {
                        recursiveChild(children[i]);
                    }
                }
            };
            cc.Director._getInstance().on(cc.Director.EVENT_PROJECTION_CHANGED, function() {
                var director = cc.director;
                var stack = cc.director._scenesStack;
                for (var i = 0; i < stack.length; i++) {
                    recursiveChild(stack[i]);
                }
            });
            _p.setProjection = function(projection) {
                var _t = this;
                var size = _t._winSizeInPoints;
                _t.setViewport();
                var view = _t._openGLView, ox = view._viewPortRect.x / view._scaleX, oy = view._viewPortRect.y / view._scaleY;
                switch (projection) {
                  case cc.Director.PROJECTION_2D:
                    cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
                    cc.kmGLLoadIdentity();
                    var orthoMatrix = cc.math.Matrix4.createOrthographicProjection(-ox, size.width - ox, -oy, size.height - oy, -1024, 1024);
                    cc.kmGLMultMatrix(orthoMatrix);
                    cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
                    cc.kmGLLoadIdentity();
                    break;

                  case cc.Director.PROJECTION_3D:
                    var zeye = _t.getZEye();
                    var matrixPerspective = new cc.math.Matrix4(), matrixLookup = new cc.math.Matrix4();
                    cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
                    cc.kmGLLoadIdentity();
                    matrixPerspective = cc.math.Matrix4.createPerspectiveProjection(60, size.width / size.height, .1, 2 * zeye);
                    cc.kmGLMultMatrix(matrixPerspective);
                    cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
                    cc.kmGLLoadIdentity();
                    var eye = new cc.math.Vec3(-ox + size.width / 2, -oy + size.height / 2, zeye);
                    var center = new cc.math.Vec3(-ox + size.width / 2, -oy + size.height / 2, 0);
                    var up = new cc.math.Vec3(0, 1, 0);
                    matrixLookup.lookAt(eye, center, up);
                    cc.kmGLMultMatrix(matrixLookup);
                    break;

                  case cc.Director.PROJECTION_CUSTOM:
                    if (_t._projectionDelegate) {
                        _t._projectionDelegate.updateProjection();
                    }
                    break;

                  default:
                    cc.log(cc._LogInfos.Director.setProjection);
                }
                _t._projection = projection;
                _t.emit(cc.Director.EVENT_PROJECTION_CHANGED, _t);
                cc.setProjectionMatrixDirty();
                cc.renderer.childrenOrderDirty = true;
            };
            _p.setDepthTest = function(on) {
                cc.renderer.setDepthTest(on);
            };
            _p.setClearColor = function(clearColor) {
                cc.renderer._clearColor = clearColor;
            };
            _p.setOpenGLView = function(openGLView) {
                var _t = this;
                _t._winSizeInPoints.width = cc._canvas.width;
                _t._winSizeInPoints.height = cc._canvas.height;
                _t._openGLView = openGLView || cc.view;
                var conf = cc.configuration;
                conf.gatherGPUInfo();
                conf.dumpInfo();
                _t.setGLDefaultValues();
                if (cc.eventManager) {
                    cc.eventManager.setEnabled(true);
                }
            };
            _p._clear = function() {
                var gl = cc._renderContext;
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            };
            _p._beforeVisitScene = function() {
                cc.kmGLPushMatrix();
            };
            _p._afterVisitScene = function() {
                cc.kmGLPopMatrix();
            };
            _p.convertToGL = function(uiPoint) {
                var transform = new cc.math.Matrix4();
                GLToClipTransform(transform);
                var transformInv = transform.inverse();
                var zClip = transform.mat[14] / transform.mat[15];
                var glSize = this._openGLView.getDesignResolutionSize();
                var glCoord = new cc.math.Vec3(2 * uiPoint.x / glSize.width - 1, 1 - 2 * uiPoint.y / glSize.height, zClip);
                glCoord.transformCoord(transformInv);
                return cc.p(glCoord.x, glCoord.y);
            };
            _p.convertToUI = function(glPoint) {
                var transform = new cc.math.Matrix4();
                GLToClipTransform(transform);
                var clipCoord = new cc.math.Vec3(glPoint.x, glPoint.y, 0);
                clipCoord.transformCoord(transform);
                var glSize = this._openGLView.getDesignResolutionSize();
                return cc.p(glSize.width * (.5 * clipCoord.x + .5), glSize.height * (.5 * -clipCoord.y + .5));
            };
            _p.getVisibleSize = function() {
                return this._openGLView.getVisibleSize();
            };
            _p.getVisibleOrigin = function() {
                return this._openGLView.getVisibleOrigin();
            };
            _p.getZEye = function() {
                return this._winSizeInPoints.height / 1.1566;
            };
            _p.setViewport = function() {
                var view = this._openGLView;
                if (view) {
                    var locWinSizeInPoints = this._winSizeInPoints;
                    view.setViewPortInPoints(-view._viewPortRect.x / view._scaleX, -view._viewPortRect.y / view._scaleY, locWinSizeInPoints.width, locWinSizeInPoints.height);
                }
            };
            _p.getOpenGLView = function() {
                return this._openGLView;
            };
            _p.getProjection = function() {
                return this._projection;
            };
            _p.setAlphaBlending = function(on) {
                if (on) {
                    cc.glBlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
                } else {
                    cc.glBlendFunc(cc._renderContext.ONE, cc._renderContext.ZERO);
                }
            };
            _p.setGLDefaultValues = function() {
                var _t = this;
                _t.setAlphaBlending(true);
                _t.setDepthTest(false);
                _t.setProjection(_t._projection);
                cc._renderContext.clearColor(0, 0, 0, 0);
            };
        });
    }, {
        "./CCDirector": 16,
        "./CCGame": 19
    } ],
    19: [ function(require, module, exports) {
        var EventTarget = require("./event/event-target");
        var game = {
            EVENT_HIDE: "game_on_hide",
            EVENT_SHOW: "game_on_show",
            EVENT_RESIZE: "game_on_resize",
            EVENT_RENDERER_INITED: "renderer_inited",
            RENDER_TYPE_CANVAS: 0,
            RENDER_TYPE_WEBGL: 1,
            RENDER_TYPE_OPENGL: 2,
            _eventHide: null,
            _eventShow: null,
            _persistRootNodes: [],
            _ignoreRemovePersistNode: null,
            CONFIG_KEY: {
                width: "width",
                height: "height",
                engineDir: "engineDir",
                modules: "modules",
                debugMode: "debugMode",
                showFPS: "showFPS",
                frameRate: "frameRate",
                id: "id",
                renderMode: "renderMode",
                registerSystemEvent: "registerSystemEvent",
                jsList: "jsList",
                scenes: "scenes"
            },
            _paused: true,
            _isCloning: false,
            _prepareCalled: false,
            _prepared: false,
            _rendererInitialized: false,
            _renderContext: null,
            _intervalId: null,
            _lastTime: null,
            _frameTime: null,
            _sceneInfos: [],
            frame: null,
            container: null,
            canvas: null,
            config: null,
            onStart: null,
            onStop: null,
            setFrameRate: function(frameRate) {
                var self = this, config = self.config, CONFIG_KEY = self.CONFIG_KEY;
                config[CONFIG_KEY.frameRate] = frameRate;
                if (self._intervalId) {
                    window.cancelAnimationFrame(self._intervalId);
                }
                self._paused = true;
                self._setAnimFrame();
                self._runMainLoop();
            },
            step: function() {
                cc.director.mainLoop();
            },
            pause: function() {
                if (this._paused) {
                    return;
                }
                this._paused = true;
                cc.audioEngine && cc.audioEngine._pausePlaying();
                if (this._intervalId) {
                    window.cancelAnimationFrame(this._intervalId);
                }
                this._intervalId = 0;
            },
            resume: function() {
                if (!this._paused) {
                    return;
                }
                this._paused = false;
                cc.audioEngine && cc.audioEngine._resumePlaying();
                this._runMainLoop();
            },
            isPaused: function() {
                return this._paused;
            },
            restart: function() {
                cc.director.popToSceneStackLevel(0);
                cc.audioEngine && cc.audioEngine.end();
                game.onStart();
            },
            prepare: function(cb) {
                var self = this, config = self.config, CONFIG_KEY = self.CONFIG_KEY;
                this._loadConfig();
                if (this._prepared) {
                    if (cb) {
                        cb();
                    }
                    return;
                }
                if (this._prepareCalled) {
                    return;
                }
                if (cc._engineLoaded) {
                    this._prepareCalled = true;
                    this._initRenderer(config[CONFIG_KEY.width], config[CONFIG_KEY.height]);
                    cc.view = cc.EGLView._getInstance();
                    cc.director = cc.Director._getInstance();
                    if (cc.director.setOpenGLView) {
                        cc.director.setOpenGLView(cc.view);
                    }
                    cc.winSize = cc.director.getWinSize();
                    if (true) {
                        this._initEvents();
                    }
                    this._setAnimFrame();
                    this._runMainLoop();
                    var jsList = config[CONFIG_KEY.jsList];
                    if (jsList) {
                        cc.loader.loadJsWithImg(jsList, function(err) {
                            if (err) {
                                throw new Error(err);
                            }
                            self._prepared = true;
                            if (cb) {
                                cb();
                            }
                        });
                    } else {
                        if (cb) {
                            cb();
                        }
                    }
                    return;
                }
                cc.initEngine(this.config, function() {
                    self.prepare(cb);
                });
            },
            run: function(config, onStart) {
                if ("function" === typeof config) {
                    game.onStart = config;
                } else {
                    if (config) {
                        game.config = config;
                    }
                    if ("function" === typeof onStart) {
                        game.onStart = onStart;
                    }
                }
                this.prepare(game.onStart && game.onStart.bind(game));
            },
            addPersistRootNode: function(node) {
                if (!(node instanceof cc.Node)) {
                    return;
                }
                var index = this._persistRootNodes.indexOf(node);
                if (-1 === index) {
                    var scene = cc.director._scene;
                    if (cc.isValid(scene)) {
                        if (!node.parent) {
                            node.parent = scene;
                        } else {
                            if (!(node.parent instanceof cc.Scene)) {
                                cc.warn("The node can not be made persist because it's not under root node.");
                                return;
                            } else {
                                if (node.parent !== scene) {
                                    cc.warn("The node can not be made persist because it's not in current scene.");
                                    return;
                                }
                            }
                        }
                        this._persistRootNodes.push(node);
                        node._persistNode = true;
                    }
                }
            },
            removePersistRootNode: function(node) {
                if (node !== this._ignoreRemovePersistNode) {
                    var index = this._persistRootNodes.indexOf(node);
                    if (-1 !== index) {
                        this._persistRootNodes.splice(index, 1);
                    }
                    node._persistNode = false;
                }
            },
            isPersistRootNode: function(node) {
                return node._persistNode;
            },
            _setAnimFrame: function() {
                this._lastTime = new Date();
                this._frameTime = 1e3 / game.config[game.CONFIG_KEY.frameRate];
                if (cc.sys.os === cc.sys.OS_IOS && cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT || 60 !== game.config[game.CONFIG_KEY.frameRate]) {
                    window.requestAnimFrame = this._stTime;
                    window.cancelAnimationFrame = this._ctTime;
                } else {
                    window.requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || this._stTime;
                    window.cancelAnimationFrame = window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.oCancelAnimationFrame || this._ctTime;
                }
            },
            _stTime: function(callback) {
                var currTime = new Date().getTime();
                var timeToCall = Math.max(0, game._frameTime - (currTime - game._lastTime));
                var id = window.setTimeout(function() {
                    callback();
                }, timeToCall);
                game._lastTime = currTime + timeToCall;
                return id;
            },
            _ctTime: function(id) {
                window.clearTimeout(id);
            },
            _runMainLoop: function() {
                var self = this, callback, config = self.config, CONFIG_KEY = self.CONFIG_KEY, director = cc.director;
                director.setDisplayStats(config[CONFIG_KEY.showFPS]);
                callback = function() {
                    if (!self._paused) {
                        director.mainLoop();
                        if (self._intervalId) {
                            window.cancelAnimationFrame(self._intervalId);
                        }
                        self._intervalId = window.requestAnimFrame(callback);
                    }
                };
                window.requestAnimFrame(callback);
                self._paused = false;
            },
            _loadConfig: function() {
                if (this.config) {
                    this._initConfig(this.config);
                    return;
                }
                if (document["ccConfig"]) {
                    this._initConfig(document["ccConfig"]);
                } else {
                    try {
                        var cocos_script = document.getElementsByTagName("script");
                        for (var i = 0; i < cocos_script.length; i++) {
                            var _t = cocos_script[i].getAttribute("cocos");
                            if ("" === _t || _t) {
                                break;
                            }
                        }
                        var _src, txt, _resPath;
                        if (i < cocos_script.length) {
                            _src = cocos_script[i].src;
                            if (_src) {
                                _resPath = /(.*)\//.exec(_src)[0];
                                cc.loader.resPath = _resPath;
                                _src = cc.path.join(_resPath, "project.json");
                            }
                            txt = cc.loader._loadTxtSync(_src);
                        }
                        if (!txt) {
                            txt = cc.loader._loadTxtSync("project.json");
                        }
                        var data = JSON.parse(txt);
                        this._initConfig(data || {});
                    } catch (e) {
                        cc.log("Failed to read or parse project.json");
                        this._initConfig({});
                    }
                }
            },
            _initConfig: function(config) {
                var CONFIG_KEY = this.CONFIG_KEY, modules = config[CONFIG_KEY.modules];
                config[CONFIG_KEY.showFPS] = config[CONFIG_KEY.showFPS] || false;
                config[CONFIG_KEY.engineDir] = config[CONFIG_KEY.engineDir] || "frameworks/cocos2d-html5";
                if (null == config[CONFIG_KEY.debugMode]) {
                    config[CONFIG_KEY.debugMode] = 0;
                }
                config[CONFIG_KEY.frameRate] = config[CONFIG_KEY.frameRate] || 60;
                if (null == config[CONFIG_KEY.renderMode]) {
                    config[CONFIG_KEY.renderMode] = 0;
                }
                if (null == config[CONFIG_KEY.registerSystemEvent]) {
                    config[CONFIG_KEY.registerSystemEvent] = true;
                }
                if (modules && modules.indexOf("core") < 0) {
                    modules.splice(0, 0, "core");
                }
                modules && (config[CONFIG_KEY.modules] = modules);
                this._sceneInfos = this._sceneInfos.concat(config[CONFIG_KEY.scenes]);
                this.config = config;
            },
            _initRenderer: function(width, height) {
                if (this._rendererInitialized) {
                    return;
                }
                if (!cc._supportRender) {
                    throw new Error("The renderer doesn't support the renderMode " + this.config[this.CONFIG_KEY.renderMode]);
                }
                var el = this.config[game.CONFIG_KEY.id], win = window, element = cc.$(el) || cc.$("#" + el), localCanvas, localContainer, localConStyle;
                if ("CANVAS" === element.tagName) {
                    width = width || element.width;
                    height = height || element.height;
                    this.canvas = cc._canvas = localCanvas = element;
                    this.container = cc.container = localContainer = document.createElement("DIV");
                    if (localCanvas.parentNode) {
                        localCanvas.parentNode.insertBefore(localContainer, localCanvas);
                    }
                } else {
                    if ("DIV" !== element.tagName) {
                        cc.log("Warning: target element is not a DIV or CANVAS");
                    }
                    width = width || element.clientWidth;
                    height = height || element.clientHeight;
                    this.canvas = cc._canvas = localCanvas = document.createElement("CANVAS");
                    this.container = cc.container = localContainer = document.createElement("DIV");
                    element.appendChild(localContainer);
                }
                localContainer.setAttribute("id", "Cocos2dGameContainer");
                localContainer.appendChild(localCanvas);
                this.frame = localContainer.parentNode === document.body ? document.documentElement : localContainer.parentNode;
                localCanvas.addClass("gameCanvas");
                localCanvas.setAttribute("width", width || 480);
                localCanvas.setAttribute("height", height || 320);
                localCanvas.setAttribute("tabindex", 99);
                localCanvas.style.outline = "none";
                localConStyle = localContainer.style;
                localConStyle.width = (width || 480) + "px";
                localConStyle.height = (height || 320) + "px";
                localConStyle.margin = "0 auto";
                localConStyle.position = "relative";
                localConStyle.overflow = "hidden";
                localContainer.top = "100%";
                if (cc._renderType === game.RENDER_TYPE_WEBGL) {
                    this._renderContext = cc._renderContext = cc.webglContext = cc.create3DContext(localCanvas, {
                        stencil: true,
                        preserveDrawingBuffer: true,
                        antialias: !cc.sys.isMobile,
                        alpha: true
                    });
                }
                if (this._renderContext) {
                    cc.renderer = cc.rendererWebGL;
                    win.gl = this._renderContext;
                    cc.shaderCache._init();
                    cc._drawingUtil = new cc.DrawingPrimitiveWebGL(this._renderContext);
                    cc.textureCache._initializingRenderer();
                } else {
                    cc.renderer = cc.rendererCanvas;
                    this._renderContext = cc._renderContext = new cc.CanvasContextWrapper(localCanvas.getContext("2d"));
                    cc._drawingUtil = cc.DrawingPrimitiveCanvas ? new cc.DrawingPrimitiveCanvas(this._renderContext) : null;
                }
                cc._gameDiv = localContainer;
                game.canvas.oncontextmenu = function() {
                    if (!cc._isContextMenuEnable) {
                        return false;
                    }
                };
                this.emit(this.EVENT_RENDERER_INITED, true);
                this._rendererInitialized = true;
            },
            _initEvents: function() {
                var win = window, self = this, hidden, visibilityChange, _undef = "undefined";
                this._eventHide = this._eventHide || new cc.Event.EventCustom(this.EVENT_HIDE);
                this._eventHide.setUserData(this);
                this._eventShow = this._eventShow || new cc.Event.EventCustom(this.EVENT_SHOW);
                this._eventShow.setUserData(this);
                if (this.config[this.CONFIG_KEY.registerSystemEvent]) {
                    cc.inputManager.registerSystemEvent(this.canvas);
                }
                if (!cc.js.isUndefined(document.hidden)) {
                    hidden = "hidden";
                    visibilityChange = "visibilitychange";
                } else {
                    if (!cc.js.isUndefined(document.mozHidden)) {
                        hidden = "mozHidden";
                        visibilityChange = "mozvisibilitychange";
                    } else {
                        if (!cc.js.isUndefined(document.msHidden)) {
                            hidden = "msHidden";
                            visibilityChange = "msvisibilitychange";
                        } else {
                            if (!cc.js.isUndefined(document.webkitHidden)) {
                                hidden = "webkitHidden";
                                visibilityChange = "webkitvisibilitychange";
                            }
                        }
                    }
                }
                var onHidden = function() {
                    if (cc.eventManager && game._eventHide) {
                        cc.eventManager.dispatchEvent(game._eventHide);
                    }
                };
                var onShow = function() {
                    if (cc.eventManager && game._eventShow) {
                        cc.eventManager.dispatchEvent(game._eventShow);
                    }
                };
                if (hidden) {
                    document.addEventListener(visibilityChange, function() {
                        if (document[hidden]) {
                            onHidden();
                        } else {
                            onShow();
                        }
                    }, false);
                } else {
                    win.addEventListener("blur", onHidden, false);
                    win.addEventListener("focus", onShow, false);
                }
                if (navigator.userAgent.indexOf("MicroMessenger") > -1) {
                    win.onfocus = function() {
                        onShow();
                    };
                }
                if ("onpageshow" in window && "onpagehide" in window) {
                    win.addEventListener("pagehide", onHidden, false);
                    win.addEventListener("pageshow", onShow, false);
                }
                cc.eventManager.addCustomListener(game.EVENT_HIDE, function() {
                    game.pause();
                });
                cc.eventManager.addCustomListener(game.EVENT_SHOW, function() {
                    game.resume();
                });
            }
        };
        EventTarget.call(game);
        cc.js.addon(game, EventTarget.prototype);
        cc.game = module.exports = game;
    }, {
        "./event/event-target": 52
    } ],
    20: [ function(require, module, exports) {
        "use strict";
        var EventTarget = require("./event/event-target");
        var JS = cc.js;
        var Flags = cc.Object.Flags;
        var Destroying = Flags.Destroying;
        var DontDestroy = Flags.DontDestroy;
        var EventType = cc.Enum({
            TOUCH_START: "touchstart",
            TOUCH_MOVE: "touchmove",
            TOUCH_END: "touchend",
            TOUCH_CANCEL: "touchcancel",
            MOUSE_DOWN: "mousedown",
            MOUSE_MOVE: "mousemove",
            MOUSE_ENTER: "mouseenter",
            MOUSE_LEAVE: "mouseleave",
            MOUSE_UP: "mouseup",
            MOUSE_WHEEL: "mousewheel"
        });
        var _touchEvents = [ EventType.TOUCH_START, EventType.TOUCH_MOVE, EventType.TOUCH_END, EventType.TOUCH_CANCEL ];
        var _mouseEvents = [ EventType.MOUSE_DOWN, EventType.MOUSE_ENTER, EventType.MOUSE_MOVE, EventType.MOUSE_LEAVE, EventType.MOUSE_UP, EventType.MOUSE_WHEEL ];
        var _touchStartHandler = function(touch, event) {
            var pos = touch.getLocation();
            var node = this.owner;
            if (node._hitTest(pos, this)) {
                event.type = EventType.TOUCH_START;
                event.touch = touch;
                event.bubbles = true;
                node.dispatchEvent(event);
                return true;
            }
            return false;
        };
        var _touchMoveHandler = function(touch, event) {
            var node = this.owner;
            event.type = EventType.TOUCH_MOVE;
            event.touch = touch;
            event.bubbles = true;
            node.dispatchEvent(event);
        };
        var _touchEndHandler = function(touch, event) {
            var pos = touch.getLocation();
            var node = this.owner;
            if (node._hitTest(pos, this)) {
                event.type = EventType.TOUCH_END;
            } else {
                event.type = EventType.TOUCH_CANCEL;
            }
            event.touch = touch;
            event.bubbles = true;
            node.dispatchEvent(event);
        };
        var _mouseDownHandler = function(event) {
            var pos = event.getLocation();
            var node = this.owner;
            if (node._hitTest(pos, this)) {
                event.type = EventType.MOUSE_DOWN;
                node.dispatchEvent(event);
                event.stopPropagation();
            }
        };
        var _mouseMoveHandler = function(event) {
            var pos = event.getLocation();
            var node = this.owner;
            if (node._hitTest(pos, this)) {
                event.stopPropagation();
                if (!this._previousIn) {
                    event.type = EventType.MOUSE_ENTER;
                    node.dispatchEvent(event);
                    this._previousIn = true;
                }
                event.type = EventType.MOUSE_MOVE;
                node.dispatchEvent(event);
            } else {
                if (this._previousIn) {
                    event.type = EventType.MOUSE_LEAVE;
                    node.dispatchEvent(event);
                    this._previousIn = false;
                }
            }
        };
        var _mouseUpHandler = function(event) {
            var pos = event.getLocation();
            var node = this.owner;
            if (node._hitTest(pos, this)) {
                event.type = EventType.MOUSE_UP;
                node.dispatchEvent(event);
                event.stopPropagation();
            }
        };
        var _mouseWheelHandler = function(event) {
            var pos = event.getLocation();
            var node = this.owner;
            if (node._hitTest(pos, this)) {
                event.type = EventType.MOUSE_WHEEL;
                node.dispatchEvent(event);
                event.stopPropagation();
            }
        };
        var _searchMaskParent = function(node) {
            if (cc.Mask) {
                var index = 0;
                var mask = null;
                for (var curr = node; curr && curr instanceof cc.Node; curr = curr.parent, ++index) {
                    mask = curr.getComponent(cc.Mask);
                    if (mask) {
                        return {
                            index: index,
                            node: curr
                        };
                    }
                }
            }
            return null;
        };
        var Node = cc.Class({
            name: "cc.Node",
            "extends": require("./utils/base-node"),
            mixins: [ EventTarget ],
            properties: {
                active: {
                    get: function() {
                        return this._active;
                    },
                    set: function(value) {
                        value = !!value;
                        if (this._active !== value) {
                            this._active = value;
                            var canActiveInHierarchy = this._parent && this._parent._activeInHierarchy;
                            if (canActiveInHierarchy) {
                                this._onActivatedInHierarchy(value);
                            }
                        }
                    }
                },
                activeInHierarchy: {
                    get: function() {
                        return this._activeInHierarchy;
                    }
                },
                _active: true,
                _components: [],
                _prefab: {
                    "default": null,
                    editorOnly: true
                },
                _persistNode: {
                    get: function() {
                        return (this._objFlags & DontDestroy) > 0;
                    },
                    set: function(value) {
                        if (value) {
                            this._objFlags |= DontDestroy;
                        } else {
                            this._objFlags &= ~DontDestroy;
                        }
                    }
                }
            },
            ctor: function() {
                var name = arguments[0];
                this._name = "undefined" !== typeof name ? name : "New Node";
                this._activeInHierarchy = false;
                this.__instanceId = this._id || cc.ClassManager.getNewInstanceId();
                this._widget = null;
                this._touchListener = null;
                this._mouseListener = null;
                this.__eventTargets = [];
                if (cc.sys.isNative) {
                    this._retainedActions = [];
                }
            },
            statics: {
                _DirtyFlags: require("./utils/misc").DirtyFlags
            },
            destroy: function() {
                if (cc.Object.prototype.destroy.call(this)) {
                    if (this._activeInHierarchy) {
                        this._deactivateChildComponents();
                    }
                }
            },
            _onPreDestroy: function() {
                var i, len;
                this._objFlags |= Destroying;
                var parent = this._parent;
                var destroyByParent = parent && parent._objFlags & Destroying;
                if (!destroyByParent) {
                    if (false) {
                        this._registerIfAttached(false);
                    }
                }
                var children = this._children;
                for (i = 0, len = children.length; i < len; ++i) {
                    children[i]._destroyImmediate();
                }
                for (i = 0, len = this._components.length; i < len; ++i) {
                    var component = this._components[i];
                    component._destroyImmediate();
                }
                this.stopAllActions();
                this._releaseAllActions();
                cc.eventManager.removeListeners(this);
                for (i = 0, len = this.__eventTargets.length; i < len; ++i) {
                    var target = this.__eventTargets[i];
                    target && target.targetOff(this);
                }
                this.__eventTargets.length = 0;
                if (this._persistNode) {
                    cc.game.removePersistRootNode(this);
                }
                if (!destroyByParent) {
                    if (parent) {
                        var childIndex = parent._children.indexOf(this);
                        parent._children.splice(childIndex, 1);
                        parent.emit("child-removed", this);
                    }
                    this._removeSgNode();
                    if (false) {
                        this._parent = null;
                    }
                }
            },
            getComponent: function(typeOrClassName) {
                if (!typeOrClassName) {
                    cc.error("getComponent: Type must be non-nil");
                    return null;
                }
                var constructor;
                if ("string" === typeof typeOrClassName) {
                    constructor = JS.getClassByName(typeOrClassName);
                } else {
                    constructor = typeOrClassName;
                }
                if (constructor) {
                    for (var c = 0; c < this._components.length; ++c) {
                        var component = this._components[c];
                        if (component instanceof constructor) {
                            return component;
                        }
                    }
                }
                return null;
            },
            _checkMultipleComp: false,
            addComponent: function(typeOrClassName) {
                if (this._objFlags & Destroying && false) {
                    cc.error("isDestroying");
                    return null;
                }
                var constructor;
                if ("string" === typeof typeOrClassName) {
                    constructor = JS.getClassByName(typeOrClassName);
                    if (!constructor) {
                        cc.error('addComponent: Failed to get class "%s"', typeOrClassName);
                        if (cc._RFpeek()) {
                            cc.error('addComponent: Should not add component ("%s") when the scripts are still loading.', typeOrClassName);
                        }
                        return null;
                    }
                } else {
                    if (!typeOrClassName) {
                        cc.error("addComponent: Type must be non-nil");
                        return null;
                    }
                    constructor = typeOrClassName;
                }
                if ("function" !== typeof constructor) {
                    cc.error("addComponent: The component to add must be a constructor");
                    return null;
                }
                if (!cc.isChildClassOf(constructor, cc.Component)) {
                    cc.error("addComponent: The component to add must be child class of cc.Component");
                    return null;
                }
                if (constructor._disallowMultiple && false) {
                    if (!this._checkMultipleComp(constructor)) {
                        return null;
                    }
                }
                var ReqComp = constructor._requireComponent;
                if (ReqComp && !this.getComponent(ReqComp)) {
                    var depended = this.addComponent(ReqComp);
                    if (!depended) {
                        return null;
                    }
                }
                var component = new constructor();
                component.node = this;
                this._components.push(component);
                if (this._activeInHierarchy) {
                    component.__onNodeActivated(true);
                }
                return component;
            },
            _addComponentAt: false,
            removeComponent: function(component) {
                if (!component) {
                    cc.error("removeComponent: Component must be non-nil");
                    return;
                }
                if ("object" !== typeof component) {
                    component = this.getComponent(component);
                }
                if (component) {
                    component.destroy();
                }
            },
            _getDependComponent: false,
            _removeComponent: function(component) {
                if (!component) {
                    cc.error("Argument must be non-nil");
                    return;
                }
                if (!(this._objFlags & Destroying)) {
                    var i = this._components.indexOf(component);
                    if (-1 !== i) {
                        this._components.splice(i, 1);
                        component.node = null;
                    } else {
                        if (component.node !== this) {
                            cc.error("Component not owned by this entity");
                        }
                    }
                }
            },
            _registerIfAttached: false,
            _onActivatedInHierarchy: function(newActive) {
                this._activeInHierarchy = newActive;
                var originCount = this._components.length;
                for (var c = 0; c < originCount; ++c) {
                    var component = this._components[c];
                    if (!(component instanceof cc.Component) && false) {
                        cc.error('Sorry, the component of entity "%s" which with an index of %s is corrupted! It has been removed.\nSee DevTools for details.', this.name, c);
                        console.log("Corrupted component value:", component);
                        if (component) {
                            this._removeComponent(component);
                        } else {
                            this._components.splice(c, 1);
                        }
                        --c;
                        --originCount;
                    } else {
                        component.__onNodeActivated(newActive);
                    }
                }
                for (var i = 0, len = this.childrenCount; i < len; ++i) {
                    var child = this._children[i];
                    if (child._active) {
                        child._onActivatedInHierarchy(newActive);
                    }
                }
                var target = this;
                if (cc.sys.isNative) {
                    target = this._sgNode;
                }
                if (newActive) {
                    cc.director.getActionManager().resumeTarget(target);
                    cc.eventManager.resumeTarget(target);
                } else {
                    cc.director.getActionManager().pauseTarget(target);
                    cc.eventManager.pauseTarget(target);
                }
            },
            _onHierarchyChanged: function(oldParent) {
                var newParent = this._parent;
                if (this._persistNode && !(newParent instanceof cc.Scene)) {
                    cc.game.removePersistRootNode(this);
                    if (false) {
                        cc.warn('Set "%s" to normal node (not persist root node).');
                    }
                }
                var activeInHierarchyBefore = this._active && !!(oldParent && oldParent._activeInHierarchy);
                var shouldActiveNow = this._active && !!(newParent && newParent._activeInHierarchy);
                if (activeInHierarchyBefore !== shouldActiveNow) {
                    this._onActivatedInHierarchy(shouldActiveNow);
                }
                if (false) {
                    var scene = cc.director.getScene();
                    var inCurrentSceneBefore = oldParent && oldParent.isChildOf(scene);
                    var inCurrentSceneNow = newParent && newParent.isChildOf(scene);
                    if (!inCurrentSceneBefore && inCurrentSceneNow) {
                        this._registerIfAttached(true);
                    } else {
                        if (inCurrentSceneBefore && !inCurrentSceneNow) {
                            this._registerIfAttached(false);
                        }
                    }
                    var newPrefabRoot = newParent && newParent._prefab && newParent._prefab.root;
                    var myPrefabInfo = this._prefab;
                    if (myPrefabInfo) {
                        if (newPrefabRoot) {
                            Editor.PrefabUtils.linkPrefab(newPrefabRoot._prefab.asset, newPrefabRoot, this);
                        } else {
                            if (myPrefabInfo.root !== this) {
                                Editor.PrefabUtils.unlinkPrefab(this);
                            }
                        }
                    } else {
                        if (newPrefabRoot) {
                            Editor.PrefabUtils.linkPrefab(newPrefabRoot._prefab.asset, newPrefabRoot, this);
                        }
                    }
                }
            },
            _deactivateChildComponents: function() {
                var originCount = this._components.length;
                for (var c = 0; c < originCount; ++c) {
                    var component = this._components[c];
                    component.__onNodeActivated(false);
                }
                for (var i = 0, len = this.childrenCount; i < len; ++i) {
                    var entity = this._children[i];
                    if (entity._active) {
                        entity._deactivateChildComponents();
                    }
                }
            },
            _instantiate: function() {
                var clone = cc.instantiate._clone(this, this);
                clone._parent = null;
                if (false) {
                    this._name += " (Clone)";
                }
                clone._onBatchCreated();
                return clone;
            },
            _onColorChanged: function() {
                for (var c = 0; c < this._components.length; ++c) {
                    var comp = this._components[c];
                    if (comp instanceof cc._ComponentInSG && comp.isValid) {
                        comp._sgNode.setColor(this._color);
                        if (!this._cascadeOpacityEnabled) {
                            comp._sgNode.setOpacity(this._opacity);
                        }
                    }
                }
            },
            _onCascadeChanged: function() {
                var opacity = this._cascadeOpacityEnabled ? 255 : this._opacity;
                for (var c = 0; c < this._components.length; ++c) {
                    var comp = this._components[c];
                    if (comp instanceof cc._ComponentInSG && comp.isValid) {
                        comp._sgNode.setOpacity(opacity);
                    }
                }
            },
            _onAnchorChanged: function() {
                for (var c = 0; c < this._components.length; ++c) {
                    var comp = this._components[c];
                    if (comp instanceof cc._ComponentInSG && comp.isValid) {
                        comp._sgNode.setAnchorPoint(this._anchorPoint);
                        comp._sgNode.ignoreAnchorPointForPosition(this._ignoreAnchorPointForPosition);
                    }
                }
            },
            _onOpacityModifyRGBChanged: function() {
                for (var c = 0; c < this._components.length; ++c) {
                    var comp = this._components[c];
                    if (comp instanceof cc._ComponentInSG && comp.isValid) {
                        comp._sgNode.setOpacityModifyRGB(this._opacityModifyRGB);
                    }
                }
            },
            on: function(type, callback, target) {
                if (-1 !== _touchEvents.indexOf(type)) {
                    if (!this._touchListener) {
                        this._touchListener = cc.EventListener.create({
                            event: cc.EventListener.TOUCH_ONE_BY_ONE,
                            swallowTouches: true,
                            owner: this,
                            mask: _searchMaskParent(this),
                            onTouchBegan: _touchStartHandler,
                            onTouchMoved: _touchMoveHandler,
                            onTouchEnded: _touchEndHandler
                        });
                        this._touchListener.retain();
                        cc.eventManager.addListener(this._touchListener, this);
                    }
                } else {
                    if (-1 !== _mouseEvents.indexOf(type)) {
                        if (!this._mouseListener) {
                            this._mouseListener = cc.EventListener.create({
                                event: cc.EventListener.MOUSE,
                                _previousIn: false,
                                owner: this,
                                mask: _searchMaskParent(this),
                                onMouseDown: _mouseDownHandler,
                                onMouseMove: _mouseMoveHandler,
                                onMouseUp: _mouseUpHandler,
                                onMouseScroll: _mouseWheelHandler
                            });
                            this._mouseListener.retain();
                            cc.eventManager.addListener(this._mouseListener, this);
                        }
                    }
                }
                EventTarget.prototype.on.call(this, type, callback, target);
            },
            off: function(type, callback, target) {
                EventTarget.prototype.off.call(this, type, callback, target);
                if (-1 !== _touchEvents.indexOf(type)) {
                    this._checkTouchListeners();
                } else {
                    if (-1 !== _mouseEvents.indexOf(type)) {
                        this._checkMouseListeners();
                    }
                }
            },
            targetOff: function(target) {
                EventTarget.prototype.targetOff.call(this, target);
                this._checkTouchListeners();
                this._checkMouseListeners();
            },
            _checkTouchListeners: function() {
                if (this._bubblingListeners && this._touchListener) {
                    for (var e in _touchEvents) {
                        if (this._bubblingListeners.has(e)) {
                            return;
                        }
                    }
                    cc.eventManager.removeListener(this._touchListener);
                    this._touchListener = null;
                }
            },
            _checkMouseListeners: function() {
                if (this._bubblingListeners && this._mouseListener) {
                    for (var e in _mouseEvents) {
                        if (this._bubblingListeners.has(e)) {
                            return;
                        }
                    }
                    cc.eventManager.removeListener(this._mouseListener);
                    this._mouseListener = null;
                }
            },
            _hitTest: function(point, listener) {
                var apx = this._anchorPoint.x, apy = this._anchorPoint.y, w = this.width, h = this.height;
                var rect = cc.rect(-apx * w, -apy * h, w, h);
                var trans = this.getNodeToWorldTransform();
                cc._rectApplyAffineTransformIn(rect, trans);
                var left = point.x - rect.x, right = rect.x + rect.width - point.x, bottom = point.y - rect.y, top = rect.y + rect.height - point.y;
                if (left >= 0 && right >= 0 && top >= 0 && bottom >= 0) {
                    if (listener && listener.mask) {
                        var mask = listener.mask;
                        var parent = this;
                        for (var i = 0; parent && i < mask.index; ++i, parent = parent.parent) {}
                        if (parent === mask.node) {
                            return parent._hitTest(point);
                        } else {
                            listener.mask = null;
                            return true;
                        }
                    } else {
                        return true;
                    }
                } else {
                    return false;
                }
            },
            _getBubblingTargets: function(type, array) {
                var parent = this.parent;
                while (parent) {
                    if (parent.hasEventListener(type)) {
                        array.push(parent);
                    }
                    parent = parent.parent;
                }
            },
            isRunning: function() {
                return this.active;
            },
            runAction: function(action) {
                if (!this.active) {
                    return;
                }
                cc.assert(action, cc._LogInfos.Node.runAction);
                var target = this;
                if (cc.sys.isNative) {
                    target = this._sgNode;
                    this._retainAction(action);
                }
                cc.director.getActionManager().addAction(action, target, false);
                return action;
            },
            stopAllActions: function() {
                var target = cc.sys.isNative ? this._sgNode : this;
                cc.director.getActionManager().removeAllActionsFromTarget(target);
            },
            stopAction: function(action) {
                cc.director.getActionManager().removeAction(action);
            },
            stopActionByTag: function(tag) {
                if (tag === cc.ACTION_TAG_INVALID) {
                    cc.log(cc._LogInfos.Node.stopActionByTag);
                    return;
                }
                var target = cc.sys.isNative ? this._sgNode : this;
                cc.director.getActionManager().removeActionByTag(tag, target);
            },
            getActionByTag: function(tag) {
                if (tag === cc.ACTION_TAG_INVALID) {
                    cc.log(cc._LogInfos.Node.getActionByTag);
                    return null;
                }
                var target = cc.sys.isNative ? this._sgNode : this;
                cc.director.getActionManager().getActionByTag(tag, target);
            },
            getNumberOfRunningActions: function() {
                var target = cc.sys.isNative ? this._sgNode : this;
                cc.director.getActionManager().numberOfRunningActionsInTarget(target);
            },
            _retainAction: function(action) {
                if (cc.sys.isNative && action instanceof cc.Action && -1 === this._retainedActions.indexOf(action)) {
                    this._retainedActions.push(action);
                    action.retain();
                }
            },
            _releaseAllActions: function() {
                if (cc.sys.isNative) {
                    for (var i = 0; i < this._retainedActions.length; ++i) {
                        this._retainedActions[i].release();
                    }
                    this._retainedActions.length = 0;
                }
            }
        });
        if (cc.sys.isNative) {
            cc.js.getset(Node.prototype, "_sgNode", function() {
                return this.__sgNode;
            }, function(value) {
                this.__sgNode = value;
                if (this._touchListener) {
                    this._touchListener.retain();
                    cc.eventManager.removeListener(this._touchListener);
                    cc.eventManager.addListener(this._touchListener, this);
                    this._touchListener.release();
                }
                if (this._mouseListener) {
                    this._mouseListener.retain();
                    cc.eventManager.removeListener(this._mouseListener);
                    cc.eventManager.addListener(this._mouseListener, this);
                    this._mouseListener.release();
                }
            }, true);
        }
        Node.EventType = EventType;
        cc.Node = module.exports = Node;
    }, {
        "./event/event-target": 52,
        "./utils/base-node": 85,
        "./utils/misc": 88
    } ],
    21: [ function(require, module, exports) {
        var NIL = function() {};
        cc.Scene = cc.Class({
            name: "cc.Scene",
            "extends": require("./utils/base-node"),
            ctor: function() {
                var sgNode = this._sgNode = new _ccsg.Scene();
                sgNode.retain();
                sgNode.setAnchorPoint(0, 0);
                this._anchorPoint.x = 0;
                this._anchorPoint.y = 0;
                this._activeInHierarchy = false;
                this._inited = !cc.game._isCloning;
            },
            destroy: function() {
                var children = this._children;
                var DontDestroy = cc.Object.Flags.DontDestroy;
                for (var i = 0, len = children.length; i < len; ++i) {
                    var child = children[i];
                    if (child.isValid) {
                        if (!(child._objFlags & DontDestroy)) {
                            child.destroy();
                        }
                    }
                }
                this._super();
                this._activeInHierarchy = false;
            },
            _onHierarchyChanged: NIL,
            _onColorChanged: NIL,
            _onAnchorChanged: NIL,
            _onOpacityModifyRGBChanged: NIL,
            _onCascadeChanged: NIL,
            _load: function() {
                if (!this._inited) {
                    this._onBatchCreated();
                    this._inited = true;
                }
            },
            _activate: function() {
                var i, child, children = this._children, len = children.length;
                if (false) {
                    for (i = 0; i < len; ++i) {
                        child = children[i];
                        child._registerIfAttached(true);
                    }
                }
                this._activeInHierarchy = true;
                for (i = 0; i < len; ++i) {
                    child = children[i];
                    if (child._active) {
                        child._onActivatedInHierarchy(true);
                    }
                }
            }
        });
        module.exports = cc.Scene;
        if (false) {
            var ERR = '"%s" is not defined in the Scene, it is only defined in child nodes.';
            Object.defineProperties(cc.Scene.prototype, {
                active: {
                    get: function() {
                        cc.error(ERR, "active");
                        return true;
                    },
                    set: function() {
                        cc.error(ERR, "active");
                    }
                },
                activeInHierarchy: {
                    get: function() {
                        cc.error(ERR, "activeInHierarchy");
                        return true;
                    }
                },
                getComponent: {
                    get: function() {
                        cc.error(ERR, "getComponent");
                        return function() {
                            return null;
                        };
                    }
                },
                addComponent: {
                    get: function() {
                        cc.error(ERR, "addComponent");
                        return function() {
                            return null;
                        };
                    }
                }
            });
        }
    }, {
        "./utils/base-node": 85
    } ],
    22: [ function(require, module, exports) {
        var RawAsset = require("./CCRawAsset");
        cc.Asset = cc.Class({
            name: "cc.Asset",
            "extends": RawAsset,
            ctor: function() {
                Object.defineProperty(this, "_uuid", {
                    value: "",
                    writable: true,
                    enumerable: false
                });
            },
            properties: {
                url: {
                    get: function() {
                        if (this._rawFiles) {
                            if (cc.AssetLibrary) {
                                var url = cc.AssetLibrary.getImportedDir(this._uuid);
                                var filename = this._rawFiles[0];
                                return url + cc.path.sep + filename;
                            } else {
                                cc.error("asset.url is not usable in core process");
                            }
                        }
                        return "";
                    },
                    visible: false
                },
                urls: {
                    get: function() {
                        if (this._rawFiles) {
                            if (cc.AssetLibrary) {
                                var url = cc.AssetLibrary.getImportedDir(this._uuid);
                                return this._rawFiles.map(function(filename) {
                                    return url + cc.path.sep + filename;
                                });
                            } else {
                                cc.error("asset.urls is not usable in core process");
                            }
                        }
                        return [];
                    },
                    visible: false
                },
                _rawFiles: null
            },
            statics: {
                deserialize: function(data) {
                    return cc.deserialize(data);
                }
            },
            serialize: function() {
                return Editor.serialize(this);
            },
            createNode: null,
            _setRawFiles: function(rawFiles) {
                rawFiles = rawFiles.map(function(item) {
                    if ("." === item.charAt(0)) {
                        item = item.slice(1);
                    }
                    var nextChar = item.charAt(0);
                    if ("/" === nextChar || "\\" === nextChar) {
                        item = item.slice(1);
                    }
                    return item;
                });
                this._rawFiles = rawFiles.length > 0 ? rawFiles : null;
            }
        });
        module.exports = cc.Asset;
    }, {
        "./CCRawAsset": 27
    } ],
    23: [ function(require, module, exports) {
        var AudioClip = cc.Class({
            name: "cc.AudioClip",
            "extends": cc.RawAsset
        });
        cc.AudioClip = AudioClip;
        module.exports = AudioClip;
    }, {} ],
    24: [ function(require, module, exports) {
        var BitmapFont = cc.Class({
            name: "cc.BitmapFont",
            "extends": cc.Font
        });
        cc.BitmapFont = BitmapFont;
        module.exports = BitmapFont;
    }, {} ],
    25: [ function(require, module, exports) {
        var Font = cc.Class({
            name: "cc.Font",
            "extends": cc.RawAsset
        });
        cc.Font = Font;
        module.exports = Font;
    }, {} ],
    26: [ function(require, module, exports) {
        function visitWrapper(wrapper, visitor) {
            visitor(wrapper);
            var children = wrapper._children;
            for (var i = 0; i < children.length; i++) {
                visitor(children[i]);
            }
        }
        var Prefab = cc.Class({
            name: "cc.Prefab",
            "extends": cc.Asset,
            properties: {
                data: null
            },
            createNode: function(cb) {
                if (false) {
                    var node = cc.instantiate(this);
                    cb(null, node);
                }
            },
            _instantiate: function() {
                var node = cc.instantiate(this.data);
                if (false) {
                    Editor.PrefabUtils.linkPrefab(this, node);
                }
                return node;
            }
        });
        cc.Prefab = module.exports = Prefab;
        cc.js.obsolete(cc, "cc._Prefab", "Prefab");
    }, {} ],
    27: [ function(require, module, exports) {
        var CCObject = require("../platform/CCObject");
        cc.RawAsset = cc.Class({
            name: "cc.RawAsset",
            "extends": CCObject,
            statics: {
                createNodeByInfo: null
            }
        });
        module.exports = cc.RawAsset;
    }, {
        "../platform/CCObject": 62
    } ],
    28: [ function(require, module, exports) {
        var Scene = cc.Class({
            name: "cc.SceneAsset",
            "extends": cc.Asset,
            properties: {
                scene: null
            }
        });
        cc.SceneAsset = Scene;
        module.exports = Scene;
    }, {} ],
    29: [ function(require, module, exports) {
        var Script = cc.Class({
            name: "cc.Script",
            "extends": cc.Asset
        });
        cc._Script = Script;
        var JavaScript = cc.Class({
            name: "cc.JavaScript",
            "extends": Script
        });
        cc._JavaScript = JavaScript;
        var CoffeeScript = cc.Class({
            name: "cc.CoffeeScript",
            "extends": Script
        });
        cc._CoffeeScript = CoffeeScript;
    }, {} ],
    30: [ function(require, module, exports) {
        var SpriteAnimationAsset = cc.Class({
            name: "cc.SpriteAnimationAsset",
            "extends": cc.Asset,
            properties: {
                0: {
                    "default": "",
                    url: cc.Texture2D
                },
                1: {
                    "default": "",
                    url: cc.Texture2D
                },
                2: {
                    "default": "",
                    url: cc.Texture2D
                },
                3: {
                    "default": "",
                    url: cc.Texture2D
                },
                4: {
                    "default": "",
                    url: cc.Texture2D
                },
                5: {
                    "default": "",
                    url: cc.Texture2D
                },
                6: {
                    "default": "",
                    url: cc.Texture2D
                },
                7: {
                    "default": "",
                    url: cc.Texture2D
                },
                8: {
                    "default": "",
                    url: cc.Texture2D
                },
                9: {
                    "default": "",
                    url: cc.Texture2D
                },
                loop: {
                    "default": true
                },
                delay: {
                    "default": .5
                }
            }
        });
        cc.SpriteAnimationAsset = SpriteAnimationAsset;
        module.exports = SpriteAnimationAsset;
    }, {} ],
    31: [ function(require, module, exports) {
        var SpriteAtlas = cc.Class({
            name: "cc.SpriteAtlas",
            "extends": cc.Asset
        });
        cc.SpriteAtlas = SpriteAtlas;
        module.exports = SpriteAtlas;
    }, {} ],
    32: [ function(require, module, exports) {
        var TTFFont = cc.Class({
            name: "cc.TTFFont",
            "extends": cc.Font
        });
        cc.TTFFont = TTFFont;
        module.exports = TTFFont;
    }, {} ],
    33: [ function(require, module, exports) {
        var TiledMapAsset = cc.Class({
            name: "cc.TiledMapAsset",
            "extends": cc.RawAsset,
            statics: {
                createNodeByInfo: function(info, callback) {
                    if (false) {
                        var Url = require("fire-url");
                        cc.TiledMapWrapper.preloadTmx(info.url, function(err, textures) {
                            if (err) {
                                callback(err);
                                return;
                            }
                            var node;
                            try {
                                node = new cc.TMXTiledMap(info.url);
                                node._file = info.url;
                            } catch (e) {
                                return callback(e);
                            }
                            var wrapper = cc.getWrapper(node);
                            wrapper.name = Url.basenameNoExt(info.url);
                            wrapper._textures = textures;
                            return callback(null, node);
                        }.bind(this));
                    }
                }
            }
        });
        cc.TiledMapAsset = TiledMapAsset;
        module.exports = TiledMapAsset;
    }, {
        "fire-url": void 0
    } ],
    34: [ function(require, module, exports) {
        require("./CCRawAsset");
        require("./CCAsset");
        require("./CCFont");
        require("./CCPrefab");
        require("./CCAudioClip");
        require("./CCBitmapFont");
        require("./CCScripts");
        require("./CCSceneAsset");
        require("../sprites/CCSpriteFrame");
        require("../textures/CCTexture2D");
        require("./CCTTFFont");
        require("./CCSpriteAnimation");
        require("./CCSpriteAtlas");
        require("./CCTiledMapAsset");
    }, {
        "../sprites/CCSpriteFrame": 77,
        "../textures/CCTexture2D": 78,
        "./CCAsset": 22,
        "./CCAudioClip": 23,
        "./CCBitmapFont": 24,
        "./CCFont": 25,
        "./CCPrefab": 26,
        "./CCRawAsset": 27,
        "./CCSceneAsset": 28,
        "./CCScripts": 29,
        "./CCSpriteAnimation": 30,
        "./CCSpriteAtlas": 31,
        "./CCTTFFont": 32,
        "./CCTiledMapAsset": 33
    } ],
    35: [ function(require, module, exports) {
        function getParentSize(parent) {
            if (parent instanceof cc.Scene) {
                return false ? cc.engine.getDesignResolutionSize() : cc.visibleRect;
            } else {
                if (!parent._sizeProvider || parent._sizeProvider instanceof _ccsg.Node) {
                    return parent._contentSize;
                } else {
                    return parent.getContentSize();
                }
            }
        }
        function alignToParent(node, widget) {
            var parent = node._parent;
            var parentSize = getParentSize(parent);
            var parentWidth = parentSize.width;
            var parentHeight = parentSize.height;
            var parentAnchor = parent._anchorPoint;
            var localLeft, localRight, localTop, localBottom;
            if (true && parent instanceof cc.Scene) {
                var visibleRect = cc.visibleRect;
                localLeft = visibleRect.left.x;
                localRight = visibleRect.right.x;
                localBottom = visibleRect.bottom.y;
                localTop = visibleRect.top.y;
            } else {
                localLeft = -parentAnchor.x * parentWidth;
                localRight = localLeft + parentWidth;
                localBottom = -parentAnchor.y * parentHeight;
                localTop = localBottom + parentHeight;
            }
            localLeft += widget._isAbsLeft ? widget._left : widget._left * parentWidth;
            localRight -= widget._isAbsRight ? widget._right : widget._right * parentWidth;
            localBottom += widget._isAbsBottom ? widget._bottom : widget._bottom * parentHeight;
            localTop -= widget._isAbsTop ? widget._top : widget._top * parentHeight;
            var anchor = node.getAnchorPoint();
            var width, x = node._position.x, anchorX = anchor.x;
            if (widget.isStretchWidth) {
                width = localRight - localLeft;
                node.width = width;
                x = localLeft + anchorX * width;
            } else {
                width = node.width;
                if (widget.isAlignHorizontalCenter) {
                    var parentCenter = (.5 - parentAnchor.x) * parentWidth;
                    x = parentCenter + (anchorX - .5) * width;
                } else {
                    if (widget.isAlignLeft) {
                        x = localLeft + anchorX * width;
                    } else {
                        if (widget.isAlignRight) {
                            x = localRight + anchorX * width - width;
                        }
                    }
                }
            }
            var height, y = node._position.y, anchorY = anchor.y;
            if (widget.isStretchHeight) {
                height = localTop - localBottom;
                node.height = height;
                y = localBottom + anchorY * height;
            } else {
                height = node.height;
                if (widget.isAlignVerticalCenter) {
                    var parentMiddle = (.5 - parentAnchor.y) * parentHeight;
                    y = parentMiddle + (anchorY - .5) * height;
                } else {
                    if (widget.isAlignBottom) {
                        y = localBottom + anchorY * height;
                    } else {
                        if (widget.isAlignTop) {
                            y = localTop + anchorY * height - height;
                        }
                    }
                }
            }
            node.setPosition(x, y);
        }
        function visitNode(node) {
            var widget = node._widget;
            if (widget) {
                alignToParent(node, widget);
            }
            var children = node._children;
            for (var i = 0; i < children.length; i++) {
                var child = children[i];
                if (child._active) {
                    visitNode(child);
                }
            }
        }
        function visit() {
            var scene = cc.director.getScene();
            if (scene) {
                widgetManager.isAligning = true;
                visitNode(scene);
                widgetManager.isAligning = false;
            }
        }
        var adjustWidgetToAllowMovingInEditor = false;
        var adjustWidgetToAllowResizingInEditor = false;
        var widgetManager = cc._widgetManager = {
            isAligning: false,
            init: function(director) {
                director.on(cc.Director.EVENT_BEFORE_VISIT, visit);
            },
            add: function(widget) {
                widget.node._widget = widget;
                if (false) {
                    widget.node.on("position-changed", adjustWidgetToAllowMovingInEditor, widget);
                    widget.node.on("size-changed", adjustWidgetToAllowResizingInEditor, widget);
                }
            },
            remove: function(widget) {
                widget.node._widget = null;
                if (false) {
                    widget.node.off("position-changed", adjustWidgetToAllowMovingInEditor, widget);
                    widget.node.off("size-changed", adjustWidgetToAllowResizingInEditor, widget);
                }
            },
            _getParentSize: getParentSize
        };
    }, {} ],
    36: [ function(require, module, exports) {
        var AnimationAnimator = require("../../animation/animation-animator");
        var AnimationClip = require("../../animation/animation-clip");
        function equalClips(clip1, clip2) {
            if (clip1 === clip2) {
                return true;
            }
            return clip1 && clip2 && (clip1.name === clip2.name || clip1._uuid === clip2._uuid);
        }
        var Animation = cc.Class({
            name: "cc.Animation",
            "extends": require("./CCComponent"),
            editor: false,
            ctor: function() {
                this._animator = null;
                this._nameToState = {};
                this._didInit = false;
                this._currentClip = null;
            },
            properties: {
                _defaultClip: {
                    "default": null,
                    type: AnimationClip
                },
                defaultClip: {
                    type: AnimationClip,
                    get: function() {
                        return this._defaultClip;
                    },
                    set: function(value) {
                        var engine = cc.engine;
                        if (true) {
                            return;
                        }
                        this._defaultClip = value;
                        var clips = this._clips;
                        for (var i = 0, l = clips.length; i < l; i++) {
                            if (equalClips(value, clips[i])) {
                                return;
                            }
                        }
                        this.addClip(value);
                    },
                    tooltip: "i18n:COMPONENT.animation.default_clip"
                },
                currentClip: {
                    get: function() {
                        return this._currentClip;
                    },
                    set: function(value, force) {
                        this._currentClip = value;
                        if (false) {
                            this._updateClip(value);
                        }
                    },
                    type: AnimationClip,
                    visible: false
                },
                _clips: {
                    "default": [],
                    type: [ AnimationClip ],
                    tooltip: "i18n:COMPONENT.animation.clips",
                    visible: true
                },
                playOnLoad: {
                    "default": false,
                    tooltip: "i18n:COMPONENT.animation.play_on_load"
                }
            },
            onLoad: function() {
                if (false) {
                    return;
                }
                this._init();
                if (this.playOnLoad && this._defaultClip) {
                    var state = this.getAnimationState(this._defaultClip.name);
                    this._animator.playState(state);
                }
            },
            onDisable: function() {
                this.stop();
            },
            getClips: function() {
                return this._clips;
            },
            play: function(name, startTime) {
                this._init();
                var state = this.getAnimationState(name || this._defaultClip.name);
                if (state) {
                    var animator = this._animator;
                    if (animator.isPlaying && state.isPlaying) {
                        if (state.isPaused) {
                            animator.resumeState(state);
                        } else {
                            animator.stopState(state);
                            animator.playState(state, startTime);
                        }
                    } else {
                        animator.playState(state, startTime);
                    }
                    this.currentClip = state.clip;
                }
                return state;
            },
            stop: function(name) {
                if (!this._didInit) {
                    return;
                }
                if (name) {
                    var state = this._nameToState[name];
                    if (state) {
                        this._animator.stopState(state);
                    }
                } else {
                    this._animator.stop();
                }
            },
            pause: function(name) {
                if (!this._didInit) {
                    return;
                }
                if (name) {
                    var state = this._nameToState[name];
                    if (state) {
                        this._animator.pauseState(state);
                    }
                } else {
                    this._animator.pause();
                }
            },
            resume: function(name) {
                if (!this._didInit) {
                    return;
                }
                if (name) {
                    var state = this._nameToState[name];
                    if (state) {
                        this._animator.resumeState(state);
                    }
                } else {
                    this._animator.resume();
                }
            },
            setCurrentTime: function(time, name) {
                this._init();
                if (name) {
                    var state = this._nameToState[name];
                    if (state) {
                        this._animator.setStateTime(state, time);
                    }
                } else {
                    for (var name in this._nameToState) {
                        state = this._nameToState[name];
                        this._animator.setStateTime(state, time);
                    }
                }
            },
            getAnimationState: function(name) {
                this._init();
                var state = this._nameToState[name];
                if (false) {
                    this._didInit = false;
                    if (this.animator) {
                        this.animator.stop();
                    }
                    this._init();
                    state = this._nameToState[name];
                }
                return state || null;
            },
            addClip: function(clip, newName) {
                if (!clip) {
                    cc.warn("Invalid clip to add");
                    return;
                }
                this._init();
                if (!cc.js.array.contains(this._clips, clip)) {
                    this._clips.push(clip);
                }
                newName = newName || clip.name;
                var oldState = this._nameToState[newName];
                if (oldState) {
                    if (oldState.clip === clip) {
                        return oldState;
                    } else {
                        this._clips.splice(this._clips.indexOf(oldState.clip), 1);
                    }
                }
                var newState = new cc.AnimationState(clip, newName);
                this._nameToState[newName] = newState;
                return newState;
            },
            _removeStateIfNotUsed: function(state, force) {
                var needRemove = state.clip !== this._defaultClip && !cc.js.array.contains(this._clips, state.clip);
                if (force || needRemove) {
                    if (state.isPlaying) {
                        this.stop(state.name);
                    }
                    delete this._nameToState[state.name];
                }
            },
            removeClip: function(clip, force) {
                if (!clip) {
                    cc.warn("Invalid clip to remove");
                    return;
                }
                this._init();
                this._clips = this._clips.filter(function(item) {
                    return item !== clip;
                });
                var state;
                for (var name in this._nameToState) {
                    state = this._nameToState[name];
                    var stateClip = state.clip;
                    if (stateClip === clip) {
                        this._removeStateIfNotUsed(state, force);
                    }
                }
            },
            sample: function() {
                this._init();
                this._animator.sample();
            },
            _init: function() {
                if (this._didInit) {
                    return;
                }
                this._didInit = true;
                this._animator = new AnimationAnimator(this.node, this);
                this._createStates();
            },
            _createStates: function() {
                var state = null;
                var defaultClipState = false;
                for (var i = 0; i < this._clips.length; ++i) {
                    var clip = this._clips[i];
                    if (clip) {
                        state = new cc.AnimationState(clip);
                        if (false) {
                            this._animator.reloadClip(state);
                        }
                        this._nameToState[state.name] = state;
                        if (equalClips(this._defaultClip, clip)) {
                            defaultClipState = state;
                        }
                    }
                }
                if (this._defaultClip && !defaultClipState) {
                    state = new cc.AnimationState(this._defaultClip);
                    if (false) {
                        this._animator.reloadClip(state);
                    }
                    this._nameToState[state.name] = state;
                }
            },
            _updateClip: false
        });
        cc.Animation = module.exports = Animation;
    }, {
        "../../animation/animation-animator": 3,
        "../../animation/animation-clip": 4,
        "./CCComponent": 40
    } ],
    37: [ function(require, module, exports) {
        var audioEngine = cc.audioEngine;
        var AudioSource = cc.Class({
            name: "cc.AudioSource",
            "extends": require("./CCComponent"),
            editor: false,
            ctor: function() {
                this.audio = null;
            },
            properties: {
                _clip: {
                    "default": "",
                    url: cc.AudioClip
                },
                _volume: 1,
                _mute: false,
                _loop: false,
                isPlaying: {
                    get: function() {
                        return !cc.sys.isNative && this.audio && this.audio.getPlaying();
                    },
                    visible: false
                },
                clip: {
                    get: function() {
                        return this._clip;
                    },
                    set: function(value) {
                        this._clip = value;
                    },
                    url: cc.AudioClip,
                    tooltip: "i18n.COMPONENT.audio.clip"
                },
                volume: {
                    get: function() {
                        return this._volume;
                    },
                    set: function(value) {
                        this._volume = value;
                        if (this.audio) {
                            if (cc.sys.isNative) {
                                cc.audioEngine.setEffectsVolume(value);
                            } else {
                                this.audio.setVolume(value);
                            }
                        }
                    },
                    tooltip: "i18n.COMPONENT.audio.volume"
                },
                mute: {
                    get: function() {
                        return this._mute;
                    },
                    set: function(value) {
                        this._mute = value;
                        if (this.audio) {
                            if (this._mute) {
                                if (cc.sys.isNative) {
                                    cc.audioEngine.setEffectsVolume(0);
                                } else {
                                    this.audio.setVolume(0);
                                }
                            } else {
                                if (cc.sys.isNative) {
                                    cc.audioEngine.setEffectsVolume(this._volume);
                                } else {
                                    this.audio.setVolume(this._volume);
                                }
                            }
                        }
                    },
                    tooltip: "i18n.COMPONENT.audio.mute"
                },
                loop: {
                    get: function() {
                        return this._loop;
                    },
                    set: function(value) {
                        this._loop = value;
                        if ("object" === typeof this.audio) {
                            this.audio.loop = this._loop;
                        }
                    },
                    tooltip: "i18n.COMPONENT.audio.loop"
                },
                playOnLoad: {
                    "default": false,
                    tooltip: "i18n.COMPONENT.audio.play_on_load"
                }
            },
            onLoad: function() {
                if (this.isPlaying) {
                    this.stop();
                }
            },
            onEnable: function() {
                if (this.playOnLoad) {
                    this.play();
                }
            },
            onDisable: function() {
                this.stop();
            },
            onDestroy: function() {
                this.stop();
            },
            play: function() {
                if (this._clip) {
                    this.audio = audioEngine.playEffect(this._clip, this._loop);
                }
            },
            stop: function() {
                if (this.audio) {
                    cc.audioEngine.stopEffect(this.audio);
                }
            },
            pause: function() {
                if (this.audio) {
                    cc.audioEngine.pauseEffect(this.audio);
                }
            },
            resume: function() {
                if (this.audio) {
                    cc.audioEngine.resumeEffect(this.audio);
                }
            },
            rewind: function() {
                if (this.audio) {
                    cc.audioEngine.stopEffect(this.audio);
                    cc.audioEngine.playEffect(this.audio);
                }
            }
        });
        cc.AudioSource = module.exports = AudioSource;
    }, {
        "./CCComponent": 40
    } ],
    38: [ function(require, module, exports) {
        var Transition = cc.Enum({
            NONE: 0,
            COLOR: 1,
            SPRITE: 2
        });
        var ClickEvent = cc.Class({
            name: "cc.ClickEvent",
            properties: {
                target: {
                    "default": null,
                    type: cc.Node,
                    tooltip: "i18n:COMPONENT.button.click_event.target"
                },
                component: {
                    "default": "",
                    tooltip: "i18n:COMPONENT.button.click_event.component"
                },
                handler: {
                    "default": "",
                    tooltip: "i18n:COMPONENT.button.click_event.handler"
                }
            }
        });
        var WHITE = cc.Color.WHITE;
        var ButtonState = {
            Normal: "normal",
            Pressed: "pressed",
            Hover: "hover",
            Disabled: "disabled"
        };
        var Button = cc.Class({
            name: "cc.Button",
            "extends": require("./CCComponent"),
            ctor: function() {
                this._pressed = false;
                this._hovered = false;
                this._sprite = null;
                this._fromColor = null;
                this._toColor = null;
                this._time = 0;
                this._transitionFinished = true;
            },
            editor: false,
            properties: {
                interactable: {
                    "default": true,
                    tooltip: "i18n:COMPONENT.button.interactable",
                    notify: function() {
                        this._initState();
                    }
                },
                transition: {
                    "default": Transition.NONE,
                    tooltip: "i18n:COMPONENT.button.transition",
                    type: Transition
                },
                normalColor: {
                    "default": WHITE,
                    displayName: "Normal",
                    tooltip: "i18n:COMPONENT.button.normal_color",
                    notify: function() {
                        this._initState();
                    }
                },
                pressedColor: {
                    "default": WHITE,
                    displayName: "Pressed",
                    tooltip: "i18n:COMPONENT.button.pressed_color"
                },
                hoverColor: {
                    "default": WHITE,
                    displayName: "Hover",
                    tooltip: "i18n:COMPONENT.button.hover_color"
                },
                disabledColor: {
                    "default": WHITE,
                    displayName: "Disabled",
                    tooltip: "i18n:COMPONENT.button.diabled_color",
                    notify: function() {
                        this._initState();
                    }
                },
                duration: {
                    "default": .1,
                    range: [ 0, Number.MAX_VALUE ],
                    tooltip: "i18n:COMPONENT.button.duration"
                },
                normalSprite: {
                    "default": null,
                    type: cc.SpriteFrame,
                    displayName: "Normal",
                    tooltip: "i18n:COMPONENT.button.normal_sprite",
                    notify: function() {
                        this._initState();
                    }
                },
                pressedSprite: {
                    "default": null,
                    type: cc.SpriteFrame,
                    displayName: "Pressed",
                    tooltip: "i18n:COMPONENT.button.pressed_sprite"
                },
                hoverSprite: {
                    "default": null,
                    type: cc.SpriteFrame,
                    displayName: "Hover",
                    tooltip: "i18n:COMPONENT.button.hover_sprite"
                },
                disabledSprite: {
                    "default": null,
                    type: cc.SpriteFrame,
                    displayName: "Disabled",
                    tooltip: "i18n:COMPONENT.button.disabled_sprite",
                    notify: function() {
                        this._initState();
                    }
                },
                target: {
                    "default": null,
                    type: cc.Node,
                    tooltip: "i18n:COMPONENT.button.target",
                    notify: function() {
                        this._applyTarget();
                    }
                },
                clickEvents: {
                    "default": [],
                    type: ClickEvent,
                    tooltip: "i18n:COMPONENT.button.click_events"
                }
            },
            statics: {
                Transition: Transition,
                ClickEvent: ClickEvent
            },
            onLoad: function() {
                if (!this.target) {
                    this.target = this.node;
                }
                if (true) {
                    this._registerEvent();
                }
            },
            start: function() {
                this._applyTarget();
                this._initState();
            },
            update: function(dt) {
                var target = this.target;
                if (!this.transition === Transition.COLOR || !target || this._transitionFinished) {
                    return;
                }
                this.time += dt;
                var ratio = this.time / this.duration;
                if (ratio > 1) {
                    ratio = 1;
                    this._transitionFinished = true;
                }
                target.color = this._fromColor.lerp(this._toColor, ratio);
            },
            _registerEvent: function() {
                this.node.on(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this);
                this.node.on(cc.Node.EventType.TOUCH_MOVE, this._onTouchMove, this);
                this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
                this.node.on(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancel, this);
                this.node.on(cc.Node.EventType.MOUSE_ENTER, this._onMouseMoveIn, this);
                this.node.on(cc.Node.EventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
            },
            _handleClickEvent: function() {
                var events = this.clickEvents;
                for (var i = 0, l = events.length; i < l; i++) {
                    var event = events[i];
                    var target = event.target;
                    if (!target) {
                        continue;
                    }
                    var comp = target.getComponent(event.component);
                    if (!comp) {
                        continue;
                    }
                    var handler = comp[event.handler];
                    if (!handler) {
                        continue;
                    }
                    handler.call(comp);
                }
            },
            _cancelButtonClick: function() {
                this._pressed = false;
            },
            _applyTarget: function() {
                var target = this.target;
                if (target) {
                    this._sprite = target.getComponent(cc.Sprite);
                } else {
                    this._sprite = null;
                }
            },
            _initState: function() {
                var state = this.interactable ? ButtonState.Normal : ButtonState.Disabled;
                this._applyState(state);
            },
            _onTouchBegan: function(event) {
                if (!this.interactable || !this.enabledInHierarchy) {
                    return;
                }
                this._pressed = true;
                this._applyState(ButtonState.Pressed);
            },
            _onTouchMove: function(event) {
                var touch = event.touch;
                var hit = this.node._hitTest(touch.getLocation());
                if (hit && this._pressed) {
                    this._applyState(ButtonState.Pressed);
                } else {
                    this._applyState(ButtonState.Normal);
                }
            },
            _onTouchEnded: function() {
                if (this._hovered) {
                    this._applyState(ButtonState.Hover);
                }
                if (this._pressed) {
                    this._applyState(ButtonState.Normal);
                    this._handleClickEvent();
                }
                this._pressed = false;
            },
            _onTouchCancel: function() {
                this._pressed = false;
            },
            _onMouseMoveIn: function(event) {
                if (this._pressed || !this.interactable || !this.enabledInHierarchy) {
                    return;
                }
                if (!this._hovered) {
                    this._hovered = true;
                    this._applyState(ButtonState.Hover);
                }
            },
            _onMouseMoveOut: function() {
                if (!this.interactable || !this.enabledInHierarchy) {
                    return;
                }
                if (this._hovered) {
                    this._hovered = false;
                    this._applyState(ButtonState.Normal);
                }
            },
            _applyState: function(state) {
                var color = this[state + "Color"];
                var sprite = this[state + "Sprite"];
                this._applyTransition(color, sprite);
            },
            _applyTransition: function(color, sprite) {
                var transition = this.transition;
                if (transition === Transition.COLOR) {
                    var target = this.target;
                    if (false) {
                        target.color = color;
                    } else {
                        this._fromColor = target.color.clone();
                        this._toColor = color;
                        this.time = 0;
                        this._transitionFinished = false;
                    }
                } else {
                    if (transition === Transition.SPRITE && this._sprite && sprite) {
                        this._sprite.spriteFrame = sprite;
                    }
                }
            }
        });
        cc.Button = module.exports = Button;
    }, {
        "./CCComponent": 40
    } ],
    39: [ function(require, module, exports) {
        var designResolutionWrapper = {
            getContentSize: function() {
                return false ? cc.engine.getDesignResolutionSize() : cc.visibleRect;
            },
            setContentSize: function(size) {},
            _getWidth: function() {
                return this.getContentSize().width;
            },
            _getHeight: function() {
                return this.getContentSize().height;
            }
        };
        var Canvas = cc.Class({
            name: "cc.Canvas",
            "extends": require("./CCComponent"),
            editor: false,
            statics: {
                instance: null
            },
            properties: {
                _designResolution: cc.size(960, 640),
                designResolution: {
                    get: function() {
                        return cc.size(this._designResolution);
                    },
                    set: function(value) {
                        this._designResolution.width = value.width;
                        this._designResolution.height = value.height;
                        this.applySettings();
                    },
                    tooltip: "i18n:COMPONENT.canvas.design_resolution"
                },
                _fitWidth: false,
                _fitHeight: true,
                fitHeight: {
                    get: function() {
                        return this._fitHeight;
                    },
                    set: function(value) {
                        if (this._fitHeight !== value) {
                            this._fitHeight = value;
                            this.applySettings();
                        }
                    },
                    tooltip: "i18n:COMPONENT.canvas.fit_height"
                },
                fitWidth: {
                    get: function() {
                        return this._fitWidth;
                    },
                    set: function(value) {
                        if (this._fitWidth !== value) {
                            this._fitWidth = value;
                            this.applySettings();
                        }
                    },
                    tooltip: "i18n:COMPONENT.canvas.fit_width"
                }
            },
            ctor: function() {
                this._thisOnResized = this.onResized.bind(this);
            },
            onLoad: function() {
                if (Canvas.instance) {
                    return cc.error("Can't init canvas '%s' because it conflicts with the existing '%s', the scene should only have one active canvas at the same time", this.node.name, Canvas.instance.node.name);
                }
                Canvas.instance = this;
                if (!this.node._sizeProvider) {
                    this.node._sizeProvider = designResolutionWrapper;
                } else {
                    cc.error("CCCanvas: Node can only have one size.");
                }
                cc.director.on(cc.Director.EVENT_BEFORE_VISIT, this.alignWithScreen, this);
                if (false) {
                    cc.engine.on("design-resolution-changed", this._thisOnResized);
                } else {
                    if (!cc.sys.isNative) {
                        if (cc.sys.isMobile) {
                            window.addEventListener("resize", this._thisOnResized);
                        } else {
                            cc.eventManager.addCustomListener("canvas-resize", this._thisOnResized);
                        }
                    }
                }
                this.onResized();
                this.applySettings();
            },
            onDestroy: function() {
                if (this.node._sizeProvider === designResolutionWrapper) {
                    this.node._sizeProvider = null;
                }
                cc.director.off(cc.Director.EVENT_BEFORE_VISIT, this.alignWithScreen, this);
                if (false) {
                    cc.engine.off("design-resolution-changed", this._thisOnResized);
                } else {
                    if (!cc.sys.isNative) {
                        if (cc.sys.isMobile) {
                            window.removeEventListener("resize", this._thisOnResized);
                        } else {
                            cc.eventManager.removeCustomListeners("canvas-resize", this._thisOnResized);
                        }
                    }
                }
                if (Canvas.instance === this) {
                    Canvas.instance = null;
                }
            },
            alignWithScreen: function() {
                var designSize;
                if (false) {
                    designSize = cc.engine.getDesignResolutionSize();
                    this.node.setPosition(.5 * designSize.width, .5 * designSize.height);
                } else {
                    var canvasSize = cc.visibleRect;
                    var clipTopRight = !this.fitHeight && !this.fitWidth;
                    var offsetX = 0;
                    var offsetY = 0;
                    if (clipTopRight) {
                        designSize = cc.view.getDesignResolutionSize();
                        offsetX = .5 * (designSize.width - canvasSize.width);
                        offsetY = .5 * (designSize.height - canvasSize.height);
                    }
                    this.node.setPosition(.5 * canvasSize.width + offsetX, .5 * canvasSize.height + offsetY);
                }
            },
            onResized: function() {
                this.alignWithScreen();
            },
            applySettings: function() {
                var ResolutionPolicy = cc.ResolutionPolicy;
                var policy;
                if (this.fitHeight && this.fitWidth) {
                    policy = ResolutionPolicy.SHOW_ALL;
                } else {
                    if (!this.fitHeight && !this.fitWidth) {
                        policy = ResolutionPolicy.NO_BORDER;
                    } else {
                        if (this.fitWidth) {
                            policy = ResolutionPolicy.FIXED_WIDTH;
                        } else {
                            policy = ResolutionPolicy.FIXED_HEIGHT;
                        }
                    }
                }
                var designRes = this._designResolution;
                if (false) {
                    cc.engine.setDesignResolutionSize(designRes.width, designRes.height);
                } else {
                    cc.view.setDesignResolutionSize(designRes.width, designRes.height, policy);
                }
            }
        });
        cc.Canvas = module.exports = Canvas;
    }, {
        "./CCComponent": 40
    } ],
    40: [ function(require, module, exports) {
        require("../platform/CCObject");
        require("../CCNode");
        var Flags = cc.Object.Flags;
        var IsOnEnableCalled = Flags.IsOnEnableCalled;
        var IsOnLoadCalled = Flags.IsOnLoadCalled;
        var IsOnStartCalled = Flags.IsOnStartCalled;
        var ExecInTryCatchTmpl = false;
        if (false) {
            ExecInTryCatchTmpl = "(function call_FUNC_InTryCatch (c) { c._FUNC_() })";
        }
        var callOnEnableInTryCatch = false;
        var callOnDisableInTryCatch = false;
        var callOnLoadInTryCatch = false;
        var callStartInTryCatch = false;
        var callOnDestroyInTryCatch = false;
        var callOnFocusInTryCatch = false;
        var callOnLostFocusInTryCatch = false;
        function callOnEnable(self, enable) {
            if (false) {
                if (!(cc.engine.isPlaying || self.constructor._executeInEditMode)) {
                    return;
                }
            }
            var enableCalled = self._objFlags & IsOnEnableCalled;
            if (enable) {
                if (!enableCalled) {
                    if (self.onEnable) {
                        if (false) {
                            callOnEnableInTryCatch(self);
                        } else {
                            self.onEnable();
                        }
                    }
                    cc.director.getScheduler().resumeTarget(self);
                    _registerEvent(self, true);
                    self._objFlags |= IsOnEnableCalled;
                }
            } else {
                if (enableCalled) {
                    if (self.onDisable) {
                        if (false) {
                            callOnDisableInTryCatch(self);
                        } else {
                            self.onDisable();
                        }
                    }
                    cc.director.getScheduler().pauseTarget(self);
                    _registerEvent(self, false);
                    self._objFlags &= ~IsOnEnableCalled;
                }
            }
        }
        function _registerEvent(self, on) {
            if (false) {
                return;
            }
            if (on && self.start && !(self._objFlags & IsOnStartCalled)) {
                cc.director.once(cc.Director.EVENT_BEFORE_UPDATE, _callStart, self);
            }
            if (self.update) {
                if (on) {
                    cc.director.on(cc.Director.EVENT_COMPONENT_UPDATE, _callUpdate, self);
                } else {
                    cc.director.off(cc.Director.EVENT_COMPONENT_UPDATE, _callUpdate, self);
                }
            }
            if (self.lateUpdate) {
                if (on) {
                    cc.director.on(cc.Director.EVENT_COMPONENT_LATE_UPDATE, _callLateUpdate, self);
                } else {
                    cc.director.off(cc.Director.EVENT_COMPONENT_LATE_UPDATE, _callLateUpdate, self);
                }
            }
        }
        var _callStart = false ? function() {
            callStartInTryCatch(this);
            this._objFlags |= IsOnStartCalled;
        } : function() {
            this.start();
            this._objFlags |= IsOnStartCalled;
        };
        var _callUpdate = false ? function(event) {
            try {
                this.update(event.detail);
            } catch (e) {
                cc._throw(e);
            }
        } : function(event) {
            this.update(event.detail);
        };
        var _callLateUpdate = false ? function(event) {
            try {
                this.lateUpdate(event.detail);
            } catch (e) {
                cc._throw(e);
            }
        } : function(event) {
            this.lateUpdate(event.detail);
        };
        var CompId = 0;
        var IdPrefix = false;
        var getNewId = false;
        var Component = cc.Class({
            name: "cc.Component",
            "extends": cc.Object,
            ctor: function() {
                if (false) {
                    Editor._AssetsWatcher.initComponent(this);
                }
                Object.defineProperty(this, "_id", {
                    value: "",
                    enumerable: false
                });
                this.__instanceId = this._id || cc.ClassManager.getNewInstanceId();
            },
            properties: {
                node: {
                    "default": null,
                    visible: false
                },
                _id: {
                    "default": "",
                    serializable: false
                },
                uuid: {
                    get: function() {
                        var id = this._id;
                        if (id) {
                            return id;
                        }
                        if (false) {
                            id = this._id = getNewId();
                            cc.engine.attachedObjsForEditor[id] = this;
                            return id;
                        }
                    },
                    visible: false
                },
                __scriptAsset: false,
                _enabled: true,
                enabled: {
                    get: function() {
                        return this._enabled;
                    },
                    set: function(value) {
                        if (this._enabled !== value) {
                            this._enabled = value;
                            if (this.node._activeInHierarchy) {
                                callOnEnable(this, value);
                            }
                        }
                    },
                    visible: false
                },
                enabledInHierarchy: {
                    get: function() {
                        return this._enabled && this.node._activeInHierarchy;
                    },
                    visible: false
                },
                _isOnLoadCalled: {
                    get: function() {
                        return this._objFlags & IsOnLoadCalled;
                    },
                    visible: false
                },
                __eventTargets: {
                    "default": [],
                    serializable: false
                },
                localSize: {
                    get: function() {
                        return cc.size(0, 0);
                    },
                    visible: false
                }
            },
            update: null,
            lateUpdate: null,
            onLoad: null,
            start: null,
            onEnable: null,
            onDisable: null,
            onDestroy: null,
            onFocusInEditMode: null,
            onLostFocusInEditMode: null,
            addComponent: function(typeOrTypename) {
                return this.node.addComponent(typeOrTypename);
            },
            getComponent: function(typeOrTypename) {
                return this.node.getComponent(typeOrTypename);
            },
            destroy: function() {
                if (false) {
                    var depend = this.node._getDependComponent(this);
                    if (depend) {
                        return cc.error("Can't remove '%s' because '%s' depends on it.", cc.js.getClassName(this), cc.js.getClassName(depend));
                    }
                }
                if (this._super()) {
                    if (this._enabled && this.node._activeInHierarchy) {
                        callOnEnable(this, false);
                    }
                }
            },
            __onNodeActivated: false ? function(active) {
                if (!(this._objFlags & IsOnLoadCalled) && (cc.engine._isPlaying || this.constructor._executeInEditMode)) {
                    if (this.onLoad) {
                        callOnLoadInTryCatch(this);
                        this._objFlags |= IsOnLoadCalled;
                        if (!cc.engine._isPlaying) {
                            var focused = Editor.Selection.curActivate("node") === this.node.uuid;
                            if (focused && this.onFocusInEditMode) {
                                callOnFocusInTryCatch(this);
                            } else {
                                if (this.onLostFocusInEditMode) {
                                    callOnLostFocusInTryCatch(this);
                                }
                            }
                        }
                    } else {
                        this._objFlags |= IsOnLoadCalled;
                    }
                    Editor._AssetsWatcher.start(this);
                }
                if (this._enabled) {
                    callOnEnable(this, active);
                }
            } : function(active) {
                if (!(this._objFlags & IsOnLoadCalled)) {
                    if (this.onLoad) {
                        this.onLoad();
                    }
                    this._objFlags |= IsOnLoadCalled;
                }
                if (this._enabled) {
                    callOnEnable(this, active);
                }
            },
            _onPreDestroy: function() {
                var i, l, target;
                callOnEnable(this, false);
                this.unscheduleAllCallbacks();
                for (i = 0, l = this.__eventTargets.length; i < l; ++i) {
                    target = this.__eventTargets[i];
                    target && target.targetOff(this);
                }
                this.__eventTargets.length = 0;
                cc.eventManager.removeListeners(this);
                if (false) {
                    Editor._AssetsWatcher.stop(this);
                    if (cc.engine._isPlaying || this.constructor._executeInEditMode) {
                        if (this.onDestroy) {
                            callOnDestroyInTryCatch(this);
                        }
                    }
                } else {
                    if (this.onDestroy) {
                        this.onDestroy();
                    }
                }
                this.node._removeComponent(this);
                if (false) {
                    delete cc.engine.attachedObjsForEditor[this._id];
                }
            },
            isRunning: function() {
                return this.enabledInHierarchy;
            },
            schedule: function(callback, interval, repeat, delay) {
                cc.assert(callback, cc._LogInfos.Node.schedule);
                cc.assert(interval >= 0, cc._LogInfos.Node.schedule_2);
                interval = interval || 0;
                repeat = isNaN(repeat) ? cc.REPEAT_FOREVER : repeat;
                delay = delay || 0;
                cc.director.getScheduler().scheduleCallbackForTarget(this, callback, interval, repeat, delay, !this.enabledInHierarchy);
            },
            scheduleOnce: function(callback, delay) {
                this.schedule(callback, 0, 0, delay);
            },
            unschedule: function(callback_fn) {
                if (!callback_fn) {
                    return;
                }
                cc.director.getScheduler().unschedule(callback_fn, this);
            },
            unscheduleAllCallbacks: function() {
                cc.director.getScheduler().unscheduleAllForTarget(this);
            }
        });
        Component._requireComponent = null;
        if (false) {
            Component._executeInEditMode = false;
            Component._playOnFocus = false;
            Component._disallowMultiple = null;
            Object.defineProperty(Component, "_inspector", {
                value: "",
                enumerable: false
            });
            Object.defineProperty(Component, "_icon", {
                value: "",
                enumerable: false
            });
            cc._componentMenuItems = [];
            Component._addMenuItem = function(cls, path, priority) {
                cc._componentMenuItems.push({
                    component: cls,
                    menuPath: path,
                    priority: priority
                });
            };
        }
        Object.defineProperty(Component, "_registerEditorProps", {
            value: function(cls, props) {
                var reqComp = props.requireComponent;
                if (reqComp) {
                    cls._requireComponent = reqComp;
                }
                if (false) {
                    var name = cc.js.getClassName(cls);
                    for (var key in props) {
                        var val = props[key];
                        switch (key) {
                          case "executeInEditMode":
                            cls._executeInEditMode = !!val;
                            break;

                          case "playOnFocus":
                            if (val) {
                                var willExecuteInEditMode = "executeInEditMode" in props ? props.executeInEditMode : cls._executeInEditMode;
                                if (willExecuteInEditMode) {
                                    cls._playOnFocus = true;
                                } else {
                                    cc.warn('The editor property "playOnFocus" should be used with "executeInEditMode" in class "%s".', name);
                                }
                            }
                            break;

                          case "inspector":
                            Object.defineProperty(cls, "_inspector", {
                                value: val
                            });
                            break;

                          case "icon":
                            Object.defineProperty(cls, "_icon", {
                                value: val
                            });
                            break;

                          case "menu":
                            Component._addMenuItem(cls, val, props.menuPriority);
                            break;

                          case "disallowMultiple":
                            cls._disallowMultiple = cls;
                            break;

                          case "requireComponent":
                            break;

                          default:
                            cc.warn('Unknown editor property "%s" in class "%s".', key, name);
                        }
                    }
                }
            }
        });
        Component.prototype.__scriptUuid = "";
        cc.Component = module.exports = Component;
    }, {
        "../CCNode": 20,
        "../platform/CCObject": 62
    } ],
    41: [ function(require, module, exports) {
        var SceneGraphHelper = require("../utils/scene-graph-helper");
        var ComponentInSG = cc.Class({
            "extends": require("./CCComponent"),
            editor: false,
            ctor: function() {
                this._sgNode = null;
            },
            onLoad: function() {
                var sgNode = this._createSgNode();
                this._appendSgNode(sgNode);
                if (!this.node._sizeProvider) {
                    this.node._sizeProvider = sgNode;
                }
            },
            onEnable: function() {
                if (this._sgNode) {
                    this._sgNode.visible = true;
                }
            },
            onDisable: function() {
                if (this._sgNode) {
                    this._sgNode.visible = false;
                }
            },
            onDestroy: function() {
                if (this.node._sizeProvider === this._sgNode) {
                    this.node._sizeProvider = null;
                }
                this._removeSgNode();
            },
            _createSgNode: null,
            _removeSgNode: SceneGraphHelper.removeSgNode,
            _appendSgNode: function(sgNode) {
                var node = this.node;
                sgNode.setColor(node._color);
                if (!node._cascadeOpacityEnabled) {
                    sgNode.setOpacity(node._opacity);
                }
                sgNode.setAnchorPoint(node._anchorPoint);
                sgNode.ignoreAnchorPointForPosition(node._ignoreAnchorPointForPosition);
                sgNode.setOpacityModifyRGB(node._opacityModifyRGB);
                sgNode.setLocalZOrder(-1);
                var sgParent = node._sgNode;
                sgParent.addChild(sgNode);
                sgNode.retain();
                this._sgNode = sgNode;
            }
        });
        cc._ComponentInSG = module.exports = ComponentInSG;
    }, {
        "../utils/scene-graph-helper": 89,
        "./CCComponent": 40
    } ],
    42: [ function(require, module, exports) {
        var HorizontalAlign = cc.TextAlignment;
        var VerticalAlign = cc.VerticalTextAlignment;
        var Overflow = _ccsg.Label.Overflow;
        var LabelType = _ccsg.Label.Type;
        var Label = cc.Class({
            name: "cc.Label",
            "extends": cc._ComponentInSG,
            editor: false,
            properties: {
                _useOriginalSize: true,
                string: {
                    "default": "Label",
                    multiline: true,
                    tooltip: "i18n:COMPONENT.label.string",
                    notify: function() {
                        var sgNode = this._sgNode;
                        if (sgNode) {
                            sgNode.setString(this.string);
                        }
                    }
                },
                horizontalAlign: {
                    "default": HorizontalAlign.LEFT,
                    type: HorizontalAlign,
                    tooltip: "i18n:COMPONENT.label.horizontal_align",
                    notify: function() {
                        var sgNode = this._sgNode;
                        if (sgNode) {
                            sgNode.setHorizontalAlign(this.horizontalAlign);
                        }
                    }
                },
                verticalAlign: {
                    "default": VerticalAlign.TOP,
                    type: VerticalAlign,
                    tooltip: "i18n:COMPONENT.label.vertical_align",
                    notify: function() {
                        var sgNode = this._sgNode;
                        if (sgNode) {
                            sgNode.setVerticalAlign(this.verticalAlign);
                        }
                    }
                },
                _fontSize: 40,
                fontSize: {
                    get: function() {
                        var sgNode = this._sgNode;
                        if (sgNode) {
                            this._fontSize = sgNode.getFontSize();
                        }
                        return this._fontSize;
                    },
                    set: function(value) {
                        this._fontSize = value;
                        var sgNode = this._sgNode;
                        if (sgNode) {
                            sgNode.setFontSize(value);
                        }
                    },
                    tooltip: "i18n:COMPONENT.label.font_size"
                },
                _lineHeight: 20,
                lineHeight: {
                    get: function() {
                        var sgNode = this._sgNode;
                        if (sgNode) {
                            this._lineHeight = sgNode.getLineHeight();
                        }
                        return this._lineHeight;
                    },
                    set: function(value) {
                        this._lineHeight = value;
                        var sgNode = this._sgNode;
                        if (sgNode) {
                            sgNode.setLineHeight(value);
                        }
                    },
                    tooltip: "i18n:COMPONENT.label.line_height"
                },
                overflow: {
                    "default": Overflow.CLAMP,
                    type: Overflow,
                    tooltip: "i18n:COMPONENT.label.overflow",
                    notify: function() {
                        var sgNode = this._sgNode;
                        if (sgNode) {
                            sgNode.setOverflow(this.overflow === _ccsg.Label.Overflow.NONE ? _ccsg.Label.Overflow.CLAMP : this.overflow);
                        }
                    }
                },
                _enableWrapText: true,
                enableWrapText: {
                    get: function() {
                        var sgNode = this._sgNode;
                        if (sgNode) {
                            this._enableWrapText = sgNode.isWrapTextEnabled();
                        }
                        return this._enableWrapText;
                    },
                    set: function(value) {
                        this._enableWrapText = value;
                        var sgNode = this._sgNode;
                        if (sgNode) {
                            sgNode.enableWrapText(value);
                        }
                    },
                    tooltip: "i18n:COMPONENT.label.wrap"
                },
                file: {
                    "default": "Arial",
                    url: cc.Font,
                    tooltip: "i18n:COMPONENT.label.file",
                    notify: function() {
                        var sgNode = this._sgNode;
                        if (sgNode) {
                            sgNode.setFontFileOrFamily(this.file);
                        }
                    }
                },
                _isSystemFontUsed: true,
                useSystemFont: {
                    get: function() {
                        var sgNode = this._sgNode;
                        if (sgNode) {
                            this._isSystemFontUsed = sgNode.isSystemFontUsed();
                        }
                        return this._isSystemFontUsed;
                    },
                    set: function(value) {
                        var sgNode = this._sgNode;
                        this._isSystemFontUsed = value;
                        if (value) {
                            if (sgNode) {
                                this.file = "";
                                sgNode.setSystemFontUsed(value);
                            }
                        }
                    },
                    tooltip: "i18n:COMPONENT.label.system_font"
                }
            },
            statics: {
                HorizontalAlign: HorizontalAlign,
                VerticalAlign: VerticalAlign,
                Overflow: Overflow
            },
            onLoad: function() {
                this._super();
                this.node.on("size-changed", this._resized, this);
            },
            onDestroy: function() {
                this._super();
                this.node.off("size-changed", this._resized, this);
            },
            _createSgNode: function() {
                var sgNode = new _ccsg.Label(this.string, this.file);
                sgNode.setHorizontalAlign(this.horizontalAlign);
                sgNode.setVerticalAlign(this.verticalAlign);
                sgNode.setFontSize(this.fontSize);
                sgNode.setOverflow(this.overflow);
                sgNode.enableWrapText(this.enableWrapText);
                sgNode.setLineHeight(this.lineHeight);
                if (!this._useOriginalSize) {
                    sgNode.setContentSize(this.node.getContentSize());
                }
                sgNode.setColor(this.node.color);
                return sgNode;
            },
            _resized: function() {
                this._useOriginalSize = false;
            }
        });
        cc.Label = module.exports = Label;
    }, {} ],
    43: [ function(require, module, exports) {
        var Type = cc.Enum({
            NONE: 0,
            HORIZONTAL: 1,
            VERTICAL: 2
        });
        var VerticalDirection = cc.Enum({
            BOTTOM_TO_TOP: 0,
            TOP_TO_BOTTOM: 1
        });
        var HorizontalDirection = cc.Enum({
            LEFT_TO_RIGHT: 0,
            RIGHT_TO_LEFT: 1
        });
        var Layout = cc.Class({
            name: "cc.Layout",
            "extends": require("./CCComponent"),
            editor: false,
            properties: {
                _layoutSize: cc.size(300, 200),
                _layoutDirty: {
                    "default": true,
                    serializable: false
                },
                layoutType: {
                    "default": Type.NONE,
                    type: Type,
                    notify: function() {
                        this._doLayoutDirty();
                    },
                    tooltip: "i18n:COMPONENT.layout.layout_type"
                },
                autoResize: {
                    "default": true,
                    readonly: true,
                    tooltip: "i18n:COMPONENT.layout.auto_resize"
                },
                margin: {
                    "default": 0,
                    notify: function() {
                        this._doLayoutDirty();
                    },
                    tooltip: "i18n:COMPONENT.layout.margin"
                },
                spacingX: {
                    "default": 0,
                    notify: function() {
                        this._doLayoutDirty();
                    },
                    tooltip: "i18n:COMPONENT.layout.space_x"
                },
                spacingY: {
                    "default": 0,
                    notify: function() {
                        this._doLayoutDirty();
                    },
                    tooltip: "i18n:COMPONENT.layout.space_y"
                },
                verticalDirection: {
                    "default": VerticalDirection.TOP_TO_BOTTOM,
                    type: VerticalDirection,
                    notify: function() {
                        this._doLayoutDirty();
                    },
                    tooltip: "i18n:COMPONENT.layout.vertical_direction"
                },
                horizontalDirection: {
                    "default": HorizontalDirection.LEFT_TO_RIGHT,
                    type: HorizontalDirection,
                    notify: function() {
                        this._doLayoutDirty();
                    },
                    tooltip: "i18n:COMPONENT.layout.horizontal_direction"
                }
            },
            statics: {
                Type: Type,
                VerticalDirection: VerticalDirection,
                HorizontalDirection: HorizontalDirection
            },
            onLoad: function() {
                this.node.setContentSize(this._layoutSize);
                this.node.on("size-changed", this._resized, this);
                this.node.on("anchor-changed", this._doLayoutDirty, this);
                this.node.on("child-added", this._childrenAddOrDeleted, this);
                this.node.on("child-removed", this._childrenAddOrDeleted, this);
                this._updateChildrenEventListener();
            },
            _doLayoutDirty: function() {
                this._layoutDirty = true;
            },
            _updateChildrenEventListener: function() {
                var children = this.node.children;
                children.forEach(function(child) {
                    child.on("size-changed", this._doLayoutDirty, this);
                    child.on("position-changed", this._doLayoutDirty, this);
                    child.on("anchor-changed", this._doLayoutDirty, this);
                }.bind(this));
            },
            _childrenAddOrDeleted: function(event) {
                this._updateChildrenEventListener();
                this._doLayoutDirty();
            },
            _resized: function() {
                this._layoutSize = this.node.getContentSize();
                this._doLayoutDirty();
            },
            _doLayoutHorizontally: function(layoutAnchor, layoutSize, children) {
                var newWidth = 0;
                var sign = 1;
                children.forEach(function(child) {
                    newWidth += child.width;
                });
                newWidth += (children.length - 1) * this.spacingX + 2 * this.margin;
                this.node.setContentSize(newWidth, layoutSize.height);
                var leftBoundaryOfLayout = -layoutAnchor.x * newWidth;
                if (this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
                    sign = -1;
                    leftBoundaryOfLayout = (1 - layoutAnchor.x) * newWidth;
                }
                var nextX = leftBoundaryOfLayout + sign * this.margin - sign * this.spacingX;
                children.forEach(function(child) {
                    var anchorX = child.anchorX;
                    if (this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
                        anchorX = 1 - child.anchorX;
                    }
                    nextX = nextX + sign * anchorX * child.width + sign * this.spacingX;
                    child.setPosition(cc.p(nextX, child.y));
                    nextX += sign * (1 - anchorX) * child.width;
                }.bind(this));
            },
            _doLayoutVertically: function(layoutAnchor, layoutSize, children) {
                var newHeight = 0;
                var sign = 1;
                children.forEach(function(child) {
                    newHeight += child.height;
                });
                newHeight += (children.length - 1) * this.spacingY + 2 * this.margin;
                this.node.setContentSize(layoutSize.width, newHeight);
                var bottomBoundaryOfLayout = -layoutAnchor.y * newHeight;
                if (this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
                    sign = -1;
                    bottomBoundaryOfLayout = (1 - layoutAnchor.y) * newHeight;
                }
                var nextY = bottomBoundaryOfLayout + sign * this.margin - sign * this.spacingY;
                children.forEach(function(child) {
                    var anchorY = child.anchorY;
                    if (this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
                        anchorY = 1 - child.anchorY;
                    }
                    nextY = nextY + sign * anchorY * child.height + sign * this.spacingY;
                    child.setPosition(cc.p(child.x, nextY));
                    nextY += sign * (1 - anchorY) * child.height;
                }.bind(this));
            },
            _doLayoutBasic: function(layoutAnchor, layoutSize, children) {
                var allChildrenBoundingBox = null;
                children.forEach(function(child) {
                    if (!allChildrenBoundingBox) {
                        allChildrenBoundingBox = child.getBoundingBoxToWorld();
                    } else {
                        allChildrenBoundingBox = cc.rectUnion(allChildrenBoundingBox, child.getBoundingBoxToWorld());
                    }
                });
                if (allChildrenBoundingBox) {
                    var leftBottomInParentSpace = this.node.parent.convertToNodeSpaceAR(cc.p(allChildrenBoundingBox.x, allChildrenBoundingBox.y));
                    var rightTopInParentSpace = this.node.parent.convertToNodeSpaceAR(cc.p(allChildrenBoundingBox.x + allChildrenBoundingBox.width, allChildrenBoundingBox.y + allChildrenBoundingBox.height));
                    var newSize = cc.size(rightTopInParentSpace.x - leftBottomInParentSpace.x, rightTopInParentSpace.y - leftBottomInParentSpace.y);
                    var layoutPosition = this.node.getPosition();
                    var newAnchor = cc.p((layoutPosition.x - leftBottomInParentSpace.x) / newSize.width, (layoutPosition.y - leftBottomInParentSpace.y) / newSize.height);
                    this.node.setAnchorPoint(newAnchor);
                    this.node.setContentSize(newSize);
                }
            },
            _doLayout: function() {
                var children = this.node.children;
                var layoutAnchor = this.node.getAnchorPoint();
                var layoutSize = this.node.getContentSize();
                if (this.layoutType === Type.HORIZONTAL) {
                    this._doLayoutHorizontally(layoutAnchor, layoutSize, children);
                } else {
                    if (this.layoutType === Type.VERTICAL) {
                        this._doLayoutVertically(layoutAnchor, layoutSize, children);
                    } else {
                        if (this.layoutType === Type.NONE) {
                            this._doLayoutBasic(layoutAnchor, layoutSize, children);
                        }
                    }
                }
            },
            lateUpdate: function() {
                if (this._layoutDirty && this.node.children.length > 0) {
                    this._doLayout();
                    this._layoutDirty = false;
                }
            }
        });
        cc.Layout = module.exports = Layout;
    }, {
        "./CCComponent": 40
    } ],
    44: [ function(require, module, exports) {
        var Mask = cc.Class({
            name: "cc.Mask",
            "extends": cc.Component,
            editor: false,
            properties: {
                _clippingNode: {
                    "default": null,
                    serializable: false
                },
                _clippingStencil: {
                    "default": null,
                    serializable: false
                }
            },
            onLoad: function() {
                this._clippingStencil = new cc.DrawNode();
                this._clippingNode = new cc.ClippingNode(this._clippingStencil);
                if (cc.sys.isNative) {
                    this._clippingStencil.retain();
                    this._clippingNode.retain();
                }
            },
            onDestroy: function() {
                if (cc.sys.isNative) {
                    this._clippingStencil && this._clippingStencil.release();
                    this._clippingNode && this._clippingNode.release();
                }
            },
            _refreshStencil: function() {
                var contentSize = this.node._contentSize;
                var anchorPoint = this.node._anchorPoint;
                var x = contentSize.width * anchorPoint.x;
                var y = contentSize.height * anchorPoint.y;
                this._clippingStencil.clear();
                var rectangle = [ cc.v2(-x, -y), cc.v2(contentSize.width - x, -y), cc.v2(contentSize.width - x, contentSize.height - y), cc.v2(-x, contentSize.height - y) ];
                this._clippingStencil.drawPoly(rectangle, cc.color(255, 255, 255, 0), 0, cc.color(255, 255, 255, 0));
            },
            onEnable: function() {
                var oldNode = this.node._sgNode;
                this._refreshStencil();
                this.node._replaceSgNode(this._clippingNode);
                this.node.on("size-changed", this._onContentSizeChanged, this);
                this.node.on("anchor-changed", this._onAnchorChanged, this);
            },
            onDisable: function() {
                var oldNode = this.node._sgNode;
                var newNode = new _ccsg.Node();
                this.node._replaceSgNode(newNode);
                this.node.off("size-changed", this._onContentSizeChanged, this);
                this.node.off("anchor-changed", this._onAnchorChanged, this);
            },
            _onContentSizeChanged: function() {
                if (this._clippingStencil) {
                    this._refreshStencil();
                }
            },
            _onAnchorChanged: function() {
                if (this._clippingStencil) {
                    this._refreshStencil();
                }
            }
        });
        cc.Mask = module.exports = Mask;
    }, {} ],
    45: [ function(require, module, exports) {
        var Mode = cc.Enum({
            HORIZONTAL: 0,
            VERTICAL: 1
        });
        var ProgressBar = cc.Class({
            name: "cc.ProgressBar",
            "extends": require("./CCComponent"),
            editor: false,
            _initBarSprite: function() {
                if (this.barSprite) {
                    var entity = this.barSprite.node;
                    var nodeSize = this.node.getContentSize();
                    var nodeAnchor = this.node.getAnchorPoint();
                    var entitySize = entity.getContentSize();
                    if (entity.parent === this.node) {
                        this.node.setContentSize(entitySize);
                    }
                    var barSpriteSize = entity.getContentSize();
                    if (this.mode === Mode.HORIZONTAL) {
                        this.totalLength = barSpriteSize.width;
                    } else {
                        this.totalLength = barSpriteSize.height;
                    }
                    if (entity.parent === this.node) {
                        var x = -nodeSize.width * nodeAnchor.x;
                        var y = 0;
                        entity.setPosition(cc.p(x, y));
                    }
                }
            },
            _updateBarStatus: function() {
                if (this.barSprite) {
                    var entity = this.barSprite.node;
                    var entityAnchorPoint = entity.getAnchorPoint();
                    var entitySize = entity.getContentSize();
                    var entityPosition = entity.getPosition();
                    var anchorPoint = cc.p(0, .5);
                    var actualLenth = this.totalLength * this.progress;
                    var finalContentSize;
                    var totalWidth;
                    var totalHeight;
                    switch (this.mode) {
                      case Mode.HORIZONTAL:
                        if (this.reverse) {
                            anchorPoint = cc.p(1, .5);
                        }
                        finalContentSize = cc.size(actualLenth, entitySize.height);
                        totalWidth = this.totalLength;
                        totalHeight = entitySize.height;
                        break;

                      case Mode.VERTICAL:
                        if (this.reverse) {
                            anchorPoint = cc.p(.5, 1);
                        } else {
                            anchorPoint = cc.p(.5, 0);
                        }
                        finalContentSize = cc.size(entitySize.width, actualLenth);
                        totalWidth = entitySize.width;
                        totalHeight = this.totalLength;
                    }
                    var anchorOffsetX = anchorPoint.x - entityAnchorPoint.x;
                    var anchorOffsetY = anchorPoint.y - entityAnchorPoint.y;
                    var finalPosition = cc.p(totalWidth * anchorOffsetX, totalHeight * anchorOffsetY);
                    entity.setPosition(cc.pAdd(entityPosition, finalPosition));
                    entity.setAnchorPoint(anchorPoint);
                    entity.setContentSize(finalContentSize);
                }
            },
            properties: {
                barSprite: {
                    "default": null,
                    type: cc.Sprite,
                    tooltip: "i18n:COMPONENT.progress.bar_sprite",
                    notify: function() {
                        this._initBarSprite();
                    }
                },
                mode: {
                    "default": Mode.HORIZONTAL,
                    type: Mode,
                    tooltip: "i18n:COMPONENT.progress.mode",
                    notify: function() {
                        if (this.barSprite) {
                            var entity = this.barSprite.node;
                            var entitySize = entity.getContentSize();
                            if (this.mode === Mode.HORIZONTAL) {
                                this.totalLength = entitySize.width;
                            } else {
                                if (this.mode === Mode.VERTICAL) {
                                    this.totalLength = entitySize.height;
                                }
                            }
                        }
                    }
                },
                totalLength: {
                    "default": 1,
                    range: [ 0, Number.MAX_VALUE ],
                    tooltip: "i18n:COMPONENT.progress.total_length",
                    notify: function(value) {
                        this._updateBarStatus();
                    }
                },
                progress: {
                    "default": 1,
                    type: "Float",
                    range: [ 0, 1, .1 ],
                    tooltip: "i18n:COMPONENT.progress.progress",
                    notify: function() {
                        this._updateBarStatus();
                    }
                },
                reverse: {
                    "default": false,
                    tooltip: "i18n:COMPONENT.progress.reverse",
                    notify: function() {
                        this._updateBarStatus();
                    }
                }
            },
            statics: {
                Mode: Mode
            }
        });
        cc.ProgressBar = module.exports = ProgressBar;
    }, {
        "./CCComponent": 40
    } ],
    46: [ function(require, module, exports) {
        var GETTINGSHORTERFACTOR = 20;
        var Direction = cc.Enum({
            HORIZONTAL: 0,
            VERTICAL: 1
        });
        var Scrollbar = cc.Class({
            name: "cc.Scrollbar",
            "extends": require("./CCComponent"),
            editor: false,
            properties: {
                _scrollView: null,
                _touching: false,
                _autoHideRemainingTime: {
                    "default": 0,
                    serializable: false
                },
                _opacity: 255,
                handle: {
                    "default": null,
                    type: cc.Sprite,
                    tooltip: "i18n:COMPONENT.scrollbar.handle",
                    notify: function() {
                        this._onScroll(cc.p(0, 0));
                    }
                },
                direction: {
                    "default": Direction.HORIZONTAL,
                    type: Direction,
                    tooltip: "i18n:COMPONENT.scrollbar.direction",
                    notify: function() {
                        this._onScroll(cc.p(0, 0));
                    }
                },
                enableAutoHide: {
                    "default": true,
                    tooltip: "i18n:COMPONENT.scrollbar.auto_hide"
                },
                autoHideTime: {
                    "default": 1,
                    tooltip: "i18n:COMPONENT.scrollbar.auto_hide_time"
                }
            },
            statics: {
                Direction: Direction
            },
            setTargetScrollView: function(scrollView) {
                this._scrollView = scrollView;
            },
            _convertToScrollViewSpace: function(content) {
                var worldSpacePos = content.convertToWorldSpace(cc.p(0, 0));
                var scrollViewSpacePos = this._scrollView.node.convertToNodeSpace(worldSpacePos);
                return scrollViewSpacePos;
            },
            _setOpacity: function(opacity) {
                if (this.handle) {
                    this.node.setOpacity(opacity);
                }
            },
            _onScroll: function(outOfBoundary) {
                if (this._scrollView) {
                    var content = this._scrollView.content;
                    if (content) {
                        var contentSize = content.getContentSize();
                        var scrollViewSize = this._scrollView.node.getContentSize();
                        if (this._conditionalDisableScrollBar(contentSize, scrollViewSize)) {
                            return;
                        }
                        if (this.enableAutoHide) {
                            this._autoHideRemainingTime = this.autoHideTime;
                            this._setOpacity(this._opacity);
                        }
                        var contentMeasure = 0;
                        var scrollViewMeasure = 0;
                        var outOfBoundaryValue = 0;
                        var contentPosition = 0;
                        if (this.direction === Direction.HORIZONTAL) {
                            contentMeasure = contentSize.width;
                            scrollViewMeasure = scrollViewSize.width;
                            outOfBoundaryValue = outOfBoundary.x;
                            contentPosition = -this._convertToScrollViewSpace(content).x;
                        } else {
                            if (this.direction === Direction.VERTICAL) {
                                contentMeasure = contentSize.height;
                                scrollViewMeasure = scrollViewSize.height;
                                outOfBoundaryValue = outOfBoundary.y;
                                contentPosition = -this._convertToScrollViewSpace(content).y;
                            }
                        }
                        var length = this._calculateLength(contentMeasure, scrollViewMeasure, outOfBoundaryValue);
                        var position = this._calculatePosition(contentMeasure, scrollViewMeasure, contentPosition, outOfBoundaryValue, length);
                        this._updateLength(length);
                        this._updateHanlderPosition(position);
                    }
                }
            },
            _updateHanlderPosition: function(position) {
                if (this.handle) {
                    var oldPosition = this._fixupHandlerPosition();
                    this.handle.node.setPosition(cc.pAdd(position, oldPosition));
                }
            },
            _fixupHandlerPosition: function() {
                var barSize = this.node.getContentSize();
                var barAnchor = this.node.getAnchorPoint();
                var barPosition = this.node.getPosition();
                var fixupPosition;
                var handleParent = this.handle.node.parent;
                if (this.direction === Direction.HORIZONTAL) {
                    var leftSideWorldPosition = this.node.convertToWorldSpaceAR(cc.p(-barSize.width * barAnchor.x, -barSize.height * barAnchor.y));
                    fixupPosition = handleParent.convertToNodeSpaceAR(leftSideWorldPosition);
                } else {
                    if (this.direction === Direction.VERTICAL) {
                        var bottomSideWorldPosition = this.node.convertToWorldSpaceAR(cc.p(-barSize.width * barAnchor.x, -barSize.height * barAnchor.y));
                        fixupPosition = handleParent.convertToNodeSpaceAR(bottomSideWorldPosition);
                    }
                }
                this.handle.node.setPosition(fixupPosition);
                return fixupPosition;
            },
            _onTouchBegan: function() {
                if (!this.enableAutoHide) {
                    return;
                }
                this._touching = true;
            },
            _conditionalDisableScrollBar: function(contentSize, scrollViewSize) {
                if (contentSize.width <= scrollViewSize.width && this.direction === Direction.HORIZONTAL) {
                    return true;
                }
                if (contentSize.height <= scrollViewSize.height && this.direction === Direction.VERTICAL) {
                    return true;
                }
                return false;
            },
            _onTouchEnded: function() {
                if (!this.enableAutoHide) {
                    return;
                }
                this._touching = false;
                if (this.autoHideTime <= 0) {
                    return;
                }
                if (this._scrollView) {
                    var content = this._scrollView.content;
                    if (content) {
                        var contentSize = content.getContentSize();
                        var scrollViewSize = this._scrollView.node.getContentSize();
                        if (this._conditionalDisableScrollBar(contentSize, scrollViewSize)) {
                            return;
                        }
                    }
                }
                this._autoHideRemainingTime = this.autoHideTime;
            },
            _calculateLength: function(contentMeasure, scrollViewMeasure, outOfBoundary) {
                var denominatorValue = contentMeasure;
                if (outOfBoundary) {
                    denominatorValue += (outOfBoundary > 0 ? outOfBoundary : -outOfBoundary) * GETTINGSHORTERFACTOR;
                }
                var lengthRation = scrollViewMeasure / denominatorValue;
                return scrollViewMeasure * lengthRation;
            },
            _calculatePosition: function(contentMeasure, scrollViewMeasure, contentPosition, outOfBoundary, actualLenth) {
                var denominatorValue = contentMeasure - scrollViewMeasure;
                if (outOfBoundary) {
                    denominatorValue += Math.abs(outOfBoundary);
                }
                var positionRatio = 0;
                if (denominatorValue) {
                    positionRatio = contentPosition / denominatorValue;
                    positionRatio = cc.clamp01(positionRatio);
                }
                var position = (scrollViewMeasure - actualLenth) * positionRatio;
                if (this.direction === Direction.VERTICAL) {
                    return cc.p(0, position);
                } else {
                    return cc.p(position, 0);
                }
            },
            _updateLength: function(length) {
                if (this.handle) {
                    var handleNode = this.handle.node;
                    var handleNodeSize = this.node.getContentSize();
                    handleNode.setAnchorPoint(cc.p(0, 0));
                    if (this.direction === Direction.HORIZONTAL) {
                        handleNode.setContentSize(length, handleNodeSize.height);
                    } else {
                        handleNode.setContentSize(handleNodeSize.width, length);
                    }
                }
            },
            _processAutoHide: function(deltaTime) {
                if (!this.enableAutoHide || this._autoHideRemainingTime <= 0) {
                    return;
                } else {
                    if (this._touching) {
                        return;
                    }
                }
                this._autoHideRemainingTime -= deltaTime;
                if (this._autoHideRemainingTime <= this.autoHideTime) {
                    this._autoHideRemainingTime = Math.max(0, this._autoHideRemainingTime);
                    var opacity = this._opacity * (this._autoHideRemainingTime / this.autoHideTime);
                    this._setOpacity(opacity);
                }
            },
            start: function() {
                if (this.enableAutoHide) {
                    this._setOpacity(0);
                }
            },
            update: function(dt) {
                this._processAutoHide(dt);
            }
        });
        cc.Scrollbar = module.exports = Scrollbar;
    }, {
        "./CCComponent": 40
    } ],
    47: [ function(require, module, exports) {
        var NUMBER_OF_GATHERED_TOUCHES_FOR_MOVE_SPEED = 5;
        var OUT_OF_BOUNDARY_BREAKING_FACTOR = .05;
        var EPSILON = 1e-7;
        var MOVEMENT_FACTOR = .7;
        var quintEaseOut = function(time) {
            time -= 1;
            return time * time * time * time * time + 1;
        };
        var getTimeInMilliseconds = function() {
            var currentTime = new Date();
            return currentTime.getMilliseconds();
        };
        var ScrollView = cc.Class({
            name: "cc.ScrollView",
            "extends": require("./CCComponent"),
            editor: false,
            ctor: function() {
                this._topBoundary = 0;
                this._bottomBoundary = 0;
                this._leftBoundary = 0;
                this._rightBoundary = 0;
                this._touchMoveDisplacements = [];
                this._touchMoveTimeDeltas = [];
                this._touchMovePreviousTimestamp = 0;
                this._autoScrolling = false;
                this._autoScrollAttenuate = false;
                this._autoScrollStartPosition = cc.p(0, 0);
                this._autoScrollTargetDelta = cc.p(0, 0);
                this._autoScrollTotalTime = 0;
                this._autoScrollAccumulatedTime = 0;
                this._autoScrollCurrentlyOutOfBoundary = false;
                this._autoScrollBraking = false;
                this._autoScrollBrakingStartPosition = cc.p(0, 0);
                this._outOfBoundaryAmount = cc.p(0, 0);
                this._outOfBoundaryAmountDirty = true;
            },
            properties: {
                content: {
                    "default": null,
                    type: cc.Node,
                    tooltip: "i18n:COMPONENT.scrollview.content"
                },
                horizontal: {
                    "default": true,
                    tooltip: "i18n:COMPONENT.scrollview.horizontal"
                },
                vertical: {
                    "default": true,
                    tooltip: "i18n:COMPONENT.scrollview.vertical"
                },
                inertia: {
                    "default": true,
                    tooltip: "i18n:COMPONENT.scrollview.inertia"
                },
                brake: {
                    "default": .5,
                    type: "Float",
                    range: [ 0, 1, .1 ]
                },
                elastic: {
                    "default": true
                },
                bounceDuration: {
                    "default": 1,
                    range: [ 0, 10 ]
                },
                horizontalScrollBar: {
                    "default": null,
                    type: cc.Scrollbar,
                    tooltip: "i18n:COMPONENT.scrollview.horizontal_bar",
                    notify: function() {
                        this.horizontalScrollBar.setTargetScrollView(this);
                        this._updateScrollBar(0);
                    }
                },
                verticalScrollBar: {
                    "default": null,
                    type: cc.Scrollbar,
                    tooltip: "i18n:COMPONENT.scrollview.vertical_bar",
                    notify: function() {
                        this.verticalScrollBar.setTargetScrollView(this);
                        this._updateScrollBar(0);
                    }
                }
            },
            scrollToBottom: function(timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: cc.p(0, 0),
                    applyToHorizontal: false,
                    applyToVertical: true
                });
                if (timeInSecond) {
                    this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated);
                } else {
                    this._moveContent(moveDelta, true);
                }
            },
            scrollToTop: function(timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: cc.p(0, 1),
                    applyToHorizontal: false,
                    applyToVertical: true
                });
                if (timeInSecond) {
                    this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated);
                } else {
                    this._moveContent(moveDelta);
                }
            },
            scrollToLeft: function(timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: cc.p(0, 0),
                    applyToHorizontal: true,
                    applyToVertical: false
                });
                if (timeInSecond) {
                    this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated);
                } else {
                    this._moveContent(moveDelta);
                }
            },
            scrollToRight: function(timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: cc.p(1, 0),
                    applyToHorizontal: true,
                    applyToVertical: false
                });
                if (timeInSecond) {
                    this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated);
                } else {
                    this._moveContent(moveDelta);
                }
            },
            scrollToTopLeft: function(timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: cc.p(0, 1),
                    applyToHorizontal: true,
                    applyToVertical: true
                });
                if (timeInSecond) {
                    this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated);
                } else {
                    this._moveContent(moveDelta);
                }
            },
            scrollToTopRight: function(timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: cc.p(1, 1),
                    applyToHorizontal: true,
                    applyToVertical: true
                });
                if (timeInSecond) {
                    this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated);
                } else {
                    this._moveContent(moveDelta);
                }
            },
            scrollToBottomLeft: function(timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: cc.p(0, 0),
                    applyToHorizontal: true,
                    applyToVertical: true
                });
                if (timeInSecond) {
                    this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated);
                } else {
                    this._moveContent(moveDelta);
                }
            },
            scrollToBottomRight: function(timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: cc.p(1, 0),
                    applyToHorizontal: true,
                    applyToVertical: true
                });
                if (timeInSecond) {
                    this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated);
                } else {
                    this._moveContent(moveDelta);
                }
            },
            scrollToPercentHorizontal: function(percent, timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: cc.p(percent, 0),
                    applyToHorizontal: true,
                    applyToVertical: false
                });
                if (timeInSecond) {
                    this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated);
                } else {
                    this._moveContent(moveDelta);
                }
            },
            scrollTo: function(anchor, timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: anchor,
                    applyToHorizontal: true,
                    applyToVertical: true
                });
                if (timeInSecond) {
                    this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated);
                } else {
                    this._moveContent(moveDelta);
                }
            },
            scrollToPercentVertical: function(percent, timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: cc.p(0, percent),
                    applyToHorizontal: false,
                    applyToVertical: true
                });
                if (timeInSecond) {
                    this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated);
                } else {
                    this._moveContent(moveDelta);
                }
            },
            setContentPosition: function(position) {
                if (cc.pFuzzyEqual(position, this.getContentPosition(), EPSILON)) {
                    return;
                }
                this.content.setPosition(position);
                this._outOfBoundaryAmountDirty = true;
            },
            getContentPosition: function() {
                return this.content.getPosition();
            },
            _registerEvent: function() {
                this.node.on(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this);
                this.node.on(cc.Node.EventType.TOUCH_MOVE, this._onTouchMoved, this);
                this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
                this.node.on(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancelled, this);
            },
            _calculateMovePercentDelta: function(options) {
                var anchor = options.anchor;
                var applyToHorizontal = options.applyToHorizontal;
                var applyToVertical = options.applyToVertical;
                anchor = cc.pClamp(anchor, cc.p(0, 0), cc.p(1, 1));
                var scrollSize = this.node.getContentSize();
                var contentSize = this.content.getContentSize();
                var bottomDeta = Math.abs(this._getContentBottomBoundary() - this._bottomBoundary);
                var leftDeta = Math.abs(this._getContentLeftBoundary() - this._leftBoundary);
                var moveDelta = cc.p(0, 0);
                if (applyToHorizontal) {
                    moveDelta.x = (contentSize.width - scrollSize.width) * anchor.x - leftDeta;
                }
                if (applyToVertical) {
                    moveDelta.y = (contentSize.height - scrollSize.height) * anchor.y - bottomDeta;
                }
                moveDelta = cc.pNeg(moveDelta);
                return moveDelta;
            },
            _calculateBoundary: function() {
                if (this.content) {
                    var scrollViewSize = this.node.getContentSize();
                    var leftBottomPosition = this._convertToContentParentSpace(cc.p(0, 0));
                    this._leftBoundary = leftBottomPosition.x;
                    this._bottomBoundary = leftBottomPosition.y;
                    var topRightPosition = this._convertToContentParentSpace(cc.p(scrollViewSize.width, scrollViewSize.height));
                    this._rightBoundary = topRightPosition.x;
                    this._topBoundary = topRightPosition.y;
                }
            },
            _convertToContentParentSpace: function(position) {
                var scrollViewPositionInWorldSpace = this.node.convertToWorldSpace(position);
                var contentParent = this.content.parent;
                return contentParent.convertToNodeSpaceAR(scrollViewPositionInWorldSpace);
            },
            _onTouchBegan: function(event) {
                var touch = event.touch;
                if (this.content) {
                    this._handlePressLogic(touch);
                }
                event.stopPropagation();
            },
            _cancelButtonClick: function(touch) {
                var deltaMove = touch.getDelta();
                var needCancelTouch = false;
                if (cc.sys.isMobile) {
                    var TOUCH_CANCEL_POINT = 7;
                    if (cc.pLength(deltaMove) > TOUCH_CANCEL_POINT) {
                        needCancelTouch = true;
                    }
                } else {
                    needCancelTouch = true;
                }
                return needCancelTouch;
            },
            _onTouchMoved: function(event) {
                var touch = event.touch;
                if (this.content) {
                    var buttonComponent = event.target.getComponent(cc.Button);
                    if (buttonComponent && this._cancelButtonClick(touch)) {
                        buttonComponent._cancelButtonClick();
                    }
                    this._handleMoveLogic(touch);
                }
                event.stopPropagation();
            },
            _onTouchEnded: function(event) {
                var touch = event.touch;
                if (this.content) {
                    this._handleReleaseLogic(touch);
                }
                event.stopPropagation();
            },
            _onTouchCancelled: function(event) {
                var touch = event.touch;
                if (this.content) {
                    this._handleReleaseLogic(touch);
                }
                event.stopPropagation();
            },
            _handleMoveLogic: function(touch) {
                var deltaMove = touch.getDelta();
                this._scrollChildren(deltaMove);
                this._gatherTouchMove(deltaMove);
            },
            _scrollChildren: function(deltaMove) {
                deltaMove = this._clampDelta(deltaMove);
                var realMove = deltaMove;
                var outOfBoundary;
                if (this.elastic) {
                    outOfBoundary = this._getHowMuchOutOfBoundary();
                    realMove.x *= 0 === outOfBoundary.x ? 1 : .5;
                    realMove.y *= 0 === outOfBoundary.y ? 1 : .5;
                }
                if (!this.elastic) {
                    outOfBoundary = this._getHowMuchOutOfBoundary(realMove);
                    realMove = cc.pAdd(realMove, outOfBoundary);
                }
                this._moveContent(realMove, false);
            },
            _handlePressLogic: function(touch) {
                this._autoScrolling = false;
                this._touchMovePreviousTimestamp = getTimeInMilliseconds();
                this._touchMoveDisplacements = [];
                this._touchMoveTimeDeltas = [];
                this._onScrollBarTouchBegan();
            },
            _clampDelta: function(delta) {
                var contentSize = this.content.getContentSize();
                var scrollViewSize = this.node.getContentSize();
                if (contentSize.width <= scrollViewSize.width) {
                    delta.x = 0;
                }
                if (contentSize.height <= scrollViewSize.height) {
                    delta.y = 0;
                }
                return delta;
            },
            _gatherTouchMove: function(delta) {
                delta = this._clampDelta(delta);
                while (this._touchMoveDisplacements.length >= NUMBER_OF_GATHERED_TOUCHES_FOR_MOVE_SPEED) {
                    this._touchMoveDisplacements.shift();
                    this._touchMoveTimeDeltas.shift();
                }
                this._touchMoveDisplacements.push(delta);
                var timeStamp = getTimeInMilliseconds();
                this._touchMoveTimeDeltas.push((timeStamp - this._touchMovePreviousTimestamp) / 1e3);
                this._touchMovePreviousTimestamp = timeStamp;
            },
            _startBounceBackIfNeeded: function() {
                if (!this.elastic) {
                    return false;
                }
                var bounceBackAmount = this._getHowMuchOutOfBoundary();
                bounceBackAmount = this._clampDelta(bounceBackAmount);
                if (cc.pFuzzyEqual(bounceBackAmount, cc.p(0, 0), EPSILON)) {
                    return false;
                }
                var bounceBackTime = Math.max(this.bounceDuration, 0);
                this._startAutoScroll(bounceBackAmount, bounceBackTime, true);
                return true;
            },
            _handleReleaseLogic: function(touch) {
                var delta = touch.getDelta();
                this._gatherTouchMove(delta);
                var bounceBackStarted = this._startBounceBackIfNeeded();
                if (!bounceBackStarted && this.inertia) {
                    var touchMoveVelocity = this._calculateTouchMoveVelocity();
                    if (!cc.pFuzzyEqual(touchMoveVelocity, cc.p(0, 0), EPSILON) && this.brake < 1) {
                        this._startInertiaScroll(touchMoveVelocity);
                    }
                }
                this._onScrollBarTouchEnded();
            },
            _isOutOfBoundary: function() {
                var outOfBoundary = this._getHowMuchOutOfBoundary();
                return !cc.pFuzzyEqual(outOfBoundary, cc.p(0, 0), EPSILON);
            },
            _isNecessaryAutoScrollBrake: function() {
                if (this._autoScrollBraking) {
                    return true;
                }
                if (this._isOutOfBoundary()) {
                    if (!this._autoScrollCurrentlyOutOfBoundary) {
                        this._autoScrollCurrentlyOutOfBoundary = true;
                        this._autoScrollBraking = true;
                        this._autoScrollBrakingStartPosition = this.getContentPosition();
                        return true;
                    }
                } else {
                    this._autoScrollCurrentlyOutOfBoundary = false;
                }
                return false;
            },
            _processAutoScrolling: function(dt) {
                var isAutoScrollBrake = this._isNecessaryAutoScrollBrake();
                var brakingFactor = isAutoScrollBrake ? OUT_OF_BOUNDARY_BREAKING_FACTOR : 1;
                this._autoScrollAccumulatedTime += dt * (1 / brakingFactor);
                var percentage = Math.min(1, this._autoScrollAccumulatedTime / this._autoScrollTotalTime);
                if (this._autoScrollAttenuate) {
                    percentage = quintEaseOut(percentage);
                }
                var newPosition = cc.pAdd(this._autoScrollStartPosition, cc.pMult(this._autoScrollTargetDelta, percentage));
                var reachedEnd = 1 === percentage;
                if (this.elastic) {
                    var brakeOffsetPosition = cc.pSub(newPosition, this._autoScrollBrakingStartPosition);
                    if (isAutoScrollBrake) {
                        brakeOffsetPosition = cc.pMult(brakeOffsetPosition, brakingFactor);
                    }
                    newPosition = cc.pAdd(this._autoScrollBrakingStartPosition, brakeOffsetPosition);
                } else {
                    var moveDelta = cc.pSub(newPosition, this.getContentPosition());
                    var outOfBoundary = this._getHowMuchOutOfBoundary(moveDelta);
                    if (!cc.pFuzzyEqual(outOfBoundary, cc.p(0, 0), EPSILON)) {
                        newPosition = cc.pAdd(newPosition, outOfBoundary);
                        reachedEnd = true;
                    }
                }
                if (reachedEnd) {
                    this._autoScrolling = false;
                }
                var contentPos = cc.pSub(newPosition, this.getContentPosition());
                this._moveContent(contentPos, reachedEnd);
            },
            _startInertiaScroll: function(touchMoveVelocity) {
                var inertiaTotalMovement = cc.pMult(touchMoveVelocity, MOVEMENT_FACTOR);
                this._startAttenuatingAutoScroll(inertiaTotalMovement, touchMoveVelocity);
            },
            _startAttenuatingAutoScroll: function(deltaMove, initialVelocity) {
                var time = this._calculateAutoScrollTimeByInitalSpeed(cc.pLength(initialVelocity));
                var originalMoveLength = cc.pLength(deltaMove);
                var targetDelta = cc.pNormalize(deltaMove);
                var contentSize = this.content.getContentSize();
                var scrollviewSize = this.node.getContentSize();
                targetDelta = cc.p(targetDelta.x * (contentSize.width - scrollviewSize.width) * (1 - this.brake), targetDelta.y * (contentSize.height - scrollviewSize.height) * (1 - this.brake));
                targetDelta = cc.pAdd(deltaMove, targetDelta);
                var factor = cc.pLength(targetDelta) / originalMoveLength;
                time *= factor;
                this._startAutoScroll(targetDelta, time, true);
            },
            _calculateAutoScrollTimeByInitalSpeed: function(initalSpeed) {
                var time = Math.sqrt(Math.sqrt(initalSpeed / 5));
                return time;
            },
            _startAutoScroll: function(deltaMove, timeInSecond, attenuated) {
                var adjustedDeltaMove = this._flattenVectorByDirection(deltaMove);
                this._autoScrolling = true;
                this._autoScrollTargetDelta = adjustedDeltaMove;
                this._autoScrollAttenuate = attenuated;
                this._autoScrollStartPosition = this.getContentPosition();
                this._autoScrollTotalTime = timeInSecond;
                this._autoScrollAccumulatedTime = 0;
                this._autoScrollBraking = false;
                this._autoScrollBrakingStartPosition = cc.p(0, 0);
                var currentOutOfBoundary = this._getHowMuchOutOfBoundary();
                if (!cc.pFuzzyEqual(currentOutOfBoundary, cc.p(0, 0), EPSILON)) {
                    this._autoScrollCurrentlyOutOfBoundary = true;
                    var afterOutOfBoundary = this._getHowMuchOutOfBoundary(adjustedDeltaMove);
                    if (currentOutOfBoundary.x * afterOutOfBoundary.x > 0 || currentOutOfBoundary.y * afterOutOfBoundary.y > 0) {
                        this._autoScrollBraking = true;
                    }
                }
            },
            _calculateTouchMoveVelocity: function() {
                var totalTime = 0;
                totalTime = this._touchMoveTimeDeltas.reduce(function(a, b) {
                    return a + b;
                }, totalTime);
                if (totalTime <= 0 || totalTime >= .5) {
                    return cc.p(0, 0);
                }
                var totalMovement = cc.p(0, 0);
                totalMovement = this._touchMoveDisplacements.reduce(function(a, b) {
                    return cc.pAdd(a, b);
                }, totalMovement);
                return cc.p(totalMovement.x / totalTime, totalMovement.y / totalTime);
            },
            _flattenVectorByDirection: function(vector) {
                var result = vector;
                result.x = this.horizontal ? result.x : 0;
                result.y = this.vertical ? result.y : 0;
                return result;
            },
            _moveContent: function(deltaMove, canStartBounceBack) {
                var adjustedMove = this._flattenVectorByDirection(deltaMove);
                var newPosition = cc.pAdd(this.getContentPosition(), adjustedMove);
                this.setContentPosition(newPosition);
                var outOfBoundary = this._getHowMuchOutOfBoundary();
                this._updateScrollBar(outOfBoundary);
                if (this.elastic && canStartBounceBack) {
                    this._startBounceBackIfNeeded();
                }
            },
            _getContentLeftBoundary: function() {
                var contentPos = this.getContentPosition();
                var leftBoundary = contentPos.x - this.content.getAnchorPoint().x * this.content.getContentSize().width;
                return leftBoundary;
            },
            _getContentRightBoundary: function() {
                var contentSize = this.content.getContentSize();
                return this._getContentLeftBoundary() + contentSize.width;
            },
            _getContentTopBoundary: function() {
                var contentSize = this.content.getContentSize();
                return this._getContentBottomBoundary() + contentSize.height;
            },
            _getContentBottomBoundary: function() {
                var contentPos = this.getContentPosition();
                var bottomBoundary = contentPos.y - this.content.getAnchorPoint().y * this.content.getContentSize().height;
                return bottomBoundary;
            },
            _getHowMuchOutOfBoundary: function(addition) {
                addition = addition || cc.p(0, 0);
                if (cc.pFuzzyEqual(addition, cc.p(0, 0), EPSILON) && !this._outOfBoundaryAmountDirty) {
                    return this._outOfBoundaryAmount;
                }
                var outOfBoundaryAmount = cc.p(0, 0);
                if (this._getContentLeftBoundary() + addition.x > this._leftBoundary) {
                    outOfBoundaryAmount.x = this._leftBoundary - (this._getContentLeftBoundary() + addition.x);
                } else {
                    if (this._getContentRightBoundary() + addition.x < this._rightBoundary) {
                        outOfBoundaryAmount.x = this._rightBoundary - (this._getContentRightBoundary() + addition.x);
                    }
                }
                if (this._getContentTopBoundary() + addition.y < this._topBoundary) {
                    outOfBoundaryAmount.y = this._topBoundary - (this._getContentTopBoundary() + addition.y);
                } else {
                    if (this._getContentBottomBoundary() + addition.y > this._bottomBoundary) {
                        outOfBoundaryAmount.y = this._bottomBoundary - (this._getContentBottomBoundary() + addition.y);
                    }
                }
                if (cc.pFuzzyEqual(addition, cc.p(0, 0), EPSILON)) {
                    this._outOfBoundaryAmount = outOfBoundaryAmount;
                    this._outOfBoundaryAmountDirty = false;
                }
                outOfBoundaryAmount = this._clampDelta(outOfBoundaryAmount);
                return outOfBoundaryAmount;
            },
            _updateScrollBar: function(outOfBoundary) {
                if (this.horizontalScrollBar) {
                    this.horizontalScrollBar._onScroll(outOfBoundary);
                }
                if (this.verticalScrollBar) {
                    this.verticalScrollBar._onScroll(outOfBoundary);
                }
            },
            _onScrollBarTouchBegan: function() {
                if (this.horizontalScrollBar) {
                    this.horizontalScrollBar._onTouchBegan();
                }
                if (this.verticalScrollBar) {
                    this.verticalScrollBar._onTouchBegan();
                }
            },
            _onScrollBarTouchEnded: function() {
                if (this.horizontalScrollBar) {
                    this.horizontalScrollBar._onTouchEnded();
                }
                if (this.verticalScrollBar) {
                    this.verticalScrollBar._onTouchEnded();
                }
            },
            onLoad: function() {
                if (true) {
                    this._registerEvent();
                }
            },
            start: function() {
                this._calculateBoundary();
            },
            update: function(dt) {
                if (this._autoScrolling) {
                    this._processAutoScrolling(dt);
                }
            }
        });
        cc.ScrollView = module.exports = ScrollView;
    }, {
        "./CCComponent": 40
    } ],
    48: [ function(require, module, exports) {
        var SpriteType = cc.SpriteType;
        var Sprite = cc.Class({
            name: "cc.Sprite",
            "extends": require("./CCComponentInSG"),
            editor: false,
            properties: {
                _spriteFrame: {
                    "default": null,
                    type: cc.SpriteFrame
                },
                _type: SpriteType.SIMPLE,
                _useOriginalSize: true,
                _atlas: {
                    "default": "",
                    type: cc.SpriteAtlas,
                    tooltip: "i18n:COMPONENT.sprite.atlas",
                    editorOnly: true,
                    visible: true
                },
                spriteFrame: {
                    get: function() {
                        return this._spriteFrame;
                    },
                    set: function(value, force) {
                        var lastSprite = this._spriteFrame;
                        this._spriteFrame = value;
                        if (this._sgNode) {
                            this._applySpriteFrame(this._sgNode, lastSprite);
                            this._sgNode.setColor(this.node._color);
                            this._sgNode.setOpacity(this.node._opacity);
                        }
                    },
                    type: cc.SpriteFrame,
                    tooltip: "i18n:COMPONENT.sprite.sprite_frame"
                },
                type: {
                    get: function() {
                        return this._type;
                    },
                    set: function(value) {
                        this._type = value;
                        this._sgNode.setRenderingType(this._type);
                        this._applyCapInset();
                    },
                    type: SpriteType,
                    tooltip: "i18n:COMPONENT.sprite.type"
                },
                useOriginalSize: {
                    get: function() {
                        return this._useOriginalSize;
                    },
                    set: function(value) {
                        this._useOriginalSize = value;
                        if (value) {
                            this._applySpriteSize();
                        }
                    },
                    tooltip: "i18n:COMPONENT.sprite.original_size"
                },
                localSize: {
                    get: function() {
                        var sgNode = this._sgNode;
                        if (!sgNode) {
                            return cc.size(0, 0);
                        }
                        return cc.size(sgNode.width, sgNode.height);
                    },
                    visible: false,
                    override: true
                }
            },
            setVisible: function(visible) {
                this.enabled = visible;
            },
            setScale9Enabled: function(enabled) {
                this.type = enabled ? cc.SpriteType.SLICED : cc.SpriteType.SIMPLE;
            },
            isScale9Enabled: function() {
                return this.type === cc.SpriteType.SLICED;
            },
            initWithFile: function(file) {
                this._sgNode.initWithFile(file);
            },
            initWithSpriteFrame: function(spriteFrame) {
                this._spriteFrame = spriteFrame;
                this._sgNode.initWithSpriteFrame(spriteFrame);
            },
            initWithSpriteFrameName: function(spriteFrameName) {
                var initialized = this._sgNode.initWithSpriteFrame(spriteFrameName);
                if (false === initialized) {
                    return;
                }
                this._spriteFrame = this._sgNode.getSpriteFrame();
            },
            getOriginalSize: function() {
                return this._sgNode.getOriginalSize();
            },
            setInsetLeft: function(insetLeft) {
                this._sgNode.setInsetLeft(insetLeft);
            },
            getInsetLeft: function() {
                return this._sgNode.getInsetLeft();
            },
            setInsetTop: function(insetTop) {
                this._sgNode.setInsetTop(insetTop);
            },
            getInsetTop: function() {
                return this._sgNode.getInsetTop();
            },
            setInsetRight: function(insetRight) {
                this._sgNode.setInsetRight(insetRight);
            },
            getInsetRight: function() {
                return this._sgNode.getInsetRight();
            },
            setInsetBottom: function(insetBottom) {
                this._sgNode.setInsetBottom(insetBottom);
            },
            getInsetBottom: function() {
                return this._sgNode.getInsetBottom();
            },
            onLoad: function() {
                this._super();
                this.node.on("size-changed", this._resized, this);
            },
            onDestroy: function() {
                this._super();
                this.node.off("size-changed", this._resized, this);
            },
            _applyAtlas: false,
            _applyCapInset: function(sgNode) {
                if (this._type === SpriteType.SLICED && this._spriteFrame) {
                    sgNode = sgNode || this._sgNode;
                    sgNode.setInsetTop(this._spriteFrame.insetTop);
                    sgNode.setInsetBottom(this._spriteFrame.insetBottom);
                    sgNode.setInsetRight(this._spriteFrame.insetRight);
                    sgNode.setInsetLeft(this._spriteFrame.insetLeft);
                }
            },
            _applySpriteSize: function(sgNode) {
                sgNode = sgNode || this._sgNode;
                if (this._useOriginalSize && this._spriteFrame) {
                    var rect = this._spriteFrame.getRect();
                    this.node.setContentSize(cc.size(rect.width, rect.height));
                } else {
                    this.node.setContentSize(this.node.getContentSize(true));
                }
            },
            _onSpriteFrameLoaded: function(event, sgNode) {
                var self = this;
                sgNode = sgNode || this._sgNode;
                sgNode.setSpriteFrame(self._spriteFrame);
                self._applyCapInset(sgNode);
                self._applySpriteSize();
                if (this.enabledInHierarchy && !sgNode.isVisible()) {
                    sgNode.setVisible(true);
                }
            },
            _applySpriteFrame: function(sgNode, oldFrame) {
                if (oldFrame && oldFrame.off) {
                    oldFrame.off("load", this._onSpriteFrameLoaded, this);
                }
                if (this._spriteFrame) {
                    if (this._spriteFrame.textureLoaded()) {
                        this._onSpriteFrameLoaded(null, sgNode);
                    } else {
                        this._spriteFrame.once("load", this._onSpriteFrameLoaded, this);
                    }
                } else {
                    sgNode.setVisible(false);
                }
                if (false) {
                    this._applyAtlas(this._spriteFrame);
                }
            },
            _createSgNode: function() {
                var sgNode = new cc.Scale9Sprite();
                if (!this.enabledInHierarchy) {
                    sgNode.setVisible(false);
                }
                this._applySpriteFrame(sgNode, null);
                sgNode.setContentSize(this.node.getContentSize(true));
                this._applySpriteSize(sgNode);
                sgNode.setRenderingType(this._type);
                return sgNode;
            },
            _resized: function() {
                if (this._useOriginalSize && this._spriteFrame) {
                    var rect = this._spriteFrame.getRect();
                    var expectedW = rect.width;
                    var expectedH = rect.height;
                    var actualSize = this.node.getContentSize();
                    if (expectedW !== actualSize.width || expectedH !== actualSize.height) {
                        this.useOriginalSize = false;
                    }
                }
            }
        });
        var misc = require("../utils/misc");
        var SameNameGetSets = [ "atlas", "capInsets", "insetLeft", "insetTop", "insetRight", "insetBottom" ];
        var DiffNameGetSets = {
            type: [ null, "setRenderingType" ]
        };
        misc.propertyDefine(Sprite, SameNameGetSets, DiffNameGetSets);
        cc.Sprite = module.exports = Sprite;
    }, {
        "../utils/misc": 88,
        "./CCComponentInSG": 41
    } ],
    49: [ function(require, module, exports) {
        var TOP = 1;
        var MID = 2;
        var BOT = 4;
        var LEFT = 8;
        var CENTER = 16;
        var RIGHT = 32;
        var TOP_BOT = TOP | BOT;
        var LEFT_RIGHT = LEFT | RIGHT;
        var Widget = cc.Class({
            name: "cc.Widget",
            "extends": require("./CCComponent"),
            editor: false,
            properties: {
                isAlignTop: {
                    get: function() {
                        return (this._alignFlags & TOP) > 0;
                    },
                    set: function(value) {
                        this._setAlign(TOP, value);
                    },
                    tooltip: "i18n:COMPONENT.widget.align_top"
                },
                isAlignVerticalCenter: {
                    get: function() {
                        return (this._alignFlags & MID) > 0;
                    },
                    set: function(value) {
                        if (value) {
                            this.isAlignTop = false;
                            this.isAlignBottom = false;
                            this._alignFlags |= MID;
                        } else {
                            this._alignFlags &= ~MID;
                        }
                    },
                    tooltip: "i18n:COMPONENT.widget.align_v_center"
                },
                isAlignBottom: {
                    get: function() {
                        return (this._alignFlags & BOT) > 0;
                    },
                    set: function(value) {
                        this._setAlign(BOT, value);
                    },
                    tooltip: "i18n:COMPONENT.widget.align_bottom"
                },
                isAlignLeft: {
                    get: function() {
                        return (this._alignFlags & LEFT) > 0;
                    },
                    set: function(value) {
                        this._setAlign(LEFT, value);
                    },
                    tooltip: "i18n:COMPONENT.widget.align_left"
                },
                isAlignHorizontalCenter: {
                    get: function() {
                        return (this._alignFlags & CENTER) > 0;
                    },
                    set: function(value) {
                        if (value) {
                            this.isAlignLeft = false;
                            this.isAlignRight = false;
                            this._alignFlags |= CENTER;
                        } else {
                            this._alignFlags &= ~CENTER;
                        }
                    },
                    tooltip: "i18n:COMPONENT.widget.align_h_center"
                },
                isAlignRight: {
                    get: function() {
                        return (this._alignFlags & RIGHT) > 0;
                    },
                    set: function(value) {
                        this._setAlign(RIGHT, value);
                    },
                    tooltip: "i18n:COMPONENT.widget.align_right"
                },
                isStretchWidth: {
                    get: function() {
                        return (this._alignFlags & LEFT_RIGHT) === LEFT_RIGHT;
                    },
                    visible: false
                },
                isStretchHeight: {
                    get: function() {
                        return (this._alignFlags & TOP_BOT) === TOP_BOT;
                    },
                    visible: false
                },
                top: {
                    get: function() {
                        return this._top;
                    },
                    set: function(value) {
                        this._top = value;
                    },
                    tooltip: "i18n:COMPONENT.widget.top"
                },
                bottom: {
                    get: function() {
                        return this._bottom;
                    },
                    set: function(value) {
                        this._bottom = value;
                    },
                    tooltip: "i18n:COMPONENT.widget.bottom"
                },
                left: {
                    get: function() {
                        return this._left;
                    },
                    set: function(value) {
                        this._left = value;
                    },
                    tooltip: "i18n:COMPONENT.widget.left"
                },
                right: {
                    get: function() {
                        return this._right;
                    },
                    set: function(value) {
                        this._right = value;
                    },
                    tooltip: "i18n:COMPONENT.widget.right"
                },
                isAbsoluteTop: {
                    get: function() {
                        return this._isAbsTop;
                    },
                    set: function(value) {
                        this._isAbsTop = value;
                    }
                },
                isAbsoluteBottom: {
                    get: function() {
                        return this._isAbsBottom;
                    },
                    set: function(value) {
                        this._isAbsBottom = value;
                    }
                },
                isAbsoluteLeft: {
                    get: function() {
                        return this._isAbsLeft;
                    },
                    set: function(value) {
                        this._isAbsLeft = value;
                    }
                },
                isAbsoluteRight: {
                    get: function() {
                        return this._isAbsRight;
                    },
                    set: function(value) {
                        this._isAbsRight = value;
                    }
                },
                _alignFlags: 0,
                _left: 0,
                _right: 0,
                _top: 0,
                _bottom: 0,
                _isAbsLeft: true,
                _isAbsRight: true,
                _isAbsTop: true,
                _isAbsBottom: true,
                _originalWidth: 0,
                _originalHeight: 0
            },
            onLoad: function() {
                cc._widgetManager.add(this);
            },
            onDestroy: function() {
                cc._widgetManager.remove(this);
            },
            _setAlign: function(flag, isAlign) {
                var current = (this._alignFlags & flag) > 0;
                if (isAlign == current) {
                    return;
                }
                var isHorizontal = (flag & LEFT_RIGHT) > 0;
                if (isAlign) {
                    this._alignFlags |= flag;
                    if (isHorizontal) {
                        this.isAlignHorizontalCenter = false;
                        if (this.isStretchWidth) {
                            this._originalWidth = this.node.width;
                        }
                    } else {
                        this.isAlignVerticalCenter = false;
                        if (this.isStretchHeight) {
                            this._originalHeight = this.node.height;
                        }
                    }
                    if (false) {
                        var type;
                        if (flag & TOP) {
                            type = "top";
                        } else {
                            if (flag & LEFT) {
                                type = "left";
                            } else {
                                if (flag & RIGHT) {
                                    type = "right";
                                } else {
                                    if (flag & BOT) {
                                        type = "bottom";
                                    }
                                }
                            }
                        }
                        cc._widgetManager.updateOffsetsToStayPut(this, type);
                    }
                } else {
                    if (isHorizontal) {
                        if (this.isStretchWidth) {
                            this.node.width = this._originalWidth;
                        }
                    } else {
                        if (this.isStretchHeight) {
                            this.node.height = this._originalHeight;
                        }
                    }
                    this._alignFlags &= ~flag;
                }
            }
        });
        cc.Widget = module.exports = Widget;
    }, {
        "./CCComponent": 40
    } ],
    50: [ function(require, module, exports) {
        require("./CCComponent");
        require("./CCComponentInSG");
        module.exports = [ require("./CCSprite"), require("./CCWidget"), require("./CCCanvas"), require("./CCAudioSource"), require("./CCAnimation"), require("./CCButton"), require("./CCLabel"), require("./CCProgressBar"), require("./CCMask"), require("./CCScrollBar"), require("./CCScrollView"), require("./CCLayout") ];
    }, {
        "./CCAnimation": 36,
        "./CCAudioSource": 37,
        "./CCButton": 38,
        "./CCCanvas": 39,
        "./CCComponent": 40,
        "./CCComponentInSG": 41,
        "./CCLabel": 42,
        "./CCLayout": 43,
        "./CCMask": 44,
        "./CCProgressBar": 45,
        "./CCScrollBar": 46,
        "./CCScrollView": 47,
        "./CCSprite": 48,
        "./CCWidget": 49
    } ],
    51: [ function(require, module, exports) {
        var JS = cc.js;
        var CallbacksHandler = require("../platform/callbacks-invoker").CallbacksHandler;
        function EventListeners() {
            CallbacksHandler.call(this);
        }
        JS.extend(EventListeners, CallbacksHandler);
        EventListeners.prototype.invoke = function(event) {
            var list = this._callbackTable[event.type], i, endIndex, lastItem, callingFunc, target, hasTarget;
            if (list) {
                if (1 === list.length) {
                    list[0].call(event.currentTarget, event);
                    return;
                }
                endIndex = list.length - 1;
                lastItem = list[endIndex];
                for (i = 0; i <= endIndex; ) {
                    callingFunc = list[i];
                    target = list[i + 1];
                    hasTarget = target && "object" === typeof target;
                    var increment;
                    if (hasTarget) {
                        callingFunc.call(target, event);
                        increment = 2;
                    } else {
                        callingFunc.call(event.currentTarget, event);
                        increment = 1;
                    }
                    if (event._propagationImmediateStopped || i + increment > endIndex) {
                        break;
                    }
                    if (list[endIndex] !== lastItem) {
                        if (list[endIndex - 1] === lastItem) {
                            endIndex -= 1;
                        } else {
                            if (list[endIndex - 2] === lastItem) {
                                endIndex -= 2;
                            } else {
                                return cc.error("Call event.stopPropagationImmediate() when you remove more than one callbacks in a event callback.");
                            }
                        }
                        if (list[i] !== callingFunc) {
                            continue;
                        }
                    }
                    i += increment;
                }
            }
        };
        module.exports = EventListeners;
    }, {
        "../platform/callbacks-invoker": 66
    } ],
    52: [ function(require, module, exports) {
        var EventListeners = require("./event-listeners");
        require("./event");
        var JS = cc.js;
        var cachedArray = new Array(16);
        cachedArray.length = 0;
        var _doDispatchEvent = function(owner, event) {
            var target, i;
            event.target = owner;
            owner._getCapturingTargets(event.type, cachedArray);
            event.eventPhase = 1;
            for (i = cachedArray.length - 1; i >= 0; --i) {
                target = cachedArray[i];
                if (target._isTargetActive(event.type) && target._capturingListeners) {
                    event.currentTarget = target;
                    target._capturingListeners.invoke(event);
                    if (event._propagationStopped) {
                        return;
                    }
                }
            }
            cachedArray.length = 0;
            if (owner._isTargetActive(event.type)) {
                _doSendEvent(owner, event);
                if (event._propagationStopped) {
                    return;
                }
            }
            if (event.bubbles) {
                owner._getBubblingTargets(event.type, cachedArray);
                event.eventPhase = 3;
                for (i = 0; i < cachedArray.length; ++i) {
                    target = cachedArray[i];
                    if (target._isTargetActive(event.type) && target._bubblingListeners) {
                        event.currentTarget = target;
                        target._bubblingListeners.invoke(event);
                        if (event._propagationStopped) {
                            return;
                        }
                    }
                }
            }
            cachedArray.length = 0;
        };
        var _doSendEvent = function(owner, event) {
            event.eventPhase = 2;
            event.currentTarget = owner;
            if (owner._capturingListeners) {
                owner._capturingListeners.invoke(event);
                if (event._propagationStopped) {
                    return;
                }
            }
            if (owner._bubblingListeners) {
                owner._bubblingListeners.invoke(event);
            }
        };
        var EventTarget = function() {
            this._capturingListeners = null;
            this._bubblingListeners = null;
        };
        JS.mixin(EventTarget.prototype, {
            hasEventListener: function(type) {
                if (this._bubblingListeners && this._bubblingListeners.has(type)) {
                    return true;
                }
                if (this._capturingListeners && this._capturingListeners.has(type)) {
                    return true;
                }
                return false;
            },
            on: function(type, callback, target, useCapture) {
                if ("boolean" === typeof target) {
                    useCapture = target;
                    target = void 0;
                } else {
                    useCapture = !!useCapture;
                }
                if (!callback) {
                    cc.error("Callback of event must be non-nil");
                    return;
                }
                var listeners = null;
                if (useCapture) {
                    listeners = this._capturingListeners = this._capturingListeners || new EventListeners();
                } else {
                    listeners = this._bubblingListeners = this._bubblingListeners || new EventListeners();
                }
                if (!listeners.has(type, callback, target)) {
                    listeners.add(type, callback, target);
                    if (target && target.__eventTargets) {
                        target.__eventTargets.push(this);
                    }
                }
                return callback;
            },
            off: function(type, callback, target, useCapture) {
                if ("boolean" === typeof target) {
                    useCapture = target;
                    target = void 0;
                } else {
                    useCapture = !!useCapture;
                }
                if (!callback) {
                    return;
                }
                var listeners = useCapture ? this._capturingListeners : this._bubblingListeners;
                if (listeners) {
                    listeners.remove(type, callback, target);
                    if (target && target.__eventTargets) {
                        var index = target.__eventTargets.indexOf(this);
                        target.__eventTargets.splice(index, 1);
                    }
                }
            },
            targetOff: function(target) {
                if (this._capturingListeners) {
                    this._capturingListeners.removeAll(target);
                }
                if (this._bubblingListeners) {
                    this._bubblingListeners.removeAll(target);
                }
            },
            once: function(type, callback, target, useCapture) {
                var self = this;
                var cb = function(event) {
                    self.off(type, cb, target, useCapture);
                    callback.call(this, event);
                };
                this.on(type, cb, target, useCapture);
            },
            dispatchEvent: function(event) {
                _doDispatchEvent(this, event);
                cachedArray.length = 0;
                var notPrevented = !event._defaultPrevented;
                return notPrevented;
            },
            emit: function(message, detail) {
                if ("string" === typeof message) {
                    var event = new cc.Event.EventCustom(message);
                    event.detail = detail;
                    _doSendEvent(this, event);
                } else {
                    cc.error("The message must be provided");
                }
            },
            _isTargetActive: function(type) {
                return true;
            },
            _getCapturingTargets: function(type, array) {},
            _getBubblingTargets: function(type, array) {}
        });
        cc.EventTarget = module.exports = EventTarget;
    }, {
        "./event": 53,
        "./event-listeners": 51
    } ],
    53: [ function(require, module, exports) {
        var JS = require("../platform/js");
        cc.Event = function(type, bubbles) {
            this.type = type;
            this.bubbles = bubbles || false;
            this.target = null;
            this.currentTarget = null;
            this.eventPhase = 0;
            this._defaultPrevented = false;
            this._propagationStopped = false;
            this._propagationImmediateStopped = false;
        };
        cc.Event.prototype = {
            constructor: cc.Event,
            unuse: function() {
                this.type = cc.Event.NO_TYPE;
                this.target = null;
                this.currentTarget = null;
                this.eventPhase = cc.Event.NONE;
                this._defaultPrevented = false;
                this._propagationStopped = false;
                this._propagationImmediateStopped = false;
            },
            reuse: function(type, bubbles) {
                this.type = type;
                this.bubbles = bubbles || false;
            },
            preventDefault: function() {
                this._defaultPrevented = true;
            },
            stopPropagation: function() {
                this._propagationStopped = true;
            },
            stopPropagationImmediate: function() {
                this._propagationImmediateStopped = true;
            },
            isStopped: function() {
                return this._propagationStopped || this._propagationImmediateStopped;
            },
            getCurrentTarget: function() {
                return this.currentTarget;
            },
            getType: function() {
                return this.type;
            }
        };
        cc.Event.NO_TYPE = "no_type";
        cc.Event.NONE = 0;
        cc.Event.CAPTURING_PHASE = 1;
        cc.Event.AT_TARGET = 2;
        cc.Event.BUBBLING_PHASE = 3;
        var EventCustom = function(type, bubbles) {
            cc.Event.call(this, type, bubbles);
            this.detail = null;
        };
        JS.extend(EventCustom, cc.Event);
        JS.mixin(EventCustom.prototype, {
            setUserData: function(data) {
                this.detail = data;
            },
            getUserData: function() {
                return this.detail;
            },
            getEventName: cc.Event.prototype.getType
        });
        cc.Event.EventCustom = EventCustom;
        module.exports = cc.Event;
    }, {
        "../platform/js": 70
    } ],
    54: [ function(require, module, exports) {
        require("./event.js");
        require("./event-listeners.js");
        require("./event-target.js");
    }, {
        "./event-listeners.js": 51,
        "./event-target.js": 52,
        "./event.js": 53
    } ],
    55: [ function(require, module, exports) {
        require("./platform");
        require("./assets");
        if (true) {
            require("./CCNode");
            require("./CCScene");
            require("./components");
        }
        require("./base-ui/CCWidgetManager");
    }, {
        "./CCNode": 20,
        "./CCScene": 21,
        "./assets": 34,
        "./base-ui/CCWidgetManager": 35,
        "./components": 50,
        "./platform": 68
    } ],
    56: [ function(require, module, exports) {
        var JS = require("./js");
        var Asset = require("../assets/CCAsset");
        var callInNextTick = require("./utils").callInNextTick;
        var LoadManager = require("./load-manager");
        var CallbacksInvoker = require("./callbacks-invoker");
        var _libraryBase = "";
        var _rawAssetsBase = "";
        var _uuidToRawAssets;
        var _uuidToCallbacks = new CallbacksInvoker();
        var _tdInfo = new cc.deserialize.Details();
        var _cc_loader_loadJson = cc.loader.loadJson.bind(cc.loader);
        function LoadingHandle(readMainCache, writeMainCache, recordAssets, deserializeInfo) {
            this.readMainCache = false;
            this.writeMainCache = false;
            var needIndieCache = !(this.readMainCache && this.writeMainCache);
            this.taskIndieCache = needIndieCache ? {} : null;
            this.pendingCache = {};
            this.assetsNeedPostLoad = recordAssets ? [] : null;
            this.deserializeInfo = deserializeInfo;
        }
        LoadingHandle.prototype.readCache = function(uuid) {
            if (this.readMainCache && this.writeMainCache) {
                return AssetLibrary._uuidToAsset[uuid];
            } else {
                if (this.readMainCache) {
                    return AssetLibrary._uuidToAsset[uuid] || this.taskIndieCache[uuid];
                } else {
                    return this.taskIndieCache[uuid];
                }
            }
        };
        LoadingHandle.prototype.writeCache = function(uuid, asset, hasRawType) {
            if (this.writeMainCache) {
                AssetLibrary._uuidToAsset[uuid] = asset;
            }
            if (this.taskIndieCache) {
                this.taskIndieCache[uuid] = asset;
            }
            if (this.assetsNeedPostLoad && asset._rawFiles && !hasRawType) {
                this.assetsNeedPostLoad.push(asset);
            }
        };
        var AssetLibrary = {
            loadAsset: function(uuid, callback, options) {
                var readMainCache = "undefined" !== typeof (options && options.readMainCache) ? readMainCache : true;
                var writeMainCache = "undefined" !== typeof (options && options.writeMainCache) ? writeMainCache : true;
                var handle = new LoadingHandle(readMainCache, writeMainCache, options && options.recordAssets, options && options.deserializeInfo);
                this._loadAssetByUuid(uuid, callback, handle, options && options.existingAsset);
                return handle;
            },
            _LoadingHandle: LoadingHandle,
            getImportedDir: function(uuid) {
                return _libraryBase + uuid.slice(0, 2);
            },
            _queryAssetInfoInEditor: function(uuid, callback) {
                if (false) {
                    Editor.sendRequestToCore("scene:query-asset-info-by-uuid", uuid, function(info) {
                        if (info) {
                            Editor.onRawAssetUsed(info.url, uuid);
                            var ctor = Editor.assets[info.type];
                            if (ctor) {
                                var isRawAsset = !cc.isChildClassOf(ctor, Asset);
                                callback(null, info.url, isRawAsset, ctor);
                            } else {
                                callback(new Error("Can not find asset type " + info.type));
                            }
                        } else {
                            callback(new Error("Can not get asset url by uuid " + uuid));
                        }
                    });
                }
            },
            _getAssetInfoInRuntime: function(uuid) {
                var info = _uuidToRawAssets[uuid];
                if (info) {
                    return {
                        url: _rawAssetsBase + info.url,
                        raw: info.raw
                    };
                } else {
                    var url = this.getImportedDir(uuid) + cc.path.sep + uuid + ".json";
                    return {
                        url: url,
                        raw: false
                    };
                }
            },
            queryAssetInfo: function(uuid, callback) {
                if (false) {
                    this._queryAssetInfoInEditor(uuid, callback);
                } else {
                    var info = this._getAssetInfoInRuntime(uuid);
                    callback(null, info.url, info.raw);
                }
            },
            parseUuidInEditor: function(url) {
                if (false) {
                    var uuid = "";
                    var isImported = url.startsWith(_libraryBase);
                    if (isImported) {
                        var dir = cc.path.dirname(url);
                        var dirBasename = cc.path.basename(dir);
                        var isAssetUrl = 2 === dirBasename.length;
                        if (isAssetUrl) {
                            uuid = cc.path.basename(url);
                            var index = uuid.indexOf(".");
                            if (-1 !== index) {
                                uuid = uuid.slice(0, index);
                            }
                        } else {
                            uuid = dirBasename;
                        }
                    }
                    return uuid;
                }
            },
            _loadAssetByUuid: function(uuid, callback, handle, existingAsset) {
                if ("string" !== typeof uuid) {
                    return callInNextTick(callback, new Error("[AssetLibrary] uuid must be string"), null);
                }
                if (!existingAsset) {
                    var asset = handle.readCache(uuid);
                    if (asset) {
                        return callInNextTick(callback, null, asset);
                    }
                }
                var canShareLoadingTask = handle.readMainCache && !existingAsset;
                if (canShareLoadingTask && !_uuidToCallbacks.add(uuid, callback)) {
                    return;
                }
                var loading = handle.pendingCache[uuid];
                if (loading) {
                    return callInNextTick(callback, null, loading);
                }
                function onload(error, json, url) {
                    function onDeserializedWithDepends(err, asset, hasRawType) {
                        if (asset) {
                            asset._uuid = uuid;
                            handle.writeCache(uuid, asset, hasRawType);
                        }
                        if (canShareLoadingTask) {
                            _uuidToCallbacks.invokeAndRemove(uuid, err, asset);
                        } else {
                            if (callback) {
                                callback(err, asset);
                            }
                        }
                    }
                    if (json) {
                        AssetLibrary._deserializeWithDepends(json, url, uuid, onDeserializedWithDepends, handle, existingAsset);
                    } else {
                        onDeserializedWithDepends(error, null);
                    }
                }
                if (false) {
                    this._queryAssetInfoInEditor(uuid, function(err, url, isRawAsset) {
                        if (err) {
                            callback(err);
                        } else {
                            var shouldLoadByEngine = !isRawAsset;
                            if (!shouldLoadByEngine) {
                                return callback(new Error("Should not load raw file in AssetLibrary, uuid: " + uuid));
                            }
                            LoadManager.loadByLoader(_cc_loader_loadJson, url, function(error, json) {
                                onload(error, json, url);
                            });
                        }
                    });
                } else {
                    var info = this._getAssetInfoInRuntime(uuid);
                    if (info.raw) {
                        return callback(new Error("Should not load raw file in AssetLibrary, uuid: " + uuid));
                    }
                    LoadManager.loadByLoader(_cc_loader_loadJson, info.url, function(error, json) {
                        onload(error, json, info.url);
                    });
                }
            },
            loadJson: function(json, callback, dontCache, recordAssets) {
                var handle = new LoadingHandle(!dontCache, !dontCache, recordAssets);
                var thisTick = true;
                this._deserializeWithDepends(json, "", "", function(p1, p2) {
                    if (thisTick) {
                        callInNextTick(callback, p1, p2);
                    } else {
                        callback(p1, p2);
                    }
                }, handle);
                thisTick = false;
                return handle;
            },
            _loadDepends: function(asset, _tdInfo, url, handle, callback) {
                var pendingCount = _tdInfo.uuidList.length;
                var rawProp = _tdInfo.rawProp;
                if (rawProp) {
                    var attrs = cc.Class.attr(asset.constructor, _tdInfo.rawProp);
                    var rawType = attrs.rawType;
                    ++pendingCount;
                    LoadManager.load(url, rawType, asset._rawext, function onRawObjLoaded(error, raw) {
                        if (error) {
                            cc.error("[AssetLibrary] Failed to load %s of %s. %s", rawType, url, error);
                        }
                        asset[rawProp] = raw;
                        --pendingCount;
                        if (0 === pendingCount) {
                            callback();
                            callback = null;
                        }
                    });
                }
                if (0 === pendingCount) {
                    if (callback) {
                        callback();
                    }
                    return;
                }
                for (var i = 0; i < _tdInfo.uuidList.length; i++) {
                    var dependsUuid = _tdInfo.uuidList[i];
                    !function(dependsUuid, obj, prop) {
                        AssetLibrary.queryAssetInfo(dependsUuid, function(err, dependsUrl, isRawAsset) {
                            if (err) {
                                cc.error('[AssetLibrary] Failed to load "%s", %s', dependsUuid, err);
                                --pendingCount;
                                if (callback && 0 === pendingCount) {
                                    callback();
                                    callback = null;
                                }
                                obj[prop] = obj[prop];
                                return;
                            } else {
                                if (isRawAsset) {
                                    cc.loader.load(dependsUrl, function(err, assets) {
                                        if (err) {
                                            cc.error('[AssetLibrary] Failed to load "%s"', dependsUrl);
                                            obj[prop] = "";
                                        } else {
                                            obj[prop] = dependsUrl;
                                        }
                                        --pendingCount;
                                        if (callback && 0 === pendingCount) {
                                            callback();
                                            callback = null;
                                        }
                                    });
                                    return;
                                }
                            }
                            var onDependsAssetLoaded = function(error, dependsAsset, hasRawType) {
                                if (false) {
                                    if (Editor.AssetDB && Editor.AssetDB.isValidUuid(dependsUuid)) {
                                        cc.error('[AssetLibrary] Failed to load "%s", %s', dependsUuid, error);
                                    }
                                }
                                obj[prop] = dependsAsset;
                                --pendingCount;
                                if (callback && 0 === pendingCount) {
                                    callback();
                                    callback = null;
                                }
                            };
                            AssetLibrary._loadAssetByUuid(dependsUuid, onDependsAssetLoaded, handle);
                        });
                    }(dependsUuid, _tdInfo.uuidObjList[i], _tdInfo.uuidPropList[i]);
                }
                if (callback && 0 === pendingCount) {
                    callback();
                    callback = null;
                }
            },
            _deserializeWithDepends: function(json, url, uuid, callback, handle, existingAsset) {
                var classFinder = function(id) {
                    var cls = JS._getClassById(id);
                    if (cls) {
                        return cls;
                    }
                    cc.warn('Can not get class "%s"', id);
                    return Object;
                };
                var tdInfo = cc.sys.isNative ? new cc.deserialize.Details() : handle.deserializeInfo || _tdInfo;
                var asset = cc.deserialize(json, tdInfo, {
                    classFinder: classFinder,
                    target: existingAsset
                });
                var hasRawType = !!tdInfo.rawProp;
                if (uuid) {
                    handle.pendingCache[uuid] = asset;
                }
                this._loadDepends(asset, tdInfo, url, handle, function() {
                    if (uuid) {
                        delete handle.pendingCache[uuid];
                    }
                    callback(null, asset, hasRawType);
                });
                tdInfo.reset();
            },
            getAssetByUuid: function(uuid) {
                return AssetLibrary._uuidToAsset[uuid] || null;
            },
            init: function(options) {
                if (false) {
                    cc.error("AssetLibrary has already been initialized!");
                    return;
                }
                var libraryPath = options.libraryPath;
                libraryPath = libraryPath.replace(/\\/g, "/");
                _libraryBase = cc.path._setEndWithSep(libraryPath, "/");
                _rawAssetsBase = options.rawAssetsBase;
                _uuidToRawAssets = {};
                var rawAssets = options.rawAssets;
                if (rawAssets) {
                    for (var mountPoint in rawAssets) {
                        var assets = rawAssets[mountPoint];
                        for (var uuid in assets) {
                            var info = assets[uuid];
                            _uuidToRawAssets[uuid] = {
                                url: mountPoint + "/" + info.url,
                                raw: !!info.raw
                            };
                        }
                    }
                }
                var mountPaths = options.mountPaths;
                if (!mountPaths) {
                    mountPaths = {
                        assets: _rawAssetsBase + "assets",
                        internal: _rawAssetsBase + "internal"
                    };
                }
                cc.url._init(mountPaths);
            }
        };
        AssetLibrary._uuidToAsset = {};
        cc.AssetLibrary = AssetLibrary;
    }, {
        "../assets/CCAsset": 22,
        "./callbacks-invoker": 66,
        "./js": 70,
        "./load-manager": 71,
        "./utils": 76
    } ],
    57: [ function(require, module, exports) {
        var JS = require("./js");
        var Enum = require("../value-types/CCEnum");
        var Utils = require("./utils");
        var _isPlainEmptyObj_DEV = Utils.isPlainEmptyObj_DEV;
        var _cloneable_DEV = Utils.cloneable_DEV;
        var Attr = require("./attribute");
        var getTypeChecker = Attr.getTypeChecker;
        var preprocessAttrs = require("./preprocess-attrs");
        var BUILTIN_ENTRIES = [ "name", "extends", "mixins", "ctor", "properties", "statics", "editor" ];
        var TYPO_TO_CORRECT = false;
        var INVALID_STATICS = false;
        var _appendProp = function(cls, name) {
            if (false) {
                if (-1 !== name.indexOf(".")) {
                    cc.error('Disallow to use "." in property name');
                    return;
                }
            }
            var index = cls.__props__.indexOf(name);
            if (index < 0) {
                cls.__props__.push(name);
            }
        };
        var _metaClass = {
            prop: function(name, defaultValue, attribute) {
                "use strict";
                if (false) {
                    if ("object" === typeof defaultValue && defaultValue) {
                        if (Array.isArray(defaultValue)) {
                            if (defaultValue.length > 0) {
                                cc.error('Default array must be empty, set default value of %s.%s to [], and initialize in "onLoad" or "ctor" please. (just like "this.%s = [...];")', JS.getClassName(this), name, name);
                                return this;
                            }
                        } else {
                            if (!_isPlainEmptyObj_DEV(defaultValue)) {
                                if (!_cloneable_DEV(defaultValue)) {
                                    cc.error('Do not set default value to non-empty object, unless the object defines its own "clone" function. Set default value of %s.%s to null or {}, and initialize in "onLoad" or "ctor" please. (just like "this.%s = {foo: bar};")', JS.getClassName(this), name, name);
                                    return this;
                                }
                            }
                        }
                    }
                    for (var base = this.$super; base; base = base.$super) {
                        if (base.prototype.hasOwnProperty(name)) {
                            cc.error("Can not declare %s.%s, it is already defined in the prototype of %s", JS.getClassName(this), name, JS.getClassName(base));
                            return;
                        }
                    }
                }
                Attr.attr(this, name, {
                    "default": defaultValue
                });
                _appendProp(this, name);
                if (attribute) {
                    var onAfterProp = null;
                    var AttrArgStart = 2;
                    for (var i = AttrArgStart; i < arguments.length; i++) {
                        var attr = arguments[i];
                        Attr.attr(this, name, attr);
                        if (attr._onAfterProp) {
                            onAfterProp = onAfterProp || [];
                            onAfterProp.push(attr._onAfterProp);
                        }
                    }
                    if (onAfterProp) {
                        for (var c = 0; c < onAfterProp.length; c++) {
                            onAfterProp[c](this, name);
                        }
                    }
                }
                return this;
            },
            get: function(name, getter, attribute) {
                "use strict";
                if (false) {
                    var d = Object.getOwnPropertyDescriptor(this.prototype, name);
                    if (d && d.get) {
                        cc.error('%s: the getter of "%s" is already defined!', JS.getClassName(this), name);
                        return this;
                    }
                }
                if (attribute) {
                    var AttrArgStart = 2;
                    for (var i = AttrArgStart; i < arguments.length; i++) {
                        var attr = arguments[i];
                        if (false) {
                            if (false === attr._canUsedInGetter) {
                                cc.error('Can not apply the specified attribute to the getter of "%s.%s", attribute index: %s', JS.getClassName(this), name, i - AttrArgStart);
                                continue;
                            }
                        }
                        Attr.attr(this, name, attr);
                        if (false) {
                            if (false === attr.serializable || true === attr.editorOnly) {
                                cc.warn('No need to use "serializable: false" or "editorOnly: true" for the getter of %s.%s, every getter is actually non-serialized.', JS.getClassName(this), name);
                            }
                            if (attr.hasOwnProperty("default")) {
                                cc.error("%s: Can not set default value of a getter!", JS.getClassName(this));
                                return this;
                            }
                        }
                    }
                }
                var forceSerializable = false;
                if (!forceSerializable) {
                    Attr.attr(this, name, Attr.NonSerialized);
                }
                if (forceSerializable || false) {
                    _appendProp(this, name);
                }
                if (Object.getOwnPropertyDescriptor(this.prototype, name)) {
                    Object.defineProperty(this.prototype, name, {
                        get: getter
                    });
                } else {
                    Object.defineProperty(this.prototype, name, {
                        get: getter,
                        configurable: true,
                        enumerable: true
                    });
                }
                if (false) {
                    Attr.attr(this, name, {
                        hasGetter: true
                    });
                }
                return this;
            },
            set: function(name, setter) {
                if (false) {
                    var d = Object.getOwnPropertyDescriptor(this.prototype, name);
                    if (d && d.set) {
                        cc.error('%s: the setter of "%s" is already defined!', JS.getClassName(this), name);
                        return this;
                    }
                }
                if (false) {
                    Object.defineProperty(this.prototype, name, {
                        set: setter,
                        configurable: true,
                        enumerable: true
                    });
                    Attr.attr(this, name, {
                        hasSetter: true
                    });
                } else {
                    if (Object.getOwnPropertyDescriptor(this.prototype, name)) {
                        Object.defineProperty(this.prototype, name, {
                            set: setter
                        });
                    } else {
                        Object.defineProperty(this.prototype, name, {
                            set: setter,
                            configurable: true,
                            enumerable: true
                        });
                    }
                }
                return this;
            },
            extend: function(options) {
                options["extends"] = this;
                return CCClass(options);
            }
        };
        function getDefault(defaultVal) {
            if ("function" === typeof defaultVal) {
                if (false) {
                    try {
                        return defaultVal();
                    } catch (e) {
                        cc._throw(e);
                        return void 0;
                    }
                } else {
                    return defaultVal();
                }
            }
            return defaultVal;
        }
        function instantiateProps(instance, itsClass) {
            var propList = itsClass.__props__;
            for (var i = 0; i < propList.length; i++) {
                var prop = propList[i];
                var attrs = Attr.attr(itsClass, prop);
                if (attrs && attrs.hasOwnProperty("default")) {
                    var def = attrs["default"];
                    if (def) {
                        if ("object" === typeof def && def) {
                            if ("function" === typeof def.clone) {
                                def = def.clone();
                            } else {
                                if (Array.isArray(def)) {
                                    def = [];
                                } else {
                                    def = {};
                                }
                            }
                        } else {
                            if ("function" === typeof def) {
                                def = getDefault(def);
                            }
                        }
                    }
                    instance[prop] = def;
                }
            }
        }
        cc.isChildClassOf = function(subclass, superclass) {
            if (subclass && superclass) {
                if ("function" !== typeof subclass) {
                    return false;
                }
                if ("function" !== typeof superclass) {
                    if (false) {
                        cc.warn("[isChildClassOf] superclass should be function type, not", superclass);
                    }
                    return false;
                }
                for (;subclass && subclass.$super; subclass = subclass.$super) {
                    if (subclass === superclass) {
                        return true;
                    }
                }
                if (subclass === superclass) {
                    return true;
                }
                var dunderProto = Object.getPrototypeOf(subclass.prototype);
                while (dunderProto) {
                    subclass = dunderProto.constructor;
                    if (subclass === superclass) {
                        return true;
                    }
                    dunderProto = Object.getPrototypeOf(subclass.prototype);
                }
            }
            return false;
        };
        function doDefine(className, baseClass, mixins, constructor, options) {
            var fireClass = _createCtor(constructor, baseClass, mixins, className, options);
            for (var staticMember in _metaClass) {
                Object.defineProperty(fireClass, staticMember, {
                    value: _metaClass[staticMember],
                    writable: true
                });
            }
            if (baseClass) {
                JS.extend(fireClass, baseClass);
                fireClass.$super = baseClass;
                fireClass.__props__ = baseClass.__props__ ? baseClass.__props__.slice() : [];
            }
            if (mixins) {
                for (var m = 0; m < mixins.length; ++m) {
                    var mixin = mixins[m];
                    JS.mixin(fireClass.prototype, mixin.prototype);
                    for (var p in mixin) {
                        if (mixin.hasOwnProperty(p) && INVALID_STATICS.indexOf(p) < 0) {
                            fireClass[p] = mixin[p];
                        }
                    }
                    fireClass.__props__ = fireClass.__props__ || [];
                    if (mixin.__props__) {
                        fireClass.__props__ = fireClass.__props__.concat(mixin.__props__.filter(function(x) {
                            return fireClass.__props__.indexOf(x) < 0;
                        }));
                    }
                }
                fireClass.prototype.constructor = fireClass;
            }
            fireClass.__props__ = fireClass.__props__ || [];
            JS.setClassName(className, fireClass);
            return fireClass;
        }
        function define(className, baseClasses, mixins, constructor, options) {
            if (cc.isChildClassOf(baseClasses, cc.Component)) {
                var frame = cc._RFpeek();
                if (frame) {
                    if (false) {
                        cc.warn("cc.Class: Should not define constructor for cc.Component.");
                    }
                    if (frame.beh) {
                        cc.error("Each script can have at most one Component.");
                        return;
                    }
                    var uuid = frame.uuid;
                    if (uuid) {
                        if (className && false) {
                            cc.warn("Should not specify class name for Component which defines in project.");
                        }
                    }
                    className = className || frame.script;
                    var cls = doDefine(className, baseClasses, mixins, constructor, options);
                    if (uuid) {
                        JS._setClassId(uuid, cls);
                        if (false) {
                            cc.Component._addMenuItem(cls, "i18n:MAIN_MENU.component.scripts/" + className, -1);
                            cls.prototype.__scriptUuid = Editor.decompressUuid(uuid);
                        }
                    }
                    frame.beh = cls;
                    return cls;
                }
            }
            return doDefine(className, baseClasses, mixins, constructor, options);
        }
        function _checkCtor(ctor) {
            if (false) {
                if (CCClass._isCCClass(ctor)) {
                    cc.error("Constructor can not be another CCClass");
                    return;
                }
                if ("function" !== typeof ctor) {
                    cc.error("Constructor of CCClass must be function type");
                    return;
                }
                if (ctor.length > 0) {
                    cc.warn("Can not instantiate CCClass with arguments.");
                    return;
                }
            }
        }
        function normalizeClassName(className) {
            if (false) {
                var DefaultName = "CCClass";
                if (className) {
                    className = className.replace(/\./g, "_");
                    className = className.split("").filter(function(x) {
                        return /^[a-zA-Z0-9_$]/.test(x);
                    }).join("");
                    if (/^[0-9]/.test(className[0])) {
                        className = "_" + className;
                    }
                    try {
                        eval("function " + className + "(){}");
                    } catch (e) {
                        className = "FireClass_" + className;
                        try {
                            eval("function " + className + "(){}");
                        } catch (e) {
                            return DefaultName;
                        }
                    }
                    return className;
                }
                return DefaultName;
            }
        }
        function _createCtor(ctor, baseClass, mixins, className, options) {
            var useTryCatch = !(className && className.startsWith("cc."));
            var shouldAddProtoCtor;
            if (false) {
                var originCtor = ctor;
                if (SuperCallReg.test(ctor)) {
                    cc.warn(cc._LogInfos.Editor.Class.callSuperCtor, className);
                    ctor = function() {
                        this._super = function() {};
                        var ret = originCtor.apply(this, arguments);
                        this._super = null;
                        return ret;
                    };
                }
                if (/\bprototype.ctor\b/.test(originCtor)) {
                    cc.warn(cc._LogInfos.Editor.Class.callSuperCtor, className);
                    shouldAddProtoCtor = true;
                }
            }
            var superCallBounded = options && baseClass && boundSuperCalls(baseClass, options);
            if (ctor && false) {
                _checkCtor(ctor);
            }
            var ctors = [];
            var baseOrMixins = [ baseClass ].concat(mixins);
            for (var b = 0; b < baseOrMixins.length; b++) {
                var baseOrMixin = baseOrMixins[b];
                if (baseOrMixin) {
                    if (CCClass._isCCClass(baseOrMixin)) {
                        var baseCtors = baseOrMixin.__ctors__;
                        if (baseCtors) {
                            ctors = ctors.concat(baseCtors);
                        }
                    } else {
                        if (baseOrMixin) {
                            ctors.push(baseOrMixin);
                        }
                    }
                }
            }
            if (ctor) {
                ctors.push(ctor);
            }
            var body;
            if (false) {
                body = "(function " + normalizeClassName(className) + "(){\n";
            } else {
                body = "(function(){\n";
            }
            if (superCallBounded) {
                body += "this._super=null;\n";
            }
            body += "instantiateProps(this,fireClass);\n";
            if (ctors.length > 0) {
                body += "var cs=fireClass.__ctors__;\n";
                if (useTryCatch) {
                    body += "try{\n";
                }
                if (ctors.length <= 5) {
                    for (var i = 0; i < ctors.length; i++) {
                        body += "(cs[" + i + "]).apply(this,arguments);\n";
                    }
                } else {
                    body += "for(var i=0,l=cs.length;i<l;++i){\n";
                    body += "(cs[i]).apply(this,arguments);\n}\n";
                }
                if (useTryCatch) {
                    body += "}catch(e){\ncc._throw(e);\n}\n";
                }
            }
            body += "})";
            var fireClass = eval(body);
            Object.defineProperty(fireClass, "__ctors__", {
                value: ctors.length > 0 ? ctors : null,
                writable: false,
                enumerable: false
            });
            if (shouldAddProtoCtor && false) {
                fireClass.prototype.ctor = function() {};
            }
            return fireClass;
        }
        var SuperCallReg = /xyz/.test(function() {
            xyz;
        }) ? /\b_super\b/ : /.*/;
        function _boundSuperCall(func, funcName, base) {
            var superFunc = null;
            var pd = JS.getPropertyDescriptor(base.prototype, funcName);
            if (pd) {
                if (pd.value) {
                    if ("function" === typeof pd.value) {
                        superFunc = pd.value;
                    }
                } else {
                    if (pd.get) {
                        var got = pd.get();
                        if ("function" === typeof got) {
                            superFunc = got;
                        }
                    }
                }
            }
            if (superFunc) {
                var hasSuperCall = SuperCallReg.test(func);
                if (hasSuperCall) {
                    return function() {
                        var tmp = this._super;
                        this._super = superFunc;
                        var ret = func.apply(this, arguments);
                        this._super = tmp;
                        return ret;
                    };
                }
            }
            return null;
        }
        function boundSuperCalls(baseClass, options) {
            var hasSuperCall = false;
            for (var funcName in options) {
                if (BUILTIN_ENTRIES.indexOf(funcName) < 0) {
                    var func = options[funcName];
                    if ("function" === typeof func) {
                        var bounded = _boundSuperCall(func, funcName, baseClass);
                        if (bounded) {
                            hasSuperCall = true;
                            options[funcName] = bounded;
                        }
                    }
                }
            }
            return hasSuperCall;
        }
        function CCClass(options) {
            if (0 === arguments.length) {
                return define();
            }
            if (!options) {
                cc.error("cc.Class: Option must be non-nil");
                return define();
            }
            var name = options.name;
            var base = options["extends"];
            var cls;
            cls = define(name, base, options.mixins, options.ctor, options);
            if (!name) {
                name = cc.js.getClassName(cls);
            }
            var properties = options.properties;
            if (properties) {
                preprocessAttrs(properties, name, cls);
                for (var propName in properties) {
                    var val = properties[propName];
                    var attrs = parseAttributes(val, name, propName);
                    if ("default" in val) {
                        cls.prop.apply(cls, [ propName, val["default"] ].concat(attrs));
                    } else {
                        var getter = val.get;
                        var setter = val.set;
                        if (false) {
                            if (!getter && !setter) {
                                cc.error('Property %s.%s must define at least one of "default", "get" or "set".', name, propName);
                            }
                        }
                        if (getter) {
                            cls.get.apply(cls, [ propName, getter ].concat(attrs));
                        }
                        if (setter) {
                            cls.set(propName, setter);
                        }
                    }
                }
            }
            var statics = options.statics;
            if (statics) {
                var staticPropName;
                if (false) {
                    for (staticPropName in statics) {
                        if (-1 !== INVALID_STATICS.indexOf(staticPropName)) {
                            cc.error('Cannot define %s.%s because static member name can not be "%s".', name, staticPropName, staticPropName);
                            continue;
                        }
                    }
                }
                for (staticPropName in statics) {
                    cls[staticPropName] = statics[staticPropName];
                }
            }
            for (var funcName in options) {
                if (BUILTIN_ENTRIES.indexOf(funcName) >= 0) {
                    continue;
                }
                var func = options[funcName];
                if ("function" === typeof func || null === func) {
                    cls.prototype[funcName] = func;
                } else {
                    if (false) {
                        var correct = TYPO_TO_CORRECT[funcName];
                        if (correct) {
                            cc.warn('Unknown parameter of %s.%s, maybe you want is "%s".', name, funcName, correct);
                        } else {
                            if (func) {
                                cc.error('Unknown parameter of %s.%s, property should be defined in "properties" or "ctor"', name, funcName);
                            }
                        }
                    }
                }
            }
            if (false) {
                var editor = options.editor;
                if (editor) {
                    if (cc.isChildClassOf(base, cc.Component)) {
                        cc.Component._registerEditorProps(cls, editor);
                    } else {
                        cc.warn('Can not use "editor" attribute, "%s" not inherits from Components.', name);
                    }
                }
            }
            return cls;
        }
        CCClass._isCCClass = function(constructor) {
            return !!constructor && constructor.prop === _metaClass.prop;
        };
        function fastDefine(className, constructor, serializableFields) {
            JS.setClassName(className, constructor);
            constructor.__props__ = serializableFields;
            for (var i = 0; i < serializableFields.length; i++) {
                Attr.attr(constructor, serializableFields[i], {
                    visible: false
                });
            }
        }
        CCClass.attr = Attr.attr;
        var tmpAttrs = [];
        function parseAttributes(attrs, className, propName) {
            var ERR_Type = false ? "The %s of %s must be type %s" : "";
            tmpAttrs.length = 0;
            var result = tmpAttrs;
            var type = attrs.type;
            if (type) {
                switch (type) {
                  case "Integer":
                    result.push({
                        type: "Integer"
                    });
                    break;

                  case "Float":
                    result.push({
                        type: "Float"
                    });
                    break;

                  case "Boolean":
                    result.push({
                        type: "Boolean",
                        _onAfterProp: getTypeChecker("Boolean", "Boolean")
                    });
                    break;

                  case "String":
                    result.push({
                        type: "String",
                        _onAfterProp: getTypeChecker("String", "String")
                    });
                    break;

                  case "Object":
                    if (false) {
                        cc.error('Please define "type" parameter of %s.%s as the actual constructor.', className, propName);
                    }
                    break;

                  default:
                    if (type === Attr.ScriptUuid) {
                        var attr = Attr.ObjectType(cc.ScriptAsset);
                        attr.type = "Script";
                        result.push(attr);
                    } else {
                        if ("object" === typeof type) {
                            if (Enum.isEnum(type)) {
                                result.push({
                                    type: "Enum",
                                    enumList: Enum.getList(type)
                                });
                            } else {
                                if (false) {
                                    cc.error('Please define "type" parameter of %s.%s as the constructor of %s.', className, propName, type);
                                }
                            }
                        } else {
                            if ("function" === typeof type) {
                                result.push(Attr.ObjectType(type));
                            } else {
                                if (false) {
                                    cc.error('Unknown "type" parameter of %s.%s%s', className, propName, type);
                                }
                            }
                        }
                    }
                }
            }
            function parseSimpleAttr(attrName, expectType, attrCreater) {
                var val = attrs[attrName];
                if (val) {
                    if (typeof val === expectType) {
                        if ("undefined" === typeof attrCreater) {
                            var attr = {};
                            attr[attrName] = val;
                            result.push(attr);
                        } else {
                            result.push("function" === typeof attrCreater ? attrCreater(val) : attrCreater);
                        }
                    } else {
                        if (false) {
                            cc.error("The %s of %s.%s must be type %s", attrName, className, propName, expectType);
                        }
                    }
                }
            }
            parseSimpleAttr("rawType", "string", Attr.RawType);
            parseSimpleAttr("editorOnly", "boolean", Attr.EditorOnly);
            if (false) {
                parseSimpleAttr("displayName", "string");
                parseSimpleAttr("multiline", "boolean", {
                    multiline: true
                });
                parseSimpleAttr("readonly", "boolean", {
                    readonly: true
                });
                parseSimpleAttr("tooltip", "string");
            }
            if (attrs.url) {
                result.push({
                    saveUrlAsAsset: true
                });
            }
            if (false === attrs.serializable) {
                result.push(Attr.NonSerialized);
            }
            if (false) {
                var visible = attrs.visible;
                if ("undefined" !== typeof visible) {
                    if (!attrs.visible) {
                        result.push({
                            visible: false
                        });
                    }
                } else {
                    var startsWithUS = 95 === propName.charCodeAt(0);
                    if (startsWithUS) {
                        result.push({
                            visible: false
                        });
                    }
                }
            }
            var range = attrs.range;
            if (range) {
                if (Array.isArray(range)) {
                    if (range.length >= 2) {
                        result.push(Attr.Range(range[0], range[1]));
                    } else {
                        if (false) {
                            cc.error("The length of range array must be 2");
                        }
                    }
                } else {
                    if (false) {
                        cc.error(ERR_Type, '"range"', className + "." + propName, "array");
                    }
                }
            }
            var nullable = attrs.nullable;
            if (nullable) {
                if ("object" === typeof nullable) {
                    var boolPropName = nullable.propName;
                    if ("string" === typeof boolPropName) {
                        var def = nullable["default"];
                        if ("boolean" === typeof def) {
                            result.push(Attr.Nullable(boolPropName, def));
                        } else {
                            if (false) {
                                cc.error(ERR_Type, '"default"', "nullable object", "boolean");
                            }
                        }
                    } else {
                        if (false) {
                            cc.error(ERR_Type, '"propName"', "nullable object", "string");
                        }
                    }
                } else {
                    if (false) {
                        cc.error(ERR_Type, '"nullable"', className + "." + propName, "object");
                    }
                }
            }
            return result;
        }
        CCClass.extend = CCClass;
        cc.Class = CCClass;
        module.exports = {
            instantiateProps: instantiateProps,
            isArray: function(defaultVal) {
                defaultVal = getDefault(defaultVal);
                return Array.isArray(defaultVal);
            },
            fastDefine: fastDefine
        };
    }, {
        "../value-types/CCEnum": 92,
        "./attribute": 65,
        "./js": 70,
        "./preprocess-attrs": 73,
        "./utils": 76
    } ],
    58: [ function(require, module, exports) {
        var inputManager = require("./CCInputManager");
        inputManager.setAccelerometerEnabled = function(isEnable) {
            var _t = this;
            if (_t._accelEnabled === isEnable) {
                return;
            }
            _t._accelEnabled = isEnable;
            var scheduler = cc.director.getScheduler();
            if (_t._accelEnabled) {
                _t._accelCurTime = 0;
                scheduler.scheduleUpdate(_t);
            } else {
                _t._accelCurTime = 0;
                scheduler.scheduleUpdate(_t);
            }
        };
        inputManager.setAccelerometerInterval = function(interval) {
            if (this._accelInterval !== interval) {
                this._accelInterval = interval;
            }
        };
        inputManager._registerKeyboardEvent = function() {
            cc.game.canvas.addEventListener("keydown", function(e) {
                cc.eventManager.dispatchEvent(new cc.Event.EventKeyboard(e.keyCode, true));
                e.stopPropagation();
                e.preventDefault();
            }, false);
            cc.game.canvas.addEventListener("keyup", function(e) {
                cc.eventManager.dispatchEvent(new cc.Event.EventKeyboard(e.keyCode, false));
                e.stopPropagation();
                e.preventDefault();
            }, false);
        };
        inputManager._registerAccelerometerEvent = function() {
            var w = window, _t = this;
            _t._acceleration = new cc.Acceleration();
            _t._accelDeviceEvent = w.DeviceMotionEvent || w.DeviceOrientationEvent;
            if (cc.sys.browserType === cc.sys.BROWSER_TYPE_MOBILE_QQ) {
                _t._accelDeviceEvent = window.DeviceOrientationEvent;
            }
            var _deviceEventType = _t._accelDeviceEvent === w.DeviceMotionEvent ? "devicemotion" : "deviceorientation";
            var ua = navigator.userAgent;
            if (/Android/.test(ua) || /Adr/.test(ua) && cc.sys.browserType === cc.BROWSER_TYPE_UC) {
                _t._minus = -1;
            }
            w.addEventListener(_deviceEventType, _t.didAccelerate.bind(_t), false);
        };
        inputManager.didAccelerate = function(eventData) {
            var _t = this, w = window;
            if (!_t._accelEnabled) {
                return;
            }
            var mAcceleration = _t._acceleration;
            var x, y, z;
            if (_t._accelDeviceEvent === window.DeviceMotionEvent) {
                var eventAcceleration = eventData["accelerationIncludingGravity"];
                x = _t._accelMinus * eventAcceleration.x * .1;
                y = _t._accelMinus * eventAcceleration.y * .1;
                z = .1 * eventAcceleration.z;
            } else {
                x = eventData["gamma"] / 90 * .981;
                y = .981 * -(eventData["beta"] / 90);
                z = eventData["alpha"] / 90 * .981;
            }
            if (cc.sys.os === cc.sys.OS_ANDROID) {
                mAcceleration.x = -x;
                mAcceleration.y = -y;
            } else {
                mAcceleration.x = x;
                mAcceleration.y = y;
            }
            mAcceleration.z = z;
            mAcceleration.timestamp = eventData.timeStamp || Date.now();
            var tmpX = mAcceleration.x;
            if (w.orientation === cc.UIOrientation.LANDSCAPE_RIGHT) {
                mAcceleration.x = -mAcceleration.y;
                mAcceleration.y = tmpX;
            } else {
                if (w.orientation === cc.UIOrientation.LANDSCAPE_LEFT) {
                    mAcceleration.x = mAcceleration.y;
                    mAcceleration.y = -tmpX;
                } else {
                    if (w.orientation === cc.UIOrientation.PORTRAIT_UPSIDE_DOWN) {
                        mAcceleration.x = -mAcceleration.x;
                        mAcceleration.y = -mAcceleration.y;
                    }
                }
            }
        };
    }, {
        "./CCInputManager": 59
    } ],
    59: [ function(require, module, exports) {
        Enum = require("../value-types/CCEnum");
        cc.UIOrientation = cc.Enum({
            PORTRAIT: 0,
            LANDSCAPE_LEFT: -90,
            LANDSCAPE_RIGHT: 90,
            PORTRAIT_UPSIDE_DOWN: 180
        });
        var inputManager = {
            _mousePressed: false,
            _isRegisterEvent: false,
            _preTouchPoint: cc.p(0, 0),
            _prevMousePoint: cc.p(0, 0),
            _preTouchPool: [],
            _preTouchPoolPointer: 0,
            _touches: [],
            _touchesIntegerDict: {},
            _indexBitsUsed: 0,
            _maxTouches: 5,
            _accelEnabled: false,
            _accelInterval: 1 / 30,
            _accelMinus: 1,
            _accelCurTime: 0,
            _acceleration: null,
            _accelDeviceEvent: null,
            _getUnUsedIndex: function() {
                var temp = this._indexBitsUsed;
                for (var i = 0; i < this._maxTouches; i++) {
                    if (!(1 & temp)) {
                        this._indexBitsUsed |= 1 << i;
                        return i;
                    }
                    temp >>= 1;
                }
                return -1;
            },
            _removeUsedIndexBit: function(index) {
                if (index < 0 || index >= this._maxTouches) {
                    return;
                }
                var temp = 1 << index;
                temp = ~temp;
                this._indexBitsUsed &= temp;
            },
            _glView: null,
            handleTouchesBegin: function(touches) {
                var selTouch, index, curTouch, touchID, handleTouches = [], locTouchIntDict = this._touchesIntegerDict;
                for (var i = 0, len = touches.length; i < len; i++) {
                    selTouch = touches[i];
                    touchID = selTouch.getID();
                    index = locTouchIntDict[touchID];
                    if (null == index) {
                        var unusedIndex = this._getUnUsedIndex();
                        if (-1 === unusedIndex) {
                            cc.log(cc._LogInfos.inputManager.handleTouchesBegin, unusedIndex);
                            continue;
                        }
                        curTouch = this._touches[unusedIndex] = new cc.Touch(selTouch._point.x, selTouch._point.y, selTouch.getID());
                        curTouch._setPrevPoint(selTouch._prevPoint);
                        locTouchIntDict[touchID] = unusedIndex;
                        handleTouches.push(curTouch);
                    }
                }
                if (handleTouches.length > 0) {
                    this._glView._convertTouchesWithScale(handleTouches);
                    var touchEvent = new cc.Event.EventTouch(handleTouches);
                    touchEvent._eventCode = cc.Event.EventTouch.BEGAN;
                    cc.eventManager.dispatchEvent(touchEvent);
                }
            },
            handleTouchesMove: function(touches) {
                var selTouch, index, touchID, handleTouches = [], locTouches = this._touches;
                for (var i = 0, len = touches.length; i < len; i++) {
                    selTouch = touches[i];
                    touchID = selTouch.getID();
                    index = this._touchesIntegerDict[touchID];
                    if (null == index) {
                        continue;
                    }
                    if (locTouches[index]) {
                        locTouches[index]._setPoint(selTouch._point);
                        locTouches[index]._setPrevPoint(selTouch._prevPoint);
                        handleTouches.push(locTouches[index]);
                    }
                }
                if (handleTouches.length > 0) {
                    this._glView._convertTouchesWithScale(handleTouches);
                    var touchEvent = new cc.Event.EventTouch(handleTouches);
                    touchEvent._eventCode = cc.Event.EventTouch.MOVED;
                    cc.eventManager.dispatchEvent(touchEvent);
                }
            },
            handleTouchesEnd: function(touches) {
                var handleTouches = this.getSetOfTouchesEndOrCancel(touches);
                if (handleTouches.length > 0) {
                    this._glView._convertTouchesWithScale(handleTouches);
                    var touchEvent = new cc.Event.EventTouch(handleTouches);
                    touchEvent._eventCode = cc.Event.EventTouch.ENDED;
                    cc.eventManager.dispatchEvent(touchEvent);
                }
            },
            handleTouchesCancel: function(touches) {
                var handleTouches = this.getSetOfTouchesEndOrCancel(touches);
                if (handleTouches.length > 0) {
                    this._glView._convertTouchesWithScale(handleTouches);
                    var touchEvent = new cc.Event.EventTouch(handleTouches);
                    touchEvent._eventCode = cc.Event.EventTouch.CANCELLED;
                    cc.eventManager.dispatchEvent(touchEvent);
                }
            },
            getSetOfTouchesEndOrCancel: function(touches) {
                var selTouch, index, touchID, handleTouches = [], locTouches = this._touches, locTouchesIntDict = this._touchesIntegerDict;
                for (var i = 0, len = touches.length; i < len; i++) {
                    selTouch = touches[i];
                    touchID = selTouch.getID();
                    index = locTouchesIntDict[touchID];
                    if (null == index) {
                        continue;
                    }
                    if (locTouches[index]) {
                        locTouches[index]._setPoint(selTouch._point);
                        locTouches[index]._setPrevPoint(selTouch._prevPoint);
                        handleTouches.push(locTouches[index]);
                        this._removeUsedIndexBit(index);
                        delete locTouchesIntDict[touchID];
                    }
                }
                return handleTouches;
            },
            getHTMLElementPosition: function(element) {
                var docElem = document.documentElement;
                var win = window;
                var box = null;
                if (cc.js.isFunction(element.getBoundingClientRect)) {
                    box = element.getBoundingClientRect();
                } else {
                    if (element instanceof HTMLCanvasElement) {
                        box = {
                            left: 0,
                            top: 0,
                            width: element.width,
                            height: element.height
                        };
                    } else {
                        box = {
                            left: 0,
                            top: 0,
                            width: parseInt(element.style.width),
                            height: parseInt(element.style.height)
                        };
                    }
                }
                return {
                    left: box.left + win.pageXOffset - docElem.clientLeft,
                    top: box.top + win.pageYOffset - docElem.clientTop,
                    width: box.width,
                    height: box.height
                };
            },
            getPreTouch: function(touch) {
                var preTouch = null;
                var locPreTouchPool = this._preTouchPool;
                var id = touch.getID();
                for (var i = locPreTouchPool.length - 1; i >= 0; i--) {
                    if (locPreTouchPool[i].getID() === id) {
                        preTouch = locPreTouchPool[i];
                        break;
                    }
                }
                if (!preTouch) {
                    preTouch = touch;
                }
                return preTouch;
            },
            setPreTouch: function(touch) {
                var find = false;
                var locPreTouchPool = this._preTouchPool;
                var id = touch.getID();
                for (var i = locPreTouchPool.length - 1; i >= 0; i--) {
                    if (locPreTouchPool[i].getID() === id) {
                        locPreTouchPool[i] = touch;
                        find = true;
                        break;
                    }
                }
                if (!find) {
                    if (locPreTouchPool.length <= 50) {
                        locPreTouchPool.push(touch);
                    } else {
                        locPreTouchPool[this._preTouchPoolPointer] = touch;
                        this._preTouchPoolPointer = (this._preTouchPoolPointer + 1) % 50;
                    }
                }
            },
            getTouchByXY: function(tx, ty, pos) {
                var locPreTouch = this._preTouchPoint;
                var location = this._glView.convertToLocationInView(tx, ty, pos);
                var touch = new cc.Touch(location.x, location.y);
                touch._setPrevPoint(locPreTouch.x, locPreTouch.y);
                locPreTouch.x = location.x;
                locPreTouch.y = location.y;
                return touch;
            },
            getMouseEvent: function(location, pos, eventType) {
                var locPreMouse = this._prevMousePoint;
                this._glView._convertMouseToLocationInView(location, pos);
                var mouseEvent = new cc.Event.EventMouse(eventType);
                mouseEvent.setLocation(location.x, location.y);
                mouseEvent._setPrevCursor(locPreMouse.x, locPreMouse.y);
                locPreMouse.x = location.x;
                locPreMouse.y = location.y;
                return mouseEvent;
            },
            getPointByEvent: function(event, pos) {
                if (null != event.pageX) {
                    return {
                        x: event.pageX,
                        y: event.pageY
                    };
                }
                pos.left -= document.body.scrollLeft;
                pos.top -= document.body.scrollTop;
                return {
                    x: event.clientX,
                    y: event.clientY
                };
            },
            getTouchesByEvent: function(event, pos) {
                var touchArr = [], locView = this._glView;
                var touch_event, touch, preLocation;
                var locPreTouch = this._preTouchPoint;
                var length = event.changedTouches.length;
                for (var i = 0; i < length; i++) {
                    touch_event = event.changedTouches[i];
                    if (touch_event) {
                        var location;
                        if (cc.sys.BROWSER_TYPE_FIREFOX === cc.sys.browserType) {
                            location = locView.convertToLocationInView(touch_event.pageX, touch_event.pageY, pos);
                        } else {
                            location = locView.convertToLocationInView(touch_event.clientX, touch_event.clientY, pos);
                        }
                        if (null != touch_event.identifier) {
                            touch = new cc.Touch(location.x, location.y, touch_event.identifier);
                            preLocation = this.getPreTouch(touch).getLocation();
                            touch._setPrevPoint(preLocation.x, preLocation.y);
                            this.setPreTouch(touch);
                        } else {
                            touch = new cc.Touch(location.x, location.y);
                            touch._setPrevPoint(locPreTouch.x, locPreTouch.y);
                        }
                        locPreTouch.x = location.x;
                        locPreTouch.y = location.y;
                        touchArr.push(touch);
                    }
                }
                return touchArr;
            },
            registerSystemEvent: function(element) {
                if (this._isRegisterEvent) {
                    return;
                }
                var locView = this._glView = cc.view;
                var selfPointer = this;
                var supportMouse = "mouse" in cc.sys.capabilities, supportTouches = "touches" in cc.sys.capabilities;
                var prohibition = false;
                if (cc.sys.isMobile) {
                    prohibition = true;
                }
                if (supportMouse) {
                    !prohibition && window.addEventListener("mousedown", function() {
                        selfPointer._mousePressed = true;
                    }, false);
                    !prohibition && window.addEventListener("mouseup", function(event) {
                        var savePressed = selfPointer._mousePressed;
                        selfPointer._mousePressed = false;
                        if (!savePressed) {
                            return;
                        }
                        var pos = selfPointer.getHTMLElementPosition(element);
                        var location = selfPointer.getPointByEvent(event, pos);
                        if (!cc.rectContainsPoint(new cc.Rect(pos.left, pos.top, pos.width, pos.height), location)) {
                            selfPointer.handleTouchesEnd([ selfPointer.getTouchByXY(location.x, location.y, pos) ]);
                            var mouseEvent = selfPointer.getMouseEvent(location, pos, cc.Event.EventMouse.UP);
                            mouseEvent.setButton(event.button);
                            cc.eventManager.dispatchEvent(mouseEvent);
                        }
                    }, false);
                    !prohibition && element.addEventListener("mousedown", function(event) {
                        selfPointer._mousePressed = true;
                        var pos = selfPointer.getHTMLElementPosition(element);
                        var location = selfPointer.getPointByEvent(event, pos);
                        selfPointer.handleTouchesBegin([ selfPointer.getTouchByXY(location.x, location.y, pos) ]);
                        var mouseEvent = selfPointer.getMouseEvent(location, pos, cc.Event.EventMouse.DOWN);
                        mouseEvent.setButton(event.button);
                        cc.eventManager.dispatchEvent(mouseEvent);
                        event.stopPropagation();
                        event.preventDefault();
                        element.focus();
                    }, false);
                    !prohibition && element.addEventListener("mouseup", function(event) {
                        selfPointer._mousePressed = false;
                        var pos = selfPointer.getHTMLElementPosition(element);
                        var location = selfPointer.getPointByEvent(event, pos);
                        selfPointer.handleTouchesEnd([ selfPointer.getTouchByXY(location.x, location.y, pos) ]);
                        var mouseEvent = selfPointer.getMouseEvent(location, pos, cc.Event.EventMouse.UP);
                        mouseEvent.setButton(event.button);
                        cc.eventManager.dispatchEvent(mouseEvent);
                        event.stopPropagation();
                        event.preventDefault();
                    }, false);
                    !prohibition && element.addEventListener("mousemove", function(event) {
                        var pos = selfPointer.getHTMLElementPosition(element);
                        var location = selfPointer.getPointByEvent(event, pos);
                        selfPointer.handleTouchesMove([ selfPointer.getTouchByXY(location.x, location.y, pos) ]);
                        var mouseEvent = selfPointer.getMouseEvent(location, pos, cc.Event.EventMouse.MOVE);
                        if (selfPointer._mousePressed) {
                            mouseEvent.setButton(event.button);
                        } else {
                            mouseEvent.setButton(null);
                        }
                        cc.eventManager.dispatchEvent(mouseEvent);
                        event.stopPropagation();
                        event.preventDefault();
                    }, false);
                    element.addEventListener("mousewheel", function(event) {
                        var pos = selfPointer.getHTMLElementPosition(element);
                        var location = selfPointer.getPointByEvent(event, pos);
                        var mouseEvent = selfPointer.getMouseEvent(location, pos, cc.Event.EventMouse.SCROLL);
                        mouseEvent.setButton(event.button);
                        mouseEvent.setScrollData(0, event.wheelDelta);
                        cc.eventManager.dispatchEvent(mouseEvent);
                        event.stopPropagation();
                        event.preventDefault();
                    }, false);
                    element.addEventListener("DOMMouseScroll", function(event) {
                        var pos = selfPointer.getHTMLElementPosition(element);
                        var location = selfPointer.getPointByEvent(event, pos);
                        var mouseEvent = selfPointer.getMouseEvent(location, pos, cc.Event.EventMouse.SCROLL);
                        mouseEvent.setButton(event.button);
                        mouseEvent.setScrollData(0, -120 * event.detail);
                        cc.eventManager.dispatchEvent(mouseEvent);
                        event.stopPropagation();
                        event.preventDefault();
                    }, false);
                }
                if (window.navigator.msPointerEnabled) {
                    var _pointerEventsMap = {
                        MSPointerDown: selfPointer.handleTouchesBegin,
                        MSPointerMove: selfPointer.handleTouchesMove,
                        MSPointerUp: selfPointer.handleTouchesEnd,
                        MSPointerCancel: selfPointer.handleTouchesCancel
                    };
                    for (var eventName in _pointerEventsMap) {
                        !function(_pointerEvent, _touchEvent) {
                            element.addEventListener(_pointerEvent, function(event) {
                                var pos = selfPointer.getHTMLElementPosition(element);
                                pos.left -= document.documentElement.scrollLeft;
                                pos.top -= document.documentElement.scrollTop;
                                _touchEvent.call(selfPointer, [ selfPointer.getTouchByXY(event.clientX, event.clientY, pos) ]);
                                event.stopPropagation();
                            }, false);
                        }(eventName, _pointerEventsMap[eventName]);
                    }
                }
                if (supportTouches) {
                    element.addEventListener("touchstart", function(event) {
                        if (!event.changedTouches) {
                            return;
                        }
                        var pos = selfPointer.getHTMLElementPosition(element);
                        pos.left -= document.body.scrollLeft;
                        pos.top -= document.body.scrollTop;
                        selfPointer.handleTouchesBegin(selfPointer.getTouchesByEvent(event, pos));
                        event.stopPropagation();
                        event.preventDefault();
                        element.focus();
                    }, false);
                    element.addEventListener("touchmove", function(event) {
                        if (!event.changedTouches) {
                            return;
                        }
                        var pos = selfPointer.getHTMLElementPosition(element);
                        pos.left -= document.body.scrollLeft;
                        pos.top -= document.body.scrollTop;
                        selfPointer.handleTouchesMove(selfPointer.getTouchesByEvent(event, pos));
                        event.stopPropagation();
                        event.preventDefault();
                    }, false);
                    element.addEventListener("touchend", function(event) {
                        if (!event.changedTouches) {
                            return;
                        }
                        var pos = selfPointer.getHTMLElementPosition(element);
                        pos.left -= document.body.scrollLeft;
                        pos.top -= document.body.scrollTop;
                        selfPointer.handleTouchesEnd(selfPointer.getTouchesByEvent(event, pos));
                        event.stopPropagation();
                        event.preventDefault();
                    }, false);
                    element.addEventListener("touchcancel", function(event) {
                        if (!event.changedTouches) {
                            return;
                        }
                        var pos = selfPointer.getHTMLElementPosition(element);
                        pos.left -= document.body.scrollLeft;
                        pos.top -= document.body.scrollTop;
                        selfPointer.handleTouchesCancel(selfPointer.getTouchesByEvent(event, pos));
                        event.stopPropagation();
                        event.preventDefault();
                    }, false);
                }
                this._registerKeyboardEvent();
                this._registerAccelerometerEvent();
                this._isRegisterEvent = true;
            },
            _registerKeyboardEvent: function() {},
            _registerAccelerometerEvent: function() {},
            update: function(dt) {
                if (this._accelCurTime > this._accelInterval) {
                    this._accelCurTime -= this._accelInterval;
                    cc.eventManager.dispatchEvent(new cc.Event.EventAcceleration(this._acceleration));
                }
                this._accelCurTime += dt;
            }
        };
        cc.inputManager = inputManager;
        module.exports = inputManager;
    }, {
        "../value-types/CCEnum": 92
    } ],
    60: [ function(require, module, exports) {
        var _noCacheRex = /\?/;
        function urlAppendTimestamp(url) {
            if (cc.game.config["noCache"] && "string" === typeof url) {
                if (_noCacheRex.test(url)) {
                    url += "&_t=" + (new Date() - 0);
                } else {
                    url += "?_t=" + (new Date() - 0);
                }
            }
            return url;
        }
        cc.loader = cc.loader || function() {
            var _jsCache = {}, _register = {}, _langPathCache = {}, _aliases = {}, _urlRegExp = new RegExp("^(?:(?:https?|ftp)://)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))|(?:localhost))(?::\\d{2,5})?(?:/\\S*)?$", "i");
            return {
                resPath: "",
                audioPath: "",
                cache: {},
                getXMLHttpRequest: function() {
                    return window.XMLHttpRequest ? new window.XMLHttpRequest() : new ActiveXObject("MSXML2.XMLHTTP");
                },
                _getArgs4Js: function(args) {
                    var a0 = args[0], a1 = args[1], a2 = args[2], results = [ "", null, null ];
                    if (1 === args.length) {
                        results[1] = a0 instanceof Array ? a0 : [ a0 ];
                    } else {
                        if (2 === args.length) {
                            if ("function" === typeof a1) {
                                results[1] = a0 instanceof Array ? a0 : [ a0 ];
                                results[2] = a1;
                            } else {
                                results[0] = a0 || "";
                                results[1] = a1 instanceof Array ? a1 : [ a1 ];
                            }
                        } else {
                            if (3 === args.length) {
                                results[0] = a0 || "";
                                results[1] = a1 instanceof Array ? a1 : [ a1 ];
                                results[2] = a2;
                            } else {
                                throw new Error("arguments error to load js!");
                            }
                        }
                    }
                    return results;
                },
                loadJs: function(baseDir, jsList, cb) {
                    var self = this, args = self._getArgs4Js(arguments);
                    var preDir = args[0], list = args[1], callback = args[2];
                    if (navigator.userAgent.indexOf("Trident/5") > -1) {
                        self._loadJs4Dependency(preDir, list, 0, callback);
                    } else {
                        cc.async.map(list, function(item, index, cb1) {
                            var jsPath = cc.path.join(preDir, item);
                            if (_jsCache[jsPath]) {
                                return cb1(null);
                            }
                            self._createScript(jsPath, false, cb1);
                        }, callback);
                    }
                },
                loadJsWithImg: function(baseDir, jsList, cb) {
                    var self = this, jsLoadingImg = self._loadJsImg(), args = self._getArgs4Js(arguments);
                    this.loadJs(args[0], args[1], function(err) {
                        if (err) {
                            throw new Error(err);
                        }
                        jsLoadingImg.parentNode.removeChild(jsLoadingImg);
                        if (args[2]) {
                            args[2]();
                        }
                    });
                },
                _createScript: function(jsPath, isAsync, cb) {
                    var d = document, self = this, s = document.createElement("script");
                    s.async = isAsync;
                    _jsCache[jsPath] = true;
                    s.src = urlAppendTimestamp(jsPath);
                    s.addEventListener("load", function() {
                        s.parentNode.removeChild(s);
                        s.removeEventListener("load", arguments.callee, false);
                        cb();
                    }, false);
                    s.addEventListener("error", function() {
                        s.parentNode.removeChild(s);
                        cb("Load " + jsPath + " failed!");
                    }, false);
                    d.body.appendChild(s);
                },
                _loadJs4Dependency: function(baseDir, jsList, index, cb) {
                    if (index >= jsList.length) {
                        if (cb) {
                            cb();
                        }
                        return;
                    }
                    var self = this;
                    self._createScript(cc.path.join(baseDir, jsList[index]), false, function(err) {
                        if (err) {
                            return cb(err);
                        }
                        self._loadJs4Dependency(baseDir, jsList, index + 1, cb);
                    });
                },
                _loadJsImg: function() {
                    var d = document, jsLoadingImg = d.getElementById("cocos2d_loadJsImg");
                    if (!jsLoadingImg) {
                        jsLoadingImg = document.createElement("img");
                        if (cc._loadingImage) {
                            jsLoadingImg.src = cc._loadingImage;
                        }
                        var canvasNode = d.getElementById(cc.game.config["id"]);
                        canvasNode.style.backgroundColor = "transparent";
                        canvasNode.parentNode.appendChild(jsLoadingImg);
                        var canvasStyle = getComputedStyle ? getComputedStyle(canvasNode) : canvasNode.currentStyle;
                        if (!canvasStyle) {
                            canvasStyle = {
                                width: canvasNode.width,
                                height: canvasNode.height
                            };
                        }
                        jsLoadingImg.style.left = canvasNode.offsetLeft + (parseFloat(canvasStyle.width) - jsLoadingImg.width) / 2 + "px";
                        jsLoadingImg.style.top = canvasNode.offsetTop + (parseFloat(canvasStyle.height) - jsLoadingImg.height) / 2 + "px";
                        jsLoadingImg.style.position = "absolute";
                    }
                    return jsLoadingImg;
                },
                loadTxt: function(url, cb) {
                    var xhr = this.getXMLHttpRequest(), errInfo = "load " + url + " failed!";
                    url = urlAppendTimestamp(url);
                    xhr.open("GET", url, true);
                    if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
                        xhr.setRequestHeader("Accept-Charset", "utf-8");
                        xhr.onreadystatechange = function() {
                            if (4 === xhr.readyState) {
                                200 === xhr.status || 0 === xhr.status ? cb(null, xhr.responseText) : cb({
                                    status: xhr.status,
                                    errorMessage: errInfo
                                }, null);
                            }
                        };
                    } else {
                        if (xhr.overrideMimeType) {
                            xhr.overrideMimeType("text/plain; charset=utf-8");
                        }
                        xhr.onload = function() {
                            if (4 === xhr.readyState) {
                                200 === xhr.status || 0 === xhr.status ? cb(null, xhr.responseText) : cb({
                                    status: xhr.status,
                                    errorMessage: errInfo
                                }, null);
                            }
                        };
                        xhr.onerror = function() {
                            cb({
                                status: xhr.status,
                                errorMessage: errInfo
                            }, null);
                        };
                    }
                    xhr.send(null);
                },
                _loadTxtSync: function(url) {
                    var xhr = this.getXMLHttpRequest();
                    xhr.open("GET", url, false);
                    if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
                        xhr.setRequestHeader("Accept-Charset", "utf-8");
                    } else {
                        if (xhr.overrideMimeType) {
                            xhr.overrideMimeType("text/plain; charset=utf-8");
                        }
                    }
                    xhr.send(null);
                    if (4 === !xhr.readyState || !(200 === xhr.status || 0 === xhr.status)) {
                        return null;
                    }
                    return xhr.responseText;
                },
                loadCsb: function(url, cb) {
                    var xhr = new XMLHttpRequest(), errInfo = "load " + url + " failed!";
                    url = urlAppendTimestamp(url);
                    xhr.open("GET", url, true);
                    xhr.responseType = "arraybuffer";
                    xhr.onload = function() {
                        var arrayBuffer = xhr.response;
                        if (arrayBuffer) {
                            window.msg = arrayBuffer;
                        }
                        if (4 === xhr.readyState) {
                            200 === xhr.status ? cb(null, xhr.response) : cb({
                                status: xhr.status,
                                errorMessage: errInfo
                            }, null);
                        }
                    };
                    xhr.onerror = function() {
                        cb({
                            status: xhr.status,
                            errorMessage: errInfo
                        }, null);
                    };
                    xhr.send(null);
                },
                loadJson: function(url, cb) {
                    this.loadTxt(url, function(err, txt) {
                        if (err) {
                            cb(err);
                        } else {
                            try {
                                var result = JSON.parse(txt);
                            } catch (e) {
                                throw new Error("parse json [" + url + "] failed : " + e);
                            }
                            cb(null, result);
                        }
                    });
                },
                _checkIsImageURL: function(url) {
                    var ext = /(\.png)|(\.jpg)|(\.bmp)|(\.jpeg)|(\.gif)/.exec(url);
                    return null != ext;
                },
                loadImg: function(url, option, callback) {
                    var opt = {
                        isCrossOrigin: true
                    };
                    if (void 0 !== callback) {
                        opt.isCrossOrigin = null === option.isCrossOrigin ? opt.isCrossOrigin : option.isCrossOrigin;
                    } else {
                        if (void 0 !== option) {
                            callback = option;
                        }
                    }
                    url = urlAppendTimestamp(url);
                    var isNew = false;
                    var img = this.getRes(url);
                    if (!img) {
                        img = new Image();
                        isNew = true;
                        if (opt.isCrossOrigin && "file://" !== location.origin) {
                            img.crossOrigin = "Anonymous";
                        }
                    }
                    if (!isNew && img.complete && img.naturalWidth > 0) {
                        callback && callback(null, img);
                    } else {
                        function loadCallback() {
                            img.removeEventListener("load", loadCallback);
                            img.removeEventListener("error", errorCallback);
                            if (callback) {
                                callback(null, img);
                            }
                        }
                        var self = this;
                        function errorCallback() {
                            img.removeEventListener("load", loadCallback);
                            img.removeEventListener("error", errorCallback);
                            if (img.crossOrigin && "anonymous" === img.crossOrigin.toLowerCase()) {
                                opt.isCrossOrigin = false;
                                self.release(url);
                                cc.loader.loadImg(url, opt, callback);
                            } else {
                                "function" === typeof callback && callback("load image failed");
                            }
                        }
                        img.addEventListener("load", loadCallback);
                        img.addEventListener("error", errorCallback);
                    }
                    if (isNew) {
                        img.src = url;
                    }
                    return img;
                },
                _loadResIterator: function(item, index, cb) {
                    var self = this, url = null;
                    var type = item.type;
                    if (type) {
                        type = "." + type.toLowerCase();
                        url = item.src ? item.src : item.name + type;
                    } else {
                        url = item;
                        type = cc.path.extname(url);
                    }
                    var obj = self.getRes(url);
                    if (obj) {
                        return cb(null, obj);
                    }
                    var loader = null;
                    if (type) {
                        loader = _register[type.toLowerCase()];
                    }
                    if (!loader) {
                        cc.error("loader for [" + type + "] not exists!");
                        return cb();
                    }
                    var realUrl = url;
                    if (!_urlRegExp.test(url)) {
                        var basePath = loader.getBasePath ? loader.getBasePath() : self.resPath;
                        realUrl = self.getUrl(basePath, url);
                    }
                    loader.load(realUrl, url, item, function(err, data) {
                        if (err) {
                            cc.log(err);
                            self.cache[url] = null;
                            delete self.cache[url];
                            cb({
                                status: 520,
                                errorMessage: err
                            }, null);
                        } else {
                            self.cache[url] = data;
                            cb(null, data);
                        }
                    });
                },
                getUrl: function(basePath, url) {
                    var self = this, path = cc.path;
                    if (void 0 !== basePath && void 0 === url) {
                        url = basePath;
                        var type = path.extname(url);
                        type = type ? type.toLowerCase() : "";
                        var loader = _register[type];
                        if (!loader) {
                            basePath = self.resPath;
                        } else {
                            basePath = loader.getBasePath ? loader.getBasePath() : self.resPath;
                        }
                    }
                    url = cc.path.join(basePath || "", url);
                    if (url.match(/[\/(\\\\)]lang[\/(\\\\)]/i)) {
                        if (_langPathCache[url]) {
                            return _langPathCache[url];
                        }
                        var extname = path.extname(url) || "";
                        url = _langPathCache[url] = url.substring(0, url.length - extname.length) + "_" + cc.sys.language + extname;
                    }
                    return url;
                },
                load: function(resources, option, loadCallback) {
                    "use strict";
                    var self = this;
                    var len = arguments.length;
                    if (0 === len) {
                        throw new Error("arguments error!");
                    }
                    if (3 === len) {
                        if ("function" === typeof option) {
                            if ("function" === typeof loadCallback) {
                                option = {
                                    trigger: option,
                                    cb: loadCallback
                                };
                            } else {
                                option = {
                                    cb: option,
                                    cbTarget: loadCallback
                                };
                            }
                        }
                    } else {
                        if (2 === len) {
                            if ("function" === typeof option) {
                                option = {
                                    cb: option
                                };
                            }
                        } else {
                            if (1 === len) {
                                option = {};
                            }
                        }
                    }
                    if (!(resources instanceof Array)) {
                        resources = [ resources ];
                    }
                    var asyncPool = new cc.AsyncPool(resources, 0, function(value, index, AsyncPoolCallback, aPool) {
                        self._loadResIterator(value, index, function(err, res) {
                            if (option.trigger) {
                                option.trigger.call(option.triggerTarget, res, aPool.size, aPool.finishedSize);
                            }
                            AsyncPoolCallback(err, res);
                        });
                    }, option.cb, option.cbTarget);
                    asyncPool.flow();
                    return asyncPool;
                },
                _handleAliases: function(fileNames, cb) {
                    var self = this;
                    var resList = [];
                    for (var key in fileNames) {
                        var value = fileNames[key];
                        _aliases[key] = value;
                        resList.push(value);
                    }
                    this.load(resList, cb);
                },
                loadAliases: function(url, callback) {
                    var self = this, dict = self.getRes(url);
                    if (!dict) {
                        self.load(url, function(err, results) {
                            self._handleAliases(results[0]["filenames"], callback);
                        });
                    } else {
                        self._handleAliases(dict["filenames"], callback);
                    }
                },
                register: function(extNames, loader) {
                    if (!extNames || !loader) {
                        return;
                    }
                    var self = this;
                    if ("string" === typeof extNames) {
                        return _register[extNames.trim().toLowerCase()] = loader;
                    }
                    for (var i = 0, li = extNames.length; i < li; i++) {
                        _register["." + extNames[i].trim().toLowerCase()] = loader;
                    }
                },
                getRes: function(url) {
                    return this.cache[url] || this.cache[_aliases[url]];
                },
                getAliase: function(url) {
                    return _aliases[url];
                },
                release: function(url) {
                    var cache = this.cache;
                    delete cache[url];
                    delete cache[_aliases[url]];
                    delete _aliases[url];
                },
                releaseAll: function() {
                    var locCache = this.cache;
                    for (var key in locCache) {
                        delete locCache[key];
                    }
                    for (var key in _aliases) {
                        delete _aliases[key];
                    }
                }
            };
        }();
    }, {} ],
    61: [ function(require, module, exports) {
        cc.INVALID_INDEX = -1;
        cc.PI = Math.PI;
        cc.FLT_MAX = parseFloat("3.402823466e+38F");
        cc.FLT_MIN = parseFloat("1.175494351e-38F");
        cc.RAD = cc.PI / 180;
        cc.DEG = 180 / cc.PI;
        cc.UINT_MAX = 4294967295;
        cc.swap = function(x, y, ref) {
            if (cc.js.isObject(ref) && !cc.js.isUndefined(ref.x) && !cc.js.isUndefined(ref.y)) {
                var tmp = ref[x];
                ref[x] = ref[y];
                ref[y] = tmp;
            } else {
                cc.log(cc._LogInfos.swap);
            }
        };
        cc.lerp = function(a, b, r) {
            return a + (b - a) * r;
        };
        cc.rand = function() {
            return 16777215 * Math.random();
        };
        cc.randomMinus1To1 = function() {
            return 2 * (Math.random() - .5);
        };
        cc.random0To1 = Math.random;
        cc.degreesToRadians = function(angle) {
            return angle * cc.RAD;
        };
        cc.radiansToDegrees = function(angle) {
            return angle * cc.DEG;
        };
        cc.radiansToDegress = function(angle) {
            cc.log(cc._LogInfos.radiansToDegress);
            return angle * cc.DEG;
        };
        cc.REPEAT_FOREVER = cc.sys.isNative ? 4294967295 : Number.MAX_VALUE - 1;
        cc.nodeDrawSetup = function(node) {
            if (node._shaderProgram) {
                node._shaderProgram.use();
                node._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4();
            }
        };
        cc.enableDefaultGLStates = function() {};
        cc.disableDefaultGLStates = function() {};
        cc.incrementGLDraws = function(addNumber) {
            cc.g_NumberOfDraws += addNumber;
        };
        cc.FLT_EPSILON = 1.192092896e-7;
        cc.contentScaleFactor = cc.IS_RETINA_DISPLAY_SUPPORTED ? function() {
            return cc.director.getContentScaleFactor();
        } : function() {
            return 1;
        };
        cc.pointPointsToPixels = function(points) {
            var scale = cc.contentScaleFactor();
            return cc.p(points.x * scale, points.y * scale);
        };
        cc.pointPixelsToPoints = function(pixels) {
            var scale = cc.contentScaleFactor();
            return cc.p(pixels.x / scale, pixels.y / scale);
        };
        cc._pointPixelsToPointsOut = function(pixels, outPoint) {
            var scale = cc.contentScaleFactor();
            outPoint.x = pixels.x / scale;
            outPoint.y = pixels.y / scale;
        };
        cc.sizePointsToPixels = function(sizeInPoints) {
            var scale = cc.contentScaleFactor();
            return cc.size(sizeInPoints.width * scale, sizeInPoints.height * scale);
        };
        cc.sizePixelsToPoints = function(sizeInPixels) {
            var scale = cc.contentScaleFactor();
            return cc.size(sizeInPixels.width / scale, sizeInPixels.height / scale);
        };
        cc._sizePixelsToPointsOut = function(sizeInPixels, outSize) {
            var scale = cc.contentScaleFactor();
            outSize.width = sizeInPixels.width / scale;
            outSize.height = sizeInPixels.height / scale;
        };
        cc.rectPixelsToPoints = cc.IS_RETINA_DISPLAY_SUPPORTED ? function(pixel) {
            var scale = cc.contentScaleFactor();
            return cc.rect(pixel.x / scale, pixel.y / scale, pixel.width / scale, pixel.height / scale);
        } : function(p) {
            return cc.rect(p);
        };
        cc.rectPointsToPixels = cc.IS_RETINA_DISPLAY_SUPPORTED ? function(point) {
            var scale = cc.contentScaleFactor();
            return cc.rect(point.x * scale, point.y * scale, point.width * scale, point.height * scale);
        } : function(p) {
            return cc.rect(p);
        };
        cc.ONE = 1;
        cc.ZERO = 0;
        cc.SRC_ALPHA = 770;
        cc.SRC_ALPHA_SATURATE = 776;
        cc.SRC_COLOR = 768;
        cc.DST_ALPHA = 772;
        cc.DST_COLOR = 774;
        cc.ONE_MINUS_SRC_ALPHA = 771;
        cc.ONE_MINUS_SRC_COLOR = 769;
        cc.ONE_MINUS_DST_ALPHA = 773;
        cc.ONE_MINUS_DST_COLOR = 775;
        cc.ONE_MINUS_CONSTANT_ALPHA = 32772;
        cc.ONE_MINUS_CONSTANT_COLOR = 32770;
        cc.LINEAR = 9729;
        cc.defineGetterSetter(cc, "BLEND_SRC", function() {
            if (cc._renderType === cc.game.RENDER_TYPE_WEBGL && cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA) {
                return cc.ONE;
            } else {
                return cc.SRC_ALPHA;
            }
        });
        cc.BLEND_DST = 771;
        cc.checkGLErrorDebug = function() {
            if (cc.renderMode === cc.game.RENDER_TYPE_WEBGL) {
                var _error = cc._renderContext.getError();
                if (_error) {
                    cc.log(cc._LogInfos.checkGLErrorDebug, _error);
                }
            }
        };
        cc.DEVICE_ORIENTATION_PORTRAIT = 0;
        cc.DEVICE_ORIENTATION_LANDSCAPE_LEFT = 1;
        cc.DEVICE_ORIENTATION_PORTRAIT_UPSIDE_DOWN = 2;
        cc.DEVICE_ORIENTATION_LANDSCAPE_RIGHT = 3;
        cc.DEVICE_MAX_ORIENTATIONS = 2;
        cc.VERTEX_ATTRIB_FLAG_NONE = 0;
        cc.VERTEX_ATTRIB_FLAG_POSITION = 1;
        cc.VERTEX_ATTRIB_FLAG_COLOR = 2;
        cc.VERTEX_ATTRIB_FLAG_TEX_COORDS = 4;
        cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX = cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS;
        cc.GL_ALL = 0;
        cc.VERTEX_ATTRIB_POSITION = 0;
        cc.VERTEX_ATTRIB_COLOR = 1;
        cc.VERTEX_ATTRIB_TEX_COORDS = 2;
        cc.VERTEX_ATTRIB_MAX = 3;
        cc.UNIFORM_PMATRIX = 0;
        cc.UNIFORM_MVMATRIX = 1;
        cc.UNIFORM_MVPMATRIX = 2;
        cc.UNIFORM_TIME = 3;
        cc.UNIFORM_SINTIME = 4;
        cc.UNIFORM_COSTIME = 5;
        cc.UNIFORM_RANDOM01 = 6;
        cc.UNIFORM_SAMPLER = 7;
        cc.UNIFORM_MAX = 8;
        cc.SHADER_POSITION_TEXTURECOLOR = "ShaderPositionTextureColor";
        cc.SHADER_POSITION_TEXTURECOLORALPHATEST = "ShaderPositionTextureColorAlphaTest";
        cc.SHADER_POSITION_COLOR = "ShaderPositionColor";
        cc.SHADER_POSITION_TEXTURE = "ShaderPositionTexture";
        cc.SHADER_POSITION_TEXTURE_UCOLOR = "ShaderPositionTexture_uColor";
        cc.SHADER_POSITION_TEXTUREA8COLOR = "ShaderPositionTextureA8Color";
        cc.SHADER_POSITION_UCOLOR = "ShaderPosition_uColor";
        cc.SHADER_POSITION_LENGTHTEXTURECOLOR = "ShaderPositionLengthTextureColor";
        cc.UNIFORM_PMATRIX_S = "CC_PMatrix";
        cc.UNIFORM_MVMATRIX_S = "CC_MVMatrix";
        cc.UNIFORM_MVPMATRIX_S = "CC_MVPMatrix";
        cc.UNIFORM_TIME_S = "CC_Time";
        cc.UNIFORM_SINTIME_S = "CC_SinTime";
        cc.UNIFORM_COSTIME_S = "CC_CosTime";
        cc.UNIFORM_RANDOM01_S = "CC_Random01";
        cc.UNIFORM_SAMPLER_S = "CC_Texture0";
        cc.UNIFORM_ALPHA_TEST_VALUE_S = "CC_alpha_value";
        cc.ATTRIBUTE_NAME_COLOR = "a_color";
        cc.ATTRIBUTE_NAME_POSITION = "a_position";
        cc.ATTRIBUTE_NAME_TEX_COORD = "a_texCoord";
        cc.ITEM_SIZE = 32;
        cc.CURRENT_ITEM = 3233828865;
        cc.ZOOM_ACTION_TAG = 3233828866;
        cc.NORMAL_TAG = 8801;
        cc.SELECTED_TAG = 8802;
        cc.DISABLE_TAG = 8803;
    }, {} ],
    62: [ function(require, module, exports) {
        var JS = require("./js");
        var Destroyed = 1;
        var ToDestroy = 2;
        var DontSave = 4;
        var EditorOnly = 8;
        var Dirty = 16;
        var DontDestroy = 32;
        var Destroying = 64;
        var HideInGame = 512;
        var HideInEditor = 1024;
        var IsOnEnableCalled = 4096;
        var IsOnLoadCalled = 8192;
        var IsOnStartCalled = 16384;
        var Hide = HideInGame | HideInEditor;
        var PersistentMask = ~(ToDestroy | Dirty | Destroying | DontDestroy | IsOnEnableCalled | IsOnLoadCalled | IsOnStartCalled);
        function CCObject() {
            this._name = "";
            this._objFlags = 0;
        }
        CCObject.Flags = {
            DontSave: DontSave,
            EditorOnly: EditorOnly,
            Dirty: Dirty,
            DontDestroy: DontDestroy,
            PersistentMask: PersistentMask,
            Destroying: Destroying,
            HideInGame: HideInGame,
            HideInEditor: HideInEditor,
            Hide: Hide,
            IsOnLoadCalled: IsOnLoadCalled,
            IsOnEnableCalled: IsOnEnableCalled,
            IsOnStartCalled: IsOnStartCalled
        };
        require("./CCClass").fastDefine("cc.Object", CCObject, [ "_name", "_objFlags" ]);
        var objectsToDestroy = [];
        function deferredDestroy() {
            var deleteCount = objectsToDestroy.length;
            for (var i = 0; i < deleteCount; ++i) {
                var obj = objectsToDestroy[i];
                if (!(obj._objFlags & Destroyed)) {
                    obj._destroyImmediate();
                }
            }
            if (deleteCount === objectsToDestroy.length) {
                objectsToDestroy.length = 0;
            } else {
                objectsToDestroy.splice(0, deleteCount);
            }
            if (false) {
                deferredDestroyTimer = null;
            }
        }
        Object.defineProperty(CCObject, "_deferredDestroy", {
            value: deferredDestroy
        });
        if (false) {
            Object.defineProperty(CCObject, "_clearDeferredDestroyTimer", {
                value: function() {
                    if (null !== deferredDestroyTimer) {
                        clearImmediate(deferredDestroyTimer);
                        deferredDestroyTimer = null;
                    }
                },
                enumerable: false
            });
        }
        var prototype = CCObject.prototype;
        JS.getset(prototype, "name", function() {
            return this._name;
        }, function(value) {
            this._name = value;
        });
        JS.get(prototype, "isValid", function() {
            return !(this._objFlags & Destroyed);
        });
        var deferredDestroyTimer = null;
        prototype.destroy = function() {
            if (this._objFlags & Destroyed) {
                cc.warn("object already destroyed");
                return false;
            }
            if (this._objFlags & ToDestroy) {
                return false;
            }
            this._objFlags |= ToDestroy;
            objectsToDestroy.push(this);
            if (null === deferredDestroyTimer && cc.engine && !cc.engine._isUpdating && false) {
                deferredDestroyTimer = setImmediate(deferredDestroy);
            }
            return true;
        };
        if (false) {
            prototype.realDestroyInEditor = function() {
                if (this._objFlags & Destroyed) {
                    cc.warn("object already destroyed");
                    return false;
                }
                if (this._objFlags & ToDestroy) {
                    return false;
                }
                this._objFlags |= ToDestroy;
                objectsToDestroy.push(this);
                if (null === deferredDestroyTimer && cc.engine && !cc.engine._isUpdating && false) {
                    deferredDestroyTimer = setImmediate(deferredDestroy);
                }
                return true;
            };
        }
        prototype._destruct = function() {
            if (false) {
                return cc.error("object not yet destroyed");
            }
            for (var key in this) {
                if (this.hasOwnProperty(key)) {
                    switch (typeof this[key]) {
                      case "string":
                        this[key] = "";
                        break;

                      case "object":
                      case "function":
                        this[key] = null;
                    }
                }
            }
        };
        prototype._onPreDestroy = null;
        prototype._destroyImmediate = function() {
            if (this._objFlags & Destroyed) {
                cc.error("object already destroyed");
                return;
            }
            if (this._onPreDestroy) {
                this._onPreDestroy();
            }
            if (true) {
                this._destruct();
            }
            this._objFlags |= Destroyed;
        };
        if (false) {
            prototype._serialize = null;
        }
        prototype._deserialize = null;
        cc.isValid = function(value) {
            if ("object" === typeof value) {
                return !!value && !(value._objFlags & Destroyed);
            } else {
                return "undefined" !== typeof value;
            }
        };
        if (false) {
            Object.defineProperty(CCObject, "_willDestroy", {
                value: function(obj) {
                    return !(obj._objFlags & Destroyed) && (obj._objFlags & ToDestroy) > 0;
                }
            });
            Object.defineProperty(CCObject, "_cancelDestroy", {
                value: function(obj) {
                    obj._objFlags &= ~ToDestroy;
                    var index = objectsToDestroy.indexOf(obj);
                    if (-1 !== index) {
                        objectsToDestroy.splice(index, 1);
                    }
                }
            });
        }
        cc.Object = CCObject;
        module.exports = CCObject;
    }, {
        "./CCClass": 57,
        "./js": 70
    } ],
    63: [ function(require, module, exports) {
        if (cc.sys) {
            return;
        }
        cc.sys = {};
        var sys = cc.sys;
        sys.LANGUAGE_ENGLISH = "en";
        sys.LANGUAGE_CHINESE = "zh";
        sys.LANGUAGE_FRENCH = "fr";
        sys.LANGUAGE_ITALIAN = "it";
        sys.LANGUAGE_GERMAN = "de";
        sys.LANGUAGE_SPANISH = "es";
        sys.LANGUAGE_DUTCH = "du";
        sys.LANGUAGE_RUSSIAN = "ru";
        sys.LANGUAGE_KOREAN = "ko";
        sys.LANGUAGE_JAPANESE = "ja";
        sys.LANGUAGE_HUNGARIAN = "hu";
        sys.LANGUAGE_PORTUGUESE = "pt";
        sys.LANGUAGE_ARABIC = "ar";
        sys.LANGUAGE_NORWEGIAN = "no";
        sys.LANGUAGE_POLISH = "pl";
        sys.LANGUAGE_UNKNOWN = "unkonwn";
        sys.OS_IOS = "iOS";
        sys.OS_ANDROID = "Android";
        sys.OS_WINDOWS = "Windows";
        sys.OS_MARMALADE = "Marmalade";
        sys.OS_LINUX = "Linux";
        sys.OS_BADA = "Bada";
        sys.OS_BLACKBERRY = "Blackberry";
        sys.OS_OSX = "OS X";
        sys.OS_WP8 = "WP8";
        sys.OS_WINRT = "WINRT";
        sys.OS_UNKNOWN = "Unknown";
        sys.UNKNOWN = -1;
        sys.WIN32 = 0;
        sys.LINUX = 1;
        sys.MACOS = 2;
        sys.ANDROID = 3;
        sys.IPHONE = 4;
        sys.IPAD = 5;
        sys.BLACKBERRY = 6;
        sys.NACL = 7;
        sys.EMSCRIPTEN = 8;
        sys.TIZEN = 9;
        sys.WINRT = 10;
        sys.WP8 = 11;
        sys.MOBILE_BROWSER = 100;
        sys.DESKTOP_BROWSER = 101;
        sys.EDITOR_PAGE = 102;
        sys.EDITOR_CORE = 103;
        sys.BROWSER_TYPE_WECHAT = "wechat";
        sys.BROWSER_TYPE_ANDROID = "androidbrowser";
        sys.BROWSER_TYPE_IE = "ie";
        sys.BROWSER_TYPE_QQ = "qqbrowser";
        sys.BROWSER_TYPE_MOBILE_QQ = "mqqbrowser";
        sys.BROWSER_TYPE_UC = "ucbrowser";
        sys.BROWSER_TYPE_360 = "360browser";
        sys.BROWSER_TYPE_BAIDU_APP = "baiduboxapp";
        sys.BROWSER_TYPE_BAIDU = "baidubrowser";
        sys.BROWSER_TYPE_MAXTHON = "maxthon";
        sys.BROWSER_TYPE_OPERA = "opera";
        sys.BROWSER_TYPE_OUPENG = "oupeng";
        sys.BROWSER_TYPE_MIUI = "miuibrowser";
        sys.BROWSER_TYPE_FIREFOX = "firefox";
        sys.BROWSER_TYPE_SAFARI = "safari";
        sys.BROWSER_TYPE_CHROME = "chrome";
        sys.BROWSER_TYPE_LIEBAO = "liebao";
        sys.BROWSER_TYPE_QZONE = "qzone";
        sys.BROWSER_TYPE_SOUGOU = "sogou";
        sys.BROWSER_TYPE_UNKNOWN = "unknown";
        sys.isNative = false;
        sys.isBrowser = "object" === typeof window && "object" === typeof document;
        if ("undefined" !== typeof Editor && Editor.isCoreLevel) {
            sys.isMobile = false;
            sys.platform = sys.EDITOR_CORE;
            sys.language = sys.LANGUAGE_UNKNOWN;
            sys.os = {
                darwin: sys.OS_OSX,
                win32: sys.OS_WINDOWS,
                linux: sys.OS_LINUX
            }[process.platform] || sys.OS_UNKNOWN;
            sys.browserType = null;
            sys.browserVersion = null;
            sys.windowPixelResolution = {
                width: 0,
                height: 0
            };
        } else {
            var win = window, nav = win.navigator, doc = document, docEle = doc.documentElement;
            var ua = nav.userAgent.toLowerCase();
            if (cc.isEditor) {
                sys.isMobile = false;
                sys.platform = sys.EDITOR_PAGE;
            } else {
                sys.isMobile = -1 !== ua.indexOf("mobile") || -1 !== ua.indexOf("android");
                sys.platform = sys.isMobile ? sys.MOBILE_BROWSER : sys.DESKTOP_BROWSER;
            }
            var currLanguage = nav.language;
            currLanguage = currLanguage ? currLanguage : nav.browserLanguage;
            currLanguage = currLanguage ? currLanguage.split("-")[0] : sys.LANGUAGE_ENGLISH;
            sys.language = currLanguage;
            var iOS = ua.match(/(iPad|iPhone|iPod)/i) ? true : false;
            var isAndroid = ua.match(/android/i) || nav.platform.match(/android/i) ? true : false;
            var osName = sys.OS_UNKNOWN;
            if (-1 !== nav.appVersion.indexOf("Win")) {
                osName = sys.OS_WINDOWS;
            } else {
                if (iOS) {
                    osName = sys.OS_IOS;
                } else {
                    if (-1 !== nav.appVersion.indexOf("Mac")) {
                        osName = sys.OS_OSX;
                    } else {
                        if (-1 !== nav.appVersion.indexOf("X11") && -1 === nav.appVersion.indexOf("Linux")) {
                            osName = sys.OS_UNIX;
                        } else {
                            if (isAndroid) {
                                osName = sys.OS_ANDROID;
                            } else {
                                if (-1 !== nav.appVersion.indexOf("Linux")) {
                                    osName = sys.OS_LINUX;
                                }
                            }
                        }
                    }
                }
            }
            sys.os = osName;
            sys.browserType = sys.BROWSER_TYPE_UNKNOWN;
            !function() {
                var typeReg1 = /mqqbrowser|sogou|qzone|liebao|micromessenger|ucbrowser|360 aphone|360browser|baiduboxapp|baidubrowser|maxthon|mxbrowser|trident|miuibrowser/i;
                var typeReg2 = /qqbrowser|chrome|safari|firefox|opr|oupeng|opera/i;
                var browserTypes = typeReg1.exec(ua);
                if (!browserTypes) {
                    browserTypes = typeReg2.exec(ua);
                }
                var browserType = browserTypes ? browserTypes[0] : sys.BROWSER_TYPE_UNKNOWN;
                if ("micromessenger" === browserType) {
                    browserType = sys.BROWSER_TYPE_WECHAT;
                } else {
                    if ("safari" === browserType && ua.match(/android.*applewebkit/)) {
                        browserType = sys.BROWSER_TYPE_ANDROID;
                    } else {
                        if ("trident" === browserType) {
                            browserType = sys.BROWSER_TYPE_IE;
                        } else {
                            if ("360 aphone" === browserType) {
                                browserType = sys.BROWSER_TYPE_360;
                            } else {
                                if ("mxbrowser" === browserType) {
                                    browserType = sys.BROWSER_TYPE_MAXTHON;
                                } else {
                                    if ("opr" === browserType) {
                                        browserType = sys.BROWSER_TYPE_OPERA;
                                    }
                                }
                            }
                        }
                    }
                }
                sys.browserType = browserType;
            }();
            sys.browserVersion = "";
            !function() {
                var versionReg1 = /(micromessenger|qq|mx|maxthon|baidu|sogou)(mobile)?(browser)?\/?([\d.]+)/i;
                var versionReg2 = /(msie |rv:|firefox|chrome|ucbrowser|oupeng|opera|opr|safari|miui)(mobile)?(browser)?\/?([\d.]+)/i;
                var tmp = ua.match(versionReg1);
                if (!tmp) {
                    tmp = ua.match(versionReg2);
                }
                sys.browserVersion = tmp ? tmp[4] : "";
            }();
            var w = window.innerWidth || document.documentElement.clientWidth;
            var h = window.innerHeight || document.documentElement.clientHeight;
            var ratio = window.devicePixelRatio || 1;
            sys.windowPixelResolution = {
                width: ratio * w,
                height: ratio * h
            };
            sys._checkWebGLRenderMode = function() {
                if (cc._renderType !== cc.game.RENDER_TYPE_WEBGL) {
                    throw new Error("This feature supports WebGL render mode only.");
                }
            };
            var _tmpCanvas1 = document.createElement("canvas"), _tmpCanvas2 = document.createElement("canvas");
            cc.create3DContext = function(canvas, opt_attribs) {
                var names = [ "webgl", "experimental-webgl", "webkit-3d", "moz-webgl" ];
                var context = null;
                for (var ii = 0; ii < names.length; ++ii) {
                    try {
                        context = canvas.getContext(names[ii], opt_attribs);
                    } catch (e) {}
                    if (context) {
                        break;
                    }
                }
                return context;
            };
            sys._supportCanvasNewBlendModes = function() {
                var canvas = _tmpCanvas1;
                canvas.width = 1;
                canvas.height = 1;
                var context = canvas.getContext("2d");
                context.fillStyle = "#000";
                context.fillRect(0, 0, 1, 1);
                context.globalCompositeOperation = "multiply";
                var canvas2 = _tmpCanvas2;
                canvas2.width = 1;
                canvas2.height = 1;
                var context2 = canvas2.getContext("2d");
                context2.fillStyle = "#fff";
                context2.fillRect(0, 0, 1, 1);
                context.drawImage(canvas2, 0, 0, 1, 1);
                return 0 === context.getImageData(0, 0, 1, 1).data[0];
            }();
            if (cc.sys.isMobile) {
                var fontStyle = document.createElement("style");
                fontStyle.type = "text/css";
                document.body.appendChild(fontStyle);
                fontStyle.textContent = "body,canvas,div{ -moz-user-select: none;-webkit-user-select: none;-ms-user-select: none;-khtml-user-select: none;-webkit-tap-highlight-color:rgba(0,0,0,0);}";
            }
            try {
                var localStorage = sys.localStorage = win.localStorage;
                localStorage.setItem("storage", "");
                localStorage.removeItem("storage");
                localStorage = null;
            } catch (e) {
                var warn = function() {
                    cc.warn("Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option");
                };
                sys.localStorage = {
                    getItem: warn,
                    setItem: warn,
                    removeItem: warn,
                    clear: warn
                };
            }
            var _supportCanvas = !!_tmpCanvas1.getContext("2d");
            var _supportWebGL = false;
            var tmpCanvas = document.createElement("CANVAS");
            if (win.WebGLRenderingContext) {
                try {
                    var context = cc.create3DContext(tmpCanvas, {
                        stencil: true,
                        preserveDrawingBuffer: true
                    });
                    if (context) {
                        _supportWebGL = true;
                    }
                    if (sys.os === sys.OS_ANDROID) {
                        _supportWebGL = false;
                        var browserVer = parseFloat(sys.browserVersion);
                        if (sys.browserType === sys.BROWSER_TYPE_MOBILE_QQ && browserVer >= 6.2) {
                            _supportWebGL = true;
                        } else {
                            if (sys.osMainVersion && sys.osMainVersion >= 5 && sys.browserType === sys.BROWSER_TYPE_ANDROID) {
                                _supportWebGL = true;
                            }
                        }
                    }
                } catch (e) {}
            }
            var capabilities = sys.capabilities = {
                canvas: _supportCanvas,
                opengl: _supportWebGL
            };
            if (void 0 !== docEle["ontouchstart"] || void 0 !== doc["ontouchstart"] || nav.msPointerEnabled) {
                capabilities["touches"] = true;
            }
            if (void 0 !== docEle["onmouseup"]) {
                capabilities["mouse"] = true;
            }
            if (void 0 !== docEle["onkeyup"]) {
                capabilities["keyboard"] = true;
            }
            if (win.DeviceMotionEvent || win.DeviceOrientationEvent) {
                capabilities["accelerometer"] = true;
            }
            delete _tmpCanvas1;
            delete _tmpCanvas2;
        }
        sys.garbageCollect = function() {};
        sys.dumpRoot = function() {};
        sys.restartVM = function() {};
        sys.cleanScript = function(jsfile) {};
        sys.isObjectValid = function(obj) {
            if (obj) {
                return true;
            } else {
                return false;
            }
        };
        sys.dump = function() {
            var self = this;
            var str = "";
            str += "isMobile : " + self.isMobile + "\r\n";
            str += "language : " + self.language + "\r\n";
            str += "browserType : " + self.browserType + "\r\n";
            str += "browserVersion : " + self.browserVersion + "\r\n";
            str += "capabilities : " + JSON.stringify(self.capabilities) + "\r\n";
            str += "os : " + self.os + "\r\n";
            str += "osVersion : " + self.osVersion + "\r\n";
            str += "platform : " + self.platform + "\r\n";
            str += "Using " + (cc._renderType === cc.game.RENDER_TYPE_WEBGL ? "WEBGL" : "CANVAS") + " renderer.\r\n";
            cc.log(str);
        };
        sys.openURL = function(url) {
            window.open(url);
        };
        module.exports = sys;
    }, {} ],
    64: [ function(require, module, exports) {
        var ClassManager = cc.ClassManager = {
            id: 0 | 998 * Math.random(),
            instanceId: 0 | 998 * Math.random(),
            getNewID: function() {
                return this.id++;
            },
            getNewInstanceId: function() {
                return this.instanceId++;
            }
        };
        var fnTest = /\b_super\b/;
        var Class = function() {};
        Class.extend = function(props) {
            var _super = this.prototype;
            var prototype = Object.create(_super);
            var classId = ClassManager.getNewID();
            ClassManager[classId] = _super;
            var desc = {
                writable: true,
                enumerable: false,
                configurable: true
            };
            prototype.__instanceId = null;
            function _Class() {
                this.__instanceId = ClassManager.getNewInstanceId();
                if (this.ctor) {
                    this.ctor.apply(this, arguments);
                }
            }
            _Class.id = classId;
            desc.value = classId;
            Object.defineProperty(prototype, "__cid__", desc);
            _Class.prototype = prototype;
            desc.value = _Class;
            Object.defineProperty(_Class.prototype, "constructor", desc);
            for (var idx = 0, li = arguments.length; idx < li; ++idx) {
                var prop = arguments[idx];
                for (var name in prop) {
                    var isFunc = "function" === typeof prop[name];
                    var override = "function" === typeof _super[name];
                    var hasSuperCall = fnTest.test(prop[name]);
                    if (isFunc && override && hasSuperCall) {
                        desc.value = function(name, fn) {
                            return function() {
                                var tmp = this._super;
                                this._super = _super[name];
                                var ret = fn.apply(this, arguments);
                                this._super = tmp;
                                return ret;
                            };
                        }(name, prop[name]);
                        Object.defineProperty(prototype, name, desc);
                    } else {
                        if (isFunc) {
                            desc.value = prop[name];
                            Object.defineProperty(prototype, name, desc);
                        } else {
                            prototype[name] = prop[name];
                        }
                    }
                }
            }
            _Class.extend = Class.extend;
            _Class.implement = function(prop) {
                for (var name in prop) {
                    prototype[name] = prop[name];
                }
            };
            return _Class;
        };
        cc.defineGetterSetter = function(proto, prop, getter, setter, getterName, setterName) {
            if (proto.__defineGetter__) {
                getter && proto.__defineGetter__(prop, getter);
                setter && proto.__defineSetter__(prop, setter);
            } else {
                if (Object.defineProperty) {
                    var desc = {
                        enumerable: false,
                        configurable: true
                    };
                    getter && (desc.get = getter);
                    setter && (desc.set = setter);
                    Object.defineProperty(proto, prop, desc);
                } else {
                    throw new Error("browser does not support getters");
                }
            }
        };
        cc.clone = function(obj) {
            var newObj = obj.constructor ? new obj.constructor() : {};
            for (var key in obj) {
                var copy = obj[key];
                if ("object" === typeof copy && copy && !(copy instanceof _ccsg.Node) && !(copy instanceof HTMLElement)) {
                    newObj[key] = cc.clone(copy);
                } else {
                    newObj[key] = copy;
                }
            }
            return newObj;
        };
        cc._Class = module.exports = Class;
    }, {} ],
    65: [ function(require, module, exports) {
        var JS = require("./js");
        var isPlainEmptyObj = require("./utils").isPlainEmptyObj_DEV;
        function attr(constructor, propertyName, attributes) {
            var key = "_attr$" + propertyName;
            var instance, attrs, name;
            if ("function" === typeof constructor) {
                instance = constructor.prototype;
                attrs = instance[key];
                if ("undefined" !== typeof attributes) {
                    if ("object" === typeof attributes) {
                        if (!attrs) {
                            instance[key] = attrs = {};
                        }
                        for (name in attributes) {
                            if ("_" !== name[0]) {
                                attrs[name] = attributes[name];
                            }
                        }
                    } else {
                        instance[key] = attributes;
                        return attributes;
                    }
                }
                return attrs;
            } else {
                instance = constructor;
                if ("undefined" !== typeof attributes) {
                    if ("object" === typeof attributes) {
                        if (instance.hasOwnProperty(key)) {
                            attrs = instance[key];
                        }
                        if (!attrs) {
                            instance[key] = attrs = {};
                        }
                        for (name in attributes) {
                            if ("_" !== name[0]) {
                                attrs[name] = attributes[name];
                            }
                        }
                        return JS.addon({}, attrs, instance.constructor.prototype[key]);
                    } else {
                        instance[key] = attributes;
                        return attributes;
                    }
                } else {
                    attrs = instance[key];
                    if ("object" === typeof attrs) {
                        return JS.addon({}, attrs, instance.constructor.prototype[key]);
                    } else {
                        return attrs;
                    }
                }
            }
        }
        cc.Integer = "Integer";
        cc.Float = "Float";
        cc.Boolean = "Boolean";
        cc.String = "String";
        var NonSerialized = {
            serializable: false,
            _canUsedInGetter: false
        };
        var EditorOnly = {
            editorOnly: true,
            _canUsedInGetter: false
        };
        function getTypeChecker(type, attrName, objectTypeCtor) {
            if (false) {
                return function(constructor, mainPropName) {
                    var mainPropAttrs = cc.Class.attr(constructor, mainPropName) || {};
                    if (mainPropAttrs.type !== type) {
                        cc.warn("Can only indicate one type attribute for %s.%s.", JS.getClassName(constructor), mainPropName);
                        return;
                    }
                    if (!mainPropAttrs.hasOwnProperty("default")) {
                        return;
                    }
                    var defaultVal = mainPropAttrs["default"];
                    if ("undefined" === typeof defaultVal) {
                        return;
                    }
                    var isContainer = Array.isArray(defaultVal) || isPlainEmptyObj(defaultVal);
                    if (isContainer) {
                        return;
                    }
                    var defaultType = typeof defaultVal;
                    var type_lowerCase = type.toLowerCase();
                    if (defaultType === type_lowerCase) {
                        if ("object" === type_lowerCase) {
                            if (defaultVal && !(defaultVal instanceof objectTypeCtor)) {
                                cc.warn("The default value of %s.%s is not instance of %s.", JS.getClassName(constructor), mainPropName, JS.getClassName(objectTypeCtor));
                            } else {
                                return;
                            }
                        } else {
                            cc.warn('No needs to indicate the "%s" attribute for %s.%s, which its default value is type of %s.', attrName, JS.getClassName(constructor), mainPropName, type);
                        }
                    } else {
                        if ("function" !== defaultType) {
                            cc.warn('Can not indicate the "%s" attribute for %s.%s, which its default value is type of %s.', attrName, JS.getClassName(constructor), mainPropName, defaultType);
                        }
                    }
                    delete mainPropAttrs.type;
                };
            }
        }
        function ObjectType(typeCtor) {
            return {
                type: "Object",
                ctor: typeCtor
            };
        }
        function RawType(typename) {
            var NEED_EXT_TYPES = [ "image", "json", "text", "audio" ];
            return {
                rawType: typename,
                serializable: false,
                _canUsedInGetter: false,
                _onAfterProp: function(constructor, mainPropName) {
                    var checked = true;
                }
            };
        }
        function Nullable(boolPropName, hasValueByDefault) {
            return {
                nullable: boolPropName,
                _onAfterProp: function(constructor, mainPropName) {
                    constructor.prop(boolPropName, hasValueByDefault, {
                        visible: false
                    });
                    var mainPropAttr = cc.Class.attr(constructor, mainPropName) || {};
                    if (false === mainPropAttr.serializable) {
                        cc.Class.attr(constructor, boolPropName, NonSerialized);
                    } else {
                        if (mainPropAttr.editorOnly) {
                            cc.Class.attr(constructor, boolPropName, EditorOnly);
                        }
                    }
                }
            };
        }
        function Range(min, max) {
            return {
                min: min,
                max: max
            };
        }
        module.exports = {
            attr: attr,
            getTypeChecker: getTypeChecker,
            NonSerialized: NonSerialized,
            EditorOnly: EditorOnly,
            ObjectType: ObjectType,
            RawType: RawType,
            ScriptUuid: {},
            Nullable: Nullable,
            Range: Range
        };
    }, {
        "./js": 70,
        "./utils": 76
    } ],
    66: [ function(require, module, exports) {
        var JS = require("./js");
        var CallbacksHandler = function() {
            this._callbackTable = {};
        };
        CallbacksHandler.prototype.add = function(key, callback, target) {
            var list = this._callbackTable[key];
            if ("undefined" !== typeof list) {
                if ("function" === typeof callback) {
                    if (null !== list) {
                        list.push(callback);
                    } else {
                        list = [ callback ];
                        this._callbackTable[key] = list;
                    }
                    if ("object" === typeof target) {
                        list.push(target);
                    }
                }
                return false;
            } else {
                list = "function" === typeof callback ? [ callback ] : null;
                if (list && "object" === typeof target) {
                    list.push(target);
                }
                this._callbackTable[key] = list;
                return true;
            }
        };
        CallbacksHandler.prototype.has = function(key, callback, target) {
            var list = this._callbackTable[key], callbackTarget, index;
            if (list && list.length > 0) {
                if (!callback) {
                    return true;
                } else {
                    if ("function" !== typeof callback) {
                        return false;
                    }
                }
                index = list.indexOf(callback);
                while (-1 !== index) {
                    callbackTarget = list[index + 1];
                    if ("object" !== typeof callbackTarget) {
                        callbackTarget = void 0;
                    }
                    if (callbackTarget === target) {
                        return true;
                    }
                    index = cc.js.array.indexOf.call(list, callback, index + 1);
                }
                return false;
            }
            return false;
        };
        CallbacksHandler.prototype.removeAll = function(key) {
            if ("object" === typeof key) {
                var target = key, list, index, callback;
                for (key in this._callbackTable) {
                    list = this._callbackTable[key];
                    index = list.lastIndexOf(target);
                    while (-1 !== index) {
                        callback = list[index - 1];
                        if ("function" === typeof callback) {
                            list.splice(index - 1, 2);
                        } else {
                            list.splice(index, 1);
                        }
                        index = list.lastIndexOf(target);
                    }
                }
            } else {
                delete this._callbackTable[key];
            }
        };
        CallbacksHandler.prototype.remove = function(key, callback, target) {
            var list = this._callbackTable[key], index, callbackTarget;
            if (list) {
                index = list.indexOf(callback);
                while (-1 !== index) {
                    callbackTarget = list[index + 1];
                    if ("object" !== typeof callbackTarget) {
                        callbackTarget = void 0;
                    }
                    if (callbackTarget === target) {
                        list.splice(index, callbackTarget ? 2 : 1);
                        break;
                    }
                    index = cc.js.array.indexOf.call(list, callback, index + 1);
                }
                return true;
            }
            return false;
        };
        var CallbacksInvoker = function() {
            CallbacksHandler.call(this);
        };
        JS.extend(CallbacksInvoker, CallbacksHandler);
        if (false) {
            cc._Test.CallbacksInvoker = CallbacksInvoker;
        }
        CallbacksInvoker.prototype.invoke = function(key, p1, p2, p3, p4, p5) {
            var list = this._callbackTable[key];
            if (list) {
                var endIndex = list.length - 1;
                var lastItem = list[endIndex];
                for (var i = 0; i <= endIndex; ) {
                    var callingFunc = list[i];
                    var target = list[i + 1];
                    var hasTarget = target && "object" === typeof target;
                    var increment;
                    if (hasTarget) {
                        list[i].call(target, p1, p2, p3, p4, p5);
                        increment = 2;
                    } else {
                        callingFunc(p1, p2, p3, p4, p5);
                        increment = 1;
                    }
                    if (list[endIndex] !== lastItem && i + increment <= endIndex) {
                        if (list[endIndex - 1] === lastItem) {
                            endIndex -= 1;
                        } else {
                            if (list[endIndex - 2] === lastItem) {
                                endIndex -= 2;
                            } else {
                                return cc.error("Can remove only a callback at a time.");
                            }
                        }
                        if (list[i] !== callingFunc) {
                            continue;
                        }
                    }
                    i += increment;
                }
            }
        };
        CallbacksInvoker.prototype.invokeAndRemove = function(key, p1, p2, p3, p4, p5) {
            var list = this._callbackTable[key], i, l, target;
            if (list) {
                for (i = 0, l = list.length; i < l; ) {
                    target = list[i + 1];
                    if (target && "object" === typeof target) {
                        list[i].call(target, p1, p2, p3, p4, p5);
                        i += 2;
                    } else {
                        list[i](p1, p2, p3, p4, p5);
                        ++i;
                    }
                }
            }
            this.removeAll(key);
        };
        CallbacksInvoker.prototype.bindKey = function(key, remove) {
            var self = this;
            return function bindedInvocation(p1, p2, p3, p4, p5) {
                var list = self._callbackTable[key], i, l, target;
                if (list) {
                    for (i = 0, l = list.length; i < l; ) {
                        target = list[i + 1];
                        if (target && "object" === typeof target) {
                            list[i].call(target, p1, p2, p3, p4, p5);
                            i += 2;
                        } else {
                            list[i](p1, p2, p3, p4, p5);
                            ++i;
                        }
                    }
                }
                if (remove) {
                    self.removeAll(key);
                }
            };
        };
        CallbacksInvoker.CallbacksHandler = CallbacksHandler;
        module.exports = CallbacksInvoker;
    }, {
        "./js": 70
    } ],
    67: [ function(require, module, exports) {
        var JS = require("./js");
        var CCObject = require("./CCObject");
        var EDITOR = false;
        var ENABLE_TARGET = EDITOR;
        var Details = function() {
            this.uuidList = [];
            this.uuidObjList = [];
            this.uuidPropList = [];
            this.rawProp = "";
            if (EDITOR) {
                this.visitorInEditor = null;
                this.visitObjList = [];
                this.visitPropList = [];
            }
        };
        Details.prototype.reset = function() {
            this.uuidList.length = 0;
            this.uuidObjList.length = 0;
            this.uuidPropList.length = 0;
            this.rawProp = "";
            if (EDITOR) {
                this.visitorInEditor = null;
                this.visitObjList.length = 0;
                this.visitPropList.length = 0;
            }
        };
        if (EDITOR) {
            Details.prototype.visitLater = function(obj, propName) {
                this.visitObjList.push(obj);
                this.visitPropList.push(propName);
            };
        }
        Details.prototype.getUuidOf = function(obj, propName) {
            for (var i = 0; i < this.uuidObjList.length; i++) {
                if (this.uuidObjList[i] === obj && this.uuidPropList[i] === propName) {
                    return this.uuidList[i];
                }
            }
            return "";
        };
        Details.prototype.assignAssetsBy = function(getter) {
            var success = true;
            for (var i = 0, len = this.uuidList.length; i < len; i++) {
                var uuid = this.uuidList[i];
                var asset = getter(uuid);
                if (asset) {
                    var obj = this.uuidObjList[i];
                    var prop = this.uuidPropList[i];
                    obj[prop] = asset;
                } else {
                    cc.error("Failed to assign asset: " + uuid);
                    success = false;
                }
            }
            return success;
        };
        Details.prototype.push = function(obj, propName, uuid) {
            this.uuidList.push(uuid);
            this.uuidObjList.push(obj);
            this.uuidPropList.push(propName);
        };
        var _Deserializer = function() {
            function _Deserializer(jsonObj, result, target, classFinder) {
                this._classFinder = classFinder;
                if (ENABLE_TARGET) {
                    this._target = target;
                }
                this._idList = [];
                this._idObjList = [];
                this._idPropList = [];
                this.result = result || new Details();
                if (Array.isArray(jsonObj)) {
                    var jsonArray = jsonObj;
                    var refCount = jsonArray.length;
                    this.deserializedList = new Array(refCount);
                    for (var i = 0; i < refCount; i++) {
                        if (jsonArray[i]) {
                            var mainTarget;
                            if (ENABLE_TARGET) {
                                mainTarget = 0 === i && target;
                            }
                            this.deserializedList[i] = _deserializeObject(this, jsonArray[i], mainTarget);
                        }
                    }
                    this.deserializedData = refCount > 0 ? this.deserializedList[0] : [];
                } else {
                    this.deserializedList = [ null ];
                    this.deserializedData = jsonObj ? _deserializeObject(this, jsonObj, target) : null;
                    this.deserializedList[0] = this.deserializedData;
                }
                _dereference(this);
                if (EDITOR) {
                    this._callVisitorInEditor();
                }
            }
            var _dereference = function(self) {
                var deserializedList = self.deserializedList;
                for (var i = 0, len = self._idList.length; i < len; i++) {
                    var propName = self._idPropList[i];
                    var id = self._idList[i];
                    self._idObjList[i][propName] = deserializedList[id];
                }
            };
            if (EDITOR) {
                _Deserializer.prototype._callVisitorInEditor = function() {
                    var result = this.result;
                    if (result.visitorInEditor) {
                        result.visitorInEditor(result.visitObjList, result.visitPropList, this);
                    }
                };
            }
            _Deserializer.prototype._deserializeObjField = function(obj, jsonObj, propName, target) {
                var id = jsonObj.__id__;
                if ("undefined" === typeof id) {
                    var uuid = jsonObj.__uuid__;
                    if (uuid) {
                        this.result.uuidList.push(uuid);
                        this.result.uuidObjList.push(obj);
                        this.result.uuidPropList.push(propName);
                    } else {
                        if (ENABLE_TARGET) {
                            obj[propName] = _deserializeObject(this, jsonObj, target && target[propName]);
                        } else {
                            obj[propName] = _deserializeObject(this, jsonObj);
                        }
                        if (this.result.visitorInEditor && EDITOR) {
                            this.result.visitLater(obj, propName);
                        }
                    }
                } else {
                    var dObj = this.deserializedList[id];
                    if (dObj) {
                        obj[propName] = dObj;
                    } else {
                        this._idList.push(id);
                        this._idObjList.push(obj);
                        this._idPropList.push(propName);
                    }
                    if (this.result.visitorInEditor && EDITOR) {
                        this.result.visitLater(obj, propName);
                    }
                }
            };
            function _deserializePrimitiveObject(self, instance, serialized) {
                for (var propName in serialized) {
                    if (serialized.hasOwnProperty(propName)) {
                        var prop = serialized[propName];
                        if ("object" !== typeof prop) {
                            if ("__type__" !== propName) {
                                instance[propName] = prop;
                                if (self.result.visitorInEditor && EDITOR) {
                                    self.result.visitLater(instance, propName);
                                }
                            }
                        } else {
                            if (prop) {
                                if (ENABLE_TARGET) {
                                    self._deserializeObjField(instance, prop, propName, self._target && instance);
                                } else {
                                    self._deserializeObjField(instance, prop, propName);
                                }
                            } else {
                                instance[propName] = null;
                            }
                        }
                    }
                }
            }
            function _deserializeTypedObject(self, instance, serialized) {
                for (var propName in instance) {
                    var prop = serialized[propName];
                    if ("undefined" !== typeof prop && serialized.hasOwnProperty(propName)) {
                        if ("object" !== typeof prop) {
                            instance[propName] = prop;
                        } else {
                            if (prop) {
                                if (ENABLE_TARGET) {
                                    self._deserializeObjField(instance, prop, propName, self._target && instance);
                                } else {
                                    self._deserializeObjField(instance, prop, propName);
                                }
                            } else {
                                instance[propName] = null;
                            }
                        }
                    }
                }
            }
            function _deserializeFireClass(self, obj, serialized, klass, target) {
                var props = klass.__props__;
                for (var p = 0; p < props.length; p++) {
                    var propName = props[p];
                    var attrs = cc.Class.attr(klass, propName);
                    var rawType = attrs.rawType;
                    if (!rawType) {
                        if (!EDITOR && attrs.editorOnly) {
                            continue;
                        }
                        if (false === attrs.serializable) {
                            continue;
                        }
                        var prop = serialized[propName];
                        if ("undefined" === typeof prop) {
                            continue;
                        }
                        if ("object" !== typeof prop) {
                            obj[propName] = prop;
                        } else {
                            if (prop) {
                                if (ENABLE_TARGET) {
                                    self._deserializeObjField(obj, prop, propName, target && obj);
                                } else {
                                    self._deserializeObjField(obj, prop, propName);
                                }
                            } else {
                                obj[propName] = null;
                            }
                        }
                    } else {
                        if (self.result.rawProp) {
                            cc.error("not support multi raw object in a file");
                        }
                        self.result.rawProp = propName;
                    }
                }
                if ("_$erialized" === props[props.length - 1]) {
                    obj._$erialized = serialized;
                    _deserializePrimitiveObject(self, obj._$erialized, serialized);
                }
            }
            var _deserializeObject = function(self, serialized, target) {
                var propName, prop;
                var obj = null;
                var klass = null;
                if (serialized.__type__) {
                    klass = self._classFinder(serialized.__type__);
                    if (!klass) {
                        cc.error("[cc.deserialize] unknown type: " + serialized.__type__);
                        return null;
                    }
                    if (ENABLE_TARGET && target) {
                        if (!(target instanceof klass)) {
                            cc.warn("Type of target to deserialize not matched with data: target is %s, data is %s", JS.getClassName(target), klass);
                        }
                        obj = target;
                    } else {
                        obj = new klass();
                        if (cc.sys.isNative && klass === cc.SpriteFrame) {
                            obj.retain();
                        }
                    }
                    if (obj._deserialize) {
                        obj._deserialize(serialized.content, self);
                        return obj;
                    }
                    if (cc.Class._isCCClass(klass)) {
                        _deserializeFireClass(self, obj, serialized, klass, target);
                    } else {
                        _deserializeTypedObject(self, obj, serialized);
                    }
                } else {
                    if (!Array.isArray(serialized)) {
                        obj = ENABLE_TARGET && target || {};
                        _deserializePrimitiveObject(self, obj, serialized);
                    } else {
                        if (ENABLE_TARGET && target) {
                            target.length = serialized.length;
                            obj = target;
                        } else {
                            obj = new Array(serialized.length);
                        }
                        for (var i = 0; i < serialized.length; i++) {
                            prop = serialized[i];
                            if ("object" === typeof prop && prop) {
                                if (ENABLE_TARGET) {
                                    self._deserializeObjField(obj, prop, "" + i, target && obj);
                                } else {
                                    self._deserializeObjField(obj, prop, "" + i);
                                }
                            } else {
                                obj[i] = prop;
                                if (self.result.visitorInEditor && EDITOR) {
                                    self.result.visitLater(obj, "" + i);
                                }
                            }
                        }
                    }
                }
                return obj;
            };
            return _Deserializer;
        }();
        cc.deserialize = function(data, result, options) {
            var classFinder = options && options.classFinder || JS._getClassById;
            var createAssetRefs = options && options.createAssetRefs || cc.sys.platform === cc.sys.EDITOR_CORE;
            var target = ENABLE_TARGET && options && options.target;
            if (false) {
                data = data.toString();
            }
            if ("string" === typeof data) {
                data = JSON.parse(data);
            }
            if (createAssetRefs && !result) {
                result = new Details();
            }
            cc.game._isCloning = true;
            var deserializer = new _Deserializer(data, result, target, classFinder);
            cc.game._isCloning = false;
            if (createAssetRefs) {
                result.assignAssetsBy(Editor.serialize.asAsset);
            }
            return deserializer.deserializedData;
        };
        cc.deserialize.Details = Details;
    }, {
        "./CCObject": 62,
        "./js": 70
    } ],
    68: [ function(require, module, exports) {
        require("./js");
        require("./CCClass");
        require("./CCObject");
        require("./callbacks-invoker");
        require("./url");
        require("./deserialize");
        require("./instantiate");
        require("./prefab-info");
        require("./requiring-frame");
        require("./CCSys");
        require("./CCLoader");
        require("./CCMacro");
        if (cc.sys.isBrowser || cc.sys.isNative) {
            require("./load-manager");
            require("./CCAssetLibrary");
        }
    }, {
        "./CCAssetLibrary": 56,
        "./CCClass": 57,
        "./CCLoader": 60,
        "./CCMacro": 61,
        "./CCObject": 62,
        "./CCSys": 63,
        "./callbacks-invoker": 66,
        "./deserialize": 67,
        "./instantiate": 69,
        "./js": 70,
        "./load-manager": 71,
        "./prefab-info": 72,
        "./requiring-frame": 74,
        "./url": 75
    } ],
    69: [ function(require, module, exports) {
        var CCObject = require("./CCObject");
        var PersistentMask = CCObject.Flags.PersistentMask;
        var _isDomNode = require("./utils").isDomNode;
        function instantiate(original) {
            if ("object" !== typeof original || Array.isArray(original)) {
                cc.error("The thing you want to instantiate must be an object");
                return null;
            }
            if (!original) {
                cc.error("The thing you want to instantiate is nil");
                return null;
            }
            if (original instanceof CCObject && !original.isValid) {
                cc.error("The thing you want to instantiate is destroyed");
                return null;
            }
            var clone;
            if (original instanceof CCObject) {
                if (original._instantiate) {
                    cc.game._isCloning = true;
                    clone = original._instantiate();
                    cc.game._isCloning = false;
                    return clone;
                } else {
                    if (original instanceof cc.Asset) {
                        cc.error("The instantiate method for given asset do not implemented");
                        return null;
                    }
                }
            }
            cc.game._isCloning = true;
            clone = doInstantiate(original);
            cc.game._isCloning = false;
            return clone;
        }
        var objsToClearTmpVar = [];
        function doInstantiate(obj, parent) {
            if (Array.isArray(obj)) {
                cc.error("Can not instantiate array");
                return null;
            }
            if (_isDomNode && _isDomNode(obj)) {
                cc.error("Can not instantiate DOM element");
                return null;
            }
            var clone = enumerateObject(obj, parent);
            for (var i = 0, len = objsToClearTmpVar.length; i < len; ++i) {
                objsToClearTmpVar[i]._iN$t = null;
            }
            objsToClearTmpVar.length = 0;
            return clone;
        }
        var enumerateObject = function(obj, parent) {
            var value, type, key;
            var klass = obj.constructor;
            var clone = new klass();
            obj._iN$t = clone;
            objsToClearTmpVar.push(obj);
            if (cc.Class._isCCClass(klass)) {
                var props = klass.__props__;
                for (var p = 0; p < props.length; p++) {
                    key = props[p];
                    var attrs = cc.Class.attr(klass, key);
                    if (false !== attrs.serializable) {
                        value = obj[key];
                        type = typeof value;
                        if ("object" === type) {
                            clone[key] = value ? instantiateObj(value, parent, clone, key) : value;
                        } else {
                            clone[key] = "function" !== type ? value : null;
                        }
                    }
                }
                if (clone instanceof cc._BaseNode && false) {
                    clone._id = "";
                }
            } else {
                for (key in obj) {
                    if (!obj.hasOwnProperty(key) || 95 === key.charCodeAt(0) && 95 === key.charCodeAt(1)) {
                        continue;
                    }
                    value = obj[key];
                    if (value === clone) {
                        continue;
                    }
                    type = typeof value;
                    if ("object" === type) {
                        clone[key] = value ? instantiateObj(value, parent, clone, key) : value;
                    } else {
                        clone[key] = "function" !== type ? value : null;
                    }
                }
            }
            if (obj instanceof CCObject) {
                clone._objFlags &= PersistentMask;
            }
            return clone;
        };
        function instantiateObj(obj, parent, ownerObj, ownerKey) {
            var clone = obj._iN$t;
            if (clone) {
                return clone;
            }
            if (obj instanceof cc.Asset) {
                return obj;
            } else {
                if (Array.isArray(obj)) {
                    var len = obj.length;
                    clone = new Array(len);
                    obj._iN$t = clone;
                    for (var i = 0; i < len; ++i) {
                        var value = obj[i];
                        var type = typeof value;
                        if ("object" === type) {
                            clone[i] = value ? instantiateObj(value, parent, clone, "" + i) : value;
                        } else {
                            clone[i] = "function" !== type ? value : null;
                        }
                    }
                    objsToClearTmpVar.push(obj);
                    return clone;
                } else {
                    if (obj instanceof cc.ValueType) {
                        return obj.clone();
                    } else {
                        var ctor = obj.constructor;
                        if (cc.Class._isCCClass(ctor)) {
                            if (parent) {
                                if (obj instanceof cc._BaseNode) {
                                    if (!obj.isChildOf(parent)) {
                                        return obj;
                                    }
                                } else {
                                    if (obj instanceof cc.Component) {
                                        if (!obj.node.isChildOf(parent)) {
                                            return obj;
                                        }
                                    }
                                }
                            }
                        } else {
                            if (ctor !== Object) {
                                return obj;
                            }
                        }
                        return enumerateObject(obj, parent);
                    }
                }
            }
        }
        instantiate._clone = doInstantiate;
        cc.instantiate = instantiate;
        module.exports = instantiate;
    }, {
        "./CCObject": 62,
        "./utils": 76
    } ],
    70: [ function(require, module, exports) {
        function _getPropertyDescriptor(obj, name) {
            var pd = Object.getOwnPropertyDescriptor(obj, name);
            if (pd) {
                return pd;
            }
            var p = Object.getPrototypeOf(obj);
            if (p) {
                return _getPropertyDescriptor(p, name);
            } else {
                return null;
            }
        }
        function _copyprop(name, source, target) {
            var pd = _getPropertyDescriptor(source, name);
            Object.defineProperty(target, name, pd);
        }
        var js = {
            isFunction: function(obj) {
                return "function" === typeof obj;
            },
            isNumber: function(obj) {
                return "number" === typeof obj || "[object Number]" === Object.prototype.toString.call(obj);
            },
            isString: function(obj) {
                return "string" === typeof obj || "[object String]" === Object.prototype.toString.call(obj);
            },
            isArray: function(obj) {
                return Array.isArray(obj) || "object" === typeof obj && "[object Array]" === Object.prototype.toString.call(obj);
            },
            isUndefined: function(obj) {
                return "undefined" === typeof obj;
            },
            isObject: function(obj) {
                return "object" === typeof obj && "[object Object]" === Object.prototype.toString.call(obj);
            },
            addon: function(obj) {
                "use strict";
                obj = obj || {};
                for (var i = 1, length = arguments.length; i < length; i++) {
                    var source = arguments[i];
                    if (source) {
                        if ("object" !== typeof source) {
                            cc.error("cc.js.addon called on non-object:", source);
                            continue;
                        }
                        for (var name in source) {
                            if (!(name in obj)) {
                                _copyprop(name, source, obj);
                            }
                        }
                    }
                }
                return obj;
            },
            mixin: function(obj) {
                "use strict";
                obj = obj || {};
                for (var i = 1, length = arguments.length; i < length; i++) {
                    var source = arguments[i];
                    if (source) {
                        if ("object" !== typeof source) {
                            cc.error("cc.js.mixin: arguments must be type object:", source);
                            continue;
                        }
                        for (var name in source) {
                            _copyprop(name, source, obj);
                        }
                    }
                }
                return obj;
            },
            extend: function(cls, base) {
                if (false) {
                    if (!base) {
                        cc.error("The base class to extend from must be non-nil");
                        return;
                    }
                    if (!cls) {
                        cc.error("The class to extend must be non-nil");
                        return;
                    }
                }
                for (var p in base) {
                    if (base.hasOwnProperty(p)) {
                        cls[p] = base[p];
                    }
                }
                cls.prototype = Object.create(base.prototype);
                cls.prototype.constructor = cls;
                return cls;
            },
            clear: function(obj) {
                var keys = Object.keys(obj);
                for (var i = 0; i < keys.length; i++) {
                    delete obj[keys[i]];
                }
            },
            getPropertyDescriptor: _getPropertyDescriptor
        };
        js.getClassName = function(obj) {
            if ("function" === typeof obj) {
                if (obj.prototype.__classname__) {
                    return obj.prototype.__classname__;
                }
            } else {
                if (obj && obj.constructor) {
                    if (obj.constructor.prototype && obj.constructor.prototype.hasOwnProperty("__classname__")) {
                        return obj.__classname__;
                    }
                    var retval;
                    if (obj.constructor.name) {
                        retval = obj.constructor.name;
                    }
                    if (obj.constructor.toString) {
                        var arr, str = obj.constructor.toString();
                        if ("[" === str.charAt(0)) {
                            arr = str.match(/\[\w+\s*(\w+)\]/);
                        } else {
                            arr = str.match(/function\s*(\w+)/);
                        }
                        if (arr && 2 === arr.length) {
                            retval = arr[1];
                        }
                    }
                    return "Object" !== retval ? retval : "";
                }
            }
            return "";
        };
        var TCID_PREFIX = "cc.TmpCId.";
        var id = 0;
        function getTempCID() {
            return TCID_PREFIX + id++;
        }
        js._isTempClassId = function(id) {
            return false;
        };
        !function() {
            var _idToClass = {};
            var _nameToClass = {};
            function getRegister(key, table) {
                return function(id, constructor) {
                    if (constructor.prototype.hasOwnProperty(key)) {
                        delete table[constructor.prototype[key]];
                    }
                    constructor.prototype[key] = id;
                    if (id) {
                        var registered = table[id];
                        if (registered && registered !== constructor) {
                            var error = "A Class already exists with the same " + key + ' : "' + id + '".';
                            if (false) {
                                error += ' (This may be caused by error of unit test.) If you dont need serialization, you can set class id to "". You can also call cc.js.unregisterClass to remove the id of unused class';
                            }
                            cc.error(error);
                        } else {
                            table[id] = constructor;
                        }
                    }
                };
            }
            js._setClassId = getRegister("__cid__", _idToClass);
            var doSetClassName = getRegister("__classname__", _nameToClass);
            js.setClassName = function(className, constructor) {
                doSetClassName(className, constructor);
                if (!constructor.prototype.hasOwnProperty("__cid__")) {
                    var id = className || getTempCID();
                    if (id) {
                        js._setClassId(id, constructor);
                    }
                }
            };
            js.unregisterClass = function(constructor) {
                "use strict";
                for (var i = 0; i < arguments.length; i++) {
                    var p = arguments[i].prototype;
                    var classId = p.__cid__;
                    if (classId) {
                        delete _idToClass[classId];
                    }
                    var classname = p.__classname__;
                    if (classname) {
                        delete _nameToClass[classname];
                    }
                }
            };
            js._getClassById = function(classId) {
                return _idToClass[classId];
            };
            js.getClassByName = function(classname) {
                return _nameToClass[classname];
            };
            js._getClassId = function(obj, allowTempId) {
                allowTempId = "undefined" !== typeof allowTempId ? allowTempId : true;
                var res;
                if ("function" === typeof obj && obj.prototype.hasOwnProperty("__cid__")) {
                    res = obj.prototype.__cid__;
                    if (!allowTempId && js._isTempClassId(res)) {
                        return "";
                    }
                    return res;
                }
                if (obj && obj.constructor) {
                    var prototype = obj.constructor.prototype;
                    if (prototype && prototype.hasOwnProperty("__cid__")) {
                        res = obj.__cid__;
                        if (!allowTempId && js._isTempClassId(res)) {
                            return "";
                        }
                        return res;
                    }
                }
                return "";
            };
            if (false) {
                Object.defineProperty(js, "_registeredClassIds", {
                    get: function() {
                        var dump = {};
                        for (var id in _idToClass) {
                            dump[id] = _idToClass[id];
                        }
                        return dump;
                    },
                    set: function(value) {
                        js.clear(_idToClass);
                        for (var id in value) {
                            _idToClass[id] = value[id];
                        }
                    }
                });
                Object.defineProperty(js, "_registeredClassNames", {
                    get: function() {
                        var dump = {};
                        for (var id in _nameToClass) {
                            dump[id] = _nameToClass[id];
                        }
                        return dump;
                    },
                    set: function(value) {
                        js.clear(_nameToClass);
                        for (var id in value) {
                            _nameToClass[id] = value[id];
                        }
                    }
                });
            }
        }();
        js.getset = function(obj, prop, getter, setter, enumerable) {
            if ("function" !== typeof setter) {
                enumerable = setter;
                setter = void 0;
            }
            Object.defineProperty(obj, prop, {
                get: getter,
                set: setter,
                enumerable: !!enumerable
            });
        };
        js.get = function(obj, prop, getter, enumerable) {
            Object.defineProperty(obj, prop, {
                get: getter,
                enumerable: !!enumerable
            });
        };
        js.set = function(obj, prop, setter, enumerable) {
            Object.defineProperty(obj, prop, {
                set: setter,
                enumerable: !!enumerable
            });
        };
        js.obsolete = function(obj, obsoleted, newPropName, writable) {
            var oldName = obsoleted.split(".").slice(-1);
            js.get(obj, oldName, function() {
                if (false) {
                    cc.warn('"%s" is deprecated, use "%s" instead please.', obsoleted, newPropName);
                }
                return obj[newPropName];
            });
            if (writable) {
                js.set(obj, oldName, function(value) {
                    if (false) {
                        cc.warn('"%s" is deprecated, use "%s" instead please.', obsoleted, newPropName);
                    }
                    obj[newPropName] = value;
                });
            }
        };
        js.obsoletes = function(obj, objName, props, writable) {
            for (var obsoleted in props) {
                var newName = props[obsoleted];
                js.obsolete(obj, objName + "." + obsoleted, newName, writable);
            }
        };
        js.array = {
            remove: function(array, value) {
                var index = array.indexOf(value);
                if (-1 !== index) {
                    array.splice(index, 1);
                    return true;
                } else {
                    return false;
                }
            },
            removeAt: function(array, index) {
                array.splice(index, 1);
            },
            contains: function(array, value) {
                return -1 !== array.indexOf(value);
            },
            verifyType: function(array, type) {
                if (array && array.length > 0) {
                    for (var i = 0; i < array.length; i++) {
                        if (!(array[i] instanceof type)) {
                            cc.log(cc._LogInfos.Array.verifyType);
                            return false;
                        }
                    }
                }
                return true;
            },
            removeArray: function(array, minusArr) {
                for (var i = 0, l = minusArr.length; i < l; i++) {
                    remove(array, minusArr[i]);
                }
            },
            appendObjectsAt: function(array, addObjs, index) {
                array.splice.apply(array, [ index, 0 ].concat(addObjs));
                return array;
            },
            copy: function(array) {
                var i, len = array.length, arr_clone = new Array(len);
                for (i = 0; i < len; i += 1) {
                    arr_clone[i] = array[i];
                }
                return arr_clone;
            },
            indexOf: Array.prototype.indexOf
        };
        cc.js = js;
        module.exports = js;
    }, {} ],
    71: [ function(require, module, exports) {
        var CallbacksInvoker = require("./callbacks-invoker");
        function getBuiltinRawTypes() {
            return {
                image: {
                    loader: cc.loader.loadImg.bind(cc.loader),
                    defaultExtname: ".host"
                },
                json: {
                    loader: cc.loader.loadJson.bind(cc.loader),
                    defaultExtname: ".json"
                },
                text: {
                    loader: cc.loader.loadTxt.bind(cc.loader),
                    defaultExtname: ".txt"
                }
            };
        }
        var urlToCallbacks = new CallbacksInvoker();
        var loadQueue = [];
        var loadNext = function() {
            if (LoadManager._curConcurrent >= LoadManager.maxConcurrent) {
                cc.error("too many concurrent requests");
                return;
            }
            var nextOne = loadQueue.pop();
            if (nextOne) {
                doLoad(nextOne.loader, nextOne.url, nextOne.callback);
            }
        };
        function doLoad(loader, url, callback) {
            LoadManager._curConcurrent += 1;
            loader(url, function doLoadCB(error, asset) {
                callback(error, asset);
                LoadManager._curConcurrent = Math.max(0, LoadManager._curConcurrent - 1);
                loadNext();
            });
        }
        var LoadManager = {
            maxConcurrent: 2,
            _curConcurrent: 0,
            loadByLoader: function(loader, url, callback) {
                if (urlToCallbacks.add(url, callback)) {
                    var callbackBundle = urlToCallbacks.bindKey(url, true);
                    if (this._curConcurrent < this.maxConcurrent) {
                        doLoad(loader, url, callbackBundle);
                    } else {
                        loadQueue.push({
                            url: url,
                            loader: loader,
                            callback: callbackBundle
                        });
                    }
                }
            },
            load: function(url, rawType, rawExtname, callback) {
                if ("function" === typeof rawExtname) {
                    callback = rawExtname;
                }
                var typeInfo = this._rawTypes[rawType];
                if (typeInfo) {
                    var extname = rawExtname ? "." + rawExtname : typeInfo.defaultExtname;
                    if (extname) {
                        var rawUrl = url + extname;
                        this.loadByLoader(typeInfo.loader, rawUrl, callback);
                    } else {
                        callback(new Error("Undefined extname for the raw " + rawType + " file of " + url), null);
                    }
                } else {
                    callback(new Error('Unknown raw type "' + rawType + '" of ' + url), null);
                }
            },
            _rawTypes: getBuiltinRawTypes(),
            registerRawTypes: function(rawType, loader, defaultExtname) {
                if (false) {
                    if (!rawType) {
                        cc.error("[AssetLibrary.registerRawTypes] rawType must be non-nil");
                        return;
                    }
                    if ("string" !== typeof rawType) {
                        cc.error("[AssetLibrary.registerRawTypes] rawType must be string");
                        return;
                    }
                    if (!loader) {
                        cc.error("[AssetLibrary.registerRawTypes] loader must be non-nil");
                        return;
                    }
                    if ("function" !== typeof loader) {
                        cc.error("[AssetLibrary.registerRawTypes] loader must be function");
                        return;
                    }
                }
                if (this._rawTypes[rawType]) {
                    cc.error('rawType "%s" has already defined', rawType);
                    return;
                }
                if (defaultExtname && "." !== defaultExtname[0]) {
                    defaultExtname = "." + defaultExtname;
                }
                this._rawTypes[rawType] = {
                    loader: loader,
                    defaultExtname: defaultExtname
                };
            },
            reset: function() {
                if (false) {
                    var audio = this._rawTypes.audio;
                    this._rawTypes = getBuiltinRawTypes();
                    this._rawTypes.audio = audio;
                }
            },
            isLoading: function(url, alsoCheckRaw) {
                if (false) {
                    if (0 === this._curConcurrent) {
                        return false;
                    }
                    if (urlToCallbacks.has(url)) {
                        return true;
                    }
                    if (alsoCheckRaw) {
                        for (var u in urlToCallbacks._callbackTable) {
                            if (0 === u.indexOf(url)) {
                                return true;
                            }
                        }
                    }
                    return false;
                }
            }
        };
        cc._LoadManager = LoadManager;
        module.exports = LoadManager;
    }, {
        "./callbacks-invoker": 66
    } ],
    72: [ function(require, module, exports) {
        var PrefabInfo = cc.Class({
            name: "cc.PrefabInfo",
            properties: {
                root: {
                    "default": null
                },
                asset: {
                    "default": null
                },
                fileId: {
                    "default": ""
                }
            }
        });
        cc._PrefabInfo = module.exports = PrefabInfo;
    }, {} ],
    73: [ function(require, module, exports) {
        var Attr = require("./attribute");
        var SerializableAttrs = {
            url: {
                canUsedInGet: true
            },
            "default": {},
            serializable: {},
            editorOnly: {},
            rawType: {}
        };
        function parseNotify(val, propName, notify, properties) {
            if (val.get || val.set) {
                if (false) {
                    cc.warn('"notify" can\'t work with "get/set" !');
                }
                return;
            }
            if (val.hasOwnProperty("default")) {
                var newKey = "_N$" + propName;
                val.get = function() {
                    return this[newKey];
                };
                val.set = function(value) {
                    var oldValue = this[newKey];
                    this[newKey] = value;
                    notify.call(this, oldValue);
                };
                var newValue = {};
                properties[newKey] = newValue;
                for (var attr in SerializableAttrs) {
                    var v = SerializableAttrs[attr];
                    if (val.hasOwnProperty(attr)) {
                        newValue[attr] = val[attr];
                        if (!v.canUsedInGet) {
                            delete val[attr];
                        }
                    }
                }
            } else {
                if (false) {
                    cc.warn('"notify" must work with "default" !');
                }
            }
        }
        function checkUrl(val, className, propName, url) {
            if (Array.isArray(url)) {
                if (url.length > 0) {
                    url = url[0];
                } else {
                    if (false) {
                        return cc.error("Invalid url of %s.%s", className, propName);
                    }
                }
            }
            if (false) {
                if (null == url) {
                    return cc.warn('The "url" attribute of "%s.%s" is undefined when loading script.', className, propName);
                }
                if ("function" !== typeof url || !cc.isChildClassOf(url, cc.RawAsset)) {
                    return cc.error('The "url" type of "%s.%s" must be child class of cc.RawAsset.', className, propName);
                }
                if (cc.isChildClassOf(url, cc.Asset)) {
                    return cc.error('The "url" type of "%s.%s" must not be child class of cc.Asset, otherwise you should use "type: %s" instead.', className, propName, cc.js.getClassName(url));
                }
                if (val.type) {
                    return cc.warn('Can not specify "type" attribute for "%s.%s", because its "url" is already defined.', className, propName);
                }
            }
            val.type = url;
        }
        function parseType(val, type, className, propName) {
            if (Array.isArray(type)) {
                if (false) {
                    var isArray = require("./CCClass").isArray;
                    if (!isArray(val["default"])) {
                        cc.warn('The "default" attribute of "%s.%s" must be an array', className, propName);
                    }
                }
                if (type.length > 0) {
                    val.type = type = type[0];
                } else {
                    return cc.error("Invalid type of %s.%s", className, propName);
                }
            }
            if (false) {
                if ("function" === typeof type) {
                    var isRaw = cc.isChildClassOf(type, cc.RawAsset) && !cc.isChildClassOf(type, cc.Asset);
                    if (isRaw) {
                        cc.warn('The "type" attribute of "%s.%s" must be child class of cc.Asset, otherwise you should use "url: %s" instead', className, propName, cc.js.getClassName(type));
                    }
                } else {
                    if ("Number" === type) {
                        cc.warn('The "type" attribute of "%s.%s" can not be "Number", use "Float" or "Integer" instead please.', className, propName);
                    } else {
                        if (null == type) {
                            cc.warn('The "type" attribute of "%s.%s" is undefined when loading script.', className, propName);
                        }
                    }
                }
            }
        }
        function postCheckType(val, type, className, propName) {
            if ("function" === typeof type && false) {
                if (cc.Class._isCCClass(type) && false !== val.serializable && !cc.js._getClassId(type, false)) {
                    cc.warn('Can not serialize "%s.%s" because the specified type is anonymous, please provide a class name or set the "serializable" attribute of "%s.%s" to "false".', className, propName, className, propName);
                }
            }
        }
        function getBaseClassWherePropertyDefined(propName, cls) {
            if (false) {
                var res;
                for (;cls && cls.__props__ && -1 !== cls.__props__.indexOf(propName); cls = cls.$super) {
                    res = cls;
                }
                if (!res) {
                    cc.error("unknown error");
                }
                return res;
            }
        }
        module.exports = function(properties, className, cls) {
            for (var propName in properties) {
                var val = properties[propName];
                var isObj = val && "object" === typeof val && !Array.isArray(val);
                var isLiteral = isObj && val.constructor === Object;
                if (!isLiteral) {
                    properties[propName] = val = {
                        "default": val
                    };
                }
                if (val) {
                    if (!val.override && -1 !== cls.__props__.indexOf(propName) && false) {
                        var baseClass = cc.js.getClassName(getBaseClassWherePropertyDefined(propName, cls));
                        cc.warn('"%s.%s" hides inherited property "%s.%s". To make the current property override that implementation, add the `override: true` attribute please.', className, propName, baseClass, propName);
                    }
                    var notify = val.notify;
                    if (notify) {
                        parseNotify(val, propName, notify, properties);
                    }
                    if ("type" in val) {
                        parseType(val, val.type, className, propName);
                    }
                    if ("url" in val) {
                        checkUrl(val, className, propName, val.url);
                    }
                    if ("type" in val) {
                        postCheckType(val, val.type, className, propName);
                    }
                }
            }
        };
    }, {
        "./CCClass": 57,
        "./attribute": 65
    } ],
    74: [ function(require, module, exports) {
        var requiringFrames = [];
        cc._RFpush = function(module, uuid, script) {
            if (2 === arguments.length) {
                script = uuid;
                uuid = "";
            }
            requiringFrames.push({
                uuid: uuid,
                script: script,
                module: module,
                exports: module.exports,
                beh: null
            });
        };
        cc._RFpop = function() {
            var frameInfo = requiringFrames.pop();
            var module = frameInfo.module;
            var exports = module.exports;
            if (exports === frameInfo.exports) {
                for (var anyKey in exports) {
                    return;
                }
                module.exports = exports = frameInfo.beh;
            }
        };
        cc._RFpeek = function() {
            return requiringFrames[requiringFrames.length - 1];
        };
        if (false) {
            cc._RFreset = function() {
                requiringFrames = [];
            };
        }
    }, {} ],
    75: [ function(require, module, exports) {
        var _mounts = {};
        cc.url = {
            _rawAssets: "",
            _builtinRawAssets: "",
            raw: function(url) {
                if (!this._rawAssets && false) {
                    cc.error("Failed to init asset's raw path.");
                    return "";
                }
                if ("." === url[0] && "/" === url[1]) {
                    url = url.slice(2);
                } else {
                    if ("/" === url[0]) {
                        url = url.slice(1);
                    }
                }
                return this._rawAssets + url;
            },
            builtinRaw: function(url) {
                if (!this._rawAssets && false) {
                    cc.error("Failed to init builtin asset's raw path.");
                    return "";
                }
                if ("." === url[0] && "/" === url[1]) {
                    url = url.slice(2);
                } else {
                    if ("/" === url[0]) {
                        url = url.slice(1);
                    }
                }
                return this._builtinRawAssets + url;
            },
            _init: function(mountPaths) {
                for (var dir in mountPaths) {
                    var path = mountPaths[dir];
                    path = cc.path._setEndWithSep(path, "/");
                    _mounts[dir] = path;
                }
                this._rawAssets = _mounts.assets;
                this._builtinRawAssets = _mounts.internal;
            }
        };
        module.exports = cc.url;
    }, {} ],
    76: [ function(require, module, exports) {
        module.exports = {
            isDomNode: "object" === typeof window && function(obj) {
                return "object" === typeof Node ? obj instanceof Node : obj && "object" === typeof obj && "number" === typeof obj.nodeType && "string" === typeof obj.nodeName;
            },
            callInNextTick: function(callback, p1, p2) {
                if (callback) {
                    setTimeout(function() {
                        callback(p1, p2);
                    }, 1);
                }
            }
        };
        if (false) {
            cc.js.mixin(module.exports, {
                isPlainEmptyObj_DEV: function(obj) {
                    if (!obj || obj.constructor !== Object) {
                        return false;
                    }
                    for (var k in obj) {
                        return false;
                    }
                    return true;
                },
                cloneable_DEV: function(obj) {
                    return obj && "function" === typeof obj.clone && (obj.constructor.prototype.hasOwnProperty("clone") || obj.hasOwnProperty("clone"));
                }
            });
        }
        if (false) {
            if ("undefined" === typeof Editor) {
                Editor = {};
            }
            Editor.uuid = function() {
                return "" + (new Date().getTime() + Math.random());
            };
            Editor.NonUuidMark = ".";
        }
    }, {} ],
    77: [ function(require, module, exports) {
        var EventTarget = require("../event/event-target");
        cc.SpriteFrame = cc.Class({
            name: "cc.SpriteFrame",
            "extends": require("../assets/CCAsset"),
            mixins: [ EventTarget ],
            properties: {
                _textureFilenameSetter: {
                    set: function(url) {
                        this._textureFilename = url;
                        if (url) {
                            if (false) {
                                return;
                            }
                            var texture = cc.textureCache.addImage(url);
                            this._refreshTexture(texture);
                            if (this._textureLoaded) {
                                this._checkRect(texture);
                            }
                        }
                    }
                }
            },
            ctor: function() {
                var filename = arguments[0];
                var rect = arguments[1];
                var rotated = arguments[2];
                var offset = arguments[3];
                var originalSize = arguments[4];
                this._rect = null;
                this._rectInPixels = null;
                this._offset = null;
                this._offsetInPixels = null;
                this._originalSize = null;
                this._originalSizeInPixels = null;
                this._rotated = false;
                this.insetTop = 0;
                this.insetBottom = 0;
                this.insetLeft = 0;
                this.insetRight = 0;
                this._texture = null;
                this._textureFilename = "";
                this._textureLoaded = false;
                if (false) {
                    this._atlasUuid = "";
                }
                if (void 0 !== filename) {
                    this.initWithTexture(filename, rect, rotated, offset, originalSize);
                } else {}
            },
            textureLoaded: function() {
                return this._textureLoaded;
            },
            addLoadedEventListener: function(callback, target) {
                this.once("load", callback, target);
            },
            getRectInPixels: function() {
                return cc.rect(this._rectInPixels);
            },
            setRectInPixels: function(rectInPixels) {
                if (!this._rectInPixels) {
                    this._rectInPixels = cc.rect(rectInPixels);
                } else {
                    var rect = this._rectInPixels;
                    rect.x = rectInPixels.x;
                    rect.y = rectInPixels.y;
                    rect.width = rectInPixels.width;
                    rect.height = rectInPixels.height;
                }
                this._rect = cc.rectPixelsToPoints(rectInPixels);
            },
            isRotated: function() {
                return this._rotated;
            },
            setRotated: function(bRotated) {
                this._rotated = bRotated;
            },
            getRect: function() {
                return cc.rect(this._rect);
            },
            setRect: function(rect) {
                if (!this._rect) {
                    this._rect = cc.rect(rect);
                } else {
                    var locRect = this._rect;
                    locRect.x = rect.x;
                    locRect.y = rect.y;
                    locRect.width = rect.width;
                    locRect.height = rect.height;
                }
                this._rectInPixels = cc.rectPointsToPixels(rect);
            },
            getOffsetInPixels: function() {
                return cc.v2(this._offsetInPixels);
            },
            setOffsetInPixels: function(offsetInPixels) {
                if (!this._offsetInPixels) {
                    this._offsetInPixels = cc.v2(offsetInPixels);
                } else {
                    this._offsetInPixels.x = offsetInPixels.x;
                    this._offsetInPixels.y = offsetInPixels.y;
                }
                this._offset = cc.pointPixelsToPoints(offsetInPixels);
            },
            getOriginalSizeInPixels: function() {
                return cc.size(this._originalSizeInPixels);
            },
            setOriginalSizeInPixels: function(sizeInPixels) {
                if (!this._originalSizeInPixels) {
                    this._originalSizeInPixels = cc.size(sizeInPixels);
                } else {
                    this._originalSizeInPixels.width = sizeInPixels.width;
                    this._originalSizeInPixels.height = sizeInPixels.height;
                }
                this._originalSize = cc.sizePixelsToPoints(sizeInPixels);
            },
            getOriginalSize: function() {
                return cc.size(this._originalSize);
            },
            setOriginalSize: function(size) {
                if (!this._originalSize) {
                    this._originalSize = cc.size(size);
                } else {
                    this._originalSize.width = size.width;
                    this._originalSize.height = size.height;
                }
                this._originalSizeInPixels = cc.sizePointsToPixels(size);
            },
            getTexture: function() {
                return this._texture;
            },
            _refreshTexture: function(texture) {
                if (this._texture !== texture) {
                    var locLoaded = texture.isLoaded();
                    this._textureLoaded = locLoaded;
                    this._texture = texture;
                    var self = this;
                    var textureLoadedCallback = function() {
                        self._textureLoaded = true;
                        if (self._rotated && cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                            var tempElement = sender.getHtmlElementObj();
                            tempElement = _ccsg.Sprite.CanvasRenderCmd._cutRotateImageToCanvas(tempElement, self.getRect());
                            var tempTexture = new cc.Texture2D();
                            tempTexture.initWithElement(tempElement);
                            tempTexture.handleLoadedTexture();
                            self.setTexture(tempTexture);
                            var rect = self.getRect();
                            self.setRect(cc.rect(0, 0, rect.width, rect.height));
                        }
                        var w = texture.width, h = texture.height;
                        if (!self._rect) {
                            self.setRect(cc.rect(0, 0, w, h));
                        }
                        if (!self._originalSize) {
                            self.setOriginalSize(cc.size(w, h));
                        }
                        if (!self._offset) {
                            self.setOffset(cc.v2(0, 0));
                        }
                        self.emit("load");
                    };
                    if (!locLoaded) {
                        texture.once("load", textureLoadedCallback, this);
                    } else {
                        textureLoadedCallback();
                    }
                }
            },
            getOffset: function() {
                return cc.v2(this._offset);
            },
            setOffset: function(offsets) {
                if (!this._offset) {
                    this._offset = cc.v2(offsets);
                } else {
                    this._offset.x = offsets.x;
                    this._offset.y = offsets.y;
                }
                this._offsetInPixels = cc.pointPointsToPixels(offsets);
            },
            clone: function() {
                return new cc.SpriteFrame(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels);
            },
            initWithTexture: function(textureOrTextureFile, rect, rotated, offset, originalSize) {
                this.setTexture(textureOrTextureFile, rect, rotated, offset, originalSize);
            },
            setTexture: function(textureOrTextureFile, rect, rotated, offset, originalSize) {
                if (rect) {
                    this.setRectInPixels(rect);
                } else {
                    this._rect = this._rectInPixels = null;
                }
                if (offset) {
                    this.setOffsetInPixels(offset);
                } else {
                    this._offset = this._offsetInPixels = null;
                }
                if (originalSize) {
                    this.setOriginalSizeInPixels(originalSize);
                } else {
                    this._originalSize = this._originalSizeInPixels = null;
                }
                this._rotated = rotated || false;
                var texture = textureOrTextureFile;
                if (cc.js.isString(texture)) {
                    this._textureFilename = texture;
                    texture = cc.textureCache.addImage(texture);
                }
                if (texture instanceof cc.Texture2D) {
                    this._refreshTexture(texture);
                } else {}
                if (texture && texture.url && texture.isLoaded()) {
                    this._checkRect(texture);
                }
                return true;
            },
            _checkRect: function(texture) {
                var rect = this._rectInPixels;
                var maxX = rect.x, maxY = rect.y;
                if (this._rotated) {
                    maxX += rect.height;
                    maxY += rect.width;
                } else {
                    maxX += rect.width;
                    maxY += rect.height;
                }
                if (maxX > texture.getPixelWidth()) {
                    cc.error(cc._LogInfos.RectWidth, texture.url);
                }
                if (maxY > texture.getPixelHeight()) {
                    cc.error(cc._LogInfos.RectHeight, texture.url);
                }
            },
            _serialize: false,
            _deserialize: function(data, handle) {
                var rect = data.rect;
                if (rect) {
                    this.setRect(new cc.Rect(rect[0], rect[1], rect[2], rect[3]));
                }
                if (data.offset) {
                    this.setOffset(new cc.Vec2(data.offset[0], data.offset[1]));
                }
                if (data.originalSize) {
                    this.setOriginalSize(new cc.Size(data.originalSize[0], data.originalSize[1]));
                }
                this._rotated = 1 === data.rotated;
                this._name = data.name;
                var capInsets = data.capInsets;
                if (capInsets) {
                    this.insetLeft = capInsets[0];
                    this.insetTop = capInsets[1];
                    this.insetRight = capInsets[2];
                    this.insetBottom = capInsets[3];
                }
                if (false) {
                    this._atlasUuid = data.atlas;
                }
                var textureUuid = data.texture;
                if (textureUuid) {
                    handle.result.push(this, "_textureFilenameSetter", textureUuid);
                }
            }
        });
        var proto = cc.SpriteFrame.prototype;
        proto.copyWithZone = proto.clone;
        proto.copy = proto.clone;
        cc.SpriteFrame.create = function(filename, rect, rotated, offset, originalSize) {
            return new cc.SpriteFrame(filename, rect, rotated, offset, originalSize);
        };
        cc.SpriteFrame.createWithTexture = cc.SpriteFrame.create;
        cc.SpriteFrame._frameWithTextureForCanvas = function(texture, rect, rotated, offset, originalSize) {
            return new cc.SpriteFrame(texture, rect, rotated, offset, originalSize);
        };
    }, {
        "../assets/CCAsset": 22,
        "../event/event-target": 52
    } ],
    78: [ function(require, module, exports) {
        var EventTarget = require("../event/event-target");
        var sys = require("../platform/CCSys");
        var JS = require("../platform/js");
        var game = require("../CCGame");
        require("../platform/_CCClass");
        require("../platform/CCClass");
        cc.ALIGN_CENTER = 51;
        cc.ALIGN_TOP = 19;
        cc.ALIGN_TOP_RIGHT = 18;
        cc.ALIGN_RIGHT = 50;
        cc.ALIGN_BOTTOM_RIGHT = 34;
        cc.ALIGN_BOTTOM = 35;
        cc.ALIGN_BOTTOM_LEFT = 33;
        cc.ALIGN_LEFT = 49;
        cc.ALIGN_TOP_LEFT = 17;
        var WrapMode = cc.Enum({
            REPEAT: 10497,
            CLAMP_TO_EDGE: 33071,
            MIRRORED_REPEAT: 33648
        });
        var Texture2D = cc.Class({
            name: "cc.Texture2D",
            "extends": require("../assets/CCRawAsset"),
            mixins: [ EventTarget ],
            ctor: function() {
                this.url = null;
                this._textureLoaded = false;
                this._htmlElementObj = null;
                this._contentSize = cc.size(0, 0);
                if (cc._renderType === game.RENDER_TYPE_CANVAS) {
                    this._pattern = "";
                    this._grayElementObj = null;
                    this._backupElement = null;
                    this._isGray = false;
                } else {
                    if (cc._renderType === game.RENDER_TYPE_WEBGL) {
                        this._hasPremultipliedAlpha = false;
                        this._pixelFormat = Texture2D.defaultPixelFormat;
                        this._pixelsWide = 0;
                        this._pixelsHigh = 0;
                        this._hasPremultipliedAlpha = false;
                        this._hasMipmaps = false;
                        this._webTextureObj = null;
                    }
                }
            },
            getPixelWidth: function() {
                return this._contentSize.width;
            },
            getPixelHeight: function() {
                return this._contentSize.height;
            },
            getContentSize: function() {
                var locScaleFactor = cc.contentScaleFactor();
                return cc.size(this._contentSize.width / locScaleFactor, this._contentSize.height / locScaleFactor);
            },
            _getWidth: function() {
                return this._contentSize.width / cc.contentScaleFactor();
            },
            _getHeight: function() {
                return this._contentSize.height / cc.contentScaleFactor();
            },
            getContentSizeInPixels: function() {
                return this._contentSize;
            },
            initWithElement: function(element) {
                if (!element) {
                    return;
                }
                this._htmlElementObj = element;
                this._contentSize.width = element.width;
                this._contentSize.height = element.height;
                this._textureLoaded = true;
            },
            initWithData: function(data, pixelFormat, pixelsWide, pixelsHigh, contentSize) {
                return false;
            },
            initWithImage: function(uiImage) {
                return false;
            },
            getHtmlElementObj: function() {
                return this._htmlElementObj;
            },
            isLoaded: function() {
                return this._textureLoaded;
            },
            handleLoadedTexture: function() {
                var self = this;
                if (!self._htmlElementObj) {
                    var img = cc.loader.getRes(self.url);
                    if (!img) {
                        return;
                    }
                    self.initWithElement(img);
                }
                if (!self._htmlElementObj.width || !self._htmlElementObj.height) {
                    return;
                }
                var locElement = self._htmlElementObj;
                self._contentSize.width = locElement.width;
                self._contentSize.height = locElement.height;
                self.emit("load");
            },
            description: function() {
                return "<cc.Texture2D | Name = " + this.getName() + " | Dimensions = " + this.getPixelWidth() + " x " + this.getPixelHeight() + ">";
            },
            releaseTexture: function() {
                if (this._webTextureObj) {
                    cc._renderContext.deleteTexture(this._webTextureObj);
                }
                cc.loader.release(this.url);
            },
            getName: function() {
                return this._webTextureObj || null;
            },
            getPixelFormat: function() {
                return this._pixelFormat || null;
            },
            hasPremultipliedAlpha: function() {
                return this._hasPremultipliedAlpha || false;
            },
            hasMipmaps: function() {
                return this._hasMipmaps || false;
            },
            setTexParameters: function(texParams, magFilter, wrapS, wrapT) {
                if (void 0 !== magFilter) {
                    texParams = {
                        minFilter: texParams,
                        magFilter: magFilter,
                        wrapS: wrapS,
                        wrapT: wrapT
                    };
                }
                if (texParams.wrapS === WrapMode.REPEAT && texParams.wrapT === WrapMode.REPEAT) {
                    this._pattern = "repeat";
                    return;
                }
                if (texParams.wrapS === WrapMode.REPEAT) {
                    this._pattern = "repeat-x";
                    return;
                }
                if (texParams.wrapT === WrapMode.REPEAT) {
                    this._pattern = "repeat-y";
                    return;
                }
                this._pattern = "";
            },
            setAntiAliasTexParameters: function() {},
            setAliasTexParameters: function() {},
            generateMipmap: function() {},
            stringForFormat: function() {
                return "";
            },
            bitsPerPixelForFormat: function(format) {
                return -1;
            }
        });
        Texture2D.WrapMode = WrapMode;
        var _c = Texture2D;
        _c.PIXEL_FORMAT_RGBA8888 = 2;
        _c.PIXEL_FORMAT_RGB888 = 3;
        _c.PIXEL_FORMAT_RGB565 = 4;
        _c.PIXEL_FORMAT_A8 = 5;
        _c.PIXEL_FORMAT_I8 = 6;
        _c.PIXEL_FORMAT_AI88 = 7;
        _c.PIXEL_FORMAT_RGBA4444 = 8;
        _c.PIXEL_FORMAT_RGB5A1 = 7;
        _c.PIXEL_FORMAT_PVRTC4 = 9;
        _c.PIXEL_FORMAT_PVRTC2 = 10;
        _c.PIXEL_FORMAT_DEFAULT = _c.PIXEL_FORMAT_RGBA8888;
        _c.defaultPixelFormat = _c.PIXEL_FORMAT_DEFAULT;
        var _M = Texture2D._M = {};
        _M[_c.PIXEL_FORMAT_RGBA8888] = "RGBA8888";
        _M[_c.PIXEL_FORMAT_RGB888] = "RGB888";
        _M[_c.PIXEL_FORMAT_RGB565] = "RGB565";
        _M[_c.PIXEL_FORMAT_A8] = "A8";
        _M[_c.PIXEL_FORMAT_I8] = "I8";
        _M[_c.PIXEL_FORMAT_AI88] = "AI88";
        _M[_c.PIXEL_FORMAT_RGBA4444] = "RGBA4444";
        _M[_c.PIXEL_FORMAT_RGB5A1] = "RGB5A1";
        _M[_c.PIXEL_FORMAT_PVRTC4] = "PVRTC4";
        _M[_c.PIXEL_FORMAT_PVRTC2] = "PVRTC2";
        var _B = Texture2D._B = {};
        _B[_c.PIXEL_FORMAT_RGBA8888] = 32;
        _B[_c.PIXEL_FORMAT_RGB888] = 24;
        _B[_c.PIXEL_FORMAT_RGB565] = 16;
        _B[_c.PIXEL_FORMAT_A8] = 8;
        _B[_c.PIXEL_FORMAT_I8] = 8;
        _B[_c.PIXEL_FORMAT_AI88] = 16;
        _B[_c.PIXEL_FORMAT_RGBA4444] = 16;
        _B[_c.PIXEL_FORMAT_RGB5A1] = 16;
        _B[_c.PIXEL_FORMAT_PVRTC4] = 4;
        _B[_c.PIXEL_FORMAT_PVRTC2] = 3;
        var _p = Texture2D.prototype;
        _p.name;
        cc.defineGetterSetter(_p, "name", _p.getName);
        _p.pixelFormat;
        cc.defineGetterSetter(_p, "pixelFormat", _p.getPixelFormat);
        _p.pixelWidth;
        cc.defineGetterSetter(_p, "pixelWidth", _p.getPixelWidth);
        _p.pixelHeight;
        cc.defineGetterSetter(_p, "pixelHeight", _p.getPixelHeight);
        _p.width;
        cc.defineGetterSetter(_p, "width", _p._getWidth);
        _p.height;
        cc.defineGetterSetter(_p, "height", _p._getHeight);
        game.once(game.EVENT_RENDERER_INITED, function() {
            if (cc._renderType === game.RENDER_TYPE_CANVAS) {
                var renderToCache = function(image, cache) {
                    var w = image.width;
                    var h = image.height;
                    cache[0].width = w;
                    cache[0].height = h;
                    cache[1].width = w;
                    cache[1].height = h;
                    cache[2].width = w;
                    cache[2].height = h;
                    cache[3].width = w;
                    cache[3].height = h;
                    var cacheCtx = cache[3].getContext("2d");
                    cacheCtx.drawImage(image, 0, 0);
                    var pixels = cacheCtx.getImageData(0, 0, w, h).data;
                    var ctx;
                    for (var rgbI = 0; rgbI < 4; rgbI++) {
                        ctx = cache[rgbI].getContext("2d");
                        var to = ctx.getImageData(0, 0, w, h);
                        var data = to.data;
                        for (var i = 0; i < pixels.length; i += 4) {
                            data[i] = 0 === rgbI ? pixels[i] : 0;
                            data[i + 1] = 1 === rgbI ? pixels[i + 1] : 0;
                            data[i + 2] = 2 === rgbI ? pixels[i + 2] : 0;
                            data[i + 3] = pixels[i + 3];
                        }
                        ctx.putImageData(to, 0, 0);
                    }
                    image.onload = null;
                };
                var generateGrayTexture = function(texture, rect, renderCanvas) {
                    if (null === texture) {
                        return null;
                    }
                    renderCanvas = renderCanvas || document.createElement("canvas");
                    rect = rect || cc.rect(0, 0, texture.width, texture.height);
                    renderCanvas.width = rect.width;
                    renderCanvas.height = rect.height;
                    var context = renderCanvas.getContext("2d");
                    context.drawImage(texture, rect.x, rect.y, rect.width, rect.height, 0, 0, rect.width, rect.height);
                    var imgData = context.getImageData(0, 0, rect.width, rect.height);
                    var data = imgData.data;
                    for (var i = 0, len = data.length; i < len; i += 4) {
                        data[i] = data[i + 1] = data[i + 2] = .34 * data[i] + .5 * data[i + 1] + .16 * data[i + 2];
                    }
                    context.putImageData(imgData, 0, 0);
                    return renderCanvas;
                };
                JS.mixin(Texture2D.prototype, {
                    _generateTextureCacheForColor: function() {
                        if (this.channelCache) {
                            return this.channelCache;
                        }
                        var textureCache = [ document.createElement("canvas"), document.createElement("canvas"), document.createElement("canvas"), document.createElement("canvas") ];
                        renderToCache(this._htmlElementObj, textureCache);
                        return this.channelCache = textureCache;
                    },
                    _switchToGray: function(toGray) {
                        if (!this._textureLoaded || this._isGray === toGray) {
                            return;
                        }
                        this._isGray = toGray;
                        if (this._isGray) {
                            this._backupElement = this._htmlElementObj;
                            if (!this._grayElementObj) {
                                this._grayElementObj = generateGrayTexture(this._htmlElementObj);
                            }
                            this._htmlElementObj = this._grayElementObj;
                        } else {
                            if (null !== this._backupElement) {
                                this._htmlElementObj = this._backupElement;
                            }
                        }
                    },
                    _generateGrayTexture: function() {
                        if (!this._textureLoaded) {
                            return null;
                        }
                        var grayElement = generateGrayTexture(this._htmlElementObj);
                        var newTexture = new Texture2D();
                        newTexture.initWithElement(grayElement);
                        newTexture.handleLoadedTexture();
                        return newTexture;
                    },
                    _generateColorTexture: sys._supportCanvasNewBlendModes ? function(r, g, b, rect, canvas) {
                        var onlyCanvas = false;
                        if (canvas) {
                            onlyCanvas = true;
                        } else {
                            canvas = document.createElement("canvas");
                        }
                        var textureImage = this._htmlElementObj;
                        if (!rect) {
                            rect = cc.rect(0, 0, textureImage.width, textureImage.height);
                        }
                        canvas.width = rect.width;
                        canvas.height = rect.height;
                        var context = canvas.getContext("2d");
                        context.globalCompositeOperation = "source-over";
                        context.fillStyle = "rgb(" + (0 | r) + "," + (0 | g) + "," + (0 | b) + ")";
                        context.fillRect(0, 0, rect.width, rect.height);
                        context.globalCompositeOperation = "multiply";
                        context.drawImage(textureImage, rect.x, rect.y, rect.width, rect.height, 0, 0, rect.width, rect.height);
                        context.globalCompositeOperation = "destination-atop";
                        context.drawImage(textureImage, rect.x, rect.y, rect.width, rect.height, 0, 0, rect.width, rect.height);
                        if (onlyCanvas) {
                            return canvas;
                        }
                        var newTexture = new Texture2D();
                        newTexture.initWithElement(canvas);
                        newTexture.handleLoadedTexture();
                        return newTexture;
                    } : function(r, g, b, rect, canvas) {
                        var onlyCanvas = false;
                        if (canvas) {
                            onlyCanvas = true;
                        } else {
                            canvas = document.createElement("canvas");
                        }
                        var textureImage = this._htmlElementObj;
                        if (!rect) {
                            rect = cc.rect(0, 0, textureImage.width, textureImage.height);
                        }
                        var x, y, w, h;
                        x = rect.x;
                        y = rect.y;
                        w = rect.width;
                        h = rect.height;
                        if (!w || !h) {
                            return;
                        }
                        canvas.width = w;
                        canvas.height = h;
                        var context = canvas.getContext("2d");
                        var tintedImgCache = cc.textureCache.getTextureColors(this);
                        context.globalCompositeOperation = "lighter";
                        context.drawImage(tintedImgCache[3], x, y, w, h, 0, 0, w, h);
                        if (r > 0) {
                            context.globalAlpha = r / 255;
                            context.drawImage(tintedImgCache[0], x, y, w, h, 0, 0, w, h);
                        }
                        if (g > 0) {
                            context.globalAlpha = g / 255;
                            context.drawImage(tintedImgCache[1], x, y, w, h, 0, 0, w, h);
                        }
                        if (b > 0) {
                            context.globalAlpha = b / 255;
                            context.drawImage(tintedImgCache[2], x, y, w, h, 0, 0, w, h);
                        }
                        if (onlyCanvas) {
                            return canvas;
                        }
                        var newTexture = new Texture2D();
                        newTexture.initWithElement(canvas);
                        newTexture.handleLoadedTexture();
                        return newTexture;
                    }
                });
            } else {
                if (cc._renderType === game.RENDER_TYPE_WEBGL) {
                    JS.mixin(Texture2D.prototype, {
                        getPixelWidth: function() {
                            return this._pixelsWide;
                        },
                        getPixelHeight: function() {
                            return this._pixelsHigh;
                        },
                        initWithData: function(data, pixelFormat, pixelsWide, pixelsHigh, contentSize) {
                            var self = this, tex2d = Texture2D;
                            var gl = cc._renderContext;
                            var format = gl.RGBA, type = gl.UNSIGNED_BYTE;
                            var bitsPerPixel = Texture2D._B[pixelFormat];
                            var bytesPerRow = pixelsWide * bitsPerPixel / 8;
                            if (bytesPerRow % 8 === 0) {
                                gl.pixelStorei(gl.UNPACK_ALIGNMENT, 8);
                            } else {
                                if (bytesPerRow % 4 === 0) {
                                    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
                                } else {
                                    if (bytesPerRow % 2 === 0) {
                                        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 2);
                                    } else {
                                        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
                                    }
                                }
                            }
                            self._webTextureObj = gl.createTexture();
                            cc.glBindTexture2D(self);
                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                            switch (pixelFormat) {
                              case tex2d.PIXEL_FORMAT_RGBA8888:
                                format = gl.RGBA;
                                break;

                              case tex2d.PIXEL_FORMAT_RGB888:
                                format = gl.RGB;
                                break;

                              case tex2d.PIXEL_FORMAT_RGBA4444:
                                type = gl.UNSIGNED_SHORT_4_4_4_4;
                                break;

                              case tex2d.PIXEL_FORMAT_RGB5A1:
                                type = gl.UNSIGNED_SHORT_5_5_5_1;
                                break;

                              case tex2d.PIXEL_FORMAT_RGB565:
                                type = gl.UNSIGNED_SHORT_5_6_5;
                                break;

                              case tex2d.PIXEL_FORMAT_AI88:
                                format = gl.LUMINANCE_ALPHA;
                                break;

                              case tex2d.PIXEL_FORMAT_A8:
                                format = gl.ALPHA;
                                break;

                              case tex2d.PIXEL_FORMAT_I8:
                                format = gl.LUMINANCE;
                                break;

                              default:
                                cc.assert(0, cc._LogInfos.Texture2D.initWithData);
                            }
                            gl.texImage2D(gl.TEXTURE_2D, 0, format, pixelsWide, pixelsHigh, 0, format, type, data);
                            self._contentSize.width = contentSize.width;
                            self._contentSize.height = contentSize.height;
                            self._pixelsWide = pixelsWide;
                            self._pixelsHigh = pixelsHigh;
                            self._pixelFormat = pixelFormat;
                            self._hasPremultipliedAlpha = false;
                            self._hasMipmaps = false;
                            self._textureLoaded = true;
                            return true;
                        },
                        initWithImage: function(uiImage) {
                            if (null == uiImage) {
                                cc.log(cc._LogInfos.Texture2D.initWithImage);
                                return false;
                            }
                            var imageWidth = uiImage.getWidth();
                            var imageHeight = uiImage.getHeight();
                            var maxTextureSize = cc.configuration.getMaxTextureSize();
                            if (imageWidth > maxTextureSize || imageHeight > maxTextureSize) {
                                cc.log(cc._LogInfos.Texture2D.initWithImage_2, imageWidth, imageHeight, maxTextureSize, maxTextureSize);
                                return false;
                            }
                            this._textureLoaded = true;
                            return this._initPremultipliedATextureWithImage(uiImage, imageWidth, imageHeight);
                        },
                        initWithElement: function(element) {
                            if (!element) {
                                return;
                            }
                            this._webTextureObj = cc._renderContext.createTexture();
                            this._htmlElementObj = element;
                            this._textureLoaded = true;
                        },
                        handleLoadedTexture: function(premultiplied) {
                            premultiplied = !!premultiplied;
                            var self = this;
                            if (!game._rendererInitialized) {
                                return;
                            }
                            if (!self._htmlElementObj) {
                                var img = cc.loader.getRes(self.url);
                                if (!img) {
                                    return;
                                }
                                self.initWithElement(img);
                            }
                            if (!self._htmlElementObj.width || !self._htmlElementObj.height) {
                                return;
                            }
                            var gl = cc._renderContext;
                            cc.glBindTexture2D(self);
                            gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
                            if (premultiplied) {
                                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);
                            }
                            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, self._htmlElementObj);
                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                            cc.glBindTexture2D(null);
                            if (premultiplied) {
                                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
                            }
                            var pixelsWide = self._htmlElementObj.width;
                            var pixelsHigh = self._htmlElementObj.height;
                            self._pixelsWide = self._contentSize.width = pixelsWide;
                            self._pixelsHigh = self._contentSize.height = pixelsHigh;
                            self._pixelFormat = Texture2D.PIXEL_FORMAT_RGBA8888;
                            self._hasPremultipliedAlpha = premultiplied;
                            self._hasMipmaps = false;
                            self.emit("load");
                        },
                        setTexParameters: function(texParams, magFilter, wrapS, wrapT) {
                            var _t = this;
                            var gl = cc._renderContext;
                            if (void 0 !== magFilter) {
                                texParams = {
                                    minFilter: texParams,
                                    magFilter: magFilter,
                                    wrapS: wrapS,
                                    wrapT: wrapT
                                };
                            }
                            cc.assert(_t._pixelsWide === cc.NextPOT(_t._pixelsWide) && _t._pixelsHigh === cc.NextPOT(_t._pixelsHigh) || texParams.wrapS === gl.CLAMP_TO_EDGE && texParams.wrapT === gl.CLAMP_TO_EDGE, "WebGLRenderingContext.CLAMP_TO_EDGE should be used in NPOT textures");
                            cc.glBindTexture2D(_t);
                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texParams.minFilter);
                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texParams.magFilter);
                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, texParams.wrapS);
                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, texParams.wrapT);
                        },
                        setAntiAliasTexParameters: function() {
                            var gl = cc._renderContext;
                            cc.glBindTexture2D(this);
                            if (!this._hasMipmaps) {
                                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                            } else {
                                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
                            }
                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        },
                        setAliasTexParameters: function() {
                            var gl = cc._renderContext;
                            cc.glBindTexture2D(this);
                            if (!this._hasMipmaps) {
                                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                            } else {
                                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_NEAREST);
                            }
                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                        },
                        generateMipmap: function() {
                            var _t = this;
                            cc.assert(_t._pixelsWide === cc.NextPOT(_t._pixelsWide) && _t._pixelsHigh === cc.NextPOT(_t._pixelsHigh), "Mimpap texture only works in POT textures");
                            cc.glBindTexture2D(_t);
                            cc._renderContext.generateMipmap(cc._renderContext.TEXTURE_2D);
                            _t._hasMipmaps = true;
                        },
                        stringForFormat: function() {
                            return Texture2D._M[this._pixelFormat];
                        },
                        bitsPerPixelForFormat: function(format) {
                            format = format || this._pixelFormat;
                            var value = Texture2D._B[format];
                            if (null != value) {
                                return value;
                            }
                            cc.log(cc._LogInfos.Texture2D.bitsPerPixelForFormat, format);
                            return -1;
                        },
                        _initPremultipliedATextureWithImage: function(uiImage, width, height) {
                            var tex2d = Texture2D;
                            var tempData = uiImage.getData();
                            var inPixel32 = null;
                            var inPixel8 = null;
                            var outPixel16 = null;
                            var hasAlpha = uiImage.hasAlpha();
                            var imageSize = cc.size(uiImage.getWidth(), uiImage.getHeight());
                            var pixelFormat = tex2d.defaultPixelFormat;
                            var bpp = uiImage.getBitsPerComponent();
                            var i;
                            if (!hasAlpha) {
                                if (bpp >= 8) {
                                    pixelFormat = tex2d.PIXEL_FORMAT_RGB888;
                                } else {
                                    cc.log(cc._LogInfos.Texture2D._initPremultipliedATextureWithImage);
                                    pixelFormat = tex2d.PIXEL_FORMAT_RGB565;
                                }
                            }
                            var length = width * height;
                            if (pixelFormat === tex2d.PIXEL_FORMAT_RGB565) {
                                if (hasAlpha) {
                                    tempData = new Uint16Array(width * height);
                                    inPixel32 = uiImage.getData();
                                    for (i = 0; i < length; ++i) {
                                        tempData[i] = (inPixel32[i] >> 0 & 255) >> 3 << 11 | (inPixel32[i] >> 8 & 255) >> 2 << 5 | (inPixel32[i] >> 16 & 255) >> 3 << 0;
                                    }
                                } else {
                                    tempData = new Uint16Array(width * height);
                                    inPixel8 = uiImage.getData();
                                    for (i = 0; i < length; ++i) {
                                        tempData[i] = (255 & inPixel8[i]) >> 3 << 11 | (255 & inPixel8[i]) >> 2 << 5 | (255 & inPixel8[i]) >> 3 << 0;
                                    }
                                }
                            } else {
                                if (pixelFormat === tex2d.PIXEL_FORMAT_RGBA4444) {
                                    tempData = new Uint16Array(width * height);
                                    inPixel32 = uiImage.getData();
                                    for (i = 0; i < length; ++i) {
                                        tempData[i] = (inPixel32[i] >> 0 & 255) >> 4 << 12 | (inPixel32[i] >> 8 & 255) >> 4 << 8 | (inPixel32[i] >> 16 & 255) >> 4 << 4 | (inPixel32[i] >> 24 & 255) >> 4 << 0;
                                    }
                                } else {
                                    if (pixelFormat === tex2d.PIXEL_FORMAT_RGB5A1) {
                                        tempData = new Uint16Array(width * height);
                                        inPixel32 = uiImage.getData();
                                        for (i = 0; i < length; ++i) {
                                            tempData[i] = (inPixel32[i] >> 0 & 255) >> 3 << 11 | (inPixel32[i] >> 8 & 255) >> 3 << 6 | (inPixel32[i] >> 16 & 255) >> 3 << 1 | (inPixel32[i] >> 24 & 255) >> 7 << 0;
                                        }
                                    } else {
                                        if (pixelFormat === tex2d.PIXEL_FORMAT_A8) {
                                            tempData = new Uint8Array(width * height);
                                            inPixel32 = uiImage.getData();
                                            for (i = 0; i < length; ++i) {
                                                tempData[i] = inPixel32 >> 24 & 255;
                                            }
                                        }
                                    }
                                }
                            }
                            if (hasAlpha && pixelFormat === tex2d.PIXEL_FORMAT_RGB888) {
                                inPixel32 = uiImage.getData();
                                tempData = new Uint8Array(width * height * 3);
                                for (i = 0; i < length; ++i) {
                                    tempData[3 * i] = inPixel32 >> 0 & 255;
                                    tempData[3 * i + 1] = inPixel32 >> 8 & 255;
                                    tempData[3 * i + 2] = inPixel32 >> 16 & 255;
                                }
                            }
                            this.initWithData(tempData, pixelFormat, width, height, imageSize);
                            if (tempData != uiImage.getData()) {
                                tempData = null;
                            }
                            this._hasPremultipliedAlpha = uiImage.isPremultipliedAlpha();
                            return true;
                        }
                    });
                }
            }
        });
        cc.Texture2D = module.exports = Texture2D;
    }, {
        "../CCGame": 19,
        "../assets/CCRawAsset": 27,
        "../event/event-target": 52,
        "../platform/CCClass": 57,
        "../platform/CCSys": 63,
        "../platform/_CCClass": 64,
        "../platform/js": 70
    } ],
    79: [ function(require, module, exports) {
        var Class = require("../platform/_CCClass");
        var JS = require("../platform/js");
        var game = require("../CCGame");
        var TextureAtlas = Class.extend({
            dirty: false,
            texture: null,
            _indices: null,
            _buffersVBO: null,
            _capacity: 0,
            _quads: null,
            _quadsArrayBuffer: null,
            _quadsWebBuffer: null,
            _quadsReader: null,
            ctor: function(fileName, capacity) {
                this._buffersVBO = [];
                if (cc.js.isString(fileName)) {
                    this.initWithFile(fileName, capacity);
                } else {
                    if (fileName instanceof cc.Texture2D) {
                        this.initWithTexture(fileName, capacity);
                    }
                }
            },
            getTotalQuads: function() {
                return this._totalQuads;
            },
            getCapacity: function() {
                return this._capacity;
            },
            getTexture: function() {
                return this.texture;
            },
            setTexture: function(texture) {
                this.texture = texture;
            },
            setDirty: function(dirty) {
                this.dirty = dirty;
            },
            isDirty: function() {
                return this.dirty;
            },
            getQuads: function() {
                return this._quads;
            },
            setQuads: function(quads) {
                this._quads = quads;
            },
            _copyQuadsToTextureAtlas: function(quads, index) {
                if (!quads) {
                    return;
                }
                for (var i = 0; i < quads.length; i++) {
                    this._setQuadToArray(quads[i], index + i);
                }
            },
            _setQuadToArray: function(quad, index) {
                var locQuads = this._quads;
                if (!locQuads[index]) {
                    locQuads[index] = new cc.V3F_C4B_T2F_Quad(quad.tl, quad.bl, quad.tr, quad.br, this._quadsArrayBuffer, index * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT);
                    return;
                }
                locQuads[index].bl = quad.bl;
                locQuads[index].br = quad.br;
                locQuads[index].tl = quad.tl;
                locQuads[index].tr = quad.tr;
            },
            description: function() {
                return "<cc.TextureAtlas | totalQuads =" + this._totalQuads + ">";
            },
            _setupIndices: function() {
                if (0 === this._capacity) {
                    return;
                }
                var locIndices = this._indices, locCapacity = this._capacity;
                for (var i = 0; i < locCapacity; i++) {
                    if (cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP) {
                        locIndices[6 * i + 0] = 4 * i + 0;
                        locIndices[6 * i + 1] = 4 * i + 0;
                        locIndices[6 * i + 2] = 4 * i + 2;
                        locIndices[6 * i + 3] = 4 * i + 1;
                        locIndices[6 * i + 4] = 4 * i + 3;
                        locIndices[6 * i + 5] = 4 * i + 3;
                    } else {
                        locIndices[6 * i + 0] = 4 * i + 0;
                        locIndices[6 * i + 1] = 4 * i + 1;
                        locIndices[6 * i + 2] = 4 * i + 2;
                        locIndices[6 * i + 3] = 4 * i + 3;
                        locIndices[6 * i + 4] = 4 * i + 2;
                        locIndices[6 * i + 5] = 4 * i + 1;
                    }
                }
            },
            initWithFile: function(file, capacity) {
                var texture = cc.textureCache.addImage(file);
                if (texture) {
                    return this.initWithTexture(texture, capacity);
                } else {
                    cc.log(cc._LogInfos.TextureAtlas.initWithFile, file);
                    return false;
                }
            },
            initWithTexture: function(texture, capacity) {
                cc.assert(texture, cc._LogInfos.TextureAtlas.initWithTexture);
                capacity = 0 | capacity;
                this._capacity = capacity;
                this._totalQuads = 0;
                this.texture = texture;
                this._quads = [];
                this._indices = new Uint16Array(6 * capacity);
                var quadSize = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
                this._quadsArrayBuffer = new ArrayBuffer(quadSize * capacity);
                this._quadsReader = new Uint8Array(this._quadsArrayBuffer);
                if (!(this._quads && this._indices) && capacity > 0) {
                    return false;
                }
                var locQuads = this._quads;
                for (var i = 0; i < capacity; i++) {
                    locQuads[i] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, i * quadSize);
                }
                this._setupIndices();
                this._setupVBO();
                this.dirty = true;
                return true;
            },
            updateQuad: function(quad, index) {
                cc.assert(quad, cc._LogInfos.TextureAtlas.updateQuad);
                cc.assert(index >= 0 && index < this._capacity, cc._LogInfos.TextureAtlas.updateQuad_2);
                this._totalQuads = Math.max(index + 1, this._totalQuads);
                this._setQuadToArray(quad, index);
                this.dirty = true;
            },
            insertQuad: function(quad, index) {
                cc.assert(index < this._capacity, cc._LogInfos.TextureAtlas.insertQuad_2);
                this._totalQuads++;
                if (this._totalQuads > this._capacity) {
                    cc.log(cc._LogInfos.TextureAtlas.insertQuad);
                    return;
                }
                var quadSize = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
                var remaining = this._totalQuads - 1 - index;
                var startOffset = index * quadSize;
                var moveLength = remaining * quadSize;
                this._quads[this._totalQuads - 1] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, (this._totalQuads - 1) * quadSize);
                this._quadsReader.set(this._quadsReader.subarray(startOffset, startOffset + moveLength), startOffset + quadSize);
                this._setQuadToArray(quad, index);
                this.dirty = true;
            },
            insertQuads: function(quads, index, amount) {
                amount = amount || quads.length;
                cc.assert(index + amount <= this._capacity, cc._LogInfos.TextureAtlas.insertQuads);
                var quadSize = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
                this._totalQuads += amount;
                if (this._totalQuads > this._capacity) {
                    cc.log(cc._LogInfos.TextureAtlas.insertQuad);
                    return;
                }
                var remaining = this._totalQuads - 1 - index - amount;
                var startOffset = index * quadSize;
                var moveLength = remaining * quadSize;
                var lastIndex = this._totalQuads - 1 - amount;
                var i;
                for (i = 0; i < amount; i++) {
                    this._quads[lastIndex + i] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, (this._totalQuads - 1) * quadSize);
                }
                this._quadsReader.set(this._quadsReader.subarray(startOffset, startOffset + moveLength), startOffset + quadSize * amount);
                for (i = 0; i < amount; i++) {
                    this._setQuadToArray(quads[i], index + i);
                }
                this.dirty = true;
            },
            insertQuadFromIndex: function(fromIndex, newIndex) {
                if (fromIndex === newIndex) {
                    return;
                }
                cc.assert(newIndex >= 0 || newIndex < this._totalQuads, cc._LogInfos.TextureAtlas.insertQuadFromIndex);
                cc.assert(fromIndex >= 0 || fromIndex < this._totalQuads, cc._LogInfos.TextureAtlas.insertQuadFromIndex_2);
                var quadSize = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
                var locQuadsReader = this._quadsReader;
                var sourceArr = locQuadsReader.subarray(fromIndex * quadSize, quadSize);
                var startOffset, moveLength;
                if (fromIndex > newIndex) {
                    startOffset = newIndex * quadSize;
                    moveLength = (fromIndex - newIndex) * quadSize;
                    locQuadsReader.set(locQuadsReader.subarray(startOffset, startOffset + moveLength), startOffset + quadSize);
                    locQuadsReader.set(sourceArr, startOffset);
                } else {
                    startOffset = (fromIndex + 1) * quadSize;
                    moveLength = (newIndex - fromIndex) * quadSize;
                    locQuadsReader.set(locQuadsReader.subarray(startOffset, startOffset + moveLength), startOffset - quadSize);
                    locQuadsReader.set(sourceArr, newIndex * quadSize);
                }
                this.dirty = true;
            },
            removeQuadAtIndex: function(index) {
                cc.assert(index < this._totalQuads, cc._LogInfos.TextureAtlas.removeQuadAtIndex);
                var quadSize = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
                this._totalQuads--;
                this._quads.length = this._totalQuads;
                if (index !== this._totalQuads) {
                    var startOffset = (index + 1) * quadSize;
                    var moveLength = (this._totalQuads - index) * quadSize;
                    this._quadsReader.set(this._quadsReader.subarray(startOffset, startOffset + moveLength), startOffset - quadSize);
                }
                this.dirty = true;
            },
            removeQuadsAtIndex: function(index, amount) {
                cc.assert(index + amount <= this._totalQuads, cc._LogInfos.TextureAtlas.removeQuadsAtIndex);
                this._totalQuads -= amount;
                if (index !== this._totalQuads) {
                    var quadSize = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
                    var srcOffset = (index + amount) * quadSize;
                    var moveLength = (this._totalQuads - index) * quadSize;
                    var dstOffset = index * quadSize;
                    this._quadsReader.set(this._quadsReader.subarray(srcOffset, srcOffset + moveLength), dstOffset);
                }
                this.dirty = true;
            },
            removeAllQuads: function() {
                this._quads.length = 0;
                this._totalQuads = 0;
            },
            _setDirty: function(dirty) {
                this.dirty = dirty;
            },
            resizeCapacity: function(newCapacity) {
                if (newCapacity === this._capacity) {
                    return true;
                }
                var quadSize = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
                var oldCapacity = this._capacity;
                this._totalQuads = Math.min(this._totalQuads, newCapacity);
                this._capacity = 0 | newCapacity;
                var i, capacity = this._capacity, locTotalQuads = this._totalQuads;
                if (null === this._quads) {
                    this._quads = [];
                    this._quadsArrayBuffer = new ArrayBuffer(quadSize * capacity);
                    this._quadsReader = new Uint8Array(this._quadsArrayBuffer);
                    for (i = 0; i < capacity; i++) {
                        this._quads = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, i * quadSize);
                    }
                } else {
                    var newQuads, newArrayBuffer, quads = this._quads;
                    if (capacity > oldCapacity) {
                        newQuads = [];
                        newArrayBuffer = new ArrayBuffer(quadSize * capacity);
                        for (i = 0; i < locTotalQuads; i++) {
                            newQuads[i] = new cc.V3F_C4B_T2F_Quad(quads[i].tl, quads[i].bl, quads[i].tr, quads[i].br, newArrayBuffer, i * quadSize);
                        }
                        for (;i < capacity; i++) {
                            newQuads[i] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, newArrayBuffer, i * quadSize);
                        }
                        this._quadsReader = new Uint8Array(newArrayBuffer);
                        this._quads = newQuads;
                        this._quadsArrayBuffer = newArrayBuffer;
                    } else {
                        var count = Math.max(locTotalQuads, capacity);
                        newQuads = [];
                        newArrayBuffer = new ArrayBuffer(quadSize * capacity);
                        for (i = 0; i < count; i++) {
                            newQuads[i] = new cc.V3F_C4B_T2F_Quad(quads[i].tl, quads[i].bl, quads[i].tr, quads[i].br, newArrayBuffer, i * quadSize);
                        }
                        this._quadsReader = new Uint8Array(newArrayBuffer);
                        this._quads = newQuads;
                        this._quadsArrayBuffer = newArrayBuffer;
                    }
                }
                if (null === this._indices) {
                    this._indices = new Uint16Array(6 * capacity);
                } else {
                    if (capacity > oldCapacity) {
                        var tempIndices = new Uint16Array(6 * capacity);
                        tempIndices.set(this._indices, 0);
                        this._indices = tempIndices;
                    } else {
                        this._indices = this._indices.subarray(0, 6 * capacity);
                    }
                }
                this._setupIndices();
                this._mapBuffers();
                this.dirty = true;
                return true;
            },
            increaseTotalQuadsWith: function(amount) {
                this._totalQuads += amount;
            },
            moveQuadsFromIndex: function(oldIndex, amount, newIndex) {
                if (void 0 === newIndex) {
                    newIndex = amount;
                    amount = this._totalQuads - oldIndex;
                    cc.assert(newIndex + (this._totalQuads - oldIndex) <= this._capacity, cc._LogInfos.TextureAtlas.moveQuadsFromIndex);
                    if (0 === amount) {
                        return;
                    }
                } else {
                    cc.assert(newIndex + amount <= this._totalQuads, cc._LogInfos.TextureAtlas.moveQuadsFromIndex_2);
                    cc.assert(oldIndex < this._totalQuads, cc._LogInfos.TextureAtlas.moveQuadsFromIndex_3);
                    if (oldIndex === newIndex) {
                        return;
                    }
                }
                var quadSize = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
                var srcOffset = oldIndex * quadSize;
                var srcLength = amount * quadSize;
                var locQuadsReader = this._quadsReader;
                var sourceArr = locQuadsReader.subarray(srcOffset, srcOffset + srcLength);
                var dstOffset = newIndex * quadSize;
                var moveLength, moveStart;
                if (newIndex < oldIndex) {
                    moveLength = (oldIndex - newIndex) * quadSize;
                    moveStart = newIndex * quadSize;
                    locQuadsReader.set(locQuadsReader.subarray(moveStart, moveStart + moveLength), moveStart + srcLength);
                } else {
                    moveLength = (newIndex - oldIndex) * quadSize;
                    moveStart = (oldIndex + amount) * quadSize;
                    locQuadsReader.set(locQuadsReader.subarray(moveStart, moveStart + moveLength), srcOffset);
                }
                locQuadsReader.set(sourceArr, dstOffset);
                this.dirty = true;
            },
            fillWithEmptyQuadsFromIndex: function(index, amount) {
                var count = amount * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
                var clearReader = new Uint8Array(this._quadsArrayBuffer, index * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, count);
                for (var i = 0; i < count; i++) {
                    clearReader[i] = 0;
                }
            },
            _setupVBO: function() {},
            _mapBuffers: function() {},
            drawQuads: function() {},
            drawNumberOfQuads: null,
            _releaseBuffer: function() {
                var gl = cc._renderContext;
                if (this._buffersVBO) {
                    if (this._buffersVBO[0]) {
                        gl.deleteBuffer(this._buffersVBO[0]);
                    }
                    if (this._buffersVBO[1]) {
                        gl.deleteBuffer(this._buffersVBO[1]);
                    }
                }
                if (this._quadsWebBuffer) {
                    gl.deleteBuffer(this._quadsWebBuffer);
                }
            }
        });
        var _p = TextureAtlas.prototype;
        _p.totalQuads;
        cc.defineGetterSetter(_p, "totalQuads", _p.getTotalQuads);
        _p.capacity;
        cc.defineGetterSetter(_p, "capacity", _p.getCapacity);
        _p.quads;
        cc.defineGetterSetter(_p, "quads", _p.getQuads, _p.setQuads);
        game.once(game.EVENT_RENDERER_INITED, function() {
            if (cc._renderType === game.RENDER_TYPE_WEBGL) {
                JS.mixin(TextureAtlas.prototype, {
                    _setupVBO: function() {
                        var _t = this;
                        var gl = cc._renderContext;
                        _t._buffersVBO[0] = gl.createBuffer();
                        _t._buffersVBO[1] = gl.createBuffer();
                        _t._quadsWebBuffer = gl.createBuffer();
                        _t._mapBuffers();
                    },
                    _mapBuffers: function() {
                        var _t = this;
                        var gl = cc._renderContext;
                        gl.bindBuffer(gl.ARRAY_BUFFER, _t._quadsWebBuffer);
                        gl.bufferData(gl.ARRAY_BUFFER, _t._quadsArrayBuffer, gl.DYNAMIC_DRAW);
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _t._buffersVBO[1]);
                        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, _t._indices, gl.STATIC_DRAW);
                    },
                    drawQuads: function() {
                        this.drawNumberOfQuads(this._totalQuads, 0);
                    },
                    drawNumberOfQuads: function(n, start) {
                        var _t = this;
                        start = start || 0;
                        if (0 === n || !_t.texture || !_t.texture.isLoaded()) {
                            return;
                        }
                        var gl = cc._renderContext;
                        cc.glBindTexture2D(_t.texture);
                        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
                        gl.bindBuffer(gl.ARRAY_BUFFER, _t._quadsWebBuffer);
                        if (_t.dirty) {
                            gl.bufferData(gl.ARRAY_BUFFER, _t._quadsArrayBuffer, gl.DYNAMIC_DRAW);
                            _t.dirty = false;
                        }
                        gl.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, gl.FLOAT, false, 24, 0);
                        gl.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, gl.UNSIGNED_BYTE, true, 24, 12);
                        gl.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, gl.FLOAT, false, 24, 16);
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _t._buffersVBO[1]);
                        if (cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP) {
                            gl.drawElements(gl.TRIANGLE_STRIP, 6 * n, gl.UNSIGNED_SHORT, 6 * start * _t._indices.BYTES_PER_ELEMENT);
                        } else {
                            gl.drawElements(gl.TRIANGLES, 6 * n, gl.UNSIGNED_SHORT, 6 * start * _t._indices.BYTES_PER_ELEMENT);
                        }
                        cc.g_NumberOfDraws++;
                    }
                });
            }
        });
        cc.TextureAtlas = module.exports = TextureAtlas;
    }, {
        "../CCGame": 19,
        "../platform/_CCClass": 64,
        "../platform/js": 70
    } ],
    80: [ function(require, module, exports) {
        var JS = require("../platform/js");
        var game = require("../CCGame");
        var Texture2D = require("./CCTexture2D");
        var textureCache = {
            _textures: {},
            _textureColorsCache: {},
            _textureKeySeq: 0 | 1e3 * Math.random(),
            _loadedTexturesBefore: {},
            handleLoadedTexture: null,
            _initializingRenderer: function() {
                var selPath;
                var locLoadedTexturesBefore = this._loadedTexturesBefore, locTextures = this._textures;
                for (selPath in locLoadedTexturesBefore) {
                    var tex2d = locLoadedTexturesBefore[selPath];
                    tex2d.handleLoadedTexture();
                    locTextures[selPath] = tex2d;
                }
                this._loadedTexturesBefore = {};
            },
            description: function() {
                return "<TextureCache | Number of textures = " + this._textures.length + ">";
            },
            textureForKey: function(textureKeyName) {
                cc.log(cc._LogInfos.textureCache.textureForKey);
                return this.getTextureForKey(textureKeyName);
            },
            getTextureForKey: function(textureKeyName) {
                return this._textures[textureKeyName] || this._textures[cc.loader.getAliase(textureKeyName)];
            },
            getKeyByTexture: function(texture) {
                for (var key in this._textures) {
                    if (this._textures[key] === texture) {
                        return key;
                    }
                }
                return null;
            },
            _generalTextureKey: function(id) {
                return "_textureKey_" + id;
            },
            getTextureColors: function(texture) {
                var image = texture._htmlElementObj;
                var key = this.getKeyByTexture(image);
                if (!key) {
                    if (image instanceof HTMLImageElement) {
                        key = image.src;
                    } else {
                        key = this._generalTextureKey(texture.__instanceId);
                    }
                }
                if (!this._textureColorsCache[key]) {
                    this._textureColorsCache[key] = texture._generateTextureCacheForColor();
                }
                return this._textureColorsCache[key];
            },
            removeAllTextures: function() {
                var locTextures = this._textures;
                for (var selKey in locTextures) {
                    if (locTextures[selKey]) {
                        locTextures[selKey].releaseTexture();
                    }
                }
                this._textures = {};
            },
            removeTexture: function(texture) {
                if (!texture) {
                    return;
                }
                var locTextures = this._textures;
                for (var selKey in locTextures) {
                    if (locTextures[selKey] === texture) {
                        locTextures[selKey].releaseTexture();
                        delete locTextures[selKey];
                    }
                }
            },
            removeTextureForKey: function(textureKeyName) {
                if (null == textureKeyName) {
                    return;
                }
                if (this._textures[textureKeyName]) {
                    delete this._textures[textureKeyName];
                }
            },
            addImage: null,
            addImageAsync: null,
            cacheImage: function(path, texture) {
                cc.assert(path, cc._LogInfos.textureCache.invalidKey);
                if (texture instanceof Texture2D) {
                    this._textures[path] = texture;
                    return;
                }
                var texture2d = new Texture2D();
                texture2d.initWithElement(texture);
                texture2d.handleLoadedTexture();
                this._textures[path] = texture2d;
            },
            addUIImage: function(image, key) {
                cc.assert(image, cc._LogInfos.textureCache.addUIImage_2);
                if (key && this._textures[key]) {
                    return this._textures[key];
                }
                var texture = new Texture2D();
                texture.initWithImage(image);
                if (null != key) {
                    this._textures[key] = texture;
                } else {
                    cc.log(cc._LogInfos.textureCache.addUIImage);
                }
                return texture;
            },
            dumpCachedTextureInfo: function() {
                var count = 0;
                var totalBytes = 0, locTextures = this._textures;
                for (var key in locTextures) {
                    var selTexture = locTextures[key];
                    count++;
                    if (selTexture.getHtmlElementObj() instanceof HTMLImageElement) {
                        cc.log(cc._LogInfos.textureCache.dumpCachedTextureInfo, key, selTexture.getHtmlElementObj().src, selTexture.getPixelWidth(), selTexture.getPixelHeight());
                    } else {
                        cc.log(cc._LogInfos.textureCache.dumpCachedTextureInfo_2, key, selTexture.getPixelWidth(), selTexture.getPixelHeight());
                    }
                    totalBytes += selTexture.getPixelWidth() * selTexture.getPixelHeight() * 4;
                }
                var locTextureColorsCache = this._textureColorsCache;
                for (key in locTextureColorsCache) {
                    var selCanvasColorsArr = locTextureColorsCache[key];
                    for (var selCanvasKey in selCanvasColorsArr) {
                        var selCanvas = selCanvasColorsArr[selCanvasKey];
                        count++;
                        cc.log(cc._LogInfos.textureCache.dumpCachedTextureInfo_2, key, selCanvas.width, selCanvas.height);
                        totalBytes += selCanvas.width * selCanvas.height * 4;
                    }
                }
                cc.log(cc._LogInfos.textureCache.dumpCachedTextureInfo_3, count, totalBytes / 1024, (totalBytes / 1048576).toFixed(2));
            },
            _clear: function() {
                this._textures = {};
                this._textureColorsCache = {};
                this._textureKeySeq = 0 | 1e3 * Math.random();
                this._loadedTexturesBefore = {};
            }
        };
        game.once(game.EVENT_RENDERER_INITED, function() {
            var _p = textureCache;
            if (cc._renderType === game.RENDER_TYPE_CANVAS) {
                _p.handleLoadedTexture = function(url) {
                    var locTexs = this._textures;
                    var tex = locTexs[url];
                    if (!tex) {
                        cc.assert(url, cc._LogInfos.textureCache.invalidKey);
                        tex = locTexs[url] = new Texture2D();
                        tex.url = url;
                    }
                    tex.handleLoadedTexture();
                };
                _p.addImage = function(url, cb, target) {
                    cc.assert(url, cc._LogInfos.Texture2D.addImage);
                    var locTexs = this._textures;
                    var tex = locTexs[url] || locTexs[cc.loader.getAliase(url)];
                    if (tex) {
                        if (tex.isLoaded()) {
                            cb && cb.call(target, tex);
                            return tex;
                        } else {
                            tex.once("load", function() {
                                cb && cb.call(target, tex);
                            }, target);
                            return tex;
                        }
                    }
                    tex = locTexs[url] = new Texture2D();
                    tex.url = url;
                    cc.loader.loadImg(url, function(err, img) {
                        if (err) {
                            return cb && cb.call(target, err);
                        }
                        tex.initWithElement(img);
                        textureCache.handleLoadedTexture(url);
                        cb && cb.call(target, tex);
                    });
                    return tex;
                };
                _p.addImageAsync = _p.addImage;
            } else {
                if (cc._renderType === game.RENDER_TYPE_WEBGL) {
                    _p.handleLoadedTexture = function(url) {
                        var locTexs = this._textures, tex, premultiplied;
                        if (!cc.game._rendererInitialized) {
                            locTexs = this._loadedTexturesBefore;
                        }
                        tex = locTexs[url];
                        if (!tex) {
                            cc.assert(url, cc._LogInfos.textureCache.invalidKey);
                            tex = locTexs[url] = new Texture2D();
                            tex.url = url;
                        }
                        premultiplied = cc.AUTO_PREMULTIPLIED_ALPHA_FOR_PNG && ".png" === cc.path.extname(url);
                        tex.handleLoadedTexture(premultiplied);
                    };
                    _p.addImage = function(url, cb, target) {
                        cc.assert(url, cc._LogInfos.Texture2D.addImage_2);
                        var locTexs = this._textures;
                        if (!cc.game._rendererInitialized) {
                            locTexs = this._loadedTexturesBefore;
                        }
                        var tex = locTexs[url] || locTexs[cc.loader.getAliase(url)];
                        if (tex) {
                            if (tex.isLoaded()) {
                                cb && cb.call(target, tex);
                                return tex;
                            } else {
                                tex.once("load", function() {
                                    cb && cb.call(target, tex);
                                }, target);
                                return tex;
                            }
                        }
                        tex = locTexs[url] = new Texture2D();
                        tex.url = url;
                        cc.loader.loadImg(url, function(err, img) {
                            if (err) {
                                return cb && cb.call(target, err);
                            }
                            tex.initWithElement(img);
                            textureCache.handleLoadedTexture(url);
                            cb && cb.call(target, tex);
                        });
                        return tex;
                    };
                    _p.addImageAsync = _p.addImage;
                }
            }
        });
        cc.textureCache = module.exports = textureCache;
    }, {
        "../CCGame": 19,
        "../platform/js": 70,
        "./CCTexture2D": 78
    } ],
    81: [ function(require, module, exports) {
        require("./CCTexture2D");
        require("./CCTextureAtlas");
        require("./CCTextureCache");
    }, {
        "./CCTexture2D": 78,
        "./CCTextureAtlas": 79,
        "./CCTextureCache": 80
    } ],
    82: [ function(require, module, exports) {
        cc.AsyncPool = function(srcObj, limit, iterator, onEnd, target) {
            var self = this;
            self._srcObj = srcObj;
            self._limit = limit;
            self._pool = [];
            self._iterator = iterator;
            self._iteratorTarget = target;
            self._onEnd = onEnd;
            self._onEndTarget = target;
            self._errors = [];
            self._results = srcObj instanceof Array ? [] : {};
            cc.each(srcObj, function(value, index) {
                self._pool.push({
                    index: index,
                    value: value
                });
            });
            self.size = self._pool.length;
            self.finishedSize = 0;
            self._workingSize = 0;
            self._limit = self._limit || self.size;
            self.onIterator = function(iterator, target) {
                self._iterator = iterator;
                self._iteratorTarget = target;
            };
            self.onEnd = function(endCb, endCbTarget) {
                self._onEnd = endCb;
                self._onEndTarget = endCbTarget;
            };
            self._handleItem = function() {
                var self = this;
                if (0 === self._pool.length || self._workingSize >= self._limit) {
                    return;
                }
                var item = self._pool.shift();
                var value = item.value, index = item.index;
                self._workingSize++;
                self._iterator.call(self._iteratorTarget, value, index, function(err, res) {
                    self.finishedSize++;
                    self._workingSize--;
                    if (err) {
                        self._errors.push(err);
                    }
                    self._results[this.index] = res;
                    if (self.finishedSize === self.size) {
                        if (self._onEnd) {
                            self._onEnd.call(self._onEndTarget, self._errors.length > 0 ? self._errors : null, self._results);
                        }
                        return;
                    }
                    self._handleItem();
                }.bind(item), self);
            };
            self.flow = function() {
                var self = this;
                if (0 === self._pool.length) {
                    if (self._onEnd) {
                        self._onEnd.call(self._onEndTarget, null, []);
                    }
                    return;
                }
                for (var i = 0; i < self._limit; i++) {
                    self._handleItem();
                }
            };
        };
        cc.async = {
            series: function(tasks, cb, target) {
                var asyncPool = new cc.AsyncPool(tasks, 1, function(func, index, cb1) {
                    func.call(target, cb1);
                }, cb, target);
                asyncPool.flow();
                return asyncPool;
            },
            parallel: function(tasks, cb, target) {
                var asyncPool = new cc.AsyncPool(tasks, 0, function(func, index, cb1) {
                    func.call(target, cb1);
                }, cb, target);
                asyncPool.flow();
                return asyncPool;
            },
            waterfall: function(tasks, cb, target) {
                var args = [];
                var lastResults = [ null ];
                var asyncPool = new cc.AsyncPool(tasks, 1, function(func, index, cb1) {
                    args.push(function(err) {
                        args = Array.prototype.slice.call(arguments, 1);
                        if (tasks.length - 1 === index) {
                            lastResults = lastResults.concat(args);
                        }
                        cb1.apply(null, arguments);
                    });
                    func.apply(target, args);
                }, function(err) {
                    if (!cb) {
                        return;
                    }
                    if (err) {
                        return cb.call(target, err);
                    }
                    cb.apply(target, lastResults);
                });
                asyncPool.flow();
                return asyncPool;
            },
            map: function(tasks, iterator, callback, target) {
                var locIterator = iterator;
                if ("object" === typeof iterator) {
                    callback = iterator.cb;
                    target = iterator.iteratorTarget;
                    locIterator = iterator.iterator;
                }
                var asyncPool = new cc.AsyncPool(tasks, 0, locIterator, callback, target);
                asyncPool.flow();
                return asyncPool;
            },
            mapLimit: function(tasks, limit, iterator, cb, target) {
                var asyncPool = new cc.AsyncPool(tasks, limit, iterator, cb, target);
                asyncPool.flow();
                return asyncPool;
            }
        };
    }, {} ],
    83: [ function(require, module, exports) {
        require("../platform/CCSys");
        cc.path = {
            normalizeRE: /[^\.\/]+\/\.\.\//,
            join: function() {
                var l = arguments.length;
                var result = "";
                for (var i = 0; i < l; i++) {
                    result = (result + ("" === result ? "" : "/") + arguments[i]).replace(/(\/|\\\\)$/, "");
                }
                return result;
            },
            extname: function(pathStr) {
                var temp = /(\.[^\.\/\?\\]*)(\?.*)?$/.exec(pathStr);
                return temp ? temp[1] : null;
            },
            mainFileName: function(fileName) {
                if (fileName) {
                    var idx = fileName.lastIndexOf(".");
                    if (-1 !== idx) {
                        return fileName.substring(0, idx);
                    }
                }
                return fileName;
            },
            basename: function(pathStr, extname) {
                var index = pathStr.indexOf("?");
                if (index > 0) {
                    pathStr = pathStr.substring(0, index);
                }
                var reg = /(\/|\\\\)([^(\/|\\\\)]+)$/g;
                var result = reg.exec(pathStr.replace(/(\/|\\\\)$/, ""));
                if (!result) {
                    return null;
                }
                var baseName = result[2];
                if (extname && pathStr.substring(pathStr.length - extname.length).toLowerCase() === extname.toLowerCase()) {
                    return baseName.substring(0, baseName.length - extname.length);
                }
                return baseName;
            },
            dirname: function(pathStr) {
                return pathStr.replace(/((.*)(\/|\\|\\\\))?(.*?\..*$)?/, "$2");
            },
            changeExtname: function(pathStr, extname) {
                extname = extname || "";
                var index = pathStr.indexOf("?");
                var tempStr = "";
                if (index > 0) {
                    tempStr = pathStr.substring(index);
                    pathStr = pathStr.substring(0, index);
                }
                index = pathStr.lastIndexOf(".");
                if (index < 0) {
                    return pathStr + extname + tempStr;
                }
                return pathStr.substring(0, index) + extname + tempStr;
            },
            changeBasename: function(pathStr, basename, isSameExt) {
                if (0 === basename.indexOf(".")) {
                    return this.changeExtname(pathStr, basename);
                }
                var index = pathStr.indexOf("?");
                var tempStr = "";
                var ext = isSameExt ? this.extname(pathStr) : "";
                if (index > 0) {
                    tempStr = pathStr.substring(index);
                    pathStr = pathStr.substring(0, index);
                }
                index = pathStr.lastIndexOf("/");
                index = index <= 0 ? 0 : index + 1;
                return pathStr.substring(0, index) + basename + ext + tempStr;
            },
            _normalize: function(url) {
                var oldUrl = url = String(url);
                do {
                    oldUrl = url;
                    url = url.replace(this.normalizeRE, "");
                } while (oldUrl.length !== url.length);
                return url;
            },
            sep: cc.sys.os === cc.sys.OS_WINDOWS ? "\\" : "/",
            _setEndWithSep: function(path, endsWithSep) {
                var sep = cc.path.sep;
                if ("undefined" === typeof endsWithSep) {
                    endsWithSep = true;
                } else {
                    if ("string" === typeof endsWithSep) {
                        sep = endsWithSep;
                        endsWithSep = !!endsWithSep;
                    }
                }
                var endChar = path[path.length - 1];
                var oldEndWithSep = "\\" === endChar || "/" === endChar;
                if (!oldEndWithSep && endsWithSep) {
                    path += sep;
                } else {
                    if (oldEndWithSep && !endsWithSep) {
                        path = path.slice(0, -1);
                    }
                }
                return path;
            }
        };
    }, {
        "../platform/CCSys": 63
    } ],
    84: [ function(require, module, exports) {
        cc.profiler = function() {
            var _inited = _showFPS = false;
            var _frames = _frameRate = _lastSPF = _accumDt = 0;
            var _afterProjection = _afterVisitListener = _FPSLabel = _SPFLabel = _drawsLabel = null;
            var LEVEL_DET_FACTOR = .6, _levelDetCycle = 10;
            var LEVELS = [ 0, 10, 20, 30 ];
            var _fpsCount = [ 0, 0, 0, 0 ];
            var _currLevel = 3, _analyseCount = 0, _totalFPS = 0;
            var createStatsLabel = function() {
                var fontSize = 0;
                var w = cc.winSize.width, h = cc.winSize.height;
                var locStatsPosition = cc.DIRECTOR_STATS_POSITION;
                if (w > h) {
                    fontSize = 0 | h / 320 * 24;
                } else {
                    fontSize = 0 | w / 320 * 24;
                }
                _FPSLabel = new _ccsg.Label("000.0", "Arial");
                _SPFLabel = new _ccsg.Label("0.000", "Arial");
                _drawsLabel = new _ccsg.Label("0000", "Arial");
                _FPSLabel.setFontSize(fontSize);
                _SPFLabel.setFontSize(fontSize);
                _drawsLabel.setFontSize(fontSize);
                _FPSLabel.setContentSize(120, 40);
                _SPFLabel.setContentSize(120, 40);
                _drawsLabel.setContentSize(120, 40);
                _drawsLabel.setPosition(_drawsLabel.width / 2 + locStatsPosition.x, 5 * _drawsLabel.height / 2 + locStatsPosition.y);
                _SPFLabel.setPosition(_SPFLabel.width / 2 + locStatsPosition.x, 3 * _SPFLabel.height / 2 + locStatsPosition.y);
                _FPSLabel.setPosition(_FPSLabel.width / 2 + locStatsPosition.x, _FPSLabel.height / 2 + locStatsPosition.y);
            };
            var analyseFPS = function(fps) {
                var lastId = i = LEVELS.length - 1, ratio, average = 0;
                _analyseCount++;
                _totalFPS += fps;
                for (;i >= 0; i--) {
                    if (fps >= LEVELS[i]) {
                        _fpsCount[i]++;
                        break;
                    }
                }
                if (_analyseCount >= _levelDetCycle) {
                    average = _totalFPS / _levelDetCycle;
                    for (i = lastId; i > 0; i--) {
                        ratio = _fpsCount[i] / _levelDetCycle;
                        if (ratio >= LEVEL_DET_FACTOR && average >= LEVELS[i]) {
                            if (i != _currLevel) {
                                _currLevel = i;
                                profiler.onFrameRateChange && profiler.onFrameRateChange(average.toFixed(2));
                            }
                            break;
                        }
                    }
                    _changeCount = 0;
                    _analyseCount = 0;
                    _totalFPS = 0;
                    for (i = lastId; i > 0; i--) {
                        _fpsCount[i] = 0;
                    }
                }
            };
            var afterVisit = function() {
                _lastSPF = cc.director.getSecondsPerFrame();
                _frames++;
                _accumDt += cc.director.getDeltaTime();
                if (_accumDt > cc.DIRECTOR_FPS_INTERVAL) {
                    _frameRate = _frames / _accumDt;
                    _frames = 0;
                    _accumDt = 0;
                    if (profiler.onFrameRateChange) {
                        analyseFPS(_frameRate);
                    }
                    if (_showFPS) {
                        _SPFLabel.setString(_lastSPF.toFixed(3));
                        _FPSLabel.setString(_frameRate.toFixed(1));
                        _drawsLabel.setString((0 | cc.g_NumberOfDraws).toString());
                    }
                }
                if (_showFPS) {
                    _FPSLabel.visit();
                    _SPFLabel.visit();
                    _drawsLabel.visit();
                }
            };
            var afterProjection = function() {
                _FPSLabel._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
                _SPFLabel._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
                _drawsLabel._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
            };
            var profiler = {
                onFrameRateChange: null,
                getSecondsPerFrame: function() {
                    return _lastSPF;
                },
                getFrameRate: function() {
                    return _frameRate;
                },
                setProfileDuration: function(duration) {
                    if (!isNaN(duration) && duration > 0) {
                        _levelDetCycle = duration / cc.DIRECTOR_FPS_INTERVAL;
                    }
                },
                resumeProfiling: function() {
                    cc.director.on(cc.Director.EVENT_AFTER_VISIT, afterVisit);
                    cc.director.on(cc.Director.EVENT_PROJECTION_CHANGED, afterProjection);
                },
                stopProfiling: function() {
                    cc.director.off(cc.Director.EVENT_AFTER_VISIT, afterVisit);
                    cc.director.off(cc.Director.EVENT_PROJECTION_CHANGED, afterProjection);
                },
                isShowingStats: function() {
                    return _showFPS;
                },
                showStats: function() {
                    if (_ccsg.Label && !_FPSLabel) {
                        createStatsLabel();
                    }
                    if (_FPSLabel) {
                        _showFPS = true;
                    }
                    if (!_inited) {
                        this.init();
                    }
                },
                hideStats: function() {
                    _showFPS = false;
                },
                init: function() {
                    if (!_inited) {
                        this.resumeProfiling();
                        _inited = true;
                    }
                }
            };
            return profiler;
        }();
        module.exports = cc.profiler;
    }, {} ],
    85: [ function(require, module, exports) {
        var JS = cc.js;
        var SceneGraphHelper = require("./scene-graph-helper");
        var Destroying = require("../platform/CCObject").Flags.Destroying;
        var DirtyFlags = require("./misc").DirtyFlags;
        function setMaxZOrder(node) {
            var siblings = node.parent.getChildren();
            var z = 0;
            if (siblings.length >= 2) {
                var prevNode = siblings[siblings.length - 2];
                z = prevNode.getOrderOfArrival() + 1;
            }
            node.setOrderOfArrival(z);
            return z;
        }
        var POSITION_CHANGED = "position-changed";
        var ROTATION_CHANGED = "rotation-changed";
        var SCALE_CHANGED = "scale-changed";
        var SIZE_CHANGED = "size-changed";
        var ANCHOR_CHANGED = "anchor-changed";
        var COLOR_CHANGED = "color-changed";
        var OPACITY_CHANGED = "opacity-changed";
        var CHILD_ADDED = "child-added";
        var CHILD_REMOVED = "child-removed";
        var BaseNode = cc.Class({
            "extends": cc.Object,
            mixins: [ cc.EventTarget ],
            properties: {
                _opacity: 255,
                _color: cc.Color.WHITE,
                _cascadeOpacityEnabled: true,
                _parent: null,
                _anchorPoint: cc.p(.5, .5),
                _contentSize: cc.size(0, 0),
                _children: [],
                _rotationX: 0,
                _rotationY: 0,
                _scaleX: 1,
                _scaleY: 1,
                _position: cc.p(0, 0),
                _skewX: 0,
                _skewY: 0,
                _localZOrder: 0,
                _globalZOrder: 0,
                _ignoreAnchorPointForPosition: false,
                _tag: cc.NODE_TAG_INVALID,
                _opacityModifyRGB: false,
                name: {
                    get: function() {
                        return this._name;
                    },
                    set: function(value) {
                        this._name = value;
                    }
                },
                parent: {
                    get: function() {
                        return this._parent;
                    },
                    set: function(value) {
                        if (this._parent === value) {
                            return;
                        }
                        var node = this._sgNode;
                        if (node.parent) {
                            node.parent.removeChild(node, false);
                        }
                        if (value) {
                            var parent = value._sgNode;
                            parent.addChild(node);
                            setMaxZOrder(node);
                            value._children.push(this);
                            value.emit(CHILD_ADDED, this);
                        }
                        var oldParent = this._parent;
                        this._parent = value || null;
                        if (oldParent) {
                            if (!(oldParent._objFlags & Destroying)) {
                                var removeAt = oldParent._children.indexOf(this);
                                if (removeAt < 0 && false) {
                                    return cc.error("Internal error, should not remove unknown node from parent.");
                                }
                                oldParent._children.splice(removeAt, 1);
                                oldParent.emit(CHILD_REMOVED, removeAt);
                                this._onHierarchyChanged(oldParent);
                            }
                        } else {
                            if (value) {
                                this._onHierarchyChanged(null);
                            }
                        }
                    }
                },
                _id: {
                    "default": "",
                    editorOnly: true
                },
                uuid: {
                    get: function() {
                        return this._id || (this._id = window.Editor ? Editor.uuid() : "");
                    }
                },
                skewX: {
                    get: function() {
                        return this._skewX;
                    },
                    set: function(value) {
                        this._skewX = value;
                        this._sgNode.skewX = value;
                    }
                },
                skewY: {
                    get: function() {
                        return this._skewY;
                    },
                    set: function(value) {
                        this._skewY = value;
                        this._sgNode.skewY = value;
                    }
                },
                zIndex: {
                    get: function() {
                        return this._localZOrder;
                    },
                    set: function(value) {
                        this._localZOrder = value;
                        this._sgNode.zIndex = value;
                    }
                },
                rotation: {
                    get: function() {
                        if (this._rotationX !== this._rotationY) {
                            cc.log(cc._LogInfos.Node.getRotation);
                        }
                        return this._rotationX;
                    },
                    set: function(value) {
                        if (this._rotationX !== value || this._rotationY !== value) {
                            var old = this._rotationX;
                            this._rotationX = this._rotationY = value;
                            this._sgNode.rotation = value;
                            this.emit(ROTATION_CHANGED, old);
                        }
                    }
                },
                rotationX: {
                    get: function() {
                        return this._rotationX;
                    },
                    set: function(value) {
                        if (this._rotationX !== value) {
                            var old = this._rotationX;
                            this._rotationX = value;
                            this._sgNode.rotationX = value;
                            this.emit(ROTATION_CHANGED, old);
                        }
                    }
                },
                rotationY: {
                    get: function() {
                        return this._rotationY;
                    },
                    set: function(value) {
                        if (this._rotationY !== value) {
                            var oldX = this._rotationX;
                            this._rotationY = value;
                            this._sgNode.rotationY = value;
                            this.emit(ROTATION_CHANGED, oldX);
                        }
                    }
                },
                scaleX: {
                    get: function() {
                        return this._scaleX;
                    },
                    set: function(value) {
                        if (this._scaleX !== value) {
                            var oldX = this._scaleX;
                            this._scaleX = value;
                            this._sgNode.scaleX = value;
                            this.emit(SCALE_CHANGED, new cc.Vec2(oldX, this._scaleY));
                        }
                    }
                },
                scaleY: {
                    get: function() {
                        return this._scaleY;
                    },
                    set: function(value) {
                        if (this._scaleY !== value) {
                            var oldY = this._scaleY;
                            this._scaleY = value;
                            this._sgNode.scaleY = value;
                            this.emit(SCALE_CHANGED, new cc.Vec2(this._scaleX, oldY));
                        }
                    }
                },
                x: {
                    get: function() {
                        return this._position.x;
                    },
                    set: function(value) {
                        var localPosition = this._position;
                        if (value !== localPosition.x) {
                            var oldValue = localPosition.x;
                            localPosition.x = value;
                            this._sgNode.x = value;
                            if (this.emit) {
                                this.emit(POSITION_CHANGED, new cc.Vec2(oldValue, localPosition.y));
                            }
                        }
                    }
                },
                y: {
                    get: function() {
                        return this._position.y;
                    },
                    set: function(value) {
                        var localPosition = this._position;
                        if (value !== localPosition.y) {
                            var oldValue = localPosition.y;
                            localPosition.y = value;
                            this._sgNode.y = value;
                            if (this.emit) {
                                this.emit(POSITION_CHANGED, new cc.Vec2(localPosition.x, oldValue));
                            }
                        }
                    }
                },
                children: {
                    get: function() {
                        return this._children;
                    }
                },
                childrenCount: {
                    get: function() {
                        return this._children.length;
                    }
                },
                anchorX: {
                    get: function() {
                        return this._anchorPoint.x;
                    },
                    set: function(value) {
                        if (this._anchorPoint.x !== value) {
                            var old = cc.v2(this._anchorPoint);
                            this._anchorPoint.x = value;
                            this._onAnchorChanged();
                            this.emit(ANCHOR_CHANGED, old);
                        }
                    }
                },
                anchorY: {
                    get: function() {
                        return this._anchorPoint.y;
                    },
                    set: function(value) {
                        if (this._anchorPoint.y !== value) {
                            var old = cc.v2(this._anchorPoint);
                            this._anchorPoint.y = value;
                            this._onAnchorChanged();
                            this.emit(ANCHOR_CHANGED, old);
                        }
                    }
                },
                width: {
                    get: function() {
                        if (this._sizeProvider) {
                            var w = this._sizeProvider._getWidth();
                            this._contentSize.width = w;
                            return w;
                        } else {
                            return this._contentSize.width;
                        }
                    },
                    set: function(value) {
                        if (value !== this._contentSize.width) {
                            if (this._sizeProvider) {
                                this._sizeProvider.setContentSize(value, this._sizeProvider._getHeight());
                            }
                            var clone = cc.size(this._contentSize);
                            this._contentSize.width = value;
                            this.emit(SIZE_CHANGED, clone);
                        }
                    }
                },
                height: {
                    get: function() {
                        if (this._sizeProvider) {
                            var h = this._sizeProvider._getHeight();
                            this._contentSize.height = h;
                            return h;
                        } else {
                            return this._contentSize.height;
                        }
                    },
                    set: function(value) {
                        if (value !== this._contentSize.height) {
                            if (this._sizeProvider) {
                                this._sizeProvider.setContentSize(this._sizeProvider._getWidth(), value);
                            }
                            var clone = cc.size(this._contentSize);
                            this._contentSize.height = value;
                            this.emit(SIZE_CHANGED, clone);
                        }
                    }
                },
                ignoreAnchor: {
                    get: function() {
                        return this._ignoreAnchorPointForPosition;
                    },
                    set: function(value) {
                        if (this._ignoreAnchorPointForPosition !== value) {
                            this._ignoreAnchorPointForPosition = value;
                            this._sgNode.ignoreAnchor = value;
                            this._onAnchorChanged();
                            this.emit(ANCHOR_CHANGED, this._anchorPoint);
                        }
                    }
                },
                tag: {
                    get: function() {
                        return this._tag;
                    },
                    set: function(value) {
                        this._tag = value;
                        this._sgNode.tag = value;
                    }
                },
                opacity: {
                    get: function() {
                        return this._opacity;
                    },
                    set: function(value) {
                        if (this._opacity !== value) {
                            var old = this._opacity;
                            this._opacity = value;
                            this._sgNode.opacity = value;
                            this._onColorChanged();
                            this.emit(OPACITY_CHANGED, old);
                        }
                    },
                    range: [ 0, 255 ]
                },
                cascadeOpacity: {
                    get: function() {
                        return this._cascadeOpacityEnabled;
                    },
                    set: function(value) {
                        if (this._cascadeOpacityEnabled !== value) {
                            this._cascadeOpacityEnabled = value;
                            this._sgNode.cascadeOpacity = value;
                            this._onCascadeChanged();
                        }
                    }
                },
                color: {
                    get: function() {
                        var color = this._color;
                        return new cc.Color(color.r, color.g, color.b, color.a);
                    },
                    set: function(value) {
                        if (!this._color.equals(value)) {
                            var color = this._color;
                            var old = cc.color(color);
                            color.r = value.r;
                            color.g = value.g;
                            color.b = value.b;
                            if (false) {
                                cc.warn('Should not set alpha via "color", use "opacity" please.');
                            }
                            this._onColorChanged();
                            this.emit(COLOR_CHANGED, old);
                        }
                    }
                }
            },
            ctor: function() {
                Object.defineProperty(this, "_id", {
                    value: "",
                    enumerable: false
                });
                var sgNode = this._sgNode = new _ccsg.Node();
                if (cc.sys.isNative) {
                    sgNode.retain();
                    var entity = this;
                    sgNode.onEnter = function() {
                        _ccsg.Node.prototype.onEnter.call(this);
                        if (!entity._active) {
                            cc.director.getActionManager().pauseTarget(this);
                            cc.eventManager.pauseTarget(this);
                        }
                    };
                }
                if (!cc.game._isCloning) {
                    sgNode.cascadeOpacity = true;
                }
                this._dirtyFlags = DirtyFlags.ALL;
                this._sizeProvider = null;
            },
            destroy: function() {
                this._sgNode.release();
                this._super();
            },
            _onHierarchyChanged: null,
            _onColorChanged: null,
            _onAnchorChanged: null,
            _onCascadeChanged: null,
            _onOpacityModifyRGBChanged: null,
            init: function() {
                return true;
            },
            attr: function(attrs) {
                for (var key in attrs) {
                    this[key] = attrs[key];
                }
            },
            setGlobalZOrder: function(globalZOrder) {
                this._globalZOrder = globalZOrder;
                this._sgNode.setGlobalZOrder(globalZOrder);
            },
            getGlobalZOrder: function() {
                this._globalZOrder = this._sgNode.getGlobalZOrder();
                return this._globalZOrder;
            },
            getScale: function() {
                if (this._scaleX !== this._scaleY) {
                    cc.log(cc._LogInfos.Node.getScale);
                }
                return this._scaleX;
            },
            setScale: function(scale, scaleY) {
                if (scale instanceof cc.Vec2) {
                    scaleY = scale.y;
                    scale = scale.x;
                } else {
                    scaleY = scaleY || 0 === scaleY ? scaleY : scale;
                }
                if (this._scaleX !== scale || this._scaleY !== scaleY) {
                    var old = new cc.Vec2(this._scaleX, this._scaleY);
                    this._scaleX = scale;
                    this._scaleY = scaleY;
                    this._sgNode.setScale(scale, scaleY);
                    this.emit(SCALE_CHANGED, old);
                }
            },
            getPosition: function() {
                return cc.p(this._position);
            },
            setPosition: function(newPosOrxValue, yValue) {
                var locPosition = this._position;
                var oldPosition;
                if (void 0 === yValue) {
                    if (locPosition.x === newPosOrxValue.x && locPosition.y === newPosOrxValue.y) {
                        return;
                    }
                    oldPosition = cc.v2(locPosition);
                    locPosition.x = newPosOrxValue.x;
                    locPosition.y = newPosOrxValue.y;
                } else {
                    if (locPosition.x === newPosOrxValue && locPosition.y === yValue) {
                        return;
                    }
                    oldPosition = cc.v2(locPosition);
                    locPosition.x = newPosOrxValue;
                    locPosition.y = yValue;
                }
                this._sgNode.setPosition(locPosition);
                if (this.emit) {
                    this.emit(POSITION_CHANGED, oldPosition);
                }
            },
            getAnchorPoint: function() {
                return cc.p(this._anchorPoint);
            },
            setAnchorPoint: function(point, y) {
                var locAnchorPoint = this._anchorPoint;
                var old;
                if (void 0 === y) {
                    if (point.x === locAnchorPoint.x && point.y === locAnchorPoint.y) {
                        return;
                    }
                    old = cc.v2(locAnchorPoint);
                    locAnchorPoint.x = point.x;
                    locAnchorPoint.y = point.y;
                } else {
                    if (point === locAnchorPoint.x && y === locAnchorPoint.y) {
                        return;
                    }
                    old = cc.v2(locAnchorPoint);
                    locAnchorPoint.x = point;
                    locAnchorPoint.y = y;
                }
                this._onAnchorChanged();
                this.emit(ANCHOR_CHANGED, old);
            },
            getAnchorPointInPoints: function() {
                return this._sgNode.getAnchorPointInPoints();
            },
            getContentSize: function(ignoreSizeProvider) {
                if (this._sizeProvider && !ignoreSizeProvider) {
                    var size = this._sizeProvider.getContentSize();
                    this._contentSize = size;
                    return size;
                } else {
                    return cc.size(this._contentSize);
                }
            },
            setContentSize: function(size, height) {
                var locContentSize = this._contentSize;
                var clone;
                if (void 0 === height) {
                    if (size.width === locContentSize.width && size.height === locContentSize.height) {
                        return;
                    }
                    clone = cc.size(locContentSize);
                    locContentSize.width = size.width;
                    locContentSize.height = size.height;
                } else {
                    if (size === locContentSize.width && height === locContentSize.height) {
                        return;
                    }
                    clone = cc.size(locContentSize);
                    locContentSize.width = size;
                    locContentSize.height = height;
                }
                if (this._sizeProvider) {
                    this._sizeProvider.setContentSize(locContentSize);
                }
                this.emit(SIZE_CHANGED, clone);
            },
            getBoundingBox: function() {
                var rect = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
                return cc._rectApplyAffineTransformIn(rect, this.getNodeToParentTransform());
            },
            cleanup: function() {
                var i, len = this._children.length, node;
                for (i = 0; i < len; ++i) {
                    node = this._children[i];
                    if (node) {
                        node.cleanup();
                    }
                }
            },
            getChildByTag: function(aTag) {
                var children = this._children;
                if (null !== children) {
                    for (var i = 0; i < children.length; i++) {
                        var node = children[i];
                        if (node && node.tag === aTag) {
                            return node;
                        }
                    }
                }
                return null;
            },
            getChildByName: function(name) {
                if (!name) {
                    cc.log("Invalid name");
                    return null;
                }
                var locChildren = this._children;
                for (var i = 0, len = locChildren.length; i < len; i++) {
                    if (locChildren[i]._name === name) {
                        return locChildren[i];
                    }
                }
                return null;
            },
            addChild: function(child, localZOrder, tag) {
                localZOrder = void 0 === localZOrder ? child._localZOrder : localZOrder;
                var name, setTag = false;
                if (cc.js.isUndefined(tag)) {
                    tag = void 0;
                    name = child._name;
                } else {
                    if (cc.js.isString(tag)) {
                        name = tag;
                        tag = void 0;
                    } else {
                        if (cc.js.isNumber(tag)) {
                            setTag = true;
                            name = "";
                        }
                    }
                }
                cc.assert(child, cc._LogInfos.Node.addChild_3);
                cc.assert(null === child._parent, "child already added. It can't be added again");
                this._addChildHelper(child, localZOrder, tag, name, setTag);
            },
            _addChildHelper: function(child, localZOrder, tag, name, setTag) {
                this._insertChild(child, localZOrder);
                if (setTag) {
                    child.setTag(tag);
                } else {
                    child.setName(name);
                }
            },
            _insertChild: function(child, z) {
                child.parent = this;
                child.zIndex = z;
            },
            removeFromParent: function(cleanup) {
                if (this._parent) {
                    if (void 0 === cleanup) {
                        cleanup = true;
                    }
                    this._parent.removeChild(this, cleanup);
                }
            },
            removeChild: function(child, cleanup) {
                if (0 === this._children.length) {
                    return;
                }
                if (void 0 === cleanup) {
                    cleanup = true;
                }
                if (this._children.indexOf(child) > -1) {
                    this._detachChild(child, cleanup);
                }
            },
            removeChildByTag: function(tag, cleanup) {
                if (tag === cc.NODE_TAG_INVALID) {
                    cc.log(cc._LogInfos.Node.removeChildByTag);
                }
                var child = this.getChildByTag(tag);
                if (!child) {
                    cc.log(cc._LogInfos.Node.removeChildByTag_2, tag);
                } else {
                    this.removeChild(child, cleanup);
                }
            },
            removeAllChildren: function(cleanup) {
                var children = this._children;
                if (void 0 === cleanup) {
                    cleanup = true;
                }
                for (var i = children.length - 1; i >= 0; i--) {
                    var node = children[i];
                    if (node) {
                        if (cleanup) {
                            node.cleanup();
                        }
                        node.parent = null;
                    }
                }
                this._children.length = 0;
            },
            _detachChild: function(child, doCleanup) {
                if (doCleanup) {
                    child.cleanup();
                }
                child.parent = null;
                cc.js.array.remove(this._children, child);
                this.emit(CHILD_REMOVED, child);
            },
            setNodeDirty: function() {
                this._sgNode.setNodeDirty();
            },
            getParentToNodeTransform: function() {
                return this._sgNode.getParentToNodeTransform();
            },
            getNodeToWorldTransform: function() {
                return this._sgNode.getNodeToWorldTransform();
            },
            getWorldToNodeTransform: function() {
                return this._sgNode.getWorldToNodeTransform();
            },
            convertToNodeSpace: function(worldPoint) {
                var nodePositionIgnoreAnchorPoint = this._sgNode.convertToNodeSpace(worldPoint);
                return cc.pAdd(nodePositionIgnoreAnchorPoint, cc.p(this._anchorPoint.x * this._contentSize.width, this._anchorPoint.y * this._contentSize.height));
            },
            convertToWorldSpace: function(nodePoint) {
                var worldPositionIgnoreAnchorPoint = this._sgNode.convertToWorldSpace(nodePoint);
                return cc.pSub(worldPositionIgnoreAnchorPoint, cc.p(this._anchorPoint.x * this._contentSize.width, this._anchorPoint.y * this._contentSize.height));
            },
            convertToNodeSpaceAR: function(worldPoint) {
                return this._sgNode.convertToNodeSpaceAR(worldPoint);
            },
            convertToWorldSpaceAR: function(nodePoint) {
                return this._sgNode.convertToWorldSpaceAR(nodePoint);
            },
            convertTouchToNodeSpace: function(touch) {
                return this.convertToNodeSpace(touch.getLocation());
            },
            convertTouchToNodeSpaceAR: function(touch) {
                return this.convertToNodeSpaceAR(touch.getLocation());
            },
            getNodeToParentTransform: function(ancestor) {
                return this._sgNode.getNodeToParentTransform();
            },
            getBoundingBoxToWorld: function() {
                return this._sgNode.getBoundingBoxToWorld();
            },
            getDisplayedOpacity: function() {
                return this._sgNode.getDisplayedOpacity();
            },
            _updateDisplayedOpacity: function(parentOpacity) {
                this._sgNode.updateDisplayedOpacity(parentOpacity);
            },
            getDisplayedColor: function() {
                return this._sgNode.getDisplayedColor();
            },
            setOpacityModifyRGB: function(opacityValue) {
                if (this._opacityModifyRGB !== opacityValue) {
                    this._opacityModifyRGB = opacityValue;
                    this._sgNode.setOpacityModifyRGB(opacityValue);
                    this._onOpacityModifyRGBChanged();
                }
            },
            isOpacityModifyRGB: function() {
                return this._opacityModifyRGB;
            },
            getSiblingIndex: function() {
                if (this._parent) {
                    return this._parent._children.indexOf(this);
                } else {
                    return 0;
                }
            },
            setSiblingIndex: function(index) {
                if (!this._parent) {
                    return;
                }
                var array = this._parent._children;
                index = -1 !== index ? index : array.length - 1;
                var oldIndex = array.indexOf(this);
                if (index !== oldIndex) {
                    array.splice(oldIndex, 1);
                    if (index < array.length) {
                        array.splice(index, 0, this);
                    } else {
                        array.push(this);
                    }
                    var siblings = this._parent._children;
                    for (var i = 0, len = siblings.length; i < len; i++) {
                        var sibling = siblings[i];
                        sibling._sgNode.arrivalOrder = i;
                    }
                    if (cc.renderer) {
                        cc.renderer.childrenOrderDirty = this._parent._sgNode._reorderChildDirty = true;
                    }
                }
            },
            isChildOf: function(parent) {
                var child = this;
                do {
                    if (child === parent) {
                        return true;
                    }
                    child = child._parent;
                } while (child);
                return false;
            },
            _onBatchCreated: function() {
                var sgNode = this._sgNode;
                sgNode.setOpacity(this._opacity);
                sgNode.setCascadeOpacityEnabled(this._cascadeOpacityEnabled);
                sgNode.setRotationX(this._rotationX);
                sgNode.setRotationY(this._rotationY);
                sgNode.setScale(this._scaleX, this._scaleY);
                sgNode.setPosition(this._position);
                sgNode.setSkewX(this._skewX);
                sgNode.setSkewY(this._skewY);
                sgNode.setLocalZOrder(this._localZOrder);
                sgNode.setGlobalZOrder(this._globalZOrder);
                sgNode.ignoreAnchorPointForPosition(this._ignoreAnchorPointForPosition);
                sgNode.setTag(this._tag);
                sgNode.setOpacityModifyRGB(this._opacityModifyRGB);
                if (this._parent) {
                    this._parent._sgNode.addChild(sgNode);
                }
                var children = this._children;
                for (var i = 0, len = children.length; i < len; i++) {
                    children[i]._onBatchCreated();
                }
            },
            _removeSgNode: SceneGraphHelper.removeSgNode,
            _replaceSgNode: function(sgNode) {
                if (sgNode instanceof _ccsg.Node) {
                    var oldSgNode = this._sgNode;
                    sgNode.setPosition(this._position);
                    sgNode.setRotationX(this._rotationX);
                    sgNode.setRotationY(this._rotationY);
                    sgNode.setScale(this._scaleX, this._scaleY);
                    sgNode.setSkewX(this._skewX);
                    sgNode.setSkewY(this._skewY);
                    sgNode.setLocalZOrder(this._localZOrder);
                    sgNode.setGlobalZOrder(this._globalZOrder);
                    sgNode.setOpacity(this._opacity);
                    sgNode.setCascadeOpacityEnabled(this._cascadeOpacityEnabled);
                    sgNode.ignoreAnchorPointForPosition(this._ignoreAnchorPointForPosition);
                    sgNode.setTag(this._tag);
                    sgNode.setColor(this._color);
                    sgNode.setOpacityModifyRGB(this._opacityModifyRGB);
                    var children = oldSgNode.getChildren().slice(0);
                    oldSgNode.removeAllChildren();
                    for (var index = 0; index < children.length; ++index) {
                        sgNode.addChild(children[index]);
                    }
                    var parentNode = oldSgNode.getParent();
                    parentNode.removeChild(oldSgNode);
                    parentNode.addChild(sgNode);
                    sgNode.arrivalOrder = oldSgNode.arrivalOrder;
                    if (cc.renderer) {
                        cc.renderer.childrenOrderDirty = this._parent._sgNode._reorderChildDirty = true;
                    }
                    this._sgNode = sgNode;
                    if (cc.sys.isNative) {
                        oldSgNode.release();
                        sgNode.retain();
                    }
                } else {
                    throw new Error("Invalid sgNode. It must an instance of _ccsg.Node");
                }
            }
        });
        !function() {
            var SameNameGetSets = [ "name", "skewX", "skewY", "position", "rotation", "rotationX", "rotationY", "scale", "scaleX", "scaleY", "children", "childrenCount", "parent", "running", "scheduler", "opacity", "color", "tag" ];
            var DiffNameGetSets = {
                x: [ "getPositionX", "setPositionX" ],
                y: [ "getPositionY", "setPositionY" ],
                zIndex: [ "getLocalZOrder", "setLocalZOrder" ],
                ignoreAnchor: [ "isIgnoreAnchorPointForPosition", "ignoreAnchorPointForPosition" ],
                opacityModifyRGB: [ "isOpacityModifyRGB" ],
                cascadeOpacity: [ "isCascadeOpacityEnabled", "setCascadeOpacityEnabled" ],
                cascadeColor: [ "isCascadeColorEnabled", "setCascadeColorEnabled" ]
            };
            var propName, np = BaseNode.prototype;
            for (var i = 0; i < SameNameGetSets.length; i++) {
                propName = SameNameGetSets[i];
                var suffix = propName[0].toUpperCase() + propName.slice(1);
                var pd = Object.getOwnPropertyDescriptor(np, propName);
                if (pd) {
                    if (pd.get) {
                        np["get" + suffix] = pd.get;
                    }
                    if (pd.set) {
                        np["set" + suffix] = pd.set;
                    }
                } else {
                    JS.getset(np, propName, np["get" + suffix], np["set" + suffix]);
                }
            }
            for (propName in DiffNameGetSets) {
                var getset = DiffNameGetSets[propName];
                var pd = Object.getOwnPropertyDescriptor(np, propName);
                if (pd) {
                    np[getset[0]] = pd.get;
                    if (getset[1]) {
                        np[getset[1]] = pd.set;
                    }
                } else {
                    JS.getset(np, propName, np[getset[0]], np[getset[1]]);
                }
            }
        }();
        cc._BaseNode = module.exports = BaseNode;
    }, {
        "../platform/CCObject": 62,
        "./misc": 88,
        "./scene-graph-helper": 89
    } ],
    86: [ function(require, module, exports) {
        cc.find = module.exports = function(path, referenceNode) {
            if (null == path) {
                cc.error("Argument must be non-nil");
                return null;
            }
            if (!referenceNode) {
                var scene = cc.director.getScene();
                if (!scene) {
                    cc.warn("Can not get current scene.");
                    return null;
                }
                referenceNode = scene;
            }
            var match = referenceNode;
            var startIndex = "/" !== path[0] ? 0 : 1;
            var nameList = path.split("/");
            for (var n = startIndex; n < nameList.length; n++) {
                var name = nameList[n];
                var findByComp = "<" === name[0] && ">" === name[name.length - 1];
                var Comp;
                if (findByComp) {
                    var compName = name.slice(1, -1);
                    Comp = cc.js.getClassByName(compName);
                    if (!Comp) {
                        cc.warn("Failed to find component " + compName);
                        return null;
                    }
                }
                var children = match._children;
                match = null;
                for (var t = 0, len = children.length; t < len; ++t) {
                    var subChild = children[t];
                    if (findByComp) {
                        if (subChild.getComponent(Comp)) {
                            match = subChild;
                            break;
                        }
                    } else {
                        if (subChild.name === name) {
                            match = subChild;
                            break;
                        }
                    }
                }
                if (!match) {
                    return null;
                }
            }
            return match;
        };
    }, {} ],
    87: [ function(require, module, exports) {
        require("./Async");
        require("./CCPath");
        require("./CCProfiler");
        require("./find");
    }, {
        "./Async": 82,
        "./CCPath": 83,
        "./CCProfiler": 84,
        "./find": 86
    } ],
    88: [ function(require, module, exports) {
        var JS = cc.js;
        var misc = {};
        misc.propertyDefine = function(ctor, sameNameGetSets, diffNameGetSets) {
            var propName, np = ctor.prototype;
            for (var i = 0; i < sameNameGetSets.length; i++) {
                propName = sameNameGetSets[i];
                var suffix = propName[0].toUpperCase() + propName.slice(1);
                var pd = Object.getOwnPropertyDescriptor(np, propName);
                if (pd) {
                    if (pd.get) {
                        np["get" + suffix] = pd.get;
                    }
                    if (pd.set) {
                        np["set" + suffix] = pd.set;
                    }
                } else {
                    JS.getset(np, propName, np["get" + suffix], np["set" + suffix]);
                }
            }
            for (propName in diffNameGetSets) {
                var getset = diffNameGetSets[propName];
                var pd = Object.getOwnPropertyDescriptor(np, propName);
                if (pd) {
                    np[getset[0]] = pd.get;
                    if (getset[1]) {
                        np[getset[1]] = pd.set;
                    }
                } else {
                    JS.getset(np, propName, np[getset[0]], np[getset[1]]);
                }
            }
        };
        var DirtyFlags = misc.DirtyFlags = {
            TRANSFORM: 1,
            SIZE: 2,
            ALL: 3
        };
        DirtyFlags.WIDGET = DirtyFlags.TRANSFORM | DirtyFlags.SIZE;
        module.exports = misc;
    }, {} ],
    89: [ function(require, module, exports) {
        var SceneGraphUtils = {
            removeSgNode: function() {
                var node = this._sgNode;
                if (node) {
                    node.release();
                    if (node._parent) {
                        node._parent.removeChild(node);
                    }
                    this._sgNode = null;
                }
            }
        };
        if (false) {
            SceneGraphUtils._getChildrenOffset = function(entityParent) {
                if (entityParent) {
                    var sgParent = entityParent._sgNode;
                    var firstChildEntity = entityParent._children[0];
                    if (firstChildEntity) {
                        var firstChildSg = firstChildEntity._sgNode;
                        var offset = sgParent._children.indexOf(firstChildSg);
                        if (-1 !== offset) {
                            return offset;
                        } else {
                            cc.error("%s's scene graph node not contains in the parent's children", firstChildEntity.name);
                            return -1;
                        }
                    } else {
                        return sgParent._children.length;
                    }
                } else {
                    return 0;
                }
            };
            SceneGraphUtils.checkMatchCurrentScene = function() {
                var scene = cc.director.getScene();
                var sgScene = cc.director.getRunningScene();
                function checkMatch(ent, sgNode) {
                    if (ent._sgNode !== sgNode) {
                        throw new Error("scene graph node not equal: " + ent.name);
                    }
                    var childCount = ent._children.length;
                    var childrenOffset = SceneGraphUtils._getChildrenOffset(ent);
                    if (sgNode._children.length !== childCount + childrenOffset) {
                        throw new Error("Mismatched child scene graphs: " + ent.name);
                    }
                    for (var i = 0; i < childCount; i++) {
                        checkMatch(ent._children[i], sgNode._children[childrenOffset + i]);
                    }
                }
                checkMatch(scene, sgScene);
            };
            cc._Test.SceneGraphUtils = SceneGraphUtils;
        }
        module.exports = SceneGraphUtils;
    }, {} ],
    90: [ function(require, module, exports) {
        cc.AffineTransform = function(a, b, c, d, tx, ty) {
            this.a = a;
            this.b = b;
            this.c = c;
            this.d = d;
            this.tx = tx;
            this.ty = ty;
        };
        cc.affineTransformMake = function(a, b, c, d, tx, ty) {
            return {
                a: a,
                b: b,
                c: c,
                d: d,
                tx: tx,
                ty: ty
            };
        };
        cc.affineTransformClone = function(t) {
            return {
                a: t.a,
                b: t.b,
                c: t.c,
                d: t.d,
                tx: t.tx,
                ty: t.ty
            };
        };
        cc.pointApplyAffineTransform = function(point, transOrY, t) {
            var x, y;
            if (void 0 === t) {
                t = transOrY;
                x = point.x;
                y = point.y;
            } else {
                x = point;
                y = transOrY;
            }
            return {
                x: t.a * x + t.c * y + t.tx,
                y: t.b * x + t.d * y + t.ty
            };
        };
        cc._pointApplyAffineTransform = function(x, y, t) {
            return cc.pointApplyAffineTransform(x, y, t);
        };
        cc.sizeApplyAffineTransform = function(size, t) {
            return {
                width: t.a * size.width + t.c * size.height,
                height: t.b * size.width + t.d * size.height
            };
        };
        cc.affineTransformMakeIdentity = function() {
            return {
                a: 1,
                b: 0,
                c: 0,
                d: 1,
                tx: 0,
                ty: 0
            };
        };
        cc.affineTransformIdentity = function() {
            return {
                a: 1,
                b: 0,
                c: 0,
                d: 1,
                tx: 0,
                ty: 0
            };
        };
        cc.rectApplyAffineTransform = function(rect, anAffineTransform) {
            var top = cc.rectGetMinY(rect);
            var left = cc.rectGetMinX(rect);
            var right = cc.rectGetMaxX(rect);
            var bottom = cc.rectGetMaxY(rect);
            var topLeft = cc.pointApplyAffineTransform(left, top, anAffineTransform);
            var topRight = cc.pointApplyAffineTransform(right, top, anAffineTransform);
            var bottomLeft = cc.pointApplyAffineTransform(left, bottom, anAffineTransform);
            var bottomRight = cc.pointApplyAffineTransform(right, bottom, anAffineTransform);
            var minX = Math.min(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
            var maxX = Math.max(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
            var minY = Math.min(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
            var maxY = Math.max(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
            return cc.rect(minX, minY, maxX - minX, maxY - minY);
        };
        cc._rectApplyAffineTransformIn = function(rect, anAffineTransform) {
            var top = cc.rectGetMinY(rect);
            var left = cc.rectGetMinX(rect);
            var right = cc.rectGetMaxX(rect);
            var bottom = cc.rectGetMaxY(rect);
            var topLeft = cc.pointApplyAffineTransform(left, top, anAffineTransform);
            var topRight = cc.pointApplyAffineTransform(right, top, anAffineTransform);
            var bottomLeft = cc.pointApplyAffineTransform(left, bottom, anAffineTransform);
            var bottomRight = cc.pointApplyAffineTransform(right, bottom, anAffineTransform);
            var minX = Math.min(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
            var maxX = Math.max(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
            var minY = Math.min(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
            var maxY = Math.max(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
            rect.x = minX;
            rect.y = minY;
            rect.width = maxX - minX;
            rect.height = maxY - minY;
            return rect;
        };
        cc.affineTransformTranslate = function(t, tx, ty) {
            return {
                a: t.a,
                b: t.b,
                c: t.c,
                d: t.d,
                tx: t.tx + t.a * tx + t.c * ty,
                ty: t.ty + t.b * tx + t.d * ty
            };
        };
        cc.affineTransformScale = function(t, sx, sy) {
            return {
                a: t.a * sx,
                b: t.b * sx,
                c: t.c * sy,
                d: t.d * sy,
                tx: t.tx,
                ty: t.ty
            };
        };
        cc.affineTransformRotate = function(aTransform, anAngle) {
            var fSin = Math.sin(anAngle);
            var fCos = Math.cos(anAngle);
            return {
                a: aTransform.a * fCos + aTransform.c * fSin,
                b: aTransform.b * fCos + aTransform.d * fSin,
                c: aTransform.c * fCos - aTransform.a * fSin,
                d: aTransform.d * fCos - aTransform.b * fSin,
                tx: aTransform.tx,
                ty: aTransform.ty
            };
        };
        cc.affineTransformConcat = function(t1, t2) {
            return {
                a: t1.a * t2.a + t1.b * t2.c,
                b: t1.a * t2.b + t1.b * t2.d,
                c: t1.c * t2.a + t1.d * t2.c,
                d: t1.c * t2.b + t1.d * t2.d,
                tx: t1.tx * t2.a + t1.ty * t2.c + t2.tx,
                ty: t1.tx * t2.b + t1.ty * t2.d + t2.ty
            };
        };
        cc.affineTransformConcatIn = function(t1, t2) {
            var a = t1.a, b = t1.b, c = t1.c, d = t1.d, tx = t1.tx, ty = t1.ty;
            t1.a = a * t2.a + b * t2.c;
            t1.b = a * t2.b + b * t2.d;
            t1.c = c * t2.a + d * t2.c;
            t1.d = c * t2.b + d * t2.d;
            t1.tx = tx * t2.a + ty * t2.c + t2.tx;
            t1.ty = tx * t2.b + ty * t2.d + t2.ty;
            return t1;
        };
        cc.affineTransformEqualToTransform = function(t1, t2) {
            return t1.a === t2.a && t1.b === t2.b && t1.c === t2.c && t1.d === t2.d && t1.tx === t2.tx && t1.ty === t2.ty;
        };
        cc.affineTransformInvert = function(t) {
            var determinant = 1 / (t.a * t.d - t.b * t.c);
            return {
                a: determinant * t.d,
                b: -determinant * t.b,
                c: -determinant * t.c,
                d: determinant * t.a,
                tx: determinant * (t.c * t.ty - t.d * t.tx),
                ty: determinant * (t.b * t.tx - t.a * t.ty)
            };
        };
    }, {} ],
    91: [ function(require, module, exports) {
        var ValueType = require("./CCValueType");
        var JS = require("../platform/js");
        var Color = function() {
            function Color(r, g, b, a) {
                if ("object" === typeof r) {
                    g = r.g;
                    b = r.b;
                    a = r.a;
                    r = r.r;
                }
                this.r = "number" === typeof r ? r : 0;
                this.g = "number" === typeof g ? g : 0;
                this.b = "number" === typeof b ? b : 0;
                this.a = "number" === typeof a ? a : 255;
            }
            JS.extend(Color, ValueType);
            require("../platform/CCClass").fastDefine("cc.Color", Color, [ "r", "g", "b", "a" ]);
            var DefaultColors = {
                WHITE: [ 255, 255, 255, 255 ],
                BLACK: [ 0, 0, 0, 255 ],
                TRANSPARENT: [ 0, 0, 0, 0 ],
                GRAY: [ 127.5, 127.5, 127.5 ],
                RED: [ 255, 0, 0 ],
                GREEN: [ 0, 255, 0 ],
                BLUE: [ 0, 0, 255 ],
                YELLOW: [ 255, 235, 4 ],
                ORANGE: [ 255, 127, 0 ],
                CYAN: [ 0, 255, 255 ],
                MAGENTA: [ 255, 0, 255 ]
            };
            for (var colorName in DefaultColors) {
                var colorGetter = function(r, g, b, a) {
                    return function() {
                        return new Color(r, g, b, a);
                    };
                }.apply(null, DefaultColors[colorName]);
                Object.defineProperty(Color, colorName, {
                    get: colorGetter
                });
            }
            Color.prototype.clone = function() {
                return new Color(this.r, this.g, this.b, this.a);
            };
            Color.prototype.equals = function(other) {
                return other && this.r === other.r && this.g === other.g && this.b === other.b && this.a === other.a;
            };
            Color.prototype.lerp = function(to, ratio, out) {
                out = out || new Color();
                var r = this.r;
                var g = this.g;
                var b = this.b;
                var a = this.a;
                out.r = r + (to.r - r) * ratio;
                out.g = g + (to.g - g) * ratio;
                out.b = b + (to.b - b) * ratio;
                out.a = a + (to.a - a) * ratio;
                return out;
            };
            Color.prototype.toString = function() {
                return "rgba(" + this.r.toFixed() + ", " + this.g.toFixed() + ", " + this.b.toFixed() + ", " + this.a.toFixed() + ")";
            };
            Color.prototype.setR = function(red) {
                this.r = red;
                return this;
            };
            Color.prototype.setG = function(green) {
                this.g = green;
                return this;
            };
            Color.prototype.setB = function(blue) {
                this.b = blue;
                return this;
            };
            Color.prototype.setA = function(alpha) {
                this.a = alpha;
                return this;
            };
            Color.prototype.toCSS = function(opt) {
                if ("rgba" === opt) {
                    return "rgba(" + (0 | this.r) + "," + (0 | this.g) + "," + (0 | this.b) + "," + (this.a / 255).toFixed(2) + ")";
                } else {
                    if ("rgb" === opt) {
                        return "rgb(" + (0 | this.r) + "," + (0 | this.g) + "," + (0 | this.b) + ")";
                    } else {
                        return "#" + this.toHEX(opt);
                    }
                }
            };
            Color.prototype.clamp = function() {
                this.r = cc.clampf(this.r, 0, 255);
                this.g = cc.clampf(this.g, 0, 255);
                this.b = cc.clampf(this.b, 0, 255);
                this.a = cc.clampf(this.a, 0, 255);
            };
            Color.prototype.fromHEX = function(hexString) {
                var hex = parseInt(hexString.indexOf("#") > -1 ? hexString.substring(1) : hexString, 16);
                this.r = hex >> 16;
                this.g = (65280 & hex) >> 8;
                this.b = 255 & hex;
                return this;
            };
            Color.prototype.toHEX = function(fmt) {
                var hex = [ (0 | this.r).toString(16), (0 | this.g).toString(16), (0 | this.b).toString(16) ];
                var i = -1;
                if ("#rgb" === fmt) {
                    for (i = 0; i < hex.length; ++i) {
                        if (hex[i].length > 1) {
                            hex[i] = hex[i][0];
                        }
                    }
                } else {
                    if ("#rrggbb" === fmt) {
                        for (i = 0; i < hex.length; ++i) {
                            if (1 === hex[i].length) {
                                hex[i] = "0" + hex[i];
                            }
                        }
                    }
                }
                return hex.join("");
            };
            Color.prototype.toRGBValue = function() {
                return (cc.clampf(this.r, 0, 255) << 16) + (cc.clampf(this.g, 0, 255) << 8) + cc.clampf(this.b, 0, 255);
            };
            Color.prototype.fromHSV = function(h, s, v) {
                var rgb = Color.hsv2rgb(h, s, v);
                this.r = rgb.r;
                this.g = rgb.g;
                this.b = rgb.b;
                return this;
            };
            Color.prototype.toHSV = function() {
                return Color.rgb2hsv(this.r, this.g, this.b);
            };
            return Color;
        }();
        Color.rgb2hsv = function(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;
            var hsv = {
                h: 0,
                s: 0,
                v: 0
            };
            var max = Math.max(r, g, b);
            var min = Math.min(r, g, b);
            var delta = 0;
            hsv.v = max;
            hsv.s = max ? (max - min) / max : 0;
            if (!hsv.s) {
                hsv.h = 0;
            } else {
                delta = max - min;
                if (r === max) {
                    hsv.h = (g - b) / delta;
                } else {
                    if (g === max) {
                        hsv.h = 2 + (b - r) / delta;
                    } else {
                        hsv.h = 4 + (r - g) / delta;
                    }
                }
                hsv.h /= 6;
                if (hsv.h < 0) {
                    hsv.h += 1;
                }
            }
            return hsv;
        };
        Color.hsv2rgb = function(h, s, v) {
            var rgb = {
                r: 0,
                g: 0,
                b: 0
            };
            if (0 === s) {
                rgb.r = rgb.g = rgb.b = v;
            } else {
                if (0 === v) {
                    rgb.r = rgb.g = rgb.b = 0;
                } else {
                    if (1 === h) {
                        h = 0;
                    }
                    h *= 6;
                    s = s;
                    v = v;
                    var i = Math.floor(h);
                    var f = h - i;
                    var p = v * (1 - s);
                    var q = v * (1 - s * f);
                    var t = v * (1 - s * (1 - f));
                    switch (i) {
                      case 0:
                        rgb.r = v;
                        rgb.g = t;
                        rgb.b = p;
                        break;

                      case 1:
                        rgb.r = q;
                        rgb.g = v;
                        rgb.b = p;
                        break;

                      case 2:
                        rgb.r = p;
                        rgb.g = v;
                        rgb.b = t;
                        break;

                      case 3:
                        rgb.r = p;
                        rgb.g = q;
                        rgb.b = v;
                        break;

                      case 4:
                        rgb.r = t;
                        rgb.g = p;
                        rgb.b = v;
                        break;

                      case 5:
                        rgb.r = v;
                        rgb.g = p;
                        rgb.b = q;
                    }
                }
            }
            rgb.r *= 255;
            rgb.g *= 255;
            rgb.b *= 255;
            return rgb;
        };
        cc.Color = Color;
        cc.color = function color(r, g, b, a) {
            if (JS.isString(r)) {
                var result = new cc.Color();
                return result.fromHEX(r);
            }
            if (cc.js.isObject(r)) {
                return new cc.Color(r.r, r.g, r.b, r.a);
            }
            return new cc.Color(r, g, b, a);
        };
        cc.colorEqual = function(color1, color2) {
            return color1.r === color2.r && color1.g === color2.g && color1.b === color2.b;
        };
        cc.hexToColor = function(hex) {
            hex = hex.replace(/^#?/, "0x");
            var c = parseInt(hex);
            var r = c >> 16;
            var g = (65280 & c) >> 8;
            var b = 255 & c;
            return cc.color(r, g, b);
        };
        cc.colorToHex = function(color) {
            var hR = color.r.toString(16), hG = color.g.toString(16), hB = color.b.toString(16);
            return "#" + (color.r < 16 ? "0" + hR : hR) + (color.g < 16 ? "0" + hG : hG) + (color.b < 16 ? "0" + hB : hB);
        };
        module.exports = cc.Color;
    }, {
        "../platform/CCClass": 57,
        "../platform/js": 70,
        "./CCValueType": 98
    } ],
    92: [ function(require, module, exports) {
        cc.Enum = function(obj) {
            var enumType = {};
            Object.defineProperty(enumType, "__enums__", {
                value: void 0,
                writable: true
            });
            var lastIndex = -1;
            for (var key in obj) {
                var val = obj[key];
                if (-1 === val) {
                    val = ++lastIndex;
                } else {
                    lastIndex = val;
                }
                enumType[key] = val;
                var reverseKey = "" + val;
                if (key !== reverseKey) {
                    Object.defineProperty(enumType, reverseKey, {
                        value: key,
                        enumerable: false
                    });
                }
            }
            return enumType;
        };
        cc.Enum.isEnum = function(enumType) {
            return enumType && enumType.hasOwnProperty("__enums__");
        };
        cc.Enum.getList = function(enumDef) {
            if (void 0 !== enumDef.__enums__) {
                return enumDef.__enums__;
            }
            var enums = [];
            for (var entry in enumDef) {
                if (enumDef.hasOwnProperty(entry)) {
                    var value = enumDef[entry];
                    var isInteger = "number" === typeof value && (0 | value) === value;
                    if (isInteger) {
                        enums.push({
                            name: entry,
                            value: value
                        });
                    }
                }
            }
            enums.sort(function(a, b) {
                return a.value - b.value;
            });
            enumDef.__enums__ = enums;
            return enums;
        };
        if (false) {
            var _TestEnum = cc.Enum({
                ZERO: -1,
                ONE: -1,
                TWO: -1,
                THREE: -1
            });
            if (0 !== _TestEnum.ZERO || 1 !== _TestEnum.ONE || 2 !== _TestEnum.TWO || 3 !== _TestEnum.THREE) {
                cc.error('Sorry, "cc.Enum" not available on this platform, please report this error here: https://github.com/fireball-x/fireball/issues/new');
            }
        }
        module.exports = cc.Enum;
    }, {} ],
    93: [ function(require, module, exports) {
        cc.POINT_EPSILON = parseFloat("1.192092896e-07F");
        cc.pNeg = function(point) {
            return cc.p(-point.x, -point.y);
        };
        cc.pAdd = function(v1, v2) {
            return cc.p(v1.x + v2.x, v1.y + v2.y);
        };
        cc.pSub = function(v1, v2) {
            return cc.p(v1.x - v2.x, v1.y - v2.y);
        };
        cc.pMult = function(point, floatVar) {
            return cc.p(point.x * floatVar, point.y * floatVar);
        };
        cc.pMidpoint = function(v1, v2) {
            return cc.pMult(cc.pAdd(v1, v2), .5);
        };
        cc.pDot = function(v1, v2) {
            return v1.x * v2.x + v1.y * v2.y;
        };
        cc.pCross = function(v1, v2) {
            return v1.x * v2.y - v1.y * v2.x;
        };
        cc.pPerp = function(point) {
            return cc.p(-point.y, point.x);
        };
        cc.pRPerp = function(point) {
            return cc.p(point.y, -point.x);
        };
        cc.pProject = function(v1, v2) {
            return cc.pMult(v2, cc.pDot(v1, v2) / cc.pDot(v2, v2));
        };
        cc.pRotate = function(v1, v2) {
            return cc.p(v1.x * v2.x - v1.y * v2.y, v1.x * v2.y + v1.y * v2.x);
        };
        cc.pUnrotate = function(v1, v2) {
            return cc.p(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y);
        };
        cc.pLengthSQ = function(v) {
            return cc.pDot(v, v);
        };
        cc.pDistanceSQ = function(point1, point2) {
            return cc.pLengthSQ(cc.pSub(point1, point2));
        };
        cc.pLength = function(v) {
            return Math.sqrt(cc.pLengthSQ(v));
        };
        cc.pDistance = function(v1, v2) {
            return cc.pLength(cc.pSub(v1, v2));
        };
        cc.pNormalize = function(v) {
            var n = cc.pLength(v);
            return 0 === n ? cc.p(v) : cc.pMult(v, 1 / n);
        };
        cc.pForAngle = function(a) {
            return cc.p(Math.cos(a), Math.sin(a));
        };
        cc.pToAngle = function(v) {
            return Math.atan2(v.y, v.x);
        };
        cc.clampf = function(value, min_inclusive, max_inclusive) {
            if (min_inclusive > max_inclusive) {
                var temp = min_inclusive;
                min_inclusive = max_inclusive;
                max_inclusive = temp;
            }
            return value < min_inclusive ? min_inclusive : value < max_inclusive ? value : max_inclusive;
        };
        cc.clamp01 = function(value) {
            return value < 0 ? 0 : value < 1 ? value : 1;
        };
        cc.pClamp = function(p, min_inclusive, max_inclusive) {
            return cc.p(cc.clampf(p.x, min_inclusive.x, max_inclusive.x), cc.clampf(p.y, min_inclusive.y, max_inclusive.y));
        };
        cc.pFromSize = function(s) {
            return cc.p(s.width, s.height);
        };
        cc.pCompOp = function(p, opFunc) {
            return cc.p(opFunc(p.x), opFunc(p.y));
        };
        cc.pLerp = function(a, b, alpha) {
            return cc.pAdd(cc.pMult(a, 1 - alpha), cc.pMult(b, alpha));
        };
        cc.pFuzzyEqual = function(a, b, variance) {
            if (a.x - variance <= b.x && b.x <= a.x + variance) {
                if (a.y - variance <= b.y && b.y <= a.y + variance) {
                    return true;
                }
            }
            return false;
        };
        cc.pCompMult = function(a, b) {
            return cc.p(a.x * b.x, a.y * b.y);
        };
        cc.pAngleSigned = function(a, b) {
            var a2 = cc.pNormalize(a);
            var b2 = cc.pNormalize(b);
            var angle = Math.atan2(a2.x * b2.y - a2.y * b2.x, cc.pDot(a2, b2));
            if (Math.abs(angle) < cc.POINT_EPSILON) {
                return 0;
            }
            return angle;
        };
        cc.pAngle = function(a, b) {
            var angle = Math.acos(cc.pDot(cc.pNormalize(a), cc.pNormalize(b)));
            if (Math.abs(angle) < cc.POINT_EPSILON) {
                return 0;
            }
            return angle;
        };
        cc.pRotateByAngle = function(v, pivot, angle) {
            var r = cc.pSub(v, pivot);
            var cosa = Math.cos(angle), sina = Math.sin(angle);
            var t = r.x;
            r.x = t * cosa - r.y * sina + pivot.x;
            r.y = t * sina + r.y * cosa + pivot.y;
            return r;
        };
        cc.pLineIntersect = function(A, B, C, D, retP) {
            if (A.x === B.x && A.y === B.y || C.x === D.x && C.y === D.y) {
                return false;
            }
            var BAx = B.x - A.x;
            var BAy = B.y - A.y;
            var DCx = D.x - C.x;
            var DCy = D.y - C.y;
            var ACx = A.x - C.x;
            var ACy = A.y - C.y;
            var denom = DCy * BAx - DCx * BAy;
            retP.x = DCx * ACy - DCy * ACx;
            retP.y = BAx * ACy - BAy * ACx;
            if (0 === denom) {
                if (0 === retP.x || 0 === retP.y) {
                    return true;
                }
                return false;
            }
            retP.x = retP.x / denom;
            retP.y = retP.y / denom;
            return true;
        };
        cc.pSegmentIntersect = function(A, B, C, D) {
            var retP = cc.p(0, 0);
            if (cc.pLineIntersect(A, B, C, D, retP)) {
                if (retP.x >= 0 && retP.x <= 1 && retP.y >= 0 && retP.y <= 1) {
                    return true;
                }
            }
            return false;
        };
        cc.pIntersectPoint = function(A, B, C, D) {
            var retP = cc.p(0, 0);
            if (cc.pLineIntersect(A, B, C, D, retP)) {
                var P = cc.p(0, 0);
                P.x = A.x + retP.x * (B.x - A.x);
                P.y = A.y + retP.x * (B.y - A.y);
                return P;
            }
            return cc.p(0, 0);
        };
        cc.pSameAs = function(A, B) {
            if (null != A && null != B) {
                return A.x === B.x && A.y === B.y;
            }
            return false;
        };
        cc.pZeroIn = function(v) {
            v.x = 0;
            v.y = 0;
        };
        cc.pIn = function(v1, v2) {
            v1.x = v2.x;
            v1.y = v2.y;
        };
        cc.pMultIn = function(point, floatVar) {
            point.x *= floatVar;
            point.y *= floatVar;
        };
        cc.pSubIn = function(v1, v2) {
            v1.x -= v2.x;
            v1.y -= v2.y;
        };
        cc.pAddIn = function(v1, v2) {
            v1.x += v2.x;
            v1.y += v2.y;
        };
        cc.pNormalizeIn = function(v) {
            cc.pMultIn(v, 1 / Math.sqrt(v.x * v.x + v.y * v.y));
        };
    }, {} ],
    94: [ function(require, module, exports) {
        var ValueType = require("./CCValueType");
        var JS = require("../platform/js");
        function Rect(x, y, w, h) {
            if (x && "object" === typeof x) {
                y = x.y;
                w = x.width;
                h = x.height;
                x = x.x;
            }
            this.x = "number" === typeof x ? x : 0;
            this.y = "number" === typeof y ? y : 0;
            this.width = "number" === typeof w ? w : 0;
            this.height = "number" === typeof h ? h : 0;
        }
        JS.extend(Rect, ValueType);
        require("../platform/CCClass").fastDefine("cc.Rect", Rect, [ "x", "y", "width", "height" ]);
        Rect.fromMinMax = function(v1, v2) {
            var min_x = Math.min(v1.x, v2.x);
            var min_y = Math.min(v1.y, v2.y);
            var max_x = Math.max(v1.x, v2.x);
            var max_y = Math.max(v1.y, v2.y);
            return new Rect(min_x, min_y, max_x - min_x, max_y - min_y);
        };
        Rect.contain = function _Contain(a, b) {
            if (a.x <= b.x && a.x + a.width >= b.x + b.width && a.y <= b.y && a.y + a.height >= b.y + b.height) {
                return 1;
            }
            if (b.x <= a.x && b.x + b.width >= a.x + a.width && b.y <= a.y && b.y + b.height >= a.y + a.height) {
                return -1;
            }
            return 0;
        };
        var proto = Rect.prototype;
        proto.clone = function() {
            return new Rect(this.x, this.y, this.width, this.height);
        };
        proto.equals = function(other) {
            return other && this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;
        };
        proto.lerp = function(to, ratio, out) {
            out = out || new Rect();
            var x = this.x;
            var y = this.y;
            var width = this.width;
            var height = this.height;
            out.x = x + (to.x - x) * ratio;
            out.y = y + (to.y - y) * ratio;
            out.width = width + (to.width - width) * ratio;
            out.height = height + (to.height - height) * ratio;
            return out;
        };
        proto.toString = function() {
            return "(" + this.x.toFixed(2) + ", " + this.y.toFixed(2) + ", " + this.width.toFixed(2) + ", " + this.height.toFixed(2) + ")";
        };
        Object.defineProperty(proto, "xMin", {
            get: function() {
                return this.x;
            },
            set: function(value) {
                this.width += this.x - value;
                this.x = value;
            }
        });
        Object.defineProperty(proto, "yMin", {
            get: function() {
                return this.y;
            },
            set: function(value) {
                this.height += this.y - value;
                this.y = value;
            }
        });
        Object.defineProperty(proto, "xMax", {
            get: function() {
                return this.x + this.width;
            },
            set: function(value) {
                this.width = value - this.x;
            }
        });
        Object.defineProperty(proto, "yMax", {
            get: function() {
                return this.y + this.height;
            },
            set: function(value) {
                this.height = value - this.y;
            }
        });
        Object.defineProperty(proto, "center", {
            get: function() {
                return new cc.Vec2(this.x + .5 * this.width, this.y + .5 * this.height);
            },
            set: function(value) {
                this.x = value.x - .5 * this.width;
                this.y = value.y - .5 * this.height;
            }
        });
        Object.defineProperty(proto, "size", {
            get: function() {
                return new cc.Size(this.width, this.height);
            },
            set: function(value) {
                this.width = value.width;
                this.height = value.height;
            }
        });
        proto.intersects = function(rect) {
            return cc.rectIntersectsRect(this, rect);
        };
        proto.contains = function(point) {
            return this.x <= point.x && this.x + this.width >= point.x && this.y <= point.y && this.y + this.height >= point.y;
        };
        proto.containsRect = function(rect) {
            return this.x <= rect.x && this.x + this.width >= rect.x + rect.width && this.y <= rect.y && this.y + this.height >= rect.y + rect.height;
        };
        cc.Rect = Rect;
        cc.rect = function rect(x, y, w, h) {
            return new Rect(x, y, w, h);
        };
        cc.rectEqualToRect = function(rect1, rect2) {
            return rect1 && rect2 && rect1.x === rect2.x && rect1.y === rect2.y && rect1.width === rect2.width && rect1.height === rect2.height;
        };
        cc._rectEqualToZero = function(rect) {
            return rect && 0 === rect.x && 0 === rect.y && 0 === rect.width && 0 === rect.height;
        };
        cc.rectContainsRect = function(rect1, rect2) {
            if (!rect1 || !rect2) {
                return false;
            }
            return !(rect1.x >= rect2.x || rect1.y >= rect2.y || rect1.x + rect1.width <= rect2.x + rect2.width || rect1.y + rect1.height <= rect2.y + rect2.height);
        };
        cc.rectGetMaxX = function(rect) {
            return rect.x + rect.width;
        };
        cc.rectGetMidX = function(rect) {
            return rect.x + rect.width / 2;
        };
        cc.rectGetMinX = function(rect) {
            return rect.x;
        };
        cc.rectGetMaxY = function(rect) {
            return rect.y + rect.height;
        };
        cc.rectGetMidY = function(rect) {
            return rect.y + rect.height / 2;
        };
        cc.rectGetMinY = function(rect) {
            return rect.y;
        };
        cc.rectContainsPoint = function(rect, point) {
            return point.x >= cc.rectGetMinX(rect) && point.x <= cc.rectGetMaxX(rect) && point.y >= cc.rectGetMinY(rect) && point.y <= cc.rectGetMaxY(rect);
        };
        cc.rectIntersectsRect = function(ra, rb) {
            var maxax = ra.x + ra.width, maxay = ra.y + ra.height, maxbx = rb.x + rb.width, maxby = rb.y + rb.height;
            return !(maxax < rb.x || maxbx < ra.x || maxay < rb.y || maxby < ra.y);
        };
        cc.rectOverlapsRect = function(rectA, rectB) {
            return !(rectA.x + rectA.width < rectB.x || rectB.x + rectB.width < rectA.x || rectA.y + rectA.height < rectB.y || rectB.y + rectB.height < rectA.y);
        };
        cc.rectUnion = function(rectA, rectB) {
            var rect = cc.rect(0, 0, 0, 0);
            rect.x = Math.min(rectA.x, rectB.x);
            rect.y = Math.min(rectA.y, rectB.y);
            rect.width = Math.max(rectA.x + rectA.width, rectB.x + rectB.width) - rect.x;
            rect.height = Math.max(rectA.y + rectA.height, rectB.y + rectB.height) - rect.y;
            return rect;
        };
        cc.rectIntersection = function(rectA, rectB) {
            var intersection = cc.rect(Math.max(cc.rectGetMinX(rectA), cc.rectGetMinX(rectB)), Math.max(cc.rectGetMinY(rectA), cc.rectGetMinY(rectB)), 0, 0);
            intersection.width = Math.min(cc.rectGetMaxX(rectA), cc.rectGetMaxX(rectB)) - cc.rectGetMinX(intersection);
            intersection.height = Math.min(cc.rectGetMaxY(rectA), cc.rectGetMaxY(rectB)) - cc.rectGetMinY(intersection);
            return intersection;
        };
        module.exports = cc.Rect;
    }, {
        "../platform/CCClass": 57,
        "../platform/js": 70,
        "./CCValueType": 98
    } ],
    95: [ function(require, module, exports) {
        var ValueType = require("./CCValueType");
        var JS = require("../platform/js");
        function Size(width, height) {
            if (width && "object" === typeof width) {
                height = width.height;
                width = width.width;
            }
            this.width = "number" === typeof width ? width : 0;
            this.height = "number" === typeof height ? height : 0;
        }
        JS.extend(Size, ValueType);
        require("../platform/CCClass").fastDefine("cc.Size", Size, [ "width", "height" ]);
        JS.get(Size, "ZERO", function() {
            return new Size(0, 0);
        });
        var proto = Size.prototype;
        proto.clone = function() {
            return new Size(this.width, this.height);
        };
        proto.equals = function(other) {
            return other && this.width === other.width && this.height === other.height;
        };
        proto.lerp = function(to, ratio, out) {
            out = out || new Size();
            var width = this.width;
            var height = this.height;
            out.width = width + (to.width - width) * ratio;
            out.height = height + (to.height - height) * ratio;
            return out;
        };
        proto.toString = function() {
            return "(" + this.width.toFixed(2) + ", " + this.height.toFixed(2) + ")";
        };
        cc.size = function(w, h) {
            return new Size(w, h);
        };
        cc.sizeEqualToSize = function(size1, size2) {
            return size1 && size2 && size1.width === size2.width && size1.height === size2.height;
        };
        cc.Size = module.exports = Size;
    }, {
        "../platform/CCClass": 57,
        "../platform/js": 70,
        "./CCValueType": 98
    } ],
    96: [ function(require, module, exports) {
        cc.Acceleration = function(x, y, z, timestamp) {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
            this.timestamp = timestamp || 0;
        };
        cc.BlendFunc = function(src1, dst1) {
            this.src = src1;
            this.dst = dst1;
        };
        cc.BlendFunc._disable = function() {
            return new cc.BlendFunc(cc.ONE, cc.ZERO);
        };
        cc.BlendFunc._alphaPremultiplied = function() {
            return new cc.BlendFunc(cc.ONE, cc.ONE_MINUS_SRC_ALPHA);
        };
        cc.BlendFunc._alphaNonPremultiplied = function() {
            return new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
        };
        cc.BlendFunc._additive = function() {
            return new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE);
        };
        cc.BlendFunc.DISABLE;
        cc.js.get(cc.BlendFunc, "DISABLE", cc.BlendFunc._disable);
        cc.BlendFunc.ALPHA_PREMULTIPLIED;
        cc.js.get(cc.BlendFunc, "ALPHA_PREMULTIPLIED", cc.BlendFunc._alphaPremultiplied);
        cc.BlendFunc.ALPHA_NON_PREMULTIPLIED;
        cc.js.get(cc.BlendFunc, "ALPHA_NON_PREMULTIPLIED", cc.BlendFunc._alphaNonPremultiplied);
        cc.BlendFunc.ADDITIVE;
        cc.js.get(cc.BlendFunc, "ADDITIVE", cc.BlendFunc._additive);
        cc.blendFuncDisable = function() {
            return new cc.BlendFunc(cc.ONE, cc.ZERO);
        };
        cc.FontDefinition = function(properties) {
            var _t = this;
            _t.fontName = "Arial";
            _t.fontSize = 12;
            _t.textAlign = cc.TextAlignment.CENTER;
            _t.verticalAlign = cc.VerticalTextAlignment.TOP;
            _t.fillStyle = cc.color(255, 255, 255, 255);
            _t.boundingWidth = 0;
            _t.boundingHeight = 0;
            _t.strokeEnabled = false;
            _t.strokeStyle = cc.color(255, 255, 255, 255);
            _t.lineWidth = 1;
            _t.lineHeight = "normal";
            _t.fontStyle = "normal";
            _t.fontWeight = "normal";
            _t.shadowEnabled = false;
            _t.shadowOffsetX = 0;
            _t.shadowOffsetY = 0;
            _t.shadowBlur = 0;
            _t.shadowOpacity = 1;
            if (properties && properties instanceof Object) {
                for (var key in properties) {
                    _t[key] = properties[key];
                }
            }
        };
        cc.FontDefinition.prototype._getCanvasFontStr = function() {
            var lineHeight = !this.lineHeight.charAt ? this.lineHeight + "px" : this.lineHeight;
            return this.fontStyle + " " + this.fontWeight + " " + this.fontSize + "px/" + lineHeight + " '" + this.fontName + "'";
        };
        cc.SpriteType = cc.Enum({
            SIMPLE: 0,
            SLICED: 1
        });
        cc.TextAlignment = cc.Enum({
            LEFT: 0,
            CENTER: 1,
            RIGHT: 2
        });
        cc.VerticalTextAlignment = cc.Enum({
            TOP: 0,
            CENTER: 1,
            BOTTOM: 2
        });
        cc._Dictionary = cc.Class({
            ctor: function() {
                this._keyMapTb = {};
                this._valueMapTb = {};
                this.__currId = 2 << (0 | 10 * Math.random());
            },
            __getKey: function() {
                this.__currId++;
                return "key_" + this.__currId;
            },
            setObject: function(value, key) {
                if (null == key) {
                    return;
                }
                var keyId = this.__getKey();
                this._keyMapTb[keyId] = key;
                this._valueMapTb[keyId] = value;
            },
            objectForKey: function(key) {
                if (null == key) {
                    return null;
                }
                var locKeyMapTb = this._keyMapTb;
                for (var keyId in locKeyMapTb) {
                    if (locKeyMapTb[keyId] === key) {
                        return this._valueMapTb[keyId];
                    }
                }
                return null;
            },
            valueForKey: function(key) {
                return this.objectForKey(key);
            },
            removeObjectForKey: function(key) {
                if (null == key) {
                    return;
                }
                var locKeyMapTb = this._keyMapTb;
                for (var keyId in locKeyMapTb) {
                    if (locKeyMapTb[keyId] === key) {
                        delete this._valueMapTb[keyId];
                        delete locKeyMapTb[keyId];
                        return;
                    }
                }
            },
            removeObjectsForKeys: function(keys) {
                if (null == keys) {
                    return;
                }
                for (var i = 0; i < keys.length; i++) {
                    this.removeObjectForKey(keys[i]);
                }
            },
            allKeys: function() {
                var keyArr = [], locKeyMapTb = this._keyMapTb;
                for (var key in locKeyMapTb) {
                    keyArr.push(locKeyMapTb[key]);
                }
                return keyArr;
            },
            removeAllObjects: function() {
                this._keyMapTb = {};
                this._valueMapTb = {};
            },
            count: function() {
                return this.allKeys().length;
            }
        });
    }, {} ],
    97: [ function(require, module, exports) {
        cc.WebGLColor = function(r, g, b, a, arrayBuffer, offset) {
            this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.WebGLColor.BYTES_PER_ELEMENT);
            this._offset = offset || 0;
            var locArrayBuffer = this._arrayBuffer, locOffset = this._offset, locElementLen = Uint8Array.BYTES_PER_ELEMENT;
            this._rU8 = new Uint8Array(locArrayBuffer, locOffset, 1);
            this._gU8 = new Uint8Array(locArrayBuffer, locOffset + locElementLen, 1);
            this._bU8 = new Uint8Array(locArrayBuffer, locOffset + 2 * locElementLen, 1);
            this._aU8 = new Uint8Array(locArrayBuffer, locOffset + 3 * locElementLen, 1);
            this._rU8[0] = r || 0;
            this._gU8[0] = g || 0;
            this._bU8[0] = b || 0;
            this._aU8[0] = null == a ? 255 : a;
            if (void 0 === a) {
                this.a_undefined = true;
            }
        };
        cc.WebGLColor.BYTES_PER_ELEMENT = 4;
        var _p = cc.WebGLColor.prototype;
        _p._getR = function() {
            return this._rU8[0];
        };
        _p._setR = function(value) {
            this._rU8[0] = value < 0 ? 0 : value;
        };
        _p._getG = function() {
            return this._gU8[0];
        };
        _p._setG = function(value) {
            this._gU8[0] = value < 0 ? 0 : value;
        };
        _p._getB = function() {
            return this._bU8[0];
        };
        _p._setB = function(value) {
            this._bU8[0] = value < 0 ? 0 : value;
        };
        _p._getA = function() {
            return this._aU8[0];
        };
        _p._setA = function(value) {
            this._aU8[0] = value < 0 ? 0 : value;
        };
        _p.r;
        cc.js.getset(_p, "r", _p._getR, _p._setR);
        _p.g;
        cc.js.getset(_p, "g", _p._getG, _p._setG);
        _p.b;
        cc.js.getset(_p, "b", _p._getB, _p._setB);
        _p.a;
        cc.js.getset(_p, "a", _p._getA, _p._setA);
        cc.Vertex2F = function(x, y, arrayBuffer, offset) {
            this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.Vertex2F.BYTES_PER_ELEMENT);
            this._offset = offset || 0;
            this._xF32 = new Float32Array(this._arrayBuffer, this._offset, 1);
            this._yF32 = new Float32Array(this._arrayBuffer, this._offset + 4, 1);
            this._xF32[0] = x || 0;
            this._yF32[0] = y || 0;
        };
        cc.Vertex2F.BYTES_PER_ELEMENT = 8;
        _p = cc.Vertex2F.prototype;
        _p._getX = function() {
            return this._xF32[0];
        };
        _p._setX = function(xValue) {
            this._xF32[0] = xValue;
        };
        _p._getY = function() {
            return this._yF32[0];
        };
        _p._setY = function(yValue) {
            this._yF32[0] = yValue;
        };
        _p.x;
        cc.js.getset(_p, "x", _p._getX, _p._setX);
        _p.y;
        cc.js.getset(_p, "y", _p._getY, _p._setY);
        cc.Vertex3F = function(x, y, z, arrayBuffer, offset) {
            this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.Vertex3F.BYTES_PER_ELEMENT);
            this._offset = offset || 0;
            var locArrayBuffer = this._arrayBuffer, locOffset = this._offset;
            this._xF32 = new Float32Array(locArrayBuffer, locOffset, 1);
            this._xF32[0] = x || 0;
            this._yF32 = new Float32Array(locArrayBuffer, locOffset + Float32Array.BYTES_PER_ELEMENT, 1);
            this._yF32[0] = y || 0;
            this._zF32 = new Float32Array(locArrayBuffer, locOffset + 2 * Float32Array.BYTES_PER_ELEMENT, 1);
            this._zF32[0] = z || 0;
        };
        cc.Vertex3F.BYTES_PER_ELEMENT = 12;
        _p = cc.Vertex3F.prototype;
        _p._getX = function() {
            return this._xF32[0];
        };
        _p._setX = function(xValue) {
            this._xF32[0] = xValue;
        };
        _p._getY = function() {
            return this._yF32[0];
        };
        _p._setY = function(yValue) {
            this._yF32[0] = yValue;
        };
        _p._getZ = function() {
            return this._zF32[0];
        };
        _p._setZ = function(zValue) {
            this._zF32[0] = zValue;
        };
        _p.x;
        cc.js.getset(_p, "x", _p._getX, _p._setX);
        _p.y;
        cc.js.getset(_p, "y", _p._getY, _p._setY);
        _p.z;
        cc.js.getset(_p, "z", _p._getZ, _p._setZ);
        cc.Tex2F = function(u, v, arrayBuffer, offset) {
            this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.Tex2F.BYTES_PER_ELEMENT);
            this._offset = offset || 0;
            this._uF32 = new Float32Array(this._arrayBuffer, this._offset, 1);
            this._vF32 = new Float32Array(this._arrayBuffer, this._offset + 4, 1);
            this._uF32[0] = u || 0;
            this._vF32[0] = v || 0;
        };
        cc.Tex2F.BYTES_PER_ELEMENT = 8;
        _p = cc.Tex2F.prototype;
        _p._getU = function() {
            return this._uF32[0];
        };
        _p._setU = function(xValue) {
            this._uF32[0] = xValue;
        };
        _p._getV = function() {
            return this._vF32[0];
        };
        _p._setV = function(yValue) {
            this._vF32[0] = yValue;
        };
        _p.u;
        cc.js.getset(_p, "u", _p._getU, _p._setU);
        _p.v;
        cc.js.getset(_p, "v", _p._getV, _p._setV);
        cc.Quad2 = function(tl, tr, bl, br, arrayBuffer, offset) {
            this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.Quad2.BYTES_PER_ELEMENT);
            this._offset = offset || 0;
            var locArrayBuffer = this._arrayBuffer, locElementLen = cc.Vertex2F.BYTES_PER_ELEMENT;
            this._tl = tl ? new cc.Vertex2F(tl.x, tl.y, locArrayBuffer, 0) : new cc.Vertex2F(0, 0, locArrayBuffer, 0);
            this._tr = tr ? new cc.Vertex2F(tr.x, tr.y, locArrayBuffer, locElementLen) : new cc.Vertex2F(0, 0, locArrayBuffer, locElementLen);
            this._bl = bl ? new cc.Vertex2F(bl.x, bl.y, locArrayBuffer, 2 * locElementLen) : new cc.Vertex2F(0, 0, locArrayBuffer, 2 * locElementLen);
            this._br = br ? new cc.Vertex2F(br.x, br.y, locArrayBuffer, 3 * locElementLen) : new cc.Vertex2F(0, 0, locArrayBuffer, 3 * locElementLen);
        };
        cc.Quad2.BYTES_PER_ELEMENT = 32;
        _p = cc.Quad2.prototype;
        _p._getTL = function() {
            return this._tl;
        };
        _p._setTL = function(tlValue) {
            this._tl.x = tlValue.x;
            this._tl.y = tlValue.y;
        };
        _p._getTR = function() {
            return this._tr;
        };
        _p._setTR = function(trValue) {
            this._tr.x = trValue.x;
            this._tr.y = trValue.y;
        };
        _p._getBL = function() {
            return this._bl;
        };
        _p._setBL = function(blValue) {
            this._bl.x = blValue.x;
            this._bl.y = blValue.y;
        };
        _p._getBR = function() {
            return this._br;
        };
        _p._setBR = function(brValue) {
            this._br.x = brValue.x;
            this._br.y = brValue.y;
        };
        _p.tl;
        cc.js.getset(_p, "tl", _p._getTL, _p._setTL);
        _p.tr;
        cc.js.getset(_p, "tr", _p._getTR, _p._setTR);
        _p.bl;
        cc.js.getset(_p, "bl", _p._getBL, _p._setBL);
        _p.br;
        cc.js.getset(_p, "br", _p._getBR, _p._setBR);
        cc.Quad3 = function(bl1, br1, tl1, tr1) {
            this.bl = bl1 || new cc.Vertex3F(0, 0, 0);
            this.br = br1 || new cc.Vertex3F(0, 0, 0);
            this.tl = tl1 || new cc.Vertex3F(0, 0, 0);
            this.tr = tr1 || new cc.Vertex3F(0, 0, 0);
        };
        cc.V3F_C4B_T2F = function(vertices, colors, texCoords, arrayBuffer, offset) {
            this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.V3F_C4B_T2F.BYTES_PER_ELEMENT);
            this._offset = offset || 0;
            var locArrayBuffer = this._arrayBuffer, locOffset = this._offset, locElementLen = cc.Vertex3F.BYTES_PER_ELEMENT;
            this._vertices = vertices ? new cc.Vertex3F(vertices.x, vertices.y, vertices.z, locArrayBuffer, locOffset) : new cc.Vertex3F(0, 0, 0, locArrayBuffer, locOffset);
            this._colors = colors ? new cc.WebGLColor(colors.r, colors.g, colors.b, colors.a, locArrayBuffer, locOffset + locElementLen) : new cc.WebGLColor(0, 0, 0, 0, locArrayBuffer, locOffset + locElementLen);
            this._texCoords = texCoords ? new cc.Tex2F(texCoords.u, texCoords.v, locArrayBuffer, locOffset + locElementLen + cc.WebGLColor.BYTES_PER_ELEMENT) : new cc.Tex2F(0, 0, locArrayBuffer, locOffset + locElementLen + cc.WebGLColor.BYTES_PER_ELEMENT);
        };
        cc.V3F_C4B_T2F.BYTES_PER_ELEMENT = 24;
        _p = cc.V3F_C4B_T2F.prototype;
        _p._getVertices = function() {
            return this._vertices;
        };
        _p._setVertices = function(verticesValue) {
            var locVertices = this._vertices;
            locVertices.x = verticesValue.x;
            locVertices.y = verticesValue.y;
            locVertices.z = verticesValue.z;
        };
        _p._getColor = function() {
            return this._colors;
        };
        _p._setColor = function(colorValue) {
            var locColors = this._colors;
            locColors.r = colorValue.r;
            locColors.g = colorValue.g;
            locColors.b = colorValue.b;
            locColors.a = colorValue.a;
        };
        _p._getTexCoords = function() {
            return this._texCoords;
        };
        _p._setTexCoords = function(texValue) {
            this._texCoords.u = texValue.u;
            this._texCoords.v = texValue.v;
        };
        _p.vertices;
        cc.js.getset(_p, "vertices", _p._getVertices, _p._setVertices);
        _p.colors;
        cc.js.getset(_p, "colors", _p._getColor, _p._setColor);
        _p.texCoords;
        cc.js.getset(_p, "texCoords", _p._getTexCoords, _p._setTexCoords);
        cc.V3F_C4B_T2F_Quad = function(tl, bl, tr, br, arrayBuffer, offset) {
            this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT);
            this._offset = offset || 0;
            var locArrayBuffer = this._arrayBuffer, locOffset = this._offset, locElementLen = cc.V3F_C4B_T2F.BYTES_PER_ELEMENT;
            this._tl = tl ? new cc.V3F_C4B_T2F(tl.vertices, tl.colors, tl.texCoords, locArrayBuffer, locOffset) : new cc.V3F_C4B_T2F(null, null, null, locArrayBuffer, locOffset);
            this._bl = bl ? new cc.V3F_C4B_T2F(bl.vertices, bl.colors, bl.texCoords, locArrayBuffer, locOffset + locElementLen) : new cc.V3F_C4B_T2F(null, null, null, locArrayBuffer, locOffset + locElementLen);
            this._tr = tr ? new cc.V3F_C4B_T2F(tr.vertices, tr.colors, tr.texCoords, locArrayBuffer, locOffset + 2 * locElementLen) : new cc.V3F_C4B_T2F(null, null, null, locArrayBuffer, locOffset + 2 * locElementLen);
            this._br = br ? new cc.V3F_C4B_T2F(br.vertices, br.colors, br.texCoords, locArrayBuffer, locOffset + 3 * locElementLen) : new cc.V3F_C4B_T2F(null, null, null, locArrayBuffer, locOffset + 3 * locElementLen);
        };
        cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT = 96;
        _p = cc.V3F_C4B_T2F_Quad.prototype;
        _p._getTL = function() {
            return this._tl;
        };
        _p._setTL = function(tlValue) {
            var locTl = this._tl;
            locTl.vertices = tlValue.vertices;
            locTl.colors = tlValue.colors;
            locTl.texCoords = tlValue.texCoords;
        };
        _p._getBL = function() {
            return this._bl;
        };
        _p._setBL = function(blValue) {
            var locBl = this._bl;
            locBl.vertices = blValue.vertices;
            locBl.colors = blValue.colors;
            locBl.texCoords = blValue.texCoords;
        };
        _p._getTR = function() {
            return this._tr;
        };
        _p._setTR = function(trValue) {
            var locTr = this._tr;
            locTr.vertices = trValue.vertices;
            locTr.colors = trValue.colors;
            locTr.texCoords = trValue.texCoords;
        };
        _p._getBR = function() {
            return this._br;
        };
        _p._setBR = function(brValue) {
            var locBr = this._br;
            locBr.vertices = brValue.vertices;
            locBr.colors = brValue.colors;
            locBr.texCoords = brValue.texCoords;
        };
        _p._getArrayBuffer = function() {
            return this._arrayBuffer;
        };
        _p.tl;
        cc.js.getset(_p, "tl", _p._getTL, _p._setTL);
        _p.tr;
        cc.js.getset(_p, "tr", _p._getTR, _p._setTR);
        _p.bl;
        cc.js.getset(_p, "bl", _p._getBL, _p._setBL);
        _p.br;
        cc.js.getset(_p, "br", _p._getBR, _p._setBR);
        _p.arrayBuffer;
        cc.js.get(_p, "arrayBuffer", _p._getArrayBuffer);
        cc.V3F_C4B_T2F_QuadZero = function() {
            return new cc.V3F_C4B_T2F_Quad();
        };
        cc.V3F_C4B_T2F_QuadCopy = function(sourceQuad) {
            if (!sourceQuad) {
                return cc.V3F_C4B_T2F_QuadZero();
            }
            var srcTL = sourceQuad.tl, srcBL = sourceQuad.bl, srcTR = sourceQuad.tr, srcBR = sourceQuad.br;
            return {
                tl: {
                    vertices: {
                        x: srcTL.vertices.x,
                        y: srcTL.vertices.y,
                        z: srcTL.vertices.z
                    },
                    colors: {
                        r: srcTL.colors.r,
                        g: srcTL.colors.g,
                        b: srcTL.colors.b,
                        a: srcTL.colors.a
                    },
                    texCoords: {
                        u: srcTL.texCoords.u,
                        v: srcTL.texCoords.v
                    }
                },
                bl: {
                    vertices: {
                        x: srcBL.vertices.x,
                        y: srcBL.vertices.y,
                        z: srcBL.vertices.z
                    },
                    colors: {
                        r: srcBL.colors.r,
                        g: srcBL.colors.g,
                        b: srcBL.colors.b,
                        a: srcBL.colors.a
                    },
                    texCoords: {
                        u: srcBL.texCoords.u,
                        v: srcBL.texCoords.v
                    }
                },
                tr: {
                    vertices: {
                        x: srcTR.vertices.x,
                        y: srcTR.vertices.y,
                        z: srcTR.vertices.z
                    },
                    colors: {
                        r: srcTR.colors.r,
                        g: srcTR.colors.g,
                        b: srcTR.colors.b,
                        a: srcTR.colors.a
                    },
                    texCoords: {
                        u: srcTR.texCoords.u,
                        v: srcTR.texCoords.v
                    }
                },
                br: {
                    vertices: {
                        x: srcBR.vertices.x,
                        y: srcBR.vertices.y,
                        z: srcBR.vertices.z
                    },
                    colors: {
                        r: srcBR.colors.r,
                        g: srcBR.colors.g,
                        b: srcBR.colors.b,
                        a: srcBR.colors.a
                    },
                    texCoords: {
                        u: srcBR.texCoords.u,
                        v: srcBR.texCoords.v
                    }
                }
            };
        };
        cc.V3F_C4B_T2F_QuadsCopy = function(sourceQuads) {
            if (!sourceQuads) {
                return [];
            }
            var retArr = [];
            for (var i = 0; i < sourceQuads.length; i++) {
                retArr.push(cc.V3F_C4B_T2F_QuadCopy(sourceQuads[i]));
            }
            return retArr;
        };
        cc.V2F_C4B_T2F = function(vertices, colors, texCoords, arrayBuffer, offset) {
            this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.V2F_C4B_T2F.BYTES_PER_ELEMENT);
            this._offset = offset || 0;
            var locArrayBuffer = this._arrayBuffer, locOffset = this._offset, locElementLen = cc.Vertex2F.BYTES_PER_ELEMENT;
            this._vertices = vertices ? new cc.Vertex2F(vertices.x, vertices.y, locArrayBuffer, locOffset) : new cc.Vertex2F(0, 0, locArrayBuffer, locOffset);
            this._colors = colors ? new cc.WebGLColor(colors.r, colors.g, colors.b, colors.a, locArrayBuffer, locOffset + locElementLen) : new cc.WebGLColor(0, 0, 0, 0, locArrayBuffer, locOffset + locElementLen);
            this._texCoords = texCoords ? new cc.Tex2F(texCoords.u, texCoords.v, locArrayBuffer, locOffset + locElementLen + cc.WebGLColor.BYTES_PER_ELEMENT) : new cc.Tex2F(0, 0, locArrayBuffer, locOffset + locElementLen + cc.WebGLColor.BYTES_PER_ELEMENT);
        };
        cc.V2F_C4B_T2F.BYTES_PER_ELEMENT = 20;
        _p = cc.V2F_C4B_T2F.prototype;
        _p._getVertices = function() {
            return this._vertices;
        };
        _p._setVertices = function(verticesValue) {
            this._vertices.x = verticesValue.x;
            this._vertices.y = verticesValue.y;
        };
        _p._getColor = function() {
            return this._colors;
        };
        _p._setColor = function(colorValue) {
            var locColors = this._colors;
            locColors.r = colorValue.r;
            locColors.g = colorValue.g;
            locColors.b = colorValue.b;
            locColors.a = colorValue.a;
        };
        _p._getTexCoords = function() {
            return this._texCoords;
        };
        _p._setTexCoords = function(texValue) {
            this._texCoords.u = texValue.u;
            this._texCoords.v = texValue.v;
        };
        _p.vertices;
        cc.js.getset(_p, "vertices", _p._getVertices, _p._setVertices);
        _p.colors;
        cc.js.getset(_p, "colors", _p._getColor, _p._setColor);
        _p.texCoords;
        cc.js.getset(_p, "texCoords", _p._getTexCoords, _p._setTexCoords);
        cc.V2F_C4B_T2F_Triangle = function(a, b, c, arrayBuffer, offset) {
            this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT);
            this._offset = offset || 0;
            var locArrayBuffer = this._arrayBuffer, locOffset = this._offset, locElementLen = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
            this._a = a ? new cc.V2F_C4B_T2F(a.vertices, a.colors, a.texCoords, locArrayBuffer, locOffset) : new cc.V2F_C4B_T2F(null, null, null, locArrayBuffer, locOffset);
            this._b = b ? new cc.V2F_C4B_T2F(b.vertices, b.colors, b.texCoords, locArrayBuffer, locOffset + locElementLen) : new cc.V2F_C4B_T2F(null, null, null, locArrayBuffer, locOffset + locElementLen);
            this._c = c ? new cc.V2F_C4B_T2F(c.vertices, c.colors, c.texCoords, locArrayBuffer, locOffset + 2 * locElementLen) : new cc.V2F_C4B_T2F(null, null, null, locArrayBuffer, locOffset + 2 * locElementLen);
        };
        cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT = 60;
        _p = cc.V2F_C4B_T2F_Triangle.prototype;
        _p._getA = function() {
            return this._a;
        };
        _p._setA = function(aValue) {
            var locA = this._a;
            locA.vertices = aValue.vertices;
            locA.colors = aValue.colors;
            locA.texCoords = aValue.texCoords;
        };
        _p._getB = function() {
            return this._b;
        };
        _p._setB = function(bValue) {
            var locB = this._b;
            locB.vertices = bValue.vertices;
            locB.colors = bValue.colors;
            locB.texCoords = bValue.texCoords;
        };
        _p._getC = function() {
            return this._c;
        };
        _p._setC = function(cValue) {
            var locC = this._c;
            locC.vertices = cValue.vertices;
            locC.colors = cValue.colors;
            locC.texCoords = cValue.texCoords;
        };
        _p.a;
        cc.js.getset(_p, "a", _p._getA, _p._setA);
        _p.b;
        cc.js.getset(_p, "b", _p._getB, _p._setB);
        _p.c;
        cc.js.getset(_p, "c", _p._getC, _p._setC);
    }, {} ],
    98: [ function(require, module, exports) {
        var JS = require("../platform/js");
        function ValueType() {}
        JS.setClassName("cc.ValueType", ValueType);
        JS.mixin(ValueType.prototype, {
            clone: false,
            equals: false,
            toString: function() {
                return "" + {};
            },
            lerp: false
        });
        cc.ValueType = ValueType;
        module.exports = ValueType;
    }, {
        "../platform/js": 70
    } ],
    99: [ function(require, module, exports) {
        var ValueType = require("./CCValueType");
        var JS = require("../platform/js");
        var FireClass = require("../platform/CCClass");
        function Vec2(x, y) {
            if (x && "object" === typeof x) {
                y = x.y;
                x = x.x;
            }
            this.x = "number" === typeof x ? x : 0;
            this.y = "number" === typeof y ? y : 0;
        }
        JS.extend(Vec2, ValueType);
        FireClass.fastDefine("cc.Vec2", Vec2, [ "x", "y" ]);
        JS.mixin(Vec2.prototype, {
            clone: function() {
                return new Vec2(this.x, this.y);
            },
            set: function(newValue) {
                this.x = newValue.x;
                this.y = newValue.y;
                return this;
            },
            equals: function(other) {
                return other && this.x === other.x && this.y === other.y;
            },
            toString: function() {
                return "(" + this.x.toFixed(2) + ", " + this.y.toFixed(2) + ")";
            },
            lerp: function(to, ratio, out) {
                out = out || new Vec2();
                var x = this.x;
                var y = this.y;
                out.x = x + (to.x - x) * ratio;
                out.y = y + (to.y - y) * ratio;
                return out;
            },
            addSelf: function(vector) {
                this.x += vector.x;
                this.y += vector.y;
                return this;
            },
            add: function(vector, out) {
                out = out || new Vec2();
                out.x = this.x + vector.x;
                out.y = this.y + vector.y;
                return out;
            },
            subSelf: function(vector) {
                this.x -= vector.x;
                this.y -= vector.y;
                return this;
            },
            sub: function(vector, out) {
                out = out || new Vec2();
                out.x = this.x - vector.x;
                out.y = this.y - vector.y;
                return out;
            },
            mulSelf: function(num) {
                this.x *= num;
                this.y *= num;
                return this;
            },
            mul: function(num, out) {
                out = out || new Vec2();
                out.x = this.x * num;
                out.y = this.y * num;
                return out;
            },
            scaleSelf: function(vector) {
                this.x *= vector.x;
                this.y *= vector.y;
                return this;
            },
            scale: function(vector, out) {
                out = out || new Vec2();
                out.x = this.x * vector.x;
                out.y = this.y * vector.y;
                return out;
            },
            divSelf: function(num) {
                this.x /= num;
                this.y /= num;
                return this;
            },
            div: function(num, out) {
                out = out || new Vec2();
                out.x = this.x / num;
                out.y = this.y / num;
                return out;
            },
            negSelf: function() {
                this.x = -this.x;
                this.y = -this.y;
                return this;
            },
            neg: function(out) {
                out = out || new Vec2();
                out.x = -this.x;
                out.y = -this.y;
                return out;
            },
            dot: function(vector) {
                return this.x * vector.x + this.y * vector.y;
            },
            cross: function(vector) {
                return this.y * vector.x - this.x * vector.y;
            },
            mag: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            },
            magSqr: function() {
                return this.x * this.x + this.y * this.y;
            },
            normalizeSelf: function() {
                var magSqr = this.x * this.x + this.y * this.y;
                if (1 === magSqr) {
                    return this;
                }
                if (0 === magSqr) {
                    console.warn("Can't normalize zero vector");
                    return this;
                }
                var invsqrt = 1 / Math.sqrt(magSqr);
                this.x *= invsqrt;
                this.y *= invsqrt;
                return this;
            },
            normalize: function(out) {
                out = out || new Vec2();
                out.x = this.x;
                out.y = this.y;
                out.normalizeSelf();
                return out;
            },
            angle: function(vector) {
                var magSqr1 = this.magSqr();
                var magSqr2 = vector.magSqr();
                if (0 === magSqr1 || 0 === magSqr2) {
                    console.warn("Can't get angle between zero vector");
                    return 0;
                }
                var dot = this.dot(vector);
                var theta = dot / Math.sqrt(magSqr1 * magSqr2);
                theta = cc.clampf(theta, -1, 1);
                return Math.acos(theta);
            },
            signAngle: function(vector) {
                return Math.atan2(this.y, this.x) - Math.atan2(vector.y, vector.x);
            },
            rotate: function(radians, out) {
                out = out || new Vec2();
                out.x = this.x;
                out.y = this.y;
                return out.rotateSelf(radians);
            },
            rotateSelf: function(radians) {
                var sin = Math.sin(radians);
                var cos = Math.cos(radians);
                var x = this.x;
                this.x = cos * x - sin * this.y;
                this.y = sin * x + cos * this.y;
                return this;
            }
        });
        JS.get(Vec2, "ONE", function() {
            return new Vec2(1, 1);
        });
        JS.get(Vec2, "ZERO", function() {
            return new Vec2(0, 0);
        });
        JS.get(Vec2, "UP", function() {
            return new Vec2(0, 1);
        });
        JS.get(Vec2, "RIGHT", function() {
            return new Vec2(1, 0);
        });
        cc.Vec2 = Vec2;
        cc.v2 = function v2(x, y) {
            return new Vec2(x, y);
        };
        cc.p = cc.v2;
        cc.pointEqualToPoint = function(point1, point2) {
            return point1 && point2 && point1.x === point2.x && point1.y === point2.y;
        };
        module.exports = cc.Vec2;
    }, {
        "../platform/CCClass": 57,
        "../platform/js": 70,
        "./CCValueType": 98
    } ],
    100: [ function(require, module, exports) {
        require("./CCValueType");
        require("./CCEnum");
        require("./CCVec2");
        require("./CCPointExtension");
        require("./CCSize");
        require("./CCRect");
        require("./CCColor");
        require("./CCTypes");
        require("./CCAffineTransform");
        require("./CCTypesWebGL");
    }, {
        "./CCAffineTransform": 90,
        "./CCColor": 91,
        "./CCEnum": 92,
        "./CCPointExtension": 93,
        "./CCRect": 94,
        "./CCSize": 95,
        "./CCTypes": 96,
        "./CCTypesWebGL": 97,
        "./CCValueType": 98,
        "./CCVec2": 99
    } ],
    101: [ function(require, module, exports) {
        if (false) {
            var js = cc.js;
            var INFO = cc._LogInfos.deprecated;
            js.get(cc, "inject", function() {
                cc.warn(INFO + " The first argument should be the destination object", "cc.inject", "cc.js.addon");
                return js.addon;
            });
            js.get(cc, "extend", function() {
                cc.warn(INFO, "cc.extend", "cc.js.mixin");
                return js.mixin;
            });
            js.get(cc, "newElement", function() {
                cc.warn(INFO, "cc.newElement", "document.createElement");
                return document.createElement;
            });
            js.get(cc, "isFunction", function() {
                cc.warn(INFO, "cc.isFunction", "cc.js.isFunction");
                return js.isFunction;
            });
            js.get(cc, "isNumber", function() {
                cc.warn(INFO, "cc.isNumber", "cc.js.isNumber");
                return js.isNumber;
            });
            js.get(cc, "isString", function() {
                cc.warn(INFO, "cc.isString", "cc.js.isString");
                return js.isString;
            });
            js.get(cc, "isArray", function() {
                cc.warn(INFO, "cc.isArray", "cc.js.isArray");
                return js.isArray;
            });
            js.get(cc, "isUndefined", function() {
                cc.warn(INFO, "cc.isUndefined", "cc.js.isUndefined");
                return js.isUndefined;
            });
            js.get(cc, "isObject", function() {
                cc.warn(INFO, "cc.isObject", "cc.js.isObject");
                return js.isObject;
            });
            js.obsoletes(cc, "cc", {
                Point: "Vec2",
                EScene: "Scene",
                ENode: "Node"
            });
            js.get(cc, "arrayVerifyType", function() {
                cc.warn(INFO, "cc.arrayVerifyType", "cc.js.array.verifyType");
                return cc.js.array.verifyType;
            });
            js.get(cc, "arrayRemoveObject", function() {
                cc.warn(INFO, "cc.arrayRemoveObject", "cc.js.array.remove");
                return cc.js.array.remove;
            });
            js.get(cc, "arrayRemoveArray", function() {
                cc.warn(INFO, "cc.arrayRemoveArray", "cc.js.array.removeArray");
                return cc.js.array.removeArray;
            });
            js.get(cc, "arrayAppendObjectsToIndex", function() {
                cc.warn(INFO, "cc.arrayAppendObjectsToIndex", "cc.js.array.appendObjectsAt");
                return cc.js.array.appendObjectsAt;
            });
            js.get(cc, "copyArray", function() {
                cc.warn(INFO, "cc.copyArray", "cc.js.array.copy");
                return cc.js.array.copy;
            });
            function deprecateEnum(obj, oldPath, newPath, hasTypePrefixBefore) {
                hasTypePrefixBefore = false !== hasTypePrefixBefore;
                var enumDef = eval(newPath);
                var entries = cc.Enum.getList(enumDef);
                var delimiter = hasTypePrefixBefore ? "_" : ".";
                for (var i = 0; i < entries.length; i++) {
                    var entry = entries[i].name;
                    var oldPropName;
                    if (hasTypePrefixBefore) {
                        var oldTypeName = oldPath.split(".").slice(-1)[0];
                        oldPropName = oldTypeName + "_" + entry;
                    } else {
                        oldPropName = entry;
                    }
                    js.get(obj, oldPropName, function(entry) {
                        cc.warn(INFO, oldPath + delimiter + entry, newPath + "." + entry);
                        return enumDef[entry];
                    }.bind(null, entry));
                }
            }
            deprecateEnum(cc, "cc.TEXT_ALIGNMENT", "cc.TextAlignment");
            deprecateEnum(cc, "cc.VERTICAL_TEXT_ALIGNMENT", "cc.VerticalTextAlignment");
            deprecateEnum(_ccsg.ParticleSystem, "_ccsg.ParticleSystem.TYPE", "_ccsg.ParticleSystem.Type");
            deprecateEnum(_ccsg.ParticleSystem, "_ccsg.ParticleSystem.MODE", "_ccsg.ParticleSystem.Mode");
            deprecateEnum(cc.ParticleSystem, "cc.ParticleSystem.TYPE", "cc.ParticleSystem.PositionType");
            deprecateEnum(cc.ParticleSystem, "cc.ParticleSystem.MODE", "cc.ParticleSystem.EmitterMode");
            deprecateEnum(cc.ProgressTimer, "cc.ProgressTimer.TYPE", "cc.ProgressTimer.Type");
            deprecateEnum(cc.game, "cc.game.DEBUG_MODE", "cc.DebugMode");
            if (cc.EditBox) {
                deprecateEnum(cc, "cc.KEYBOARD_RETURNTYPE", "cc.KeyboardReturnType");
                deprecateEnum(cc, "cc.EDITBOX_INPUT_MODE", "cc.EditBox.InputMode");
                deprecateEnum(cc, "cc.EDITBOX_INPUT_FLAG", "cc.EditBox.InputFlag");
            }
            cc.game.once(cc.game.EVENT_RENDERER_INITED, function() {
                deprecateEnum(cc, "cc", "cc.Texture2D.WrapMode", false);
            });
            function markAsRemoved(ownerCtor, removedProps, ownerName) {
                ownerName = ownerName || js.getClassName(ownerCtor);
                removedProps.forEach(function(prop) {
                    function error() {
                        cc.error("Sorry, %s.%s is removed.", ownerName, prop);
                    }
                    js.getset(ownerCtor.prototype, prop, error, error);
                });
            }
            function provideClearError(owner, obj) {
                var className = cc.js.getClassName(owner);
                var Info = "Sorry," + className + ".%s is removed, please use %s instead.";
                for (var prop in obj) {
                    function define(prop, getset) {
                        function accessor(newProp) {
                            cc.error(Info, prop, newProp);
                        }
                        if (!Array.isArray(getset)) {
                            getset = getset.split(",").map(function(x) {
                                return x.trim();
                            });
                        }
                        js.getset(owner, prop, accessor.bind(null, getset[0]), getset[1] && accessor.bind(null, getset[1]));
                    }
                    var getset = obj[prop];
                    if ("*" === prop[0]) {
                        var etProp = prop.slice(1);
                        define("g" + etProp, getset);
                        define("s" + etProp, getset);
                    } else {
                        prop.split(",").map(function(x) {
                            return x.trim();
                        }).forEach(function(x) {
                            define(x, getset);
                        });
                    }
                }
            }
            function shouldNotUseNodeProp(component) {
                var compName = cc.js.getClassName(component);
                var Info = "Sorry, " + compName + ".%s is removed, please use cc.Node.%s instead.";
                var compProto = component.prototype;
                for (var prop in cc.Node.prototype) {
                    !function(prop) {
                        if (!(prop in compProto) && "_" !== prop[0]) {
                            js.getset(compProto, prop, function() {
                                cc.error(Info, prop, prop);
                            }, function() {
                                cc.error(Info, prop, prop);
                            });
                        }
                    }(prop);
                }
            }
            markAsRemoved(cc.Node, [ "_componentContainer", "_camera", "_additionalTransform", "_scheduler", "_actionManager", "actionManager", "_isTransitionFinished", "_additionalTransformDirty", "_shaderProgram", "shaderProgram", "_reorderChildDirty", "_normalizedPositionDirty", "_normalizedPosition", "_usingNormalizedPosition", "_renderCmd", "_vertexZ", "_showNode", "_arrayMakeObjectsPerformSelector", "getActionManager", "setActionManager", "getScheduler", "setScheduler", "sortAllChildren", "reorderChild", "draw", "transformAncestors", "onEnter", "onEnterTransitionDidFinish", "onExitTransitionDidStart", "onExit", "getNumberOfRunningActions", "scheduleUpdate", "scheduleUpdateWithPriority", "unscheduleUpdate", "schedule", "scheduleOnce", "unschedule", "unscheduleAllCallbacks", "resumeSchedulerAndActions", "resume", "pauseSchedulerAndActions", "pause", "setAdditionalTransform", "updateTransform", "retain", "release", "visit", "transform", "getCamera", "grid", "getGrid", "setGrid", "getShaderProgram", "setShaderProgram", "getGLServerState", "setGLServerState", "_initRendererCmd", "_createRenderCmd", "updateDisplayedOpacity", "updateDisplayedColor", "userData", "userObject", "_cascadeColorEnabled", "cascadeColor" ]);
            provideClearError(cc.Node.prototype, {
                arrivalOrder: "getSiblingIndex, setSiblingIndex",
                _visible: "_activeInHierarchy, active",
                _running: "_activeInHierarchy, active",
                running: "activeInHierarchy, active",
                _realOpacity: "_opacity, _opacity",
                _realColor: "_color, _color",
                getZOrder: "getLocalZOrder",
                setZOrder: "setLocalZOrder",
                getOrderOfArrival: "getSiblingIndex",
                setOrderOfArrival: "setSiblingIndex",
                boundingBox: "getBoundingBox",
                removeFromParentAndCleanup: "removeFromParent",
                removeAllChildrenWithCleanup: "removeAllChildren",
                parentToNodeTransform: "getParentToNodeTransform",
                nodeToWorldTransform: "getNodeToWorlshaderProgramdTransform",
                worldToNodeTransform: "getWorldToNodeTransform",
                nodeToParentTransform: "getNodeToParentTransform",
                removeAllComponents: "removeComponent",
                getNodeToParentAffineTransform: "getNodeToParentTransform"
            });
            markAsRemoved(cc.Sprite, [ "textureLoaded", "setBlendFunc", "getBlendFunc", "setState", "getState", "resizableSpriteWithCapInsets", "flippedX", "flippedY", "setFlippedX", "setFlippedY", "isFlippedX", "isFlippedY", "getCapInsets", "setCapInsets" ]);
            provideClearError(cc.Sprite, {
                create: "node.addComponent",
                createWithTexture: "node.addComponent",
                createWithSpriteFrameName: "node.addComponent",
                createWithSpriteFrame: "node.addComponent"
            });
            provideClearError(cc.Sprite.prototype, {
                ignoreAnchorPointForPosition: "instance.ignoreAnchor",
                getPreferredSize: "node.getContentSize",
                setPreferredSize: "node.setContentSize",
                updateWithSprite: "spriteFrame",
                getSpriteFrame: "spriteFrame",
                setSpriteFrame: "spriteFrame"
            });
            shouldNotUseNodeProp(cc.Sprite);
            markAsRemoved(cc.ParticleSystem, [ "batchNode", "drawMode", "getDrawMode", "setDrawMode", "shapeType", "getShapeType", "setShapeType", "atlasIndex", "init", "initParticle", "updateWithNoTime" ]);
            provideClearError(cc.ParticleSystem, {
                initWithFile: "instance.file",
                initWithDictionary: "instance.file",
                initWithTotalParticles: "instance.totalParticles"
            });
            provideClearError(cc.ParticleSystem.prototype, {
                destroyParticleSystem: "destroy",
                clone: "cc.instantiate",
                isActive: "active",
                "*etParticleCount": "particleCount",
                "*etDuration": "duration",
                "*etSourcePosition": "sourcePos",
                "*etPosVar": "posVar",
                "*etGravity": "gravity",
                "*etSpeed": "speed",
                "*etSpeedVar": "speedVar",
                "*etTangentialAccel": "tangentialAccel",
                "*etTangentialAccelVar": "tangentialAccelVar",
                "*etRadialAccel": "radialAccel",
                "*etRadialAccelVar": "radialAccelVar",
                "*etRotationIsDir": "rotationIsDir",
                "*etStartRadius": "startRadius",
                "*etStartRadiusVar": "startRadiusVar",
                "*etEndRadius": "endRadius",
                "*etEndRadiusVar": "endRadiusVar",
                "*etRotatePerSecond": "rotatePerS",
                "*etRotatePerSecondVar": "rotatePerSVar",
                "*etStartColor": "startColor",
                "*etStartColorVar": "startColorVar",
                "*etEndColor": "endColor",
                "*etEndColorVar": "endColorVar",
                "*etTotalParticles": "totalParticles",
                "*etTexture": "texture"
            });
            shouldNotUseNodeProp(cc.ParticleSystem);
            js.obsoletes(cc.ParticleSystem, "cc.ParticleSystem", {
                Type: "PositionType",
                Mode: "EmitterMode"
            });
            markAsRemoved(_ccsg.Node, [ "_normalizedPositionDirty", "_normalizedPosition", "_usingNormalizedPosition", "grid", "userData", "userObject", "getNormalizedPosition", "setNormalizedPosition", "getCamera", "getUserData", "setUserData", "getUserObject", "setUserObject", "getComponent", "addComponent", "removeComponent", "removeAllComponents", "enumerateChildren", "setCameraMask", "getCameraMask" ], "_ccsg.Node");
            js.obsoletes(cc.Scale9Sprite.prototype, "cc.Scale9Sprite", {
                setPreferredSize: "setContentSize",
                getPreferredSize: "getContentSize"
            });
            markAsRemoved(cc.Scale9Sprite, [ "init", "resizableSpriteWithCapInsets", "updateWithSprite", "getOriginalSize", "setCapInsets", "getCapInsets", "setScale9Enabled", "isScale9Enabled", "getSprite", "setFlippedX", "isFlippedX", "setFlippedY", "isFlippedY" ]);
        }
    }, {} ],
    102: [ function(require, module, exports) {
        var ParticleAsset = cc.Class({
            name: "cc.ParticleAsset",
            "extends": cc.RawAsset
        });
        cc.ParticleAsset = module.exports = ParticleAsset;
    }, {} ],
    103: [ function(require, module, exports) {
        var EmitterMode = cc.Enum({
            GRAVITY: 0,
            RADIUS: 1
        });
        var PositionType = cc.Enum({
            FREE: 0,
            RELATIVE: 1,
            GROUPED: 2
        });
        var properties = {
            preview: {
                "default": true,
                editorOnly: true,
                notify: false
            },
            _custom: false,
            custom: {
                get: function() {
                    return this._custom;
                },
                set: function(value) {
                    if (false) {
                        return cc.warn("Custom should not be false if file is not specified.");
                    }
                    if (this._custom !== value) {
                        this._custom = value;
                        if (this._sgNode) {
                            if (value) {
                                this._applyCustoms();
                            } else {
                                this._applyFile();
                            }
                            cc.engine.repaintInEditMode();
                        }
                    }
                }
            },
            _file: {
                "default": "",
                url: cc.ParticleAsset
            },
            file: {
                get: function() {
                    return this._file;
                },
                set: function(value, force) {
                    if (this._file !== value || false) {
                        this._file = value;
                        if (this._sgNode && value) {
                            this._applyFile();
                            cc.engine.repaintInEditMode();
                        } else {
                            this.custom = true;
                        }
                    }
                },
                url: cc.ParticleAsset
            },
            _texture: {
                "default": "",
                url: cc.Texture2D
            },
            texture: {
                get: function() {
                    return this._texture;
                },
                set: function(value) {
                    this._texture = value;
                    if (this._sgNode) {
                        this._sgNode.texture = value ? cc.textureCache.addImage(value) : null;
                    }
                },
                url: cc.Texture2D
            },
            particleCount: {
                get: function() {
                    return this._sgNode ? this._sgNode.particleCount : 0;
                },
                set: function(value) {
                    if (this._sgNode) {
                        this._sgNode.particleCount = value;
                    }
                },
                visible: false
            },
            playOnLoad: true,
            _autoRemoveOnFinish: false,
            autoRemoveOnFinish: {
                get: function() {
                    return this._autoRemoveOnFinish;
                },
                set: function(value) {
                    if (this._autoRemoveOnFinish !== value) {
                        this._autoRemoveOnFinish = value;
                        if (false) {
                            return;
                        }
                        this._applyAutoRemove();
                    }
                }
            },
            active: {
                get: function() {
                    return this._sgNode ? this._sgNode.isActive() : false;
                },
                visible: false
            }
        };
        var CustomProps = function() {
            var DefaultValues = {
                totalParticles: 150,
                duration: -1,
                emissionRate: 10,
                life: 1,
                lifeVar: 0,
                startColor: cc.Color.WHITE,
                startColorVar: cc.Color.BLACK,
                endColor: cc.color(255, 255, 255, 0),
                endColorVar: cc.color(0, 0, 0, 0),
                angle: 90,
                angleVar: 20,
                startSize: 50,
                startSizeVar: 0,
                endSize: 0,
                endSizeVar: 0,
                startSpin: 0,
                startSpinVar: 0,
                endSpin: 0,
                endSpinVar: 0,
                sourcePos: cc.p(0, 0),
                posVar: cc.p(0, 0),
                positionType: PositionType.FREE,
                emitterMode: EmitterMode.GRAVITY,
                gravity: cc.p(0, 0),
                speed: 180,
                speedVar: 50,
                tangentialAccel: 80,
                tangentialAccelVar: 0,
                radialAccel: 0,
                radialAccelVar: 0,
                rotationIsDir: false,
                startRadius: 0,
                startRadiusVar: 0,
                endRadius: 0,
                endRadiusVar: 0,
                rotatePerS: 0,
                rotatePerSVar: 0
            };
            var props = Object.keys(DefaultValues);
            for (var i = 0; i < props.length; ++i) {
                var prop = props[i];
                !function(prop, defaultValue) {
                    var internalProp = "_" + prop;
                    properties[internalProp] = defaultValue;
                    var type = defaultValue.constructor;
                    var propDef = properties[prop] = {};
                    if (cc.isChildClassOf(type, cc.ValueType)) {
                        propDef.get = function() {
                            return new type(this[internalProp]);
                        };
                        propDef.type = type;
                    } else {
                        propDef.get = function() {
                            return this[internalProp];
                        };
                    }
                    if (cc.isChildClassOf(type, cc.ValueType)) {
                        propDef.set = function(value) {
                            this[internalProp] = new type(value);
                            if (this._sgNode) {
                                this._sgNode[prop] = value;
                            }
                        };
                    } else {
                        if (false) {
                            propDef.set = function(value) {
                                this[internalProp] = value;
                                if (!isNaN(value)) {
                                    if (this._sgNode) {
                                        this._sgNode[prop] = value;
                                    }
                                } else {
                                    cc.error("The new %s must not be NaN", prop);
                                }
                            };
                        } else {
                            propDef.set = function(value) {
                                this[internalProp] = value;
                                if (this._sgNode) {
                                    this._sgNode[prop] = value;
                                }
                            };
                        }
                    }
                }(prop, DefaultValues[prop]);
            }
            return props;
        }();
        properties.positionType.type = PositionType;
        properties.emitterMode.type = EmitterMode;
        var ParticleSystem = cc.Class({
            name: "cc.ParticleSystem",
            "extends": cc._ComponentInSG,
            editor: false,
            ctor: function() {
                this._previewTimer = null;
                this._focused = false;
                this._willStart = false;
            },
            properties: properties,
            statics: {
                DURATION_INFINITY: -1,
                START_SIZE_EQUAL_TO_END_SIZE: -1,
                START_RADIUS_EQUAL_TO_END_RADIUS: -1,
                EmitterMode: EmitterMode,
                PositionType: PositionType
            },
            onLoad: function() {
                this._super();
                if (false) {
                    if (this.preview) {
                        this.resetSystem();
                    }
                } else {
                    if (this.playOnLoad) {
                        this.resetSystem();
                    }
                    this._applyAutoRemove();
                }
            },
            onDestroy: function() {
                if (this._autoRemoveOnFinish) {
                    this.autoRemoveOnFinish = false;
                }
                this._super();
            },
            onFocusInEditor: false,
            onLostFocusInEditor: false,
            _createSgNode: function() {
                var sgNode = this._sgNode = new _ccsg.ParticleSystem();
                var loadCustomAfterFile = false;
                if (this._file) {
                    var missCustomTexture = this._custom && !this._texture;
                    loadCustomAfterFile = missCustomTexture;
                    this._applyFile(loadCustomAfterFile && this._applyCustoms.bind(this));
                }
                if (this._custom && !loadCustomAfterFile) {
                    this._applyCustoms();
                }
                sgNode.stopSystem();
                return sgNode;
            },
            addParticle: function() {
                if (this._sgNode) {
                    return this._sgNode.addParticle();
                } else {
                    return false;
                }
            },
            stopSystem: function() {
                if (this._sgNode) {
                    this._sgNode.stopSystem();
                }
            },
            resetSystem: function() {
                if (this._sgNode) {
                    this._sgNode.resetSystem();
                }
            },
            isFull: function() {
                return this.particleCount >= this._totalParticles;
            },
            setDisplayFrame: function(spriteFrame) {
                if (!spriteFrame) {
                    return;
                }
                var texture = spriteFrame.getTexture();
                if (texture) {
                    this._texture = texture.url;
                }
                if (this._sgNode) {
                    this._sgNode.setDisplayFrame(spriteFrame);
                }
            },
            setTextureWithRect: function(texture, rect) {
                if (texture instanceof cc.Texture2D) {
                    this._texture = texture.url;
                }
                if (this._sgNode) {
                    this._sgNode.setTextureWithRect(texture, rect);
                }
            },
            _applyFile: function(done) {
                var node = this._sgNode;
                if (!node) {
                    return;
                }
                var file = this._file;
                if (file) {
                    var self = this;
                    cc.loader.load(file, function(err, results) {
                        if (err) {
                            throw err;
                        }
                        node.particleCount = 0;
                        var active = node.isActive();
                        node.initWithFile(file);
                        if (!active) {
                            node.stopSystem();
                        }
                        var sourcePos = node.getPosition();
                        if (false) {
                            cc.log('Discard sourcePosition: %s from "%s", you can set position in the node directly.', sourcePos, cc.path.basename(file));
                        }
                        node.setPosition(0, 0);
                        node.autoRemoveOnFinish = self._autoRemoveOnFinish;
                        if (done) {
                            done();
                        }
                    });
                }
            },
            _applyCustoms: function() {
                var node = this._sgNode;
                if (!node) {
                    return;
                }
                var active = node.isActive();
                for (var i = 0; i < CustomProps.length; i++) {
                    var prop = CustomProps[i];
                    node[prop] = this["_" + prop];
                }
                if (this._texture) {
                    node.texture = cc.textureCache.addImage(this._texture);
                }
                if (!active) {
                    node.stopSystem();
                }
                node.autoRemoveOnFinish = this._autoRemoveOnFinish;
            },
            _applyAutoRemove: function() {
                var sgNode = this._sgNode;
                if (sgNode) {
                    var autoRemove = this._autoRemoveOnFinish;
                    sgNode.autoRemoveOnFinish = autoRemove;
                    if (autoRemove) {
                        cc.assert(!sgNode.onExit);
                        var self = this;
                        sgNode.onExit = function() {
                            _ccsg.Node.prototype.onExit.call(this);
                            self.node.destroy();
                        };
                    } else {
                        if (sgNode.hasOwnProperty("onExit")) {
                            sgNode.onExit = _ccsg.Node.prototype.onExit;
                        }
                    }
                }
            }
        });
        cc.ParticleSystem = module.exports = ParticleSystem;
    }, {} ],
    104: [ function(require, module, exports) {
        require("./cocos2d/core");
        require("./cocos2d/animation");
        require("./cocos2d/particle/CCParticleAsset");
        if (true) {
            require("./cocos2d/particle/CCParticleSystem");
            if (cc.sys.isNative) {
                function log() {
                    var text = cc.formatStr.apply(this, arguments);
                    console.log(text);
                }
                cc.log = log;
                cc.error = log;
                cc.warn = log;
                cc.info = log;
            }
        }
    }, {
        "./cocos2d/animation": 12,
        "./cocos2d/core": 55,
        "./cocos2d/particle/CCParticleAsset": 102,
        "./cocos2d/particle/CCParticleSystem": 103
    } ],
    105: [ function(require, module, exports) {
        if (false) {
            eval('CC_TEST=typeof describe!=="undefined"||typeof QUnit=="object"');
        }
        if (false) {
            eval('CC_EDITOR=typeof Editor=="object"&&typeof process=="object"&&"electron" in process.versions');
        }
        if (false) {
            eval("CC_DEV=CC_EDITOR||CC_TEST");
        }
        require("./predefine");
        var isCoreLevel = false;
        if (!isCoreLevel) {
            require("./bin/modular-cocos2d");
        } else {
            cc._initDebugSetting(1);
        }
        require("./extends");
        if (false) {
            cc._require = require;
        }
        if (isCoreLevel) {
            Editor.versions["cocos2d"] = require("./package.json").version;
        } else {
            if (false) {
                require("./cocos2d/deprecated");
            }
        }
        module.exports = cc;
    }, {
        "./bin/modular-cocos2d": 2,
        "./cocos2d/deprecated": 101,
        "./extends": 104,
        "./package.json": void 0,
        "./predefine": 109
    } ],
    106: [ function(require, module, exports) {
        if (!Function.prototype.bind) {
            Function.prototype.bind = function(oThis) {
                if ("function" !== typeof this) {
                    throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
                }
                var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function() {}, fBound = function() {
                    return fToBind.apply(this instanceof fNOP && oThis ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
                };
                if (this.prototype) {
                    fNOP.prototype = this.prototype;
                }
                fBound.prototype = new fNOP();
                return fBound;
            };
        }
    }, {} ],
    107: [ function(require, module, exports) {
        require("./bind");
        require("./string");
    }, {
        "./bind": 106,
        "./string": 108
    } ],
    108: [ function(require, module, exports) {
        if (!String.prototype.startsWith) {
            String.prototype.startsWith = function(searchString, position) {
                position = position || 0;
                return this.lastIndexOf(searchString, position) === position;
            };
        }
        if (!String.prototype.endsWith) {
            String.prototype.endsWith = function(searchString, position) {
                if ("undefined" === typeof position || position > this.length) {
                    position = this.length;
                }
                position -= searchString.length;
                var lastIndex = this.indexOf(searchString, position);
                return -1 !== lastIndex && lastIndex === position;
            };
        }
    }, {} ],
    109: [ function(require, module, exports) {
        cc = {};
        _ccsg = {};
        cc.log = cc.warn = cc.error = cc._throw = cc.assert = function() {};
        if (false) {
            cc._Test = {};
        }
        require("./polyfill");
        require("./cocos2d/core/platform/js");
        require("./cocos2d/core/value-types");
        require("./cocos2d/core/utils");
        require("./cocos2d/core/platform/CCInputManager");
        require("./cocos2d/core/platform/CCInputExtension");
        require("./cocos2d/core/event");
        require("./cocos2d/core/platform/CCSys");
        require("./cocos2d/core/platform/CCLoader");
        require("./CCDebugger");
        if (false) {
            cc._initDebugSetting(1);
        }
        require("./cocos2d/core/CCDirector");
        require("./cocos2d/core/CCDirectorWebGL");
        require("./cocos2d/core/CCDirectorCanvas");
        require("./cocos2d/core/textures");
        ccui = {};
        ccs = {};
        sp = {};
        cp = {};
    }, {
        "./CCDebugger": 1,
        "./cocos2d/core/CCDirector": 16,
        "./cocos2d/core/CCDirectorCanvas": 17,
        "./cocos2d/core/CCDirectorWebGL": 18,
        "./cocos2d/core/event": 54,
        "./cocos2d/core/platform/CCInputExtension": 58,
        "./cocos2d/core/platform/CCInputManager": 59,
        "./cocos2d/core/platform/CCLoader": 60,
        "./cocos2d/core/platform/CCSys": 63,
        "./cocos2d/core/platform/js": 70,
        "./cocos2d/core/textures": 81,
        "./cocos2d/core/utils": 87,
        "./cocos2d/core/value-types": 100,
        "./polyfill": 107
    } ]
}, {}, [ 105 ]);
//# sourceMappingURL=cocos2d-js.js.map